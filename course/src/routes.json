[{"key":"/article","path":"/article","route":"/article","leaf":false,"title":"article","depth":0,"content":"","isLeaf":false,"children":[{"key":"/article/Babel","path":"/article/Babel","route":"/article/Babel","leaf":false,"title":"Babel","depth":1,"content":"","isLeaf":false,"children":[]},{"key":"/article/default","path":"/article/default","route":"/article/default","leaf":false,"title":"default","depth":1,"content":"","isLeaf":false,"children":[]}]},{"key":"/post","path":"/post","route":"/post","leaf":false,"title":"post","depth":0,"content":"","isLeaf":false,"children":[{"key":"/post/author.md","path":"/post/author.md","route":"/post/author.md","leaf":true,"title":"author","depth":1,"content":"","isLeaf":true}]},{"key":"/subject","path":"/subject","route":"/subject","leaf":false,"title":"subject","depth":0,"content":"","isLeaf":false,"children":[{"key":"/subject/Babel","path":"/subject/Babel","route":"/subject/Babel","leaf":false,"title":"Babel","depth":1,"content":"","isLeaf":false,"children":[{"key":"/subject/Babel/01 基础教程","path":"/subject/Babel/01 基础教程","route":"/subject/Babel/01 基础教程","leaf":false,"title":"01 基础教程","depth":2,"content":"","isLeaf":false,"children":[{"key":"/subject/Babel/01 基础教程/01-babel-asstes.md","path":"/subject/Babel/01 基础教程/01-babel-asstes.md","route":"/subject/Babel/01 基础教程/01-babel-asstes.md","leaf":true,"title":"01-babel-asstes","depth":3,"content":"---\ntitle: 01 babel 介绍\ntags: Babel\n---\n\n## 1、Babel 介绍\n\nBabel 是一个开源的 JavaScript 编译器工具，用于将新版本的 JavaScript 代码转换为向后兼容的旧版本，以便在不同的浏览器和环境中运行。它可以将使用最新的 ECMAScript 标准编写的代码转换为支持更旧的版本，以便在不同的浏览器中运行。\n\n## 2、Babel 版本\n\n### v6 VS v7\nBabel V7 相对于 Babel V6来说，有以下几个主要的区别：\n\n1. 命令行工具改进：V7 增加了一些新的命令行工具，如 `babel-upgrade` 和 `babel-merge` 等，这些工具让你更方便地维护Babel配置和升级到新的版本。\n\n2. 插件新增：V7 在默认插件集合中新增了一些新的插件，如 `@babel/plugin-transform-runtime` 和 `@babel/plugin-proposal-class-properties` 等，这些插件为开发者提供更多的便利和控制力。\n\n3. 配置文件更改：Babel V7 将配置文件名称从 `.babelrc` 更改为 `babel.config.js`，并支持更复杂的配置选项。\n\n4. 匹配更多的 ECMAScript 特性：Babel V7 支持更多的 ECMAScript 特性，如对象的 Rest 和 Spread 属性，对象的解构赋值，Async 函数和模板字符串标记等。\n\nBabel V7 相对于 Babel V6 的改进主要在于命令行工具、插件集合、配置文件和匹配更多的 ECMAScript 特性等方面。\n\n### V7.4.0\n- @babel/polyfill 被弃用，取而代之的是 `\"core-js/stable\"`\n\n### v7.6.0\n- 支持 TypeScript 命名空间的编译。\n\n## 3、学习资料\n\n### 官方文档\n\n- babel 官方网 [https://babeljs.io/docs/en](https://babeljs.io/docs/en/)\n- babel 中文网 [https://www.babeljs.cn/docs](https://www.babeljs.cn/docs/)\n\n### 调试工具\n\n- AST 在线 <https://astexplorer.net/#/2uBU1BLuJ1>\n- babel 插件开发手册 <https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md>\n\n### 实践经验\n- babel 腾讯云社区文档 <https://cloud.tencent.com/developer/doc/1260> 介绍babel API\n- 最简单 compiler 教程 [the-super-tiny-compiler](https://github.com/jamiebuilds/the-super-tiny-compiler/blob/master/the-super-tiny-compiler.js)\n- [高级前端基础-JavaScript抽象语法树AST](https://segmentfault.com/a/1190000018532745) <https://segmentfault.com/a/1190000018532745>\n- [AST抽象语法树——最基础的javascript重点知识，99%的人根本不了解](https://segmentfault.com/a/1190000016231512?utm_source=tag-newest#articleHeader10)\n- [从零开始写一个wepy转VUE的工具](http://zzfed.com/#/detail/5c8efc30c476e35308705a5b)\n- Babel是如何读懂JS代码的 <https://zhuanlan.zhihu.com/p/27289600>\n- 网易云课堂 JS编译原理： [https://study.163.com/course/courseMain.htm?courseId=1209486877&*trace\\_c\\_p\\_k2*=8ea58ce894c149179bd099a664c39d08](https://study.163.com/course/courseMain.htm?courseId=1209486877&_trace_c_p_k2_=8ea58ce894c149179bd099a664c39d08)","isLeaf":true},{"key":"/subject/Babel/01 基础教程/02-babel-quickstart.md","path":"/subject/Babel/01 基础教程/02-babel-quickstart.md","route":"/subject/Babel/01 基础教程/02-babel-quickstart.md","leaf":true,"title":"02-babel-quickstart","depth":3,"content":"---\ntitle: 02 babel 快速开始\ntags: Babel\n---\n\n## 1、初始化配置\n\n```shell\nyarn add --dev @babel/core @babel/cli @babel/preset-env\n```\n\n- @babel/core 提供了基本功能，包括 AST 解析 以及 AST visit\n- @babel/cli 是一个命令行工具\n- @babel/preset-env 是一个插件集合\n\n**创建配置文件**\n\n```js\nconst presets = [\n  [\n    \"@babel/preset-env\",\n    {\n      targets: {\n        edge: \"17\",\n        firefox: \"60\",\n        chrome: \"67\",\n        safari: \"11.1\",\n      },\n      useBuiltIns: \"usage\",\n      corejs: \"3.6.4\",\n    },\n  ],\n];\n\nmodule.exports = { presets };\n```\n\n```\n./node_modules/.bin/babel src --out-dir lib\n```\n\n## 2、配置文件说明\n\n- 项目范围的配置\n  - `babel.config.*` 文件，具有以下扩展名：.json, .js, .cjs, .mjs, .cts.\n- 文件相关配置\n  - `.babelrc.*` 文件，具有以下扩展名：.json, .js, .cjs, .mjs, .cts.\n  - `.babelrc` 文件，没有扩展名。\n  - `package.json` 文件，\"babel\" key\n\nhttps://babeljs.io/docs/config-files 在这里了解他们的区别，我们应该用哪种？","isLeaf":true},{"key":"/subject/Babel/01 基础教程/03-use-plugin-and-presets.md","path":"/subject/Babel/01 基础教程/03-use-plugin-and-presets.md","route":"/subject/Babel/01 基础教程/03-use-plugin-and-presets.md","leaf":true,"title":"03-use-plugin-and-presets","depth":3,"content":"---\ntitle: 03 使用 plugin 和 preset\ntags: Babel\n---\n\nBabel 插件 和 Preset 是用于在 JavaScript 项目中进行代码转换的工具。\n\n## 1、插件 和 Preset 有什么区别？\n\n- 插件是针对 Babel 的具体功能的单个功能，例如“转换箭头函数为普通函数”，“转换 ES6 类成为普通函数”等，而 preset 则是包含另外一些插件的一个集合，这些插件共同完成一些相关的 tasks。\n\n- 软件预设(packaged presets) 可以轻松地执行多项任务，而不必单独安装和配置多个插件。例如，@babel/preset-env 是一个预设，它帮助您将 ES6+代码转换为符合您指定的目标环境的 JavaScript 代码。\n\n## 2、如何使用？\n\n使用 Babel 插件和 Preset，您需要在项目中安装它们并配置 Babel。在您的项目根目录下创建一个 `.babelrc` 文件，为 Babel 提供配置。\n\n### preset\n\n例如，使用 preset-env 转换 ES6 +代码：\n\n1. 安装 `@babel/preset-env`:\n\n```\nnpm install --save-dev @babel/preset-env\n```\n\n2. 然后在 .babelrc 文件中配置：\n\n```\n{\n  \"presets\": [\"@babel/preset-env\"]\n}\n```\n\n这意味着在项目中的所有 ES6+代码都将被转换为适用于您的所需 JavaScript 环境的标准 JavaScript。\n\n### plugin\n\n```shell\nyarn add --dev @babel/plugin-transform-arrow-functions\n```\n\n```\n./node_modules/.bin/babel src --out-dir lib --plugins=@babel/plugin-transform-arrow-functions\n```\n\n```js\nconst fn = () => 1;\n\n// converted to\nvar fn = function fn() {\n  return 1;\n};\n```\n\n```js\nconst presets = [\n  [\n    \"@babel/preset-env\",\n    {\n      targets: {\n        edge: \"17\",\n        firefox: \"60\",\n        chrome: \"67\",\n        safari: \"11.1\",\n      },\n      useBuiltIns: \"usage\",\n      corejs: \"3.6.4\",\n    },\n  ],\n];\n\nconst plugins = [[\"@babel/plugin-transform-arrow-functions\"]];\n\nmodule.exports = { presets, plugins };\n```\n","isLeaf":true},{"key":"/subject/Babel/01 基础教程/04-babel-plugin-ES2015.md","path":"/subject/Babel/01 基础教程/04-babel-plugin-ES2015.md","route":"/subject/Babel/01 基础教程/04-babel-plugin-ES2015.md","leaf":true,"title":"04-babel-plugin-ES2015","depth":3,"content":"---\ntitle: 04 plugin ES2015\ntags: Babel\n---\n\nBabel 是一个编译器。从宏观角度看，它将运行代码分为3个阶段: 解析，转换，及生成（与其他编译器相同）。\n\n始阶段，Babel 并没有做任何事情。它基本上就相当于 `const babel = code => code;`，先解析代码，然后再次生成相同的代码。你可以为 Babel 添加一些 Plugins 让其去做任何事情( Plugins 会影响 Babel 的第 2 阶段，转换)。\n\n\n## 1、ES3\n\n### [es3-member-expression-literals](https://babel.docschina.org/docs/en/babel-plugin-transform-es3-member-expression-literals)\n\n```javascript\n// 在IE8及以下会报错\nfoo.catch;\n\n// 需要转换为\nfoo[\"catch\"]\n```\n\n### [es3-property-literals](https://babel.docschina.org/docs/en/babel-plugin-transform-es3-property-literals)\n\n```javascript\n// 在IE8及以下会报错\nvar foo = {\n  catch: function () {}\n};\n\n// 需要转换为\nvar foo = {\n  \"catch\": function () {}\n};\n```\n\n\n### [reserved-words](https://babeljs.io/docs/en/babel-plugin-transform-reserved-words)\n\n有些在标识符在ES3为保留字，在ES5及以后就不是了，这个插件可以重命名这些标识符。\n\n```javascript\n// IN\nvar abstract = 1;\nvar x = abstract + 1;\n\n// OUT\nvar _abstract = 1;\nvar x = _abstract + 1;\n```\n\n## 2、ES5\n\n### [property-mutators](https://babeljs.io/docs/en/babel-plugin-transform-property-mutators)\n\n对于 mutate 方法的定义，老版的部分浏览器只支持使用 Object.defineProperties 来定义：\n\n```javascript\n// In\nvar foo = {\n  get bar() {\n    return this._bar;\n  },\n  set bar(value) {\n    this._bar = value;\n  }\n};\n\n// Out\nvar foo = Object.defineProperties({}, {\n  bar: {\n    get: function () {\n      return this._bar;\n    },\n    set: function (value) {\n      this._bar = value;\n    },\n    configurable: true,\n    enumerable: true\n  }\n});\n```\n\n<a name=\"R2DiV\"></a>\n\n## 3、ES2015\n\nES2015 修订文档：<https://www.ecma-international.org/ecma-262/6.0>\n\n### [arrow-functions](https://babeljs.io/docs/en/babel-plugin-transform-arrow-functions)\n\n箭头函数转译\n\n### [block-scoped-functions](https://babeljs.io/docs/en/babel-plugin-transform-block-scoped-functions)\n\n块级作用域函数\n\n```javascript\n// In\n{\n  function name (n) {\n    return n;\n  }\n}\n\nname(\"Steve\");\n\n// Out\n{\n  let name = function (n) {\n    return n;\n  };\n}\nname(\"Steve\");\n```\n\n### [block-scoping](https://babeljs.io/docs/en/babel-plugin-transform-block-scoping)\n\n块及作用域\n\n```javascript\n// In\n{\n  let a = 3\n}\n\nlet a = 3\n\n// Out\n{\n  var _a = 3;\n}\n\nvar a = 3;\n```\n\n### [classes](https://babeljs.io/docs/en/babel-plugin-transform-classes)\n\n使用 class 定义类，如果你的代码包含子类继承 Native class 时，需要额外注意，见文档 [classes](https://babeljs.io/docs/en/babel-plugin-transform-classes)。\n\n```javascript\n// In\nclass Test {\n  constructor(name) {\n    this.name = name;\n  }\n\n  logger () {\n    console.log(\"Hello\", this.name);\n  }\n}\n\n// Out\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar Test = function () {\n  function Test(name) {\n    _classCallCheck(this, Test);\n\n    this.name = name;\n  }\n\n  Test.prototype.logger = function logger() {\n    console.log(\"Hello\", this.name);\n  };\n\n  return Test;\n}();\n```\n\n### [computed-properties](https://babeljs.io/docs/en/babel-plugin-transform-computed-properties)\n\n计算属性或表达式属性\n\n```javascript\n// In\nvar obj = {\n  [\"x\" + foo]: \"heh\",\n  [\"y\" + bar]: \"noo\",\n  foo: \"foo\",\n  bar: \"bar\"\n};\n\n// Out\nvar _obj;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar obj = (\n  _obj = {},\n  _defineProperty(_obj, \"x\" + foo, \"heh\"),\n  _defineProperty(_obj, \"y\" + bar, \"noo\"),\n  _defineProperty(_obj, \"foo\", \"foo\"),\n  _defineProperty(_obj, \"bar\", \"bar\"),\n  _obj\n);\n```\n\n### [destructuring](https://babeljs.io/docs/en/babel-plugin-transform-destructuring)\n\n解构赋值\n\n```javascript\n// In\nlet {x, y} = obj;\nlet [a, b, ...rest] = arr;\n\n// Out\nfunction _toArray(arr) { ... }\n\nlet _obj = obj,\n    x = _obj.x,\n    y = _obj.y;\n\nlet _arr = arr,\n    _arr2 = _toArray(_arr),\n    a = _arr2[0],\n    b = _arr2[1],\n    rest = _arr2.slice(2);\n```\n\n### [duplicate-keys](https://babeljs.io/docs/en/babel-plugin-transform-duplicate-keys)\n\n将重复key转为表达式key，没什么用\n\n```javascript\n// In\nvar x = { a: 5, a: 6 };\nvar y = {\n  get a() {},\n  set a(x) {},\n  a: 3,\n};\n\n// Out\nvar x = { a: 5, [\"a\"]: 6 };\nvar y = {\n  get a() {},\n  set a(x) {},\n  [\"a\"]: 3,\n};\n```\n\n### [for-of](https://babeljs.io/docs/en/babel-plugin-transform-for-of)\n\nfor-of 迭代器\n\n```javascript\n// in\nfor (var i of foo) {}\n\n// out\nvar _iteratorNormalCompletion = true;\nvar _didIteratorError = false;\nvar _iteratorError = undefined;\n\ntry {\n  for (var _iterator = foo[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n    var i = _step.value;\n  }\n} catch (err) {\n  _didIteratorError = true;\n  _iteratorError = err;\n} finally {\n  try {\n    if (!_iteratorNormalCompletion && _iterator.return != null) {\n      _iterator.return();\n    }\n  } finally {\n    if (_didIteratorError) {\n      throw _iteratorError;\n    }\n  }\n}\n```\n\n### [function-name](https://babeljs.io/docs/en/babel-plugin-transform-function-name)\n\n```javascript\n// in\nlet number = (x) => x\n\n// out\nvar number = function number(x) {\n  return x;\n};\n```\n\n### [instanceof](https://babeljs.io/docs/en/babel-plugin-transform-instanceof)\n\nES2015 对 instanceof 操作符进行了修订\n![20230608110441](http://s3.airtlab.com/blog/20230608110441.png)\n\n```javascript\n// in\nfoo instanceof Bar;\n\n// out\nfunction _instanceof(left, right) {\n  if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n    return right[Symbol.hasInstance](left);\n  } else {\n    return left instanceof right;\n  }\n}\n\n_instanceof(foo, Bar);\n```\n\n### [literals](https://babeljs.io/docs/en/babel-plugin-transform-literals)\n\n字面量转换\n\n```javascript\n// in\nvar b = 0b11; // binary integer literal\nvar o = 0o7; // octal integer literal\nconst u = 'Hello\\u{000A}\\u{0009}!'; // unicode string literals, newline and tab\n\n// out\nvar b = 3; // binary integer literal\nvar o = 7; // octal integer literal\nconst u = 'Hello\\n\\t!'; // unicode string literals, newline and tab\n```\n\n### [new-target](https://babeljs.io/docs/en/babel-plugin-transform-new-target)\n\nnew.target返回使用new方法调用类时的类的名称，子类继承父类时，new.target会返回子类。\n\n```javascript\nclass Rectangle {\n  constructor(length, width) {\n    console.log(new.target === Rectangle);\n  }\n}\n \nclass Square extends Rectangle {\n  constructor(length) {\n    super(length, length);\n  }\n}\n```\n\n### [object-super](https://babeljs.io/docs/en/babel-plugin-transform-object-super)\n\nthis 关键字总是指向函数所在的当前对象，ES6 新增了另一个类似的关键字super，指向当前对象的原型对象。\n\n```javascript\nlet obj2 = {\n  say () {\n    // [object Object]World!\n    return super.toString() + \"World!\"\n  }\n}\n```\n\n### [parameters](https://babeljs.io/docs/en/babel-plugin-transform-parameters)\n\n处理 ES2015 函数参数：\n\n- Destructuring parameters 参数解构\n- Default parameters 默认参数\n- Rest parameters 扩展符\n\n```javascript\n// in\nfunction test(x = \"hello\", { a, b }, ...args) {\n  console.log(x, a, b, args);\n}\n\n// out\nfunction test() {\n  var x =\n    arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"hello\";\n  var _ref = arguments[1];\n  var a = _ref.a,\n    b = _ref.b;\n\n  for (\n    var _len = arguments.length,\n      args = Array(_len > 2 ? _len - 2 : 0),\n      _key = 2;\n    _key < _len;\n    _key++\n  ) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  console.log(x, a, b, args);\n}\n```\n\n### [shorthand-properties](https://babeljs.io/docs/en/babel-plugin-transform-shorthand-properties)\n\n```javascript\n// in\nvar o = { a, b, c };\n\n// out\nvar o = { a: a, b: b, c: c };\n```\n\n```javascript\n// in\nvar cat = {\n  getName() {\n    return name;\n  }\n};\n\n// out\nvar cat = {\n  getName: function () {\n    return name;\n  }\n};\n```\n\n### [spread](https://babeljs.io/docs/en/babel-plugin-transform-spread)\n\n扩展运算符，与剩余运算符互为逆运算\n\n```javascript\n// in\nvar a = ['a', 'b', 'c'];\n\nvar b = [...a, 'foo'];\n\nvar c = foo(...a);\n\n// out\nvar a = ['a', 'b', 'c'];\n\nvar b = a.concat(['foo']);\n\nvar c = foo.apply(void 0, a);\n```\n\n### [sticky-regex](https://babeljs.io/docs/en/babel-plugin-transform-sticky-regex)\n\n```javascript\n// in\nconst a = /o+/y;\n\n// out\nvar a = new RegExp(\"o+\", \"y\");\n```\n\ny 修饰符：叫做 “粘连”（sticky）修饰符。用来正确处理匹配粘连的字符串。它的作用和g修饰类似，也是全局匹配。它可以使用新增的正则对象属性sticky来判断正则对象是否设置了y修饰符。y 和 g 的区别\n\n- g 修饰符只要剩余位置中存在匹配的字符串就可以返回成功。而y修饰符确保匹配必须是从剩余的所有位置中的第一个位置开始，这也是粘连的含义。\n- y 修饰符隐含了头部匹配的标志^（^x表示匹配的字符串的首个字符必须是x）\n\n### [template-literals](https://babeljs.io/docs/en/babel-plugin-transform-template-literals)\n\n模版字符串\n\n```javascript\n// in\n`foo${bar}`;\n\n// out\n\"foo\".concat(bar);\n```\n\n### [typeof-symbol](https://babeljs.io/docs/en/babel-plugin-transform-typeof-symbol)\n\nSymbol是原始值，ES6扩展了typeof操作符，返回\"symbol\"。所以可以用typeof来检测变量是否为symbol类型\n\n### [unicode-escapes](https://babeljs.io/docs/en/babel-plugin-transform-unicode-escapes)\n\nCompile ES2015 Unicode escapes to ES5\n\n```javascript\n// in\nvar \\u{1d49c} = \"\\u{Babe1}\";\n\nconsole.log(\\u{1d49c});\n\n// out\nvar _ud835_udc9c = \"\\uDAAA\\uDFE1\";\n\nconsole.log(_ud835_udc9c);\n```\n\n### [unicode-regex](https://babeljs.io/docs/en/babel-plugin-transform-unicode-regex)\n\n```js\n// in\nvar string = \"foo💩bar\";\nvar match = string.match(/foo(.)bar/u);\n```","isLeaf":true},{"key":"/subject/Babel/01 基础教程/05-babel-plugin-ES2016.md","path":"/subject/Babel/01 基础教程/05-babel-plugin-ES2016.md","route":"/subject/Babel/01 基础教程/05-babel-plugin-ES2016.md","leaf":true,"title":"05-babel-plugin-ES2016","depth":3,"content":"---\ntitle: 05 plugin ES2016\ntags: Babel\n---\n\n## 1、ES2016\n\n### [exponentiation-operator](https://babeljs.io/docs/en/babel-plugin-transform-exponentiation-operator)\n\n新增指数运算法\n\n```javascript\n// in\nlet x = 10 ** 2;\n\nx **= 3;\n\n// out\nlet x = Math.pow(10, 2);\nx = Math.pow(x, 3);\n```\n\n## 2、ES2017\n\n### [async-to-generator](https://babeljs.io/docs/en/babel-plugin-transform-async-to-generator)\n\n将 async 转换为 generator\n\n```javascript\n// in\nasync function foo() {\n  await bar();\n}\n\n// out\nvar _asyncToGenerator = function (fn) {\n  ...\n};\n\nvar foo = _asyncToGenerator(function* () {\n  yield bar();\n});\n```\n\n\n## 3、ES2018\n\n### [external-helpers](https://babeljs.io/docs/en/babel-plugin-external-helpers)\n\n内部帮助函数\n\n### [object-assign](https://babeljs.io/docs/en/babel-plugin-transform-object-assign)\n\n```javascript\n// in \nObject.assign(a, b);\n\n// out\nvar _extends = ...;\n\n_extends(a, b);\n```\n\n### [regenerator](https://babeljs.io/docs/en/babel-plugin-transform-regenerator)\n\n这是 facebook 下的一个工具，用于编译 ES6 的 generator 函数，一篇非常好的文章见：<https://www.jianshu.com/p/17a4c00d5831> <a name=\"uzkyg\"></a>\n\n![20230608110538](http://s3.airtlab.com/blog/20230608110538.png)\n\n### [runtime](https://babeljs.io/docs/en/babel-plugin-transform-runtime)\n\nruntime 库，用于重用 @babel/runtime 代码.\n\n### [strict-mode](https://babeljs.io/docs/en/babel-plugin-transform-strict-mode)\n\n编译为严格模式\n\n```javascript\n// in\nfoo();\n\n// out\n\"use strict\";\n\nfoo();\n```\n\n## Modules 模块处理\n\n- [modules-amd](https://babeljs.io/docs/en/babel-plugin-transform-modules-amd)\n- [modules-commonjs](https://babeljs.io/docs/en/babel-plugin-transform-modules-commonjs)\n- [modules-systemjs](https://babeljs.io/docs/en/babel-plugin-transform-modules-systemjs)\n- [modules-umd](https://babeljs.io/docs/en/babel-plugin-transform-modules-umd)\n\n### Experimental\n\n- [class-properties](https://babeljs.io/docs/en/babel-plugin-proposal-class-properties)\n\n扩展类的属性定义\n\n```javascript\nclass Bork {\n    //Property initializer syntax\n    instanceProperty = \"bork\";\n\n    boundFunction = () => {\n      return this.instanceProperty;\n    };\n\n    //Static class properties\n    static staticProperty = \"babelIsCool\";\n    static staticFunction = function() {\n      return Bork.staticProperty;\n    };\n}\n```\n\n- [decorators](https://babeljs.io/docs/en/babel-plugin-proposal-decorators)\n\n装饰器的支持\n\n```javascript\n@annotation\nclass MyClass { }\n\nfunction annotation(target) {\n   target.annotated = true;\n}\n```\n\n- [do-expressions](https://babeljs.io/docs/en/babel-plugin-proposal-do-expressions)\n\ndo 表达式\n\n```javascript\nlet a = do {\n  if(x > 10) {\n    'big';\n  } else {\n    'small';\n  }\n};\n// is equivalent to:\nlet a = x > 10 ? 'big' : 'small';\n```\n\n- [export-default-from](https://babeljs.io/docs/en/babel-plugin-proposal-export-default-from)\n\n快捷到出\n\n```javascript\nexport v from 'mod';\n```\n\n- [export-namespace-from](https://babeljs.io/docs/en/babel-plugin-proposal-export-namespace-from)\n\n快捷导出重命名\n\n```javascript\nexport * as ns from 'mod';\n```\n\n- [function-bind](https://babeljs.io/docs/en/babel-plugin-proposal-function-bind)\n\n快捷的函数 context 绑定\n\n```javascript\nobj::func\n// is equivalent to:\nfunc.bind(obj)\n```\n\n- [function-sent](https://babeljs.io/docs/en/babel-plugin-proposal-function-sent)\n- [logical-assignment-operators](https://babeljs.io/docs/en/babel-plugin-proposal-logical-assignment-operators)\n- [nullish-coalescing-operator](https://babeljs.io/docs/en/babel-plugin-proposal-nullish-coalescing-operator)\n- [numeric-separator](https://babeljs.io/docs/en/babel-plugin-proposal-numeric-separator)\n- [optional-chaining](https://babeljs.io/docs/en/babel-plugin-proposal-optional-chaining)\n- [partial-application](https://babeljs.io/docs/en/babel-plugin-proposal-partial-application)\n- [pipeline-operator](https://babeljs.io/docs/en/babel-plugin-proposal-pipeline-operator)\n- [private-methods](https://babeljs.io/docs/en/babel-plugin-proposal-private-methods)\n- [throw-expressions](https://babeljs.io/docs/en/babel-plugin-proposal-throw-expressions)\n- [private-property-in-object](https://babeljs.io/docs/en/babel-plugin-proposal-private-property-in-object)\n\n\n## React 相关语法\n\n- [react-constant-elements](https://babeljs.io/docs/en/babel-plugin-transform-react-constant-elements)\n- [react-display-name](https://babeljs.io/docs/en/babel-plugin-transform-react-display-name)\n- [react-inline-elements](https://babeljs.io/docs/en/babel-plugin-transform-react-inline-elements)\n- [react-jsx](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx)\n- [react-jsx-compat](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx-compat)\n- [react-jsx-self](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx-self)\n- [react-jsx-source](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx-source)\n","isLeaf":true},{"key":"/subject/Babel/01 基础教程/06-babel-presets.md","path":"/subject/Babel/01 基础教程/06-babel-presets.md","route":"/subject/Babel/01 基础教程/06-babel-presets.md","leaf":true,"title":"06-babel-presets","depth":3,"content":"---\ntitle: 06 babel presets\ntags: Babel\n---\n\npresets 是一些 plugins 的集合。\n\n\n## 1、官方 Presets\n\n- [@babel/preset-env](https://babeljs.io/docs/en/babel-preset-env)\n- [@babel/preset-flow](https://babeljs.io/docs/en/babel-preset-flow)\n- [@babel/preset-react](https://babeljs.io/docs/en/babel-preset-react)\n- [@babel/preset-typescript](https://babeljs.io/docs/en/babel-preset-typescript)\n\n## 2、实验阶段 Presets\n\n- [Stage 0](https://babeljs.io/docs/en/babel-preset-stage-0) - Strawman: just an idea, possible Babel plugin.\n- [Stage 1](https://babeljs.io/docs/en/babel-preset-stage-1) - Proposal: this is worth working on.\n- [Stage 2](https://babeljs.io/docs/en/babel-preset-stage-2) - Draft: initial spec.\n- [Stage 3](https://babeljs.io/docs/en/babel-preset-stage-3) - Candidate: complete spec and initial browser implementations.\n- Stage 4 - Finished: will be added to the next yearly release.\n\n## 3、自定义 presets\n\n```javascript\nmodule.exports = function() {\n  return {\n    plugins: [\n      \"pluginA\",\n      \"pluginB\",\n      \"pluginC\",\n    ]\n  };\n}\n```\n\npresets 中也可以包含其他 presets：\n\n```javascript\nmodule.exports = () => ({\n  presets: [\n    require(\"@babel/preset-env\"),\n  ],\n  plugins: [\n    [require(\"@babel/plugin-proposal-class-properties\"), { loose: true }],\n    require(\"@babel/plugin-proposal-object-rest-spread\"),\n  ],\n});\n```\n\n使用 presets:\n\n```javascript\n// 非 node_modules\n{\n  \"presets\": [\"./myProject/myPreset\"]\n}\n\n// node_modules 下\n{\n  \"presets\": [\"babel-preset-myPreset\"]\n}\n```","isLeaf":true},{"key":"/subject/Babel/01 基础教程/07-preset-react.md","path":"/subject/Babel/01 基础教程/07-preset-react.md","route":"/subject/Babel/01 基础教程/07-preset-react.md","leaf":true,"title":"07-preset-react","depth":3,"content":"---\ntitle: 07 preset react\ntags: Babel\n---\n\nThis preset always includes the following plugins:\n\n- @babel/plugin-syntax-jsx\n- @babel/plugin-transform-react-jsx\n- @babel/plugin-transform-react-display-name\n\nAnd with the development option:\n\nClassic runtime adds:\n\n- @babel/plugin-transform-react-jsx-self\n- @babel/plugin-transform-react-jsx-source\n\n```json\n{\n  \"presets\": [\n    [\n      \"@babel/preset-react\",\n      {\n        \"pragma\": \"dom\", // default pragma is React.createElement (only in classic runtime)\n        \"pragmaFrag\": \"DomFrag\", // default is React.Fragment (only in classic runtime)\n        \"throwIfNamespace\": false, // defaults to true\n        \"runtime\": \"classic\" // defaults to classic\n        // \"importSource\": \"custom-jsx-library\" // defaults to react (only in automatic runtime)\n      }\n    ]\n  ]\n}\n```\n\n## @babel/plugin-syntax-jsx\n\n@babel/plugin-syntax-jsx 是一个用于 Babel 的插件，它的作用是让 Babel 能够识别和转换 JSX 语法的代码。JSX 是一种 JavaScript 的语法扩展，它允许在 JavaScript 中编写类似于 HTML 的标记语言，用于构建用户界面。\n在没有该插件的情况下，Babel 将无法理解 JSX 代码中的标签，会抛出错误。使用 @babel/plugin-syntax-jsx 插件后，Babel 将能够正确地解析并转换 JSX 语法到普通的 JavaScript 代码。\n\n需要注意的是，该插件只是解析 JSX 语法，它并不会将 JSX 转化为真正的 DOM 操作。要将 JSX 转换为可用的 JavaScript 代码，需要使用其他的插件或工具，例如 @babel/preset-react 插件、React 或 Preact 库等。\n\n## @babel/plugin-transform-react-jsx\n\n@babel/plugin-transform-react-jsx 是一个用于 Babel 的插件，它的作用是将 JSX 语法转换为普通的 JavaScript 代码，以便 JavaScript 引擎能够识别和执行这些代码。\nJSX 是一种 JavaScript 的语法扩展，它允许在 JavaScript 中编写类似于 HTML 的标记语言，用于构建用户界面。但是，由于 JavaScript 引擎不能直接执行 JSX 代码，因此需要将其转换为普通的 JavaScript 代码，以便能够在浏览器或 Node.js 等环境中执行。\n\n\n## React 17 介绍全新的 JSX 转换 (React.createElement => jsx)\n\n![20230518151443](http://s3.airtlab.com/blog/20230518151443.png)\n\n![20230518151453](http://s3.airtlab.com/blog/20230518151453.png)\n\n![20230518151506](http://s3.airtlab.com/blog/20230518151506.png)\n\n![20230518151537](http://s3.airtlab.com/blog/20230518151537.png)\n\n![20230518151556](http://s3.airtlab.com/blog/20230518151556.png)","isLeaf":true},{"key":"/subject/Babel/01 基础教程/08-plugin-order.md","path":"/subject/Babel/01 基础教程/08-plugin-order.md","route":"/subject/Babel/01 基础教程/08-plugin-order.md","leaf":true,"title":"08-plugin-order","depth":3,"content":"---\ntitle: 08 plugin 的顺序\ntags: Babel\n---\n\nbabel 插件按顺序执行，那么插件的先后顺序是如何决定的呢？比如在一个项目中使用 React 和 Typescript，那么识别 ts 的语法插件在前面，还是识别 jsx 的语法的插件在前面？\n\n- Plugin 会运行在 Preset 之前。\n- Plugin 会从前到后顺序执行。\n- Preset 的顺序则 刚好相反(从后向前)。\n\n很明显，谁在前，谁就得支持两种语法，`@babel/preset-typescript` 已经支持了 jsx 语法\n\n![20230705145919](http://s3.airtlab.com/blog/20230705145919.png)\n\n`@babel/preset-typescript` 底层依赖，plugin-syntax-typescript ","isLeaf":true}]},{"key":"/subject/Babel/02 Babel API","path":"/subject/Babel/02 Babel API","route":"/subject/Babel/02 Babel API","leaf":false,"title":"02 Babel API","depth":2,"content":"","isLeaf":false,"children":[{"key":"/subject/Babel/02 Babel API/01-@babel_core.md","path":"/subject/Babel/02 Babel API/01-@babel_core.md","route":"/subject/Babel/02 Babel API/01-@babel_core.md","leaf":true,"title":"01-@babel_core","depth":3,"content":"---\ntitle: 01 @babel/core\ntags: Babel\n---\n\n@babel/core 暴露了 `源代码 => AST => 目标代码` 整个过程所需要的方法。\n\n## 1. transform\n\ntransform 方法将源代码处理后返回目标代码，sourcemap 代码，以及ast：\n\n```javascript\n/**\n * @param string code 源代码\n * @param object options 配置项\n * @param function callback 回调函数\n */\nbabel.transform(code: string, options?: Object, callback: Function)\n```\n\n```javascript\nconst babel = require(\"@babel/core\");\nconst code = `const name = 1`\nconst options = {}\n\nbabel.transform(code, options, function(err, result) {\n  result; // => { code, map, ast }\n  console.log(result)\n});\n```\n\n如果需要 ast 和 sourcemap:\n\n```javascript\nconst babel = require(\"@babel/core\");\nconst sourceCode = `var count = 1`\n\nbabel.transform(sourceCode, { ast: true, inputSourceMap: true }, function(err, result) {\n  result; // => { code, map, ast }\n  console.log(result)\n});\n```\n\n这里的 options 用于配置 plugins，helpers 等等，后面会详细介绍。另外 bable 还提供了 transform 的同步方法 transformSync，以及异步Promise API transformAsync:\n\n```javascript\n// 同步API\nvar result = babel.transformSync(\"code();\", options);\nresult.code;\nresult.map;\nresult.ast;\n\n// 异步API\nbabel.transformAsync(\"code();\", options).then(result => {\n  result.code;\n  result.map;\n  result.ast;\n});\n```\n\n## 2. transformFile\n\ntransformFile 用于转换整个JS文件：\n\n```javascript\nbabel.transformFile(filename: string, options?: Object, callback: Function)\n```\n\n其函数签名和 transform 差不多，只是第一个参数从源代码 code 变为了文件路径 filename：\n\n```javascript\nbabel.transformFile(\"filename.js\", options, function (err, result) {\n  result; // => { code, map, ast }\n});\n```\n\n类似的，transformFile 也额外提供了同步和异步API，transformFileSync 和 transformFileAsync。\n\n## 3. parse\n\n该方法会扫码源代码，返回一个 AST，并且 @babel/core 同样额外提供了 parse 方法的异步和同步API: parseAsync 和 parseSync。\n\n```javascript\nbabel.parse(code: string, options?: Object, callback: Function)\n```\n\n```javascript\nconst babel = require(\"@babel/core\");\nconst sourceCode = `var count = 1`\n\nbabel.parse(sourceCode, function(err, result) {\n  console.log(JSON.stringify(result))\n});\n```\n\n结果如下：\n\n```javascript\n{\n\t\"type\": \"File\",\n\t\"start\": 0,\n\t\"end\": 13,\n\t\"loc\": {\n\t\t\"start\": {\n\t\t\t\"line\": 1,\n\t\t\t\"column\": 0\n\t\t},\n\t\t\"end\": {\n\t\t\t\"line\": 1,\n\t\t\t\"column\": 13\n\t\t}\n\t},\n\t\"errors\": [],\n\t\"program\": {\n\t\t\"type\": \"Program\",\n\t\t\"start\": 0,\n\t\t\"end\": 13,\n\t\t\"loc\": {\n\t\t\t\"start\": {\n\t\t\t\t\"line\": 1,\n\t\t\t\t\"column\": 0\n\t\t\t},\n\t\t\t\"end\": {\n\t\t\t\t\"line\": 1,\n\t\t\t\t\"column\": 13\n\t\t\t}\n\t\t},\n\t\t\"sourceType\": \"module\",\n\t\t\"interpreter\": null,\n\t\t\"body\": [{\n\t\t\t\"type\": \"VariableDeclaration\",\n\t\t\t\"start\": 0,\n\t\t\t\"end\": 13,\n\t\t\t\"loc\": {\n\t\t\t\t\"start\": {\n\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\"column\": 0\n\t\t\t\t},\n\t\t\t\t\"end\": {\n\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\"column\": 13\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"declarations\": [{\n\t\t\t\t\"type\": \"VariableDeclarator\",\n\t\t\t\t\"start\": 4,\n\t\t\t\t\"end\": 13,\n\t\t\t\t\"loc\": {\n\t\t\t\t\t\"start\": {\n\t\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\t\"column\": 4\n\t\t\t\t\t},\n\t\t\t\t\t\"end\": {\n\t\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\t\"column\": 13\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"id\": {\n\t\t\t\t\t\"type\": \"Identifier\",\n\t\t\t\t\t\"start\": 4,\n\t\t\t\t\t\"end\": 9,\n\t\t\t\t\t\"loc\": {\n\t\t\t\t\t\t\"start\": {\n\t\t\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\t\t\"column\": 4\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"end\": {\n\t\t\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\t\t\"column\": 9\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"identifierName\": \"count\"\n\t\t\t\t\t},\n\t\t\t\t\t\"name\": \"count\"\n\t\t\t\t},\n\t\t\t\t\"init\": {\n\t\t\t\t\t\"type\": \"NumericLiteral\",\n\t\t\t\t\t\"start\": 12,\n\t\t\t\t\t\"end\": 13,\n\t\t\t\t\t\"loc\": {\n\t\t\t\t\t\t\"start\": {\n\t\t\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\t\t\"column\": 12\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"end\": {\n\t\t\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\t\t\"column\": 13\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\"extra\": {\n\t\t\t\t\t\t\"rawValue\": 1,\n\t\t\t\t\t\t\"raw\": \"1\"\n\t\t\t\t\t},\n\t\t\t\t\t\"value\": 1\n\t\t\t\t}\n\t\t\t}],\n\t\t\t\"kind\": \"var\"\n\t\t}],\n\t\t\"directives\": []\n\t},\n\t\"comments\": []\n}\n```\n\n## 4. transformFromAst\n\n给定一个 [AST](https://astexplorer.net/) ，将它进行转换为和parser方法输入一致的结果，也算是将 parse 方法的输入进行反序列化：\n\n```javascript\nbabel.transformFromAst(ast: Object, code?: string, options?: Object, callback: Function): FileNode | null\n```\n\n```javascript\nvar babel = require(\"@babel/core\");\n\nconst sourceCode = `var count = 1`\n\nbabel.parse(sourceCode, function(err, result) {\n  if (err) {\n    console.log(err);\n    return;\n  }\n\n  // babel.transformFromAst(result, function(err, res) {\n  //   console.log(res) // res === JSON.string(result)\n  // })\n\n  babel.transformFromAst(result, undefined, { ast: true }, function(err, res) {\n    console.log(res)\n  })\n});\n```\n\n## 5. Advanced APIs\n\n许多使用了Babel的系统都喜欢自动注入 plugins 和 presets，或覆盖选项。为了实现此目标，Babel 公开了一些功能，这些功能有助于在不进行转换的情况下部分加载配置。\n\n\n### 5.1 loadOptions\n\n用于解析 Babel 的选项，产生一个 option 对象\n\n```javascript\nbabel.loadOptions(options?: Object)\n```\n\n代码：\n\n```javascript\nvar babel = require(\"@babel/core\");\n\nconst res = babel.loadOptions({\n  \"plugins\": [\"@babel/plugin-transform-arrow-functions\"]\n})\n\nconsole.log(res)\n```\n\n输出：\n\n![20230608023018](http://s3.airtlab.com/blog/20230608023018.png)\n\n### 5.2 loadPartialConfig\n\n```javascript\nbabel.loadPartialConfig(options?: Object): PartialConfig\n```\n\n### 5.3 createConfigItem\n\n```javascript\nbabel.createConfigItem(value: string | {} | Function | [string | {} | Function, {} | void], { dirname?: string, type?: \"preset\" | \"plugin\" }): ConfigItem\n```\n\n## 6. Options 配置\n\n参考文档 <https://babeljs.io/docs/en/options>","isLeaf":true},{"key":"/subject/Babel/02 Babel API/02-@babel_generator.md","path":"/subject/Babel/02 Babel API/02-@babel_generator.md","route":"/subject/Babel/02 Babel API/02-@babel_generator.md","leaf":true,"title":"02-@babel_generator","depth":3,"content":"---\ntitle: 02 @babel/generator\ntags: Babel\n---\n\n```javascript\nimport {parse} from '@babel/parser';\nimport generate from '@babel/generator';\n\nconst code = 'class Example {}';\nconst ast = parse(code);\n\nconst output = generate(ast, { /* options */ }, code);\n```\n\n## 1、格式化输出的选项\n\n| 选项名 | 类型 | 默认值 | 描述 |\n| :--- | :--- | :--- | :--- |\n| auxiliaryCommentBefore | string |  | 可选字符串，在输出文件的开始添加块注释 |\n| auxiliaryCommentAfter | string |  | 可选字符串，在输出文件的末尾添加块注释 |\n| shouldPrintComment | function | opts.comments | 如果注释需要包含在输出中，该函数则需接受注释（作为字符串）并返回 true 。 默认情况下，如果 opts.commoents 为 true 或者 opts.minifed 为 false 并且注释中包含 @preserve 或 @license，则包含注释。 |\n| retainLines | boolean | false | 尝试在输出的代码中使用与源代码相同的行号(有助于保留栈信息跟踪) |\n| retainFunctionParens | boolean | false | 保留函数表达式的上下级 (可用于更改引擎解析行为) |\n| comments | boolean | true | 输出中是否包含注释 |\n| compact | boolean or 'auto' | opts.minified | 设置为 true 以避免添加用于格式化的空格 |\n| minified | boolean | false | 输出是否被压缩 |\n| concise | boolean | false | 设置为 true 以减少空格 (但效果不如 opts.compact ) |\n| quotes | 'single' or 'double' | 基于 ast.tokens 的自动检测 | 输出中对引号的类型进行保留 |\n| filename | string |  | 在警告信息中使用 |\n| flowCommaSeparator | boolean | false | 设置为 true 以使用逗号而不是分号作为 Flow 属性的分隔符 |\n| jsonCompatibleStrings | boolean | false | 设置为 true，使用 \"json\" 运行 jsesc：正确的将 \"\\u00A9\" 打印为 \"©\" ; |\n\nsource maps 的选项:\n\n| 选项名 | 类型 | 默认值 | 描述 |\n| :--- | :--- | :--- | :--- |\n| sourceMaps | boolean | false | 启用生成 source maps |\n| sourceMapTarget | string |  | source map 会与生成代码的文件名进行关联 |\n| sourceRoot | string |  | source map 中所有对应 URLs 的 root |\n| sourceFileName | string |  | 源代码（例如，  code 参数中的代码）的文件名。只会在 code 为字符串时使用。 |\n\n\n## 2、多个来源构建 AST\n\n在大多数情况下，Babel 会将输入文件与输出文件进行 1:1 转换。然而，你可能正在处理从多个来源构建的 AST - JS 文件，模板等。如果出现这种情况，并且你还希望 source map 为你提供正确的来源，则需要将一个对象作为 `code` 参数传递给 `generate`。其中键应该为源文件名称，值应该为源内容。\n\n```javascript\nconst { parse } = require('@babel/parser');\nconst generate = require('@babel/generator').default;\n\nconst a = 'var a = 1;';\nconst b = 'var b = 2;';\n\nconst astA = parse(a, { sourceFilename: 'a.js' });\nconst astB = parse(b, { sourceFilename: 'b.js' });\n\nconst ast = {\n  type: 'Program',\n  body: [].concat(astA.program.body, astB.program.body)\n};\n\nconst { code, map } = generate(ast, { sourceMaps: true }, {\n  'a.js': a,\n  'b.js': b\n});\n\nconsole.log(code)\nconsole.log(map)\n```\n","isLeaf":true},{"key":"/subject/Babel/02 Babel API/03-@babel_helpers.md","path":"/subject/Babel/02 Babel API/03-@babel_helpers.md","route":"/subject/Babel/02 Babel API/03-@babel_helpers.md","leaf":true,"title":"03-@babel_helpers","depth":3,"content":"---\ntitle: 03 @babel/helpers\ntags: Babel\n---\n\n该模块用于提供了编译时的一些帮助函数。\n\n```javascript\nimport * as helpers from '@babel/helpers';\nimport * as t from '@babel/types';\n\nconst typeofHelper = helpers.get('typeof');\n\nt.isExpressionStatement(typeofHelper);\n// true\n```","isLeaf":true},{"key":"/subject/Babel/02 Babel API/04-@babel_parser.md","path":"/subject/Babel/02 Babel API/04-@babel_parser.md","route":"/subject/Babel/02 Babel API/04-@babel_parser.md","leaf":true,"title":"04-@babel_parser","depth":3,"content":"---\ntitle: 04 @babel/parser\ntags: Babel\n---\n\n## 1、@babel/parser 是什么\n\n@babel/parser 主要的任务是将源代码生成AST抽象语法树。按照官网的介绍，@babel/parser 应该在 [acorn](https://github.com/marijnh/acorn) 和 [acorn-jsx](https://github.com/RReverser/acorn-jsx) 的基础上开发的，虽然 @babel/parser 的源码没有依赖 acorn 模块，其中 acorn 主要包含以下3个模块：\n\n> - [acorn](https://github.com/acornjs/acorn/blob/master/acorn/): The main parser 主要的解释器\n> - [acorn-loose](https://github.com/acornjs/acorn/blob/master/acorn-loose/): The error-tolerant parser 错误处理\n> - [acorn-walk](https://github.com/acornjs/acorn/blob/master/acorn-walk/): The syntax tree walker 语法树的遍历\n\n## 2、@babel/parser 源码定义\n\n在 @babel/parser 的 d.ts 文件可以看到，它只提供了两个方法：\n![20230608023126](http://s3.airtlab.com/blog/20230608023126.png)\n\n```typescript\n/**\n * Parse the provided code as an entire ECMAScript program.\n * 解析完整的 ECMAScript 程序\n */\nexport function parse(input: string, options?: ParserOptions): import('@babel/types').File;\n\n/**\n * Parse the provided code as a single expression.\n * 仅仅解析 ECMAScript 表达式\n */\nexport function parseExpression(input: string, options?: ParserOptions): import('@babel/types').Expression;\n```\n\n除此之外还提供了一些 type：\n\n- ParserOptions\n- ParserPlugin\n- ParserPluginWithOptions\n- DecoratorsPluginOptions\n- PipelineOperatorPluginOptions\n- FlowPluginOptions <a name=\"zJB8k\"></a>\n\n## 3、API\n\n### 3.1、parse(code, \\[options])\n\n解析完整的 ECMAScript 程序\n\n```typescript\nconst parser = require('@babel/parser');\n// console.log(parser.parse('const name = 123'))\nconsole.log(JSON.stringify(parser.parse('const name = 123')))\n```\n\n解析后的语法树为：\n\n```javascript\n{\n\t\"type\": \"File\",\n\t\"start\": 0,\n\t\"end\": 16,\n\t\"loc\": {\n\t\t\"start\": {\n\t\t\t\"line\": 1,\n\t\t\t\"column\": 0\n\t\t},\n\t\t\"end\": {\n\t\t\t\"line\": 1,\n\t\t\t\"column\": 16\n\t\t}\n\t},\n\t\"errors\": [],\n\t\"program\": {\n\t\t\"type\": \"Program\",\n\t\t\"start\": 0,\n\t\t\"end\": 16,\n\t\t\"loc\": {\n\t\t\t\"start\": {\n\t\t\t\t\"line\": 1,\n\t\t\t\t\"column\": 0\n\t\t\t},\n\t\t\t\"end\": {\n\t\t\t\t\"line\": 1,\n\t\t\t\t\"column\": 16\n\t\t\t}\n\t\t},\n\t\t\"sourceType\": \"script\",\n\t\t\"interpreter\": null,\n\t\t\"body\": [{\n\t\t\t\"type\": \"VariableDeclaration\",\n\t\t\t\"start\": 0,\n\t\t\t\"end\": 16,\n\t\t\t\"loc\": {\n\t\t\t\t\"start\": {\n\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\"column\": 0\n\t\t\t\t},\n\t\t\t\t\"end\": {\n\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\"column\": 16\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"declarations\": [{\n\t\t\t\t\"type\": \"VariableDeclarator\",\n\t\t\t\t\"start\": 6,\n\t\t\t\t\"end\": 16,\n\t\t\t\t\"loc\": {\n\t\t\t\t\t\"start\": {\n\t\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\t\"column\": 6\n\t\t\t\t\t},\n\t\t\t\t\t\"end\": {\n\t\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\t\"column\": 16\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"id\": {\n\t\t\t\t\t\"type\": \"Identifier\",\n\t\t\t\t\t\"start\": 6,\n\t\t\t\t\t\"end\": 10,\n\t\t\t\t\t\"loc\": {\n\t\t\t\t\t\t\"start\": {\n\t\t\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\t\t\"column\": 6\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"end\": {\n\t\t\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\t\t\"column\": 10\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"identifierName\": \"name\"\n\t\t\t\t\t},\n\t\t\t\t\t\"name\": \"name\"\n\t\t\t\t},\n\t\t\t\t\"init\": {\n\t\t\t\t\t\"type\": \"NumericLiteral\",\n\t\t\t\t\t\"start\": 13,\n\t\t\t\t\t\"end\": 16,\n\t\t\t\t\t\"loc\": {\n\t\t\t\t\t\t\"start\": {\n\t\t\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\t\t\"column\": 13\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"end\": {\n\t\t\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\t\t\"column\": 16\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\"extra\": {\n\t\t\t\t\t\t\"rawValue\": 123,\n\t\t\t\t\t\t\"raw\": \"123\"\n\t\t\t\t\t},\n\t\t\t\t\t\"value\": 123\n\t\t\t\t}\n\t\t\t}],\n\t\t\t\"kind\": \"const\"\n\t\t}],\n\t\t\"directives\": []\n\t},\n\t\"comments\": []\n}\n```\n\n### 3.2、parseExpression(code, \\[options])\n\n仅仅解析 ECMAScript 表达式\n\n### 3.3、options\n\n- allowImportExportEverywhere：默认情况下，import 并 export 声明只能出现在一个程序的 top level scope。将此选项设置为true允许在任何位置使用。\n- allowAwaitOutsideFunction：默认情况下，await 仅允许在异步函数内部使用，或者当 topLevelAwait 插件被启用后，在模块的 top level scope 内使用。将其设置为 true，则在脚本的 top-level scope 内可使用。\n- allowReturnOutsideFunction：默认情况下，顶层的 return 语句会引发错误。设置 true 为接受这样的代码。\n\n下面的代码将会引发错误：\n\n```typescript\nconst parser = require('@babel/parser');\n// console.log(JSON.stringify(parser.parse('const name = 123')))\n\nconsole.log(JSON.stringify(parser.parse('return 6', {\n  allowReturnOutsideFunction: false\n})))\n```\n\n![20230608023157](http://s3.airtlab.com/blog/20230608023157.png)\n\n设置 allowReturnOutsideFunction 为 true，将不会报错。\n\n- **allowSuperOutsideMethod**\n\n默认情况下，super 不允许在类和对象方法之外使用，设置 true 为接受这样的代码\n\n- **allowUndeclaredExports**\n\n默认情况下，导出在当前模块作用域中未声明的标识符将引发错误。尽管 ECMAScript 模块规范要求此行为，但Babel 的解析器无法在以后可能会插入适当声明的插件管道中预期转换，因此有时设置此选项`true`以防止解析器过早地抛出异常未声明的导出会很重要。\n\n## 4、Output\n\nBabel解析器根据 [Babel AST格式](https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md) 生成AST 。它基于 [ESTree规范](https://github.com/estree/estree)，但存在以下差异：\n\n![20230608023257](http://s3.airtlab.com/blog/20230608023257.png)\n\n## 5、Plugins\n### 5.1、语言插件\n\n| Name | Code Example |\n| --- | --- |\n| `flow`\n&#x20;([repo](https://github.com/facebook/flow)) | `var a: string = \"\";` |\n| `flowComments`\n&#x20;([docs](https://flow.org/en/docs/types/comments/)) | `/*:: type Foo = {...}; */` |\n| `jsx`\n&#x20;([repo](https://facebook.github.io/jsx/)) | `<a attr=\"b\">{s}</a>` |\n| `typescript`\n&#x20;([repo](https://github.com/Microsoft/TypeScript)) | `var a: string = \"\";` |\n| `v8intrinsic` | `%DebugPrint(foo);` |\n\n\n### 5.2、ECMAScript [proposals](https://github.com/babel/proposals)\n\n| Name | Code Example |\n| --- | --- |\n| `asyncGenerators`\n&#x20;([proposal](https://github.com/tc39/proposal-async-iteration)) | `async function*() {}`\n, `for await (let a of b) {}` |\n| `bigInt`\n&#x20;([proposal](https://github.com/tc39/proposal-bigint)) | `100n` |\n| `classProperties`\n&#x20;([proposal](https://github.com/tc39/proposal-class-public-fields)) | `class A { b = 1; }` |\n| `classPrivateProperties`\n&#x20;([proposal](https://github.com/tc39/proposal-private-fields)) | `class A { #b = 1; }` |\n| `classPrivateMethods`\n&#x20;([proposal](https://github.com/tc39/proposal-private-methods)) | `class A { #c() {} }` |\n| `decorators`\n&#x20;([proposal](https://github.com/tc39/proposal-decorators))\n`decorators-legacy` | `@a class A {}` |\n| `doExpressions`\n&#x20;([proposal](https://github.com/tc39/proposal-do-expressions)) | `var a = do { if (true) { 'hi'; } };` |\n| `dynamicImport`\n&#x20;([proposal](https://github.com/tc39/proposal-dynamic-import)) | `import('./guy').then(a)` |\n| `exportDefaultFrom`\n&#x20;([proposal](https://github.com/leebyron/ecmascript-export-default-from)) | `export v from \"mod\"` |\n| `exportNamespaceFrom`\n&#x20;([proposal](https://github.com/leebyron/ecmascript-export-ns-from)) | `export * as ns from \"mod\"` |\n| `functionBind`\n&#x20;([proposal](https://github.com/zenparsing/es-function-bind)) | `a::b`\n, `::console.log` |\n| `functionSent` | `function.sent` |\n| `importMeta`\n&#x20;([proposal](https://github.com/tc39/proposal-import-meta)) | `import.meta.url` |\n| `logicalAssignment`\n&#x20;([proposal](https://github.com/tc39/proposal-logical-assignment)) | `a &&= b` |\n| `nullishCoalescingOperator`\n&#x20;([proposal](https://github.com/babel/proposals/issues/14)) | `a ?? b` |\n| `numericSeparator`\n&#x20;([proposal](https://github.com/samuelgoto/proposal-numeric-separator)) | `1_000_000` |\n| `objectRestSpread`\n&#x20;([proposal](https://github.com/tc39/proposal-object-rest-spread)) | `var a = { b, ...c };` |\n| `optionalCatchBinding`\n&#x20;([proposal](https://github.com/babel/proposals/issues/7)) | `try {throw 0;} catch{do();}` |\n| `optionalChaining`\n&#x20;([proposal](https://github.com/tc39/proposal-optional-chaining)) | `a?.b` |\n| `partialApplication`\n&#x20;([proposal](https://github.com/babel/proposals/issues/32)) | `f(?, a)` |\n| `pipelineOperator`\n&#x20;([proposal](https://github.com/babel/proposals/issues/29)) | `a &#124;> b` |\n| `throwExpressions`\n&#x20;([proposal](https://github.com/babel/proposals/issues/23)) | `() => throw new Error(\"\")` |\n| `topLevelAwait`\n&#x20;([proposal](https://github.com/tc39/proposal-top-level-await/)) | `await promise`\n&#x20;in modules |\n\n## 6、sourceType\n\nsourceType 可以是 \"module\" 或者 \"script\"，它表示 Babylon 应该用哪种模式来解析。 \"module\" 将会在严格模式下解析并且允许模块定义，\"script\" 则不会。\n\n## 7、Example\n\n```typescript\nrequire(\"@babel/parser\").parse(\"code\", {\n  // parse in strict mode and allow module declarations\n  sourceType: \"module\",\n\n  plugins: [\n    // enable jsx and flow syntax\n    \"jsx\",\n    \"flow\"\n  ]\n});\n```\n\n## 8、参考文档\n- [1] acorn github <https://github.com/acornjs/acorn>\n- [2] estree 规范 <https://github.com/estree/estree>","isLeaf":true},{"key":"/subject/Babel/02 Babel API/05-@babel_runtime.md","path":"/subject/Babel/02 Babel API/05-@babel_runtime.md","route":"/subject/Babel/02 Babel API/05-@babel_runtime.md","leaf":true,"title":"05-@babel_runtime","depth":3,"content":"---\ntitle: 05 @babel/runtime\ntags: Babel\n---\n\n5、@babel/runtime\n\n该库提供了一些运行时的帮助函数，避免了在每个文件中都定了一份帮助函数，而统一从 @babel/runtime 中引入。@babel/runtime 主要包含 运行时的 helpers 函数 以及 regenerator runtime。\n\nbabel-plugin-transform-runtime 和 babel-runtime 的区别：\n\n- babel-plugin-transform-runtime 内部依赖了 babel-runtime","isLeaf":true},{"key":"/subject/Babel/02 Babel API/06-@babel_traverse.md","path":"/subject/Babel/02 Babel API/06-@babel_traverse.md","route":"/subject/Babel/02 Babel API/06-@babel_traverse.md","leaf":true,"title":"06-@babel_traverse","depth":3,"content":"---\ntitle: 06 @babel/traverse\ntags: Babel\n---\n\n## 预备知识\n\n### Paths（路径）\n\nAST 通常会有许多节点，那么节点直接如何相互关联呢？ 我们可以使用一个可操作和访问的巨大可变对象表示节点之间的关联关系，或者也可以用Paths（路径）来简化这件事情。Path 是表示两个节点之间连接的对象。例如，如果有下面这样一个节点及其子节点︰\n\n```json\n{\n  \"parent\": {\n    \"type\": \"FunctionDeclaration\",\n    \"id\": {...},\n    ....\n  },\n  \"node\": {\n    \"type\": \"Identifier\",\n    \"name\": \"square\"\n  }\n}\n```\n\n同时它还包含关于该路径的其他元数据：\n\n```json\n{\n  \"parent\": {...},\n  \"node\": {...},\n  \"hub\": {...},\n  \"contexts\": [],\n  \"data\": {},\n  \"shouldSkip\": false,\n  \"shouldStop\": false,\n  \"removed\": false,\n  \"state\": null,\n  \"opts\": null,\n  \"skipKeys\": null,\n  \"parentPath\": null,\n  \"context\": null,\n  \"container\": null,\n  \"listKey\": null,\n  \"inList\": false,\n  \"parentKey\": null,\n  \"key\": null,\n  \"scope\": null,\n  \"type\": null,\n  \"typeAnnotation\": null\n}\n```\n\n当然路径对象还包含添加、更新、移动和删除节点有关的其他很多方法，稍后我们再来看这些方法。在某种意义上，路径是一个节点在树中的位置以及关于该节点各种信息的响应式 **Reactive** 表示。 当你调用一个修改树的方法后，路径信息也会被更新。 Babel 帮你管理这一切，从而使得节点操作简单，尽可能做到无状态。\n\n### Paths in Visitors（访问者中的路径）\n\n当你有一个 `Identifier()` 成员方法的访问者时，你实际上是在访问路径而非节点。 通过这种方式，你操作的就是节点的响应式表示（译注：即路径）而非节点本身。\n\n```json\nconst MyVisitor = {\n  Identifier(path) {\n    console.log(\"Visiting: \" + path.node.name);\n  }\n};\n```\n\n## Visiting 访问\n\n### Get the Path of Sub-Node\n\n为了得到一个AST节点的属性值，我们一般先访问到该节点，然后利用 path.node.property 方法即可： <a name=\"kxNY7\"></a>\n\n## 转换操作\n\n### 访问\n\n#### 获取子节点的Path\n\n为了得到一个AST节点的属性值，我们一般先访问到该节点，然后利用 `path.node.property` 方法即可：\n\n```javascript\n// 获取子节点的Path\n// 下面的例子遍历所有 BinaryExpression, 这里只有一个\n\nimport * as parser from \"@babel/parser\";\nimport traverse from \"@babel/traverse\";\nimport generate from '@babel/generator';\n\nconst code = `function square(n) {\n  return n * n;\n}`;\n\nconst ast = parser.parse(code);\n\ntraverse(ast, {\n  BinaryExpression(path) {\n    console.log(path.node.left) // Identifier Node\n    console.log(path.node.right) // Identifier Node\n    console.log(path.node.operator) // \"*\"\n  }\n});\n```\n\n#### 检查节点的类型\n\n```js\n// 改变函数参数的例子\n\nimport * as parser from \"@babel/parser\";\nimport traverse from \"@babel/traverse\";\nimport generate from '@babel/generator';\nimport helpers from '@babel/helpers';\nimport * as t from '@babel/types';\n\nconst code = `function square(n) {\n  return n * fn(n);\n}`;\n\nconst ast = parser.parse(code);\n\ntraverse(ast, {\n  BinaryExpression(path) {\n    // path.node.left: Identifier 标识符\n    // path.node.right: CallExpression 函数调用表达式\n    if(t.isIdentifier(path.node.left)) {\n      console.log(path.node)\n    }\n  }\n});\n```\n\n#### 检查路径（Path）类型\n\n```javascript\nBinaryExpression(path) {\n  if (path.get('left').isIdentifier({ name: \"n\" })) {\n    // ...\n  }\n}\n\n// 相当于\nBinaryExpression(path) {\n  if (t.isIdentifier(path.node.left, { name: \"n\" })) {\n    // ...\n  }\n}\n```\n\n#### 检查标识符（Identifier）是否被引用\n\n```javascript\n// 改变函数参数的例子\n\nimport * as parser from \"@babel/parser\";\nimport traverse from \"@babel/traverse\";\nimport generate from '@babel/generator';\nimport * as t from '@babel/types';\n\nconst code = `function square(n) {\n  return n * n;\n}`;\n\nconst ast = parser.parse(code);\n\ntraverse(ast, {\n  Identifier(path) {\n    if (path.isReferencedIdentifier()) {\n      // console.log(path.node)\n    }\n  }\n});\n```\n\n## 演示例子\n\n### 修改函数参数\n\n```javascript\n// 改变函数参数的例子\n\nimport * as parser from \"@babel/parser\";\nimport traverse from \"@babel/traverse\";\nimport generate from '@babel/generator';\n\nconst code = `function square(n) {\n  return n * n;\n}`;\n\nconst ast = parser.parse(code);\n\ntraverse(ast, {\n  enter(path) {\n    if (path.isIdentifier({ name: \"n\" })) {\n      path.node.name = \"x\";\n    }\n  }\n});\n\nconst output = generate(ast, { /* options */ }, code);\n\nconsole.log(output.code);\n\n// function square(x) {\n//   return x * x;\n// }\n```\n","isLeaf":true},{"key":"/subject/Babel/02 Babel API/07-@babel_types.md","path":"/subject/Babel/02 Babel API/07-@babel_types.md","route":"/subject/Babel/02 Babel API/07-@babel_types.md","leaf":true,"title":"07-@babel_types","depth":3,"content":"---\ntitle: 07 @babel/types\n---\n\n## Identify 标识符\n\n## Expression 表达式\n\n## Statement 语句\n\n## Literal 字面量\n","isLeaf":true},{"key":"/subject/Babel/02 Babel API/08-@babel_template.md","path":"/subject/Babel/02 Babel API/08-@babel_template.md","route":"/subject/Babel/02 Babel API/08-@babel_template.md","leaf":true,"title":"08-@babel_template","depth":3,"content":"","isLeaf":true}]},{"key":"/subject/Babel/03 插件开发","path":"/subject/Babel/03 插件开发","route":"/subject/Babel/03 插件开发","leaf":false,"title":"03 插件开发","depth":2,"content":"","isLeaf":false,"children":[{"key":"/subject/Babel/03 插件开发/01-docs.md","path":"/subject/Babel/03 插件开发/01-docs.md","route":"/subject/Babel/03 插件开发/01-docs.md","leaf":true,"title":"01-docs","depth":3,"content":"---\ntitle: 01 开发文档\nurl: https://www.yuque.com/gaollard/ubc1q5/kiltvy\n---\n\n<https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-get-the-path-of-a-sub-node>\n","isLeaf":true},{"key":"/subject/Babel/03 插件开发/02-ast.md","path":"/subject/Babel/03 插件开发/02-ast.md","route":"/subject/Babel/03 插件开发/02-ast.md","leaf":true,"title":"02-ast","depth":3,"content":"---\ntitle: 02 AST 遍历\nurl: https://www.yuque.com/gaollard/ubc1q5/mvu0v5\n---\n\n<a name=\"YuHXc\"></a>\n\n### Visitors（访问者）\n\n![20230608092029](http://s3.airtlab.com/blog/20230608092029.png)\n\n***\n\n![20230608092045](http://s3.airtlab.com/blog/20230608092045.png)\n\n***\n![20230608092113](http://s3.airtlab.com/blog/20230608092113.png)\n\n***\n\n![20230608092145](http://s3.airtlab.com/blog/20230608092145.png)\n\n***\n\n![20230608092200](http://s3.airtlab.com/blog/20230608092200.png)\n","isLeaf":true},{"key":"/subject/Babel/03 插件开发/03-node.md","path":"/subject/Babel/03 插件开发/03-node.md","route":"/subject/Babel/03 插件开发/03-node.md","leaf":true,"title":"03-node","depth":3,"content":"---\ntitle: 03 Node 节点\nurl: https://www.yuque.com/gaollard/ubc1q5/vqxtr7\n---\n\n### 1、Node 介绍\n\n![20230608092219](http://s3.airtlab.com/blog/20230608092219.png)\n\n![20230608092257](http://s3.airtlab.com/blog/20230608092257.png)\n\n### 2、Node 定义\n\n```typescript\ninterface BaseNode {\n  type: Node[\"type\"];\n  leadingComments?: Comment[] | null;\n  innerComments?: Comment[] | null;\n  trailingComments?: Comment[] | null;\n  start?: number | null;\n  end?: number | null;\n  loc?: SourceLocation | null;\n  range?: [number, number];\n  extra?: Record<string, unknown>;\n}\n```\n\n```typescript\ndeclare type Node = AnyTypeAnnotation | ArgumentPlaceholder | ArrayExpression | ArrayPattern | ArrayTypeAnnotation | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BigIntLiteral | BinaryExpression | BindExpression | BlockStatement | BooleanLiteral | BooleanLiteralTypeAnnotation | BooleanTypeAnnotation | BreakStatement | CallExpression | CatchClause | ClassAccessorProperty | ClassBody | ClassDeclaration | ClassExpression | ClassImplements | ClassMethod | ClassPrivateMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | ContinueStatement | DebuggerStatement | DecimalLiteral | DeclareClass | DeclareExportAllDeclaration | DeclareExportDeclaration | DeclareFunction | DeclareInterface | DeclareModule | DeclareModuleExports | DeclareOpaqueType | DeclareTypeAlias | DeclareVariable | DeclaredPredicate | Decorator | Directive | DirectiveLiteral | DoExpression | DoWhileStatement | EmptyStatement | EmptyTypeAnnotation | EnumBooleanBody | EnumBooleanMember | EnumDeclaration | EnumDefaultedMember | EnumNumberBody | EnumNumberMember | EnumStringBody | EnumStringMember | EnumSymbolBody | ExistsTypeAnnotation | ExportAllDeclaration | ExportDefaultDeclaration | ExportDefaultSpecifier | ExportNamedDeclaration | ExportNamespaceSpecifier | ExportSpecifier | ExpressionStatement | File | ForInStatement | ForOfStatement | ForStatement | FunctionDeclaration | FunctionExpression | FunctionTypeAnnotation | FunctionTypeParam | GenericTypeAnnotation | Identifier | IfStatement | Import | ImportAttribute | ImportDeclaration | ImportDefaultSpecifier | ImportNamespaceSpecifier | ImportSpecifier | IndexedAccessType | InferredPredicate | InterfaceDeclaration | InterfaceExtends | InterfaceTypeAnnotation | InterpreterDirective | IntersectionTypeAnnotation | JSXAttribute | JSXClosingElement | JSXClosingFragment | JSXElement | JSXEmptyExpression | JSXExpressionContainer | JSXFragment | JSXIdentifier | JSXMemberExpression | JSXNamespacedName | JSXOpeningElement | JSXOpeningFragment | JSXSpreadAttribute | JSXSpreadChild | JSXText | LabeledStatement | LogicalExpression | MemberExpression | MetaProperty | MixedTypeAnnotation | ModuleExpression | NewExpression | Noop | NullLiteral | NullLiteralTypeAnnotation | NullableTypeAnnotation | NumberLiteral$1 | NumberLiteralTypeAnnotation | NumberTypeAnnotation | NumericLiteral | ObjectExpression | ObjectMethod | ObjectPattern | ObjectProperty | ObjectTypeAnnotation | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeInternalSlot | ObjectTypeProperty | ObjectTypeSpreadProperty | OpaqueType | OptionalCallExpression | OptionalIndexedAccessType | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelinePrimaryTopicReference | PipelineTopicExpression | Placeholder | PrivateName | Program | QualifiedTypeIdentifier | RecordExpression | RegExpLiteral | RegexLiteral$1 | RestElement | RestProperty$1 | ReturnStatement | SequenceExpression | SpreadElement | SpreadProperty$1 | StaticBlock | StringLiteral | StringLiteralTypeAnnotation | StringTypeAnnotation | Super | SwitchCase | SwitchStatement | SymbolTypeAnnotation | TSAnyKeyword | TSArrayType | TSAsExpression | TSBigIntKeyword | TSBooleanKeyword | TSCallSignatureDeclaration | TSConditionalType | TSConstructSignatureDeclaration | TSConstructorType | TSDeclareFunction | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSExpressionWithTypeArguments | TSExternalModuleReference | TSFunctionType | TSImportEqualsDeclaration | TSImportType | TSIndexSignature | TSIndexedAccessType | TSInferType | TSInstantiationExpression | TSInterfaceBody | TSInterfaceDeclaration | TSIntersectionType | TSIntrinsicKeyword | TSLiteralType | TSMappedType | TSMethodSignature | TSModuleBlock | TSModuleDeclaration | TSNamedTupleMember | TSNamespaceExportDeclaration | TSNeverKeyword | TSNonNullExpression | TSNullKeyword | TSNumberKeyword | TSObjectKeyword | TSOptionalType | TSParameterProperty | TSParenthesizedType | TSPropertySignature | TSQualifiedName | TSRestType | TSStringKeyword | TSSymbolKeyword | TSThisType | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeLiteral | TSTypeOperator | TSTypeParameter | TSTypeParameterDeclaration | TSTypeParameterInstantiation | TSTypePredicate | TSTypeQuery | TSTypeReference | TSUndefinedKeyword | TSUnionType | TSUnknownKeyword | TSVoidKeyword | TaggedTemplateExpression | TemplateElement | TemplateLiteral | ThisExpression | ThisTypeAnnotation | ThrowStatement | TopicReference | TryStatement | TupleExpression | TupleTypeAnnotation | TypeAlias | TypeAnnotation | TypeCastExpression | TypeParameter | TypeParameterDeclaration | TypeParameterInstantiation | TypeofTypeAnnotation | UnaryExpression | UnionTypeAnnotation | UpdateExpression | V8IntrinsicIdentifier | VariableDeclaration | VariableDeclarator | Variance | VoidTypeAnnotation | WhileStatement | WithStatement | YieldExpression;\n```\n","isLeaf":true},{"key":"/subject/Babel/03 插件开发/04-path.md","path":"/subject/Babel/03 插件开发/04-path.md","route":"/subject/Babel/03 插件开发/04-path.md","leaf":true,"title":"04-path","depth":3,"content":"---\ntitle: 04 Path 路径\nurl: https://www.yuque.com/gaollard/ubc1q5/yhzw27\n---\n\n<a name=\"jNaIt\"></a>\n\n### 1、Path 介绍\n\n![20230608092337](http://s3.airtlab.com/blog/20230608092337.png)\n\n***\n\n![20230608092353](http://s3.airtlab.com/blog/20230608092353.png)\n\n### 2、Paths in Visitors（存在于访问者中的路径）\n\n![20230608092412](http://s3.airtlab.com/blog/20230608092412.png)\n\n### 3、demo 演示\n\n```javascript\nconst fs = require('fs');\nconst babel = require(\"@babel/core\");\n\nconst MyVisitor = {\n  Identifier(path) {\n    console.log(\"Visiting: \" + path.node.name);\n  }\n};\n\nfunction MyPlugin() {\n  return {\n    visitor: MyVisitor\n  }\n}\n\nvar res = babel.transformSync(\"var code = 1; var fn = () => {}\", {\n  ast: true,\n  plugins: [\n    require('@babel/plugin-transform-arrow-functions'),\n    MyPlugin\n  ]\n});\n\nconsole.log(res.code);\n```\n","isLeaf":true},{"key":"/subject/Babel/03 插件开发/05-binding.md","path":"/subject/Babel/03 插件开发/05-binding.md","route":"/subject/Babel/03 插件开发/05-binding.md","leaf":true,"title":"05-binding","depth":3,"content":"---\ntitle: 05 Bindings（绑定）\nurl: https://www.yuque.com/gaollard/ubc1q5/rw3qxv\n---\n\n一个作用域可以创建变量，这种关系被称为绑定。\n\n```typescript\nfunction scopeOnce() {\n  var ref = \"This is a binding\";\n\n  ref; // This is a reference to a binding\n\n  function scopeTwo() {\n    ref; // This is a reference to a binding from a lower scope\n  }\n}\n```\n\n## 1、Binding 的定义\n\n```typescript\nexport type BindingKind = 'var' | 'let' | 'const' | 'module' | 'hoisted' | 'param' | 'local' | 'unknown';\n\nexport class Binding {\n    constructor(opts: { identifier: t.Identifier; scope: Scope; path: NodePath; kind: BindingKind });\n    identifier: t.Identifier;\n    scope: Scope;\n    path: NodePath;\n    kind: BindingKind;\n    referenced: boolean;            // 是否被引用\n    references: number;             // 被引用次数\n    referencePaths: NodePath[];     // 被引用的路径\n    constant: boolean;              // 是否被修改\n    constantViolations: NodePath[];\n    hasDeoptedValue?: boolean;\n    hasValue?: boolean;\n    value?: any;\n\n    deopValue(): void;\n    setValue(value: any): void;\n    clearValue(): void;\n\n    reassign(path: NodePath): void;\n    reference(path: NodePath): void;\n    dereference(): void;\n}\n```\n\n有了这些信息你就可以查找一个绑定的所有引用，并且知道这是什么类型的绑定(参数，定义等等)，查找它所属的作用域，或者拷贝它的标识符。 你甚至可以知道它是不是常量，如果不是，那么是哪个路径修改了它。 <a name=\"I31IK\"></a>\n\n## 2、代码辅助理解\n\n### 1. 引用次数 \\[references]\n\n```typescript\nfunction test1() {\n  var a = 10;\n  console.log(a);\n}\n```\n\n```typescript\nbindings: [Object: null prototype] {\n  a: Binding {\n    identifier: [Node],\n    scope: [Circular],\n    path: [NodePath],\n    kind: 'var',\n    constantViolations: [],\n    constant: true,\n    referencePaths: [Array],\n    referenced: true,\n    references: 1,\n    hasDeoptedValue: false,\n    hasValue: false,\n    value: null\n  }\n}\n```\n\n### 2. 绑定是否是常量 \\[constant]\n\na 没有修改：\n\n```typescript\nfunction test1() {\n  var a = 10;\n  console.log(a);\n}\n```\n\n```typescript\nbindings: [Object: null prototype] {\n  a: Binding {\n    identifier: [Node],\n    scope: [Circular],\n    path: [NodePath],\n    kind: 'var',\n    constantViolations: [],\n    constant: true,\n    referencePaths: [Array],\n    referenced: true,\n    references: 1,\n    hasDeoptedValue: false,\n    hasValue: false,\n    value: null\n  }\n}\n```\n\na 有被修改：\n\n```typescript\nfunction test1() {\n  var a = 10;\n  a = 20;\n  console.log(a);\n}\n```\n\n```typescript\nBinding {\n  identifier: Node {\n    type: 'Identifier',\n    start: 26,\n    end: 27,\n    loc: SourceLocation {\n      start: [Position],\n      end: [Position],\n      filename: undefined,\n      identifierName: 'a'\n    },\n    name: 'a'\n  },\n  scope: Scope {\n    uid: 1,\n    path: NodePath {\n      contexts: [Array],\n      state: undefined,\n      opts: [Object],\n      _traverseFlags: 0,\n      skipKeys: null,\n      parentPath: [NodePath],\n      container: [Array],\n      listKey: 'body',\n      key: 0,\n      node: [Node],\n      type: 'FunctionDeclaration',\n      parent: [Node],\n      hub: undefined,\n      data: null,\n      context: [TraversalContext],\n      scope: [Circular]\n    },\n    block: Node {\n      type: 'FunctionDeclaration',\n      start: 1,\n      end: 63,\n      loc: [SourceLocation],\n      id: [Node],\n      generator: false,\n      async: false,\n      params: [],\n      body: [Node]\n    },\n    labels: Map {},\n    inited: true,\n    bindings: [Object: null prototype] { a: [Circular] },\n    references: [Object: null prototype] {},\n    globals: [Object: null prototype] {},\n    uids: [Object: null prototype] {},\n    data: [Object: null prototype] {},\n    crawling: undefined\n  },\n  path: NodePath {\n    contexts: [],\n    state: {\n      references: [Array],\n      constantViolations: [],\n      assignments: [Array]\n    },\n    opts: {\n      ForStatement: [Object],\n      ImportDeclaration: [Object],\n      LabeledStatement: [Object],\n      AssignmentExpression: [Object],\n      UpdateExpression: [Object],\n      UnaryExpression: [Object],\n      CatchClause: [Object],\n      ClassExpression: [Object],\n      _exploded: true,\n      _verified: true,\n      Identifier: [Object],\n      JSXIdentifier: [Object],\n      enter: [Array],\n      FunctionDeclaration: [Object],\n      VariableDeclaration: [Object],\n      ClassDeclaration: [Object],\n      ExportAllDeclaration: [Object],\n      ExportDefaultDeclaration: [Object],\n      ExportNamedDeclaration: [Object],\n      DeclareClass: [Object],\n      DeclareFunction: [Object],\n      DeclareInterface: [Object],\n      DeclareModule: [Object],\n      DeclareModuleExports: [Object],\n      DeclareTypeAlias: [Object],\n      DeclareOpaqueType: [Object],\n      DeclareVariable: [Object],\n      DeclareExportDeclaration: [Object],\n      DeclareExportAllDeclaration: [Object],\n      InterfaceDeclaration: [Object],\n      OpaqueType: [Object],\n      TypeAlias: [Object],\n      EnumDeclaration: [Object],\n      TSDeclareFunction: [Object],\n      TSInterfaceDeclaration: [Object],\n      TSTypeAliasDeclaration: [Object],\n      TSEnumDeclaration: [Object],\n      TSModuleDeclaration: [Object],\n      ForInStatement: [Object],\n      ForOfStatement: [Object],\n      FunctionExpression: [Object],\n      ObjectMethod: [Object],\n      ArrowFunctionExpression: [Object],\n      ClassMethod: [Object],\n      ClassPrivateMethod: [Object]\n    },\n    _traverseFlags: 0,\n    skipKeys: null,\n    parentPath: NodePath {\n      contexts: [],\n      state: [Object],\n      opts: [Object],\n      _traverseFlags: 0,\n      skipKeys: null,\n      parentPath: [NodePath],\n      container: [Array],\n      listKey: 'body',\n      key: 0,\n      node: [Node],\n      type: 'VariableDeclaration',\n      parent: [Node],\n      hub: undefined,\n      data: null,\n      context: [TraversalContext],\n      scope: [Scope]\n    },\n    container: [ [Node] ],\n    listKey: 'declarations',\n    key: 0,\n    node: Node {\n      type: 'VariableDeclarator',\n      start: 26,\n      end: 32,\n      loc: [SourceLocation],\n      id: [Node],\n      init: [Node]\n    },\n    type: 'VariableDeclarator',\n    parent: Node {\n      type: 'VariableDeclaration',\n      start: 22,\n      end: 33,\n      loc: [SourceLocation],\n      declarations: [Array],\n      kind: 'var'\n    },\n    hub: undefined,\n    data: null,\n    context: TraversalContext {\n      queue: null,\n      priorityQueue: [],\n      parentPath: [NodePath],\n      scope: [Scope],\n      state: [Object],\n      opts: [Object]\n    },\n    scope: Scope {\n      uid: 1,\n      path: [NodePath],\n      block: [Node],\n      labels: Map {},\n      inited: true,\n      bindings: [Object: null prototype],\n      references: [Object: null prototype] {},\n      globals: [Object: null prototype] {},\n      uids: [Object: null prototype] {},\n      data: [Object: null prototype] {},\n      crawling: undefined\n    }\n  },\n  kind: 'var',\n  constantViolations: [\n    NodePath {\n      contexts: [],\n      state: [Object],\n      opts: [Object],\n      _traverseFlags: 0,\n      skipKeys: null,\n      parentPath: [NodePath],\n      container: [Node],\n      listKey: undefined,\n      key: 'expression',\n      node: [Node],\n      type: 'AssignmentExpression',\n      parent: [Node],\n      hub: undefined,\n      data: null,\n      context: [TraversalContext],\n      scope: [Scope]\n    }\n  ],\n  constant: false,\n  referencePaths: [\n    NodePath {\n      contexts: [],\n      state: [Object],\n      opts: [Object],\n      _traverseFlags: 0,\n      skipKeys: null,\n      parentPath: [NodePath],\n      container: [Array],\n      listKey: 'arguments',\n      key: 0,\n      node: [Node],\n      type: 'Identifier',\n      parent: [Node],\n      hub: undefined,\n      data: null,\n      context: [TraversalContext],\n      scope: [Scope]\n    }\n  ],\n  referenced: true,\n  references: 1,\n  hasDeoptedValue: false,\n  hasValue: false,\n  value: null\n}\n\n```\n\n### 3. 只有 变量定义 和 函数定义 拥有 binding\n\n```typescript\nlet binding = scope.getBinding(name);\n// 例如: var a = 123; 这里的 a 就拥有 binding。\n\nfunction test(a,b,c) {};\n// 函数名test以及形参a，b，c均拥有 binding。\n```\n\n### 4. binding.path\n\n用于定位初始拥有binding的path; <a name=\"hn5qZ\"></a>\n\n### 5. binding.referenced\n\n用于判断当前变量是否被引用，true表示代码下面有引用该变量的地方，false表示没有地方引用该变量。注意，引用和改变是分开的。 <a name=\"Y9Wns\"></a>\n\n### 6. binding.referencePaths\n\n它是一个Array类型，包含所有引用的path，多用于替换。\n\n### 7. binding.constantViolations\n\n它是一个Array类型，包含所有改变的path，多用于判断。\n","isLeaf":true},{"key":"/subject/Babel/03 插件开发/06-scope.md","path":"/subject/Babel/03 插件开发/06-scope.md","route":"/subject/Babel/03 插件开发/06-scope.md","leaf":true,"title":"06-scope","depth":3,"content":"---\ntitle: 06 Scopes（作用域）\nurl: https://www.yuque.com/gaollard/ubc1q5/wt5qg7\n---\n\n## 1、Scope 介绍\n\n接下来让我们介绍 [作用域（scope）](https://en.wikipedia.org/wiki/Scope_\\(computer_science\\))的概念。 JavaScript 支持[词法作用域](https://en.wikipedia.org/wiki/Scope_\\(computer_science\\)#Lexical_scoping_vs._dynamic_scoping)，在树状嵌套结构中代码块创建出新的作用域。\n\n```javascript\n// global scope\n\nfunction scopeOne() {\n  // scope 1\n  function scopeTwo() {\n    // scope 2\n  }\n}\n```\n\n在 JavaScript 中，每当你创建了一个引用，不管是通过变量（variable）、函数（function）、类型（class）、参数（params）、模块导入（import）还是标签（label）等，它都属于当前作用域。\n\n```javascript\nvar global = \"I am in the global scope\";\n\nfunction scopeOne() {\n  var one = \"I am in the scope created by `scopeOne()`\";\n\n  function scopeTwo() {\n    var two = \"I am in the scope created by `scopeTwo()`\";\n  }\n}\n```\n\n更深的内部作用域代码可以使用外层作用域中的引用。\n\n```javascript\nfunction scopeOne() {\n  var one = \"I am in the scope created by `scopeOne()`\";\n\n  function scopeTwo() {\n    one = \"I am updating the reference in `scopeOne` inside `scopeTwo`\";\n  }\n}\n```\n\n内层作用域也可以创建和外层作用域同名的引用。\n\n```javascript\nfunction scopeOne() {\n  var one = \"I am in the scope created by `scopeOne()`\";\n\n  function scopeTwo() {\n    var one = \"I am creating a new `one` but leaving reference in `scopeOne()` alone.\";\n  }\n}\n```\n\n当编写一个转换时，必须小心作用域。我们得确保在改变代码的各个部分时不会破坏已经存在的代码。\n我们在添加一个新的引用时需要确保新增加的引用名字和已有的所有引用不冲突。 或者我们仅仅想找出使用一个变量的所有引用， 我们只想在给定的作用域（Scope）中找出这些引用。\n作用域可以被表示为如下形式：\n\n```javascript\n{\n  path: path,\n  block: path.node,\n  parentBlock: path.parent,\n  parent: parentScope,\n  bindings: [...]\n}\n```\n\n当你创建一个新的作用域时，需要给出它的路径和父作用域，之后在遍历过程中它会在该作用域内收集所有的引用(“绑定”)。\n一旦引用收集完毕，你就可以在作用域（Scopes）上使用各种方法，稍后我们会了解这些方法。\n\n## 2、Scope 定义\n\nScope 表示作用域\n\n```typescript\nexport class Scope {\n    constructor(path: NodePath, parentScope?: Scope);\n    path: NodePath;\n    block: Node;\n    parentBlock: Node;\n    parent: Scope;\n    hub: HubInterface;\n    bindings: { [name: string]: Binding };\n\n    /** Traverse node with current scope and path. */\n    traverse<S>(node: Node | Node[], opts: TraverseOptions<S>, state: S): void;\n    traverse(node: Node | Node[], opts?: TraverseOptions, state?: any): void;\n\n    /** Generate a unique identifier and add it to the current scope. */\n    generateDeclaredUidIdentifier(name?: string): t.Identifier;\n\n    /** Generate a unique identifier. */\n    generateUidIdentifier(name?: string): t.Identifier;\n\n    /** Generate a unique `_id1` binding. */\n    generateUid(name?: string): string;\n\n    /** Generate a unique identifier based on a node. */\n    generateUidIdentifierBasedOnNode(parent: Node, defaultName?: string): t.Identifier;\n\n    /**\n     * Determine whether evaluating the specific input `node` is a consequenceless reference. ie.\n     * evaluating it wont result in potentially arbitrary code from being ran. The following are\n     * whitelisted and determined not to cause side effects:\n     *\n     *  - `this` expressions\n     *  - `super` expressions\n     *  - Bound identifiers\n     */\n    isStatic(node: Node): boolean;\n\n    /** Possibly generate a memoised identifier if it is not static and has consequences. */\n    maybeGenerateMemoised(node: Node, dontPush?: boolean): t.Identifier;\n\n    checkBlockScopedCollisions(local: Binding, kind: BindingKind, name: string, id: object): void;\n\n    rename(oldName: string, newName?: string, block?: Node): void;\n\n    dump(): void;\n\n    toArray(node: Node, i?: number): Node;\n\n    registerDeclaration(path: NodePath): void;\n\n    buildUndefinedNode(): Node;\n\n    registerConstantViolation(path: NodePath): void;\n\n    registerBinding(kind: string, path: NodePath, bindingPath?: NodePath): void;\n\n    addGlobal(node: Node): void;\n\n    hasUid(name: string): boolean;\n\n    hasGlobal(name: string): boolean;\n\n    hasReference(name: string): boolean;\n\n    isPure(node: Node, constantsOnly?: boolean): boolean;\n\n    setData(key: string, val: any): any;\n\n    getData(key: string): any;\n\n    removeData(key: string): void;\n\n    crawl(): void;\n\n    push(opts: {\n        id: t.LVal;\n        init?: t.Expression | undefined;\n        unique?: boolean | undefined;\n        kind?: 'var' | 'let' | 'const' | undefined;\n    }): void;\n\n    getProgramParent(): Scope;\n\n    getFunctionParent(): Scope | null;\n\n    getBlockParent(): Scope;\n\n    /** Walks the scope tree and gathers **all** bindings. */\n    getAllBindings(...kinds: string[]): object;\n\n    bindingIdentifierEquals(name: string, node: Node): boolean;\n\n    getBinding(name: string): Binding | undefined;\n\n    getOwnBinding(name: string): Binding | undefined;\n\n    getBindingIdentifier(name: string): t.Identifier;\n\n    getOwnBindingIdentifier(name: string): t.Identifier;\n\n    hasOwnBinding(name: string): boolean;\n\n    hasBinding(name: string, noGlobals?: boolean): boolean;\n\n    parentHasBinding(name: string, noGlobals?: boolean): boolean;\n\n    /** Move a binding of `name` to another `scope`. */\n    moveBindingTo(name: string, scope: Scope): void;\n\n    removeOwnBinding(name: string): void;\n\n    removeBinding(name: string): void;\n}\n\n```\n\n## 3、代码辅助理解\n\n### 1. 查看 scope 结构\n\n```typescript\nimport * as fs from \"fs\";\nimport * as path from 'path';\nimport * as babel from \"@babel/core\";\n\nconst code = `\nfunction test1() {\n  var a = 10;\n}\n`\n\nconst data = babel.parse(code, {\n  presets: [\"@babel/preset-typescript\"],\n  plugins: [\n    [\n      \"@babel/plugin-proposal-decorators\",\n      {\n        legacy: true,\n      },\n    ],\n  ],\n  filename: 'sss',\n});\n\n\nbabel.traverse(data, {\n  FunctionDeclaration(path) {\n    console.log(path.scope)\n  }\n})\n```\n\n```typescript\nScope {\n  uid: 1,\n  path: NodePath {\n    contexts: [ [TraversalContext] ],\n    state: undefined,\n    opts: { FunctionDeclaration: [Object], _exploded: true, _verified: true },\n    _traverseFlags: 0,\n    skipKeys: null,\n    parentPath: NodePath {\n      contexts: [Array],\n      state: undefined,\n      opts: [Object],\n      _traverseFlags: 0,\n      skipKeys: null,\n      parentPath: null,\n      container: [Node],\n      listKey: undefined,\n      key: 'program',\n      node: [Node],\n      type: 'Program',\n      parent: [Node],\n      hub: undefined,\n      data: null,\n      context: [TraversalContext],\n      scope: [Scope]\n    },\n    container: [ [Node] ],\n    listKey: 'body',\n    key: 0,\n    node: Node {\n      type: 'FunctionDeclaration',\n      start: 1,\n      end: 35,\n      loc: [SourceLocation],\n      id: [Node],\n      generator: false,\n      async: false,\n      params: [],\n      body: [Node]\n    },\n    type: 'FunctionDeclaration',\n    parent: Node {\n      type: 'Program',\n      start: 0,\n      end: 36,\n      loc: [SourceLocation],\n      sourceType: 'module',\n      interpreter: null,\n      body: [Array],\n      directives: []\n    },\n    hub: undefined,\n    data: null,\n    context: TraversalContext {\n      queue: [Array],\n      priorityQueue: [],\n      parentPath: [NodePath],\n      scope: [Scope],\n      state: undefined,\n      opts: [Object]\n    },\n    scope: [Circular]\n  },\n  block: Node {\n    type: 'FunctionDeclaration',\n    start: 1,\n    end: 35,\n    loc: SourceLocation {\n      start: [Position],\n      end: [Position],\n      filename: undefined,\n      identifierName: undefined\n    },\n    id: Node {\n      type: 'Identifier',\n      start: 10,\n      end: 15,\n      loc: [SourceLocation],\n      name: 'test1'\n    },\n    generator: false,\n    async: false,\n    params: [],\n    body: Node {\n      type: 'BlockStatement',\n      start: 18,\n      end: 35,\n      loc: [SourceLocation],\n      body: [Array],\n      directives: []\n    }\n  },\n  labels: Map {},\n  inited: true,\n  bindings: [Object: null prototype] {\n    a: Binding {\n      identifier: [Node],\n      scope: [Circular],\n      path: [NodePath],\n      kind: 'var',\n      constantViolations: [],\n      constant: true,\n      referencePaths: [],\n      referenced: false,\n      references: 0,\n      hasDeoptedValue: false,\n      hasValue: false,\n      value: null\n    }\n  },\n  references: [Object: null prototype] {},\n  globals: [Object: null prototype] {},\n  uids: [Object: null prototype] {},\n  data: [Object: null prototype] {},\n  crawling: undefined\n}\n```\n\n- block  该作用域所属的 code block\n- path   该作用域所属的 NodePath\n- bindings  该作用域能够访问变量 <a name=\"Bi4FK\"></a>\n\n### 2. 查看 binding\n\n```typescript\nimport * as fs from \"fs\";\nimport * as path from 'path';\nimport * as babel from \"@babel/core\";\n\nconst code = `\nfunction test1() {\n  var a = 10;\n}\n\nfunction test2() {\n  var b = 10;\n}\n`\n\nconst data = babel.parse(code, {\n  presets: [\"@babel/preset-typescript\"],\n  plugins: [\n    [\n      \"@babel/plugin-proposal-decorators\",\n      {\n        legacy: true,\n      },\n    ],\n  ],\n  filename: 'sss',\n});\n\n\nbabel.traverse(data, {\n  FunctionDeclaration(path) {\n    if (babel.types.isIdentifier(path.node.id)) {\n      console.log(path.node.id.name, path.scope.hasBinding(\"a\"))\n    }\n  }\n})\n\n// test1 true\n// test2 false\n```","isLeaf":true},{"key":"/subject/Babel/03 插件开发/07-state.md","path":"/subject/Babel/03 插件开发/07-state.md","route":"/subject/Babel/03 插件开发/07-state.md","leaf":true,"title":"07-state","depth":3,"content":"---\ntitle: 07 State（状态）\nurl: https://www.yuque.com/gaollard/ubc1q5/prgac1\n---\n\n状态是抽象语法树AST转换的敌人，状态管理会不断牵扯你的精力，而且几乎所有你对状态的假设，总是会有一些未考虑到的语法最终证明你的假设是错误的。\n考虑下列代码：\n\n```javascript\nfunction square(n) {\n  return n * n;\n}\n```\n\n让我们写一个把 n 重命名为 x 的访问者的快速实现:\n\n```javascript\nlet paramName;\n\nconst MyVisitor = {\n  FunctionDeclaration(path) {\n    const param = path.node.params[0];\n    paramName = param.name;\n    param.name = \"x\";\n  },\n\n  Identifier(path) {\n    if (path.node.name === paramName) {\n      path.node.name = \"x\";\n    }\n  }\n};\n```\n\n对上面的例子代码这段访问者代码也许能工作，但它很容易被打破：\n\n```javascript\nfunction square(n) {\n  return n * n;\n}\nn;\n```\n\n更好的处理方式是使用递归，下面让我们来像克里斯托佛·诺兰的电影盗梦空间那样来把一个访问者放进另外一个访问者里面:\n\n```javascript\nconst updateParamNameVisitor = {\n  Identifier(path) {\n    if (path.node.name === this.paramName) {\n      path.node.name = \"x\";\n    }\n  }\n};\n\nconst MyVisitor = {\n  FunctionDeclaration(path) {\n    const param = path.node.params[0];\n    const paramName = param.name;\n    param.name = \"x\";\n\n    path.traverse(updateParamNameVisitor, { paramName });\n  }\n};\n\npath.traverse(MyVisitor);\n```\n\n注意例子中 `path.traverse(updateParamNameVisitor, { paramName })` 第二个参数，在 visitor 中通过 this 可以访问。\n\n这个例子演示了如何从访问者中消除全局状态。\n","isLeaf":true}]},{"key":"/subject/Babel/04 babel-usage","path":"/subject/Babel/04 babel-usage","route":"/subject/Babel/04 babel-usage","leaf":false,"title":"04 babel-usage","depth":2,"content":"","isLeaf":false,"children":[{"key":"/subject/Babel/04 babel-usage/01.md","path":"/subject/Babel/04 babel-usage/01.md","route":"/subject/Babel/04 babel-usage/01.md","leaf":true,"title":"01","depth":3,"content":"---\ntitle: 1、生成 AST\nurl: https://www.yuque.com/gaollard/ubc1q5/fzvnnp\n---\n\n```javascript\nconst fs = require('fs');\nconst babel = require(\"@babel/core\");\n\nvar res = babel.transformSync(\"var code = 1; var fn = () => {}\", {\n  ast: true,\n  plugins: [\n    require('@babel/plugin-transform-arrow-functions')\n  ]\n});\n\nconsole.log(res.code);\n```\n","isLeaf":true},{"key":"/subject/Babel/04 babel-usage/02.md","path":"/subject/Babel/04 babel-usage/02.md","route":"/subject/Babel/04 babel-usage/02.md","leaf":true,"title":"02","depth":3,"content":"---\ntitle: 2、useBuiltIns 的用法\nurl: https://www.yuque.com/gaollard/ubc1q5/xwfbok\n---\n\n","isLeaf":true},{"key":"/subject/Babel/04 babel-usage/03.md","path":"/subject/Babel/04 babel-usage/03.md","route":"/subject/Babel/04 babel-usage/03.md","leaf":true,"title":"03","depth":3,"content":"---\ntitle: 3、插入节点\nurl: https://www.yuque.com/gaollard/ubc1q5/sheq24\n---\n\n### 1. 插入 Node\n\n### 2. 插入 字符串代码\n","isLeaf":true}]},{"key":"/subject/Babel/05 babel-shizhan","path":"/subject/Babel/05 babel-shizhan","route":"/subject/Babel/05 babel-shizhan","leaf":false,"title":"05 babel-shizhan","depth":2,"content":"","isLeaf":false,"children":[{"key":"/subject/Babel/05 babel-shizhan/01-how-to-traverse-jsx.md","path":"/subject/Babel/05 babel-shizhan/01-how-to-traverse-jsx.md","route":"/subject/Babel/05 babel-shizhan/01-how-to-traverse-jsx.md","leaf":true,"title":"01-how-to-traverse-jsx","depth":3,"content":"我在写一个 babel 插件，用于给每一个 div 标签都加一个 css class。现在出现了两种场景。\n\n## 1、`React.createElement('div', {})`\n\n![20230511185255](http://s3.airtlab.com/blog/20230511185255.png)\n\n```js\nmodule.exports = function (api) {\n  api && api.cache(false);\n  return {\n    presets: [\n      [\"@babel/preset-react\", { runtime: \"classic\" }],\n    ],\n    plugins: [\n      // 注意 prefix 中的空格\n      [\"./src/babel-plugin-change-jsx-className\", {\n        prefix: 'f6 '\n      }]\n    ]\n  };\n};\n\n```\n\n```js\nconst fs = require('fs');\nconst { Console } = require('console');\nconst logFile = process.cwd() + '/' + 'a.log'\n\nconst std = fs.createWriteStream(logFile, { flags: 'a' });\nconst console = new Console(std);\nconst types = require('@babel/types');\nlet config = {};\n\nmodule.exports = function (\n  _,\n  options = {\n    prefix: '',\n  },\n) {\n  config = options;\n  return {\n    visitor: {\n      CallExpression,\n      JSXElement(path) {\n        const node = path.node;\n        if (node.openingElement.name.name === \"div\") {\n          console.log(\"Found div:\", node);\n        }\n      },\n      BinaryExpression(path) {\n        console.log(path.node.left); // Identifier Node\n        console.log(path.node.right); // Identifier Node\n        console.log(path.node.operator); // \"*\"\n      },\n    },\n  };\n};\n\nfunction CallExpression(path) {\n  // debugger;\n  const _this = this;\n  const callee = path.node.callee;\n  console.log(444, callee);\n\n  if (callee.type === 'MemberExpression') {\n    const callFn = callee.object.name + '.' + callee.property.name;\n    if (callFn === 'React.createElement') {\n      path.skip();\n\n      const arg1 = path.get('arguments.1');\n\n      if (arg1.node.type === 'NullLiteral') {\n        // null\n        arg1.replaceWith(\n          types.objectExpression([\n            types.objectProperty(\n              types.identifier('className'),\n              types.stringLiteral(config.prefix),\n            ),\n            types.objectProperty(\n              types.identifier('data-code'),\n              types.stringLiteral(_this.filename),\n            ),\n          ]),\n        );\n      } else {\n        // {}\n        if (arg1.node.type === 'ObjectExpression') {\n          const index = arg1.node.properties.findIndex((it) => {\n            return it.key.name === 'className';\n          });\n          if (index !== -1) {\n            const proPath = arg1.get(`properties.${index}`);\n            proPath.node.value = types.binaryExpression(\n              '+',\n              types.StringLiteral(config.prefix),\n              proPath.node.value,\n            );\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n```json\n{\n  \"name\": \"f6\",\n  \"version\": \"0.0.0\",\n  \"description\": \"> TODO: description\",\n  \"author\": \"gaollard <1056834607@qq.com>\",\n  \"homepage\": \"\",\n  \"license\": \"ISC\",\n  \"main\": \"src/index.js\",\n  \"directories\": {\n    \"lib\": \"lib\",\n    \"test\": \"__tests__\"\n  },\n  \"files\": [\n    \"lib\",\n    \"src\"\n  ],\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: run tests from root\\\" && exit 1\",\n    \"build\": \"babel demo/index.js\"\n  },\n  \"dependencies\": {\n    \"@babel/generator\": \"^7.16.5\",\n    \"@babel/preset-react\": \"^7.16.5\",\n    \"@babel/runtime\": \"^7.16.5\",\n    \"@types/react-transition-group\": \"^4.4.4\"\n  },\n  \"devDependencies\": {\n    \"@babel/cli\": \"^7.16.0\",\n    \"@babel/core\": \"^7.16.5\",\n    \"@babel/plugin-syntax-dynamic-import\": \"^7.0.0\",\n    \"@babel/plugin-transform-modules-commonjs\": \"^7.16.5\",\n    \"@babel/plugin-transform-object-assign\": \"^7.0.0\",\n    \"@babel/plugin-transform-runtime\": \"^7.4.4\",\n    \"@babel/polyfill\": \"^7.4.4\",\n    \"@babel/preset-env\": \"^7.16.5\",\n    \"@babel/preset-typescript\": \"^7.3.3\",\n    \"@types/react\": \"^17.0.34\",\n    \"@types/react-dom\": \"^17.0.11\",\n    \"style-loader\": \"^3.3.1\",\n    \"css-loader\": \"^6.5.1\",\n    \"react\": \"^17.0.2\",\n    \"react-dom\": \"^17.0.2\",\n    \"rimraf\": \"^3.0.2\",\n    \"typescript\": \"^4.4.4\"\n  },\n  \"peerDependencies\": {\n    \"classnames\": \"^2.3.1\",\n    \"react\": \"^17.0.2\",\n    \"react-dom\": \"^17.0.2\"\n  }\n}\n```\n\n## 2、_jsx('div', {})\n\n![20230511190028](http://s3.airtlab.com/blog/20230511190028.png)\n\n## 3、遍历 JSXElement 更合理\n\n![20230511191205](http://s3.airtlab.com/blog/20230511191205.png)","isLeaf":true},{"key":"/subject/Babel/05 babel-shizhan/02-plugin-transform-react-jsx.md","path":"/subject/Babel/05 babel-shizhan/02-plugin-transform-react-jsx.md","route":"/subject/Babel/05 babel-shizhan/02-plugin-transform-react-jsx.md","leaf":true,"title":"02-plugin-transform-react-jsx","depth":3,"content":"- 原理\n- 源码分析","isLeaf":true},{"key":"/subject/Babel/05 babel-shizhan/03-add-prop-to-jsx.md","path":"/subject/Babel/05 babel-shizhan/03-add-prop-to-jsx.md","route":"/subject/Babel/05 babel-shizhan/03-add-prop-to-jsx.md","leaf":true,"title":"03-add-prop-to-jsx","depth":3,"content":"https://www.johno.com/add-a-prop-to-jsx-elements-with-babel\n\n```js\nexport default (api) => {\n  const { types: t } = api;\n\n  return {\n    visitor: {\n      JSXOpeningElement(path) {\n        const existingProp = path.node.attributes.find(\n          (node) => node.name && node.name.name === \"favoriteColor\"\n        );\n\n        if (existingProp) {\n          existingProp.node.value.value === \"tomato\";\n          return;\n        }\n\n        const newProp = t.jSXAttribute(\n          t.jSXIdentifier(\"favoriteColor\"),\n          t.stringLiteral(\"tomato\")\n        );\n\n        path.node.attributes.push(newProp);\n      },\n    },\n  };\n};\n```\n","isLeaf":true},{"key":"/subject/Babel/05 babel-shizhan/04-change-jsx-className.md","path":"/subject/Babel/05 babel-shizhan/04-change-jsx-className.md","route":"/subject/Babel/05 babel-shizhan/04-change-jsx-className.md","leaf":true,"title":"04-change-jsx-className","depth":3,"content":"---\ntitle: 01 change-jsx-className\nurl: https://www.yuque.com/gaollard/ubc1q5/nafu7s\n---\n\n<https://github.com/Webang/babel-plugin-change-jsx-className>\n\n```typescript\nconst types = require(\"@babel/types\");\nlet config = {};\n\nmodule.exports = function (\n  _,\n  options = {\n    prefix: \"\",\n  }\n) {\n  config = options;\n  return {\n    visitor: {\n      CallExpression,\n    },\n  };\n};\n\nfunction CallExpression(path) {\n  const callee = path.node.callee;\n  if (callee.type === \"MemberExpression\") {\n    const callFn = callee.object.name + \".\" + callee.property.name;\n    if (callFn === \"React.createElement\") {\n      path.skip();\n\n      const arg1 = path.get(\"arguments.1\");\n\n      if (arg1.node.type === 'NullLiteral') {\n        // null\n        arg1.replaceWith(types.objectExpression([\n          types.objectProperty(types.identifier('className'), types.stringLiteral(config.prefix))\n        ]))\n      } else {\n        // {}\n        if ((arg1.node.type) === 'ObjectExpression') {\n          const index = arg1.node.properties.findIndex(it => {\n            return it.key.name === 'className'\n          });\n          if (index !== -1) {\n            const proPath = arg1.get(`properties.${index}`);\n            proPath.node.value = types.binaryExpression(\n              \"+\",\n              types.StringLiteral(config.prefix),\n              proPath.node.value\n            );\n          }\n        }\n      }\n    }\n  }\n}\n\n```","isLeaf":true},{"key":"/subject/Babel/05 babel-shizhan/05-how-comipler-typescript.md","path":"/subject/Babel/05 babel-shizhan/05-how-comipler-typescript.md","route":"/subject/Babel/05 babel-shizhan/05-how-comipler-typescript.md","leaf":true,"title":"05-how-comipler-typescript","depth":3,"content":"---\ntitle: 05 如何编译 typescript\n---\n\n- 如果没有使用 Babel，首选 TypeScript 自带编译器（配合 ts-loader 使用）\n- 如果项目中有 Babel，安装 @babel/preset-typescript，配合 tsc 做类型检查。\n\n两种编译器不要混用。参考 https://juejin.cn/post/6954304242093932557#heading-7","isLeaf":true},{"key":"/subject/Babel/05 babel-shizhan/06-rename-function-param.md","path":"/subject/Babel/05 babel-shizhan/06-rename-function-param.md","route":"/subject/Babel/05 babel-shizhan/06-rename-function-param.md","leaf":true,"title":"06-rename-function-param","depth":3,"content":"---\ntitle: 06 修改函数参数\n---\n\n```js\nmodule.exports = function({ types: t }) {\n  return {\n    visitor: {\n      FunctionDeclaration(path, state) {\n        path.scope.rename('age', path.scope.generateUidIdentifier(\"age\").name)\n      }\n    }\n  }\n}\n```\n\n```js\nmodule.exports = function({ types: t }) {\n  return {\n    visitor: {\n      FunctionDeclaration(path, state) {\n        const { replaceMap } = state.opts;\n        const params = path.get('params');\n\n        params.forEach((idPath) => {\n          if (replaceMap[idPath.node.name]) {\n            idPath.replaceWith(t.identifier(replaceMap[idPath.node.name]))\n          }\n        })\n\n        Object.keys(path.scope.bindings).forEach((name) => {\n          const referencePaths = path.scope.bindings[name].referencePaths\n          referencePaths.forEach((idPath) => {\n            if (replaceMap[idPath.node.name]) {\n              idPath.replaceWith(t.identifier(replaceMap[idPath.node.name]))\n            }\n          })\n        })\n      }\n    }\n  }\n}\n```\n","isLeaf":true}]},{"key":"/subject/Babel/06 acorn","path":"/subject/Babel/06 acorn","route":"/subject/Babel/06 acorn","leaf":false,"title":"06 acorn","depth":2,"content":"","isLeaf":false,"children":[{"key":"/subject/Babel/06 acorn/00.md","path":"/subject/Babel/06 acorn/00.md","route":"/subject/Babel/06 acorn/00.md","leaf":true,"title":"00","depth":3,"content":"---\ntitle: acorn 源码分析\ntags: acorn\n---\n\n- AST 在线 <https://astexplorer.net/#/2uBU1BLuJ1>\n","isLeaf":true},{"key":"/subject/Babel/06 acorn/01-the-super-tiny-compiler.md","path":"/subject/Babel/06 acorn/01-the-super-tiny-compiler.md","route":"/subject/Babel/06 acorn/01-the-super-tiny-compiler.md","leaf":true,"title":"01-the-super-tiny-compiler","depth":3,"content":"---\ntitle: 01 the-super-tiny-compiler 源码分析\ntags: acornjs\n---\n\n<https://github.com/jamiebuilds/the-super-tiny-compiler>，这个设计库实在太过简单（比如：不支持取反操作），只能用作学习 compiler 的流程设计。\n\n- tokenizer(词法分析器)：划分 token，产生一个 token 数组\n- parser(语法分析器)：接受 token 数组，然后把它转化为 AST <a name=\"bsEHt\"></a>\n\n### 1. 测试 the-super-tiny-compiler\n\n    (add 21 (subtract 4 2))\n\n- (op v1 v2) 括号表示一个 CallExpression 调用表达式\n- add +\n- subtract -\n- token 只包含\n  - NumberLiteral 数字字面量\n  - StringLiteral 字符串字面量\n  - CallExpression 调用表达式\n    - add\n    - subtract\n\n#### 1.1 tokens\n\n```json\n[\n  {\n    \"type\": \"paren\",\n    \"value\": \"(\"\n  },\n  {\n    \"type\": \"name\",\n    \"value\": \"add\"\n  },\n  {\n    \"type\": \"number\",\n    \"value\": \"21\"\n  },\n  {\n    \"type\": \"paren\",\n    \"value\": \"(\"\n  },\n  {\n    \"type\": \"name\",\n    \"value\": \"subtract\"\n  },\n  {\n    \"type\": \"number\",\n    \"value\": \"4\"\n  },\n  {\n    \"type\": \"number\",\n    \"value\": \"2\"\n  },\n  {\n    \"type\": \"paren\",\n    \"value\": \")\"\n  },\n  {\n    \"type\": \"paren\",\n    \"value\": \")\"\n  }\n]\n```\n\n#### 1.2 AST\n\n```json\n{\n  \"type\": \"Program\",\n  \"body\": [\n    {\n      \"type\": \"CallExpression\",\n      \"name\": \"add\",\n      \"params\": [\n        {\n          \"type\": \"NumberLiteral\",\n          \"value\": \"21\"\n        },\n        {\n          \"type\": \"CallExpression\",\n          \"name\": \"subtract\",\n          \"params\": [\n            {\n              \"type\": \"NumberLiteral\",\n              \"value\": \"4\"\n            },\n            {\n              \"type\": \"NumberLiteral\",\n              \"value\": \"2\"\n            }\n          ]\n        }\n      ]\n    }\n  ]\n}\n```\n\n<a name=\"RKRFw\"></a>\n\n### 2. 自己实现\n\n<a name=\"fQ8XC\"></a>\n\n#### 2.1 tokenizer\n\n```javascript\n/**\n * @param {string} input \n */\nfunction tokenizer(input) {\n  let current = 0;\n  let tokens = [];\n\n  const lt_parent_l = '(';\n  const lt_parent_r = ')';\n\n  const type_paren = 'paren';\n  const type_number = 'number';\n  const type_string = 'string';\n  const type_name = 'name';\n\n  const reg_whitespcae = /\\s/;\n  const reg_numbers = /[0-9]/;\n  const reg_letters = /[a-z]/i;\n\n  const isEof = () => current >= input.length;\n\n  const genToken = (type, value, start) => {\n    const token = {\n      type,\n      value\n    }\n    token.loc = {\n      start,\n      end: token.value.length + start\n    }\n    tokens.push(token)\n  } \n\n  while(!isEof()) {\n    let c_char = input[current];\n\n    if (c_char === lt_parent_l) {\n      genToken(type_paren, c_char, current)\n      current++;\n      continue;\n    }\n\n    if (c_char === lt_parent_r) {\n      genToken(type_paren, c_char, current)\n      current++;\n      continue;\n    }\n\n    if (reg_whitespcae.test(c_char)) {\n      current++;\n      continue;\n    }\n\n    if (reg_numbers.test(c_char)) {\n      // 解析出当前的整型字面量\n\n      let value = '';\n      let start = current;\n\n      while(reg_numbers.test(c_char)) {\n        value += c_char;\n        c_char = input[++current];\n      }\n\n      genToken(type_number, value, start)\n      continue;\n    }\n\n    if (c_char === '\"') {\n      // 找出完整的字符串\n\n      let start = current\n      let value = '';\n      c_char = input[current++]; \n\n      while(c_char !== '\"') {\n        value += c_char;\n        c_char = input[++current];\n      }\n\n      // 跳过闭合的双引号\n      c_char = input[++current];\n\n      genToken(type_string, value, start)\n      continue;\n    }\n\n    if (reg_letters.test(c_char)) {\n      // 找出完整的关键字\n      let start = current;\n      let value = '';\n      while(reg_letters.test(c_char)) {\n        value += c_char;\n        c_char = input[++current];\n      }\n\n      genToken(type_name, value, start)\n      continue;\n    }\n\n    // 如果还剩一些字符，说明表达式语法有错误\n    throw new TypeError('I dont know what this character is: ' + char);\n  }\n\n  return tokens;\n}\n```\n\n```javascript\n// (add 21 (subtract 4 2))\n[\n  { type: 'paren', value: '(', loc: { start: 0, end: 1 } },\n  { type: 'name', value: 'add', loc: { start: 1, end: 4 } },\n  { type: 'number', value: '21', loc: { start: 5, end: 7 } },\n  { type: 'paren', value: '(', loc: { start: 8, end: 9 } },\n  { type: 'name', value: 'subtract', loc: { start: 9, end: 17 } },\n  { type: 'number', value: '4', loc: { start: 18, end: 19 } },\n  { type: 'number', value: '2', loc: { start: 20, end: 21 } },\n  { type: 'paren', value: ')', loc: { start: 21, end: 22 } },\n  { type: 'paren', value: ')', loc: { start: 22, end: 23 } }\n]\n```\n\n#### 2.2 parser","isLeaf":true},{"key":"/subject/Babel/06 acorn/01.md","path":"/subject/Babel/06 acorn/01.md","route":"/subject/Babel/06 acorn/01.md","leaf":true,"title":"01","depth":3,"content":"---\ntitle: 简易表达式\ntags: acornjs\n---\n\n### 1. 条件表达式 Condition\n\n```javascript\na = b ? 1 : 2 + 1  // =>  a = b ? 1 : (2 + 1)\n```\n\n### 2. 赋值表达式 Assign\n\n```javascript\na == b ? 1 : 2 + 1 // => (a == b) ? 1 : (2+1)\na += b ? 1 : 0     // => a += (b ? 1 : 0 )\n```\n\n### 3. 更新表达式 Update\n\n```javascript\na++\na--\n```\n\n### 4. 逻辑运算符 Logical\n\n```javascript\na || b\na == b ? 1 : 2 + 1 // => (a == b) ? 1 : (2+1)\n```\n\n### 5. 一元运算符\n\n```javascript\n-5\n+5\n```\n\n### 6. 运算符优先级","isLeaf":true},{"key":"/subject/Babel/06 acorn/02.md","path":"/subject/Babel/06 acorn/02.md","route":"/subject/Babel/06 acorn/02.md","leaf":true,"title":"02","depth":3,"content":"---\ntitle: acorn 解析\ntags: acornjs\n---\n\n## 1. 基础类和接口\n\n### 1.1 Node\n\n所有节点类型都实现以下接口：\n\n```typescript\ninterface Node {\n  type: string; // AST变体类型\n  start: number; // 起始位置\n  end: number; // 结束位置\n  range?: [number, number]; // [起始位置, 结束位置]\n  loc?: SourceLocation;\n}\n```\n\nloc字段表示节点的位置信息。如果解析器没有生成有关节点源位置的信息，则该字段为null。否则它是一个对象，包括一个起始位置 和一个结束位置。每个Position对象由一个line数字（1索引）和一个column数字（0索引）组成：\n\n```typescript\ninterface SourceLocation {\n    start: Position;\n    end: Position;\n    source?: string | null;\n}\n```\n\n```typescript\ninterface Position {\n    line: number >= 1;\n    column: number >= 0;\n}\n```\n\n### 1.2 Programs\n\n```typescript\ninterface Program <: Node {\n    type: \"Program\";\n    sourceType: 'script' | 'module';\n    body: StatementListItem[] | ModuleItem[];\n}\n```\n\n表示一个完整的源代码树。 <a name=\"PB0xS\"></a>\n\n## 2. 脚本和模块\n\n源代码数的来源包括两种，一种是script脚本，一种是modules模块\n\n- 当为script时，body为StatementListItem。\n- 当为modules时，body为ModuleItem。\n\n类型 StatementListItem 和 ModuleItem 类型如下：\n\n```typescript\ntype StatementListItem = Declaration | Statement;\ntype ModuleItem = ImportDeclaration | ExportDeclaration | StatementListItem;\n```\n\n### 2.1 ImportDeclaration\n\nimport语法，导入模块\n\n```typescript\ntype ImportDeclaration {\n    type: 'ImportDeclaration';\n    specifiers: ImportSpecifier[];\n    source: Literal;\n}\n```\n\nImportSpecifier：\n\n```typescript\ninterface ImportSpecifier {\n    type: 'ImportSpecifier' | 'ImportDefaultSpecifier' | 'ImportNamespaceSpecifier';\n    local: Identifier;\n    imported?: Identifier;\n}\n```\n\n#### 2.1.1 ImportSpecifier\n\nimport 部分模块\n\n```typescript\nimport { foo } from './foo';\n```\n\n#### 2.1.2 ImportDefaultSpecifier\n\nimport default 方式\n\n```typescript\nimport foo from './foo';\n```\n\n##### 2.1.3 ImportNamespaceSpecifier\n\n模块重命名\n\n```typescript\nimport * as foo from './foo';\n```\n\n### 2.2 ExportDeclaration\n\n```typescript\ntype ExportDeclaration = ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration;\n```\n\n#### 2.2.1 ExportAllDeclaration\n\n从指定模块中导出\n\n```typescript\ninterface ExportAllDeclaration {\n    type: 'ExportAllDeclaration';\n    source: Literal;\n}\n```\n\n```typescript\nexport * from './foo';\n```\n\n#### 2.2.2 ExportDefaultDeclaration\n\n导出默认模块\n\n```typescript\ninterface ExportDefaultDeclaration {\n    type: 'ExportDefaultDeclaration';\n    declaration: Identifier | BindingPattern | ClassDeclaration | Expression | FunctionDeclaration;\n}\n```\n\n```typescript\nexport default 'foo';\n```\n\n#### 2.2.3 ExportNamedDeclaration\n\n导出部分模块\n\n```typescript\ninterface ExportNamedDeclaration {\n    type: 'ExportNamedDeclaration';\n    declaration: ClassDeclaration | FunctionDeclaration | VariableDeclaration;\n    specifiers: ExportSpecifier[];\n    source: Literal;\n}\n```\n\n```typescript\nexport const foo = 'foo';\n```\n","isLeaf":true},{"key":"/subject/Babel/06 acorn/03.md","path":"/subject/Babel/06 acorn/03.md","route":"/subject/Babel/06 acorn/03.md","leaf":true,"title":"03","depth":3,"content":"---\ntitle: Declarations 声明\ntags: acornjs\nurl: https://www.yuque.com/gaollard/ubc1q5/wluqrk\n---\n\n### 1. VariableDeclarator\n\n变量声明\n\n```typescript\ninterface VariableDeclaration <: Declaration {\n    type: \"VariableDeclaration\";\n    declarations: [ VariableDeclarator ];\n    kind: \"var\" | \"let\" | \"const\";\n}\n```\n\nVariableDeclarator 表示一个变量声明:\n\n```typescript\ninterface VariableDeclarator {\n  type: \"VariableDeclarator\";\n  id: Identifier;\n  init: Expression;\n}\n```\n\n```typescript\nvar c = 30\n```\n\n```json\n{\n  \"type\": \"VariableDeclarator\",\n  \"start\": 28,\n  \"end\": 34,\n  \"id\": {\n    \"type\": \"Identifier\",\n    \"start\": 28,\n    \"end\": 29,\n    \"name\": \"c\"\n  },\n  \"init\": {\n    \"type\": \"Literal\",\n    \"start\": 32,\n    \"end\": 34,\n    \"value\": 30,\n    \"raw\": \"30\"\n  }\n}\n```\n\n### 2. FunctionDeclaration\n\n函数声明，注意与函数表达式的区别\n\n```typescript\ninterface FunctionDeclaration {\n    type: 'FunctionDeclaration';\n    id: Identifier | null;\n    params: FunctionParameter[];\n    body: BlockStatement;\n    generator: boolean;\n    async: boolean;\n    expression: false;\n}\n```\n\n```javascript\n{\n  \"type\": \"Program\",\n  \"start\": 0,\n  \"end\": 17,\n  \"body\": [\n    {\n      \"type\": \"ClassDeclaration\",\n      \"start\": 0,\n      \"end\": 17,\n      \"id\": {\n        \"type\": \"Identifier\",\n        \"start\": 6,\n        \"end\": 12,\n        \"name\": \"Person\"\n      },\n      \"superClass\": null,\n      \"body\": {\n        \"type\": \"ClassBody\",\n        \"start\": 13,\n        \"end\": 17,\n        \"body\": []\n      }\n    }\n  ],\n  \"sourceType\": \"module\"\n}\n```\n\n####\n\n```javascript\nclass Person extends Object {\n\tsleep() {}\n}\n```\n\n### 3. ClassDeclaration\n\n类声明，注意和类表达式的区别\n\n```typescript\ninterface ClassDeclaration {\n  type: 'ClassDeclaration';\n  id: Identifier | null;\n  superClass: Identifier | null;\n  body: ClassBody;\n}\n```\n\nClassBody 类主体:\n\n```typescript\ninterface ClassBody {\n  type: 'ClassBody';\n  body: MethodDefinition[];\n}\n```\n\nMethodDefinition 表示方法定义：\n\n```typescript\ninterface MethodDefinition {\n  type: 'MethodDefinition';\n  key: Expression | null;\n  computed: boolean;\n  value: FunctionExpression | null;\n  kind: 'method' | 'constructor';\n  static: boolean;\n}\n```\n\n```typescript\nclass Fn {\n  constructor() {}\n  method() {}\n};\n```\n","isLeaf":true},{"key":"/subject/Babel/06 acorn/04.md","path":"/subject/Babel/06 acorn/04.md","route":"/subject/Babel/06 acorn/04.md","leaf":true,"title":"04","depth":3,"content":"---\ntitle: Expressions 表达式\ntags: acornjs\nurl: https://www.yuque.com/gaollard/ubc1q5/slzv6w\n---\n\nExpressions 可用类型如下：\n\n```typescript\ntype Expression = ThisExpression | Identifier | Literal |\n    ArrayExpression | ObjectExpression | FunctionExpression | ArrowFunctionExpression | ClassExpression |\n    TaggedTemplateExpression | MemberExpression | Super | MetaProperty |\n    NewExpression | CallExpression | UpdateExpression | AwaitExpression | UnaryExpression |\n    BinaryExpression | LogicalExpression | ConditionalExpression |\n    YieldExpression | AssignmentExpression | SequenceExpression;\n```\n\nJS 中的表达式除了常见的表达式外，还可以是：\n\n- Identifier 标识符\n- Literal 字面量\n- Super\n\n### 1. ThisExpression\n\nthis 表达式\n\n```typescript\ninterface ThisExpression {\n  type: \"ThisExpression\";\n}\n```\n\n```typescript\n(function(ctx){})(this);\n```\n\n```typescript\n{\n  \"type\": \"Program\",\n  \"start\": 0,\n  \"end\": 29,\n  \"body\": [\n    {\n      \"type\": \"ExpressionStatement\",\n      \"start\": 0,\n      \"end\": 29,\n      \"expression\": {\n        \"type\": \"CallExpression\",\n        \"start\": 0,\n        \"end\": 28,\n        \"callee\": {\n          \"type\": \"FunctionExpression\",\n          \"start\": 5,\n          \"end\": 20,\n          \"id\": null,\n          \"expression\": false,\n          \"generator\": false,\n          \"async\": false,\n          \"params\": [\n            {\n              \"type\": \"Identifier\",\n              \"start\": 14,\n              \"end\": 17,\n              \"name\": \"ctx\"\n            }\n          ],\n          \"body\": {\n            \"type\": \"BlockStatement\",\n            \"start\": 18,\n            \"end\": 20,\n            \"body\": []\n          }\n        },\n        \"arguments\": [\n          {\n            \"type\": \"ThisExpression\",\n            \"start\": 23,\n            \"end\": 27\n          }\n        ],\n        \"optional\": false\n      }\n    }\n  ],\n  \"sourceType\": \"module\"\n}\n```\n\n### 2. Identifier\n\n标识符，比如变量名、函数名\n\n```typescript\ninterface Identifier {\n    type: 'Identifier';\n    name: string;\n}\n```\n\n### 3. Literal\n\n基础的字面量，比如\n\n- 字符串\n- 数字\n- 布尔\n- 正则\n\n```typescript\ninterface Literal {\n    type: 'Literal';\n    value: boolean | number | string | RegExp | null;\n    raw: string;\n    regex?: { pattern: string, flags: string };\n}\n```\n\n```typescript\nvar a = 10;\nvar a = 'string';\nvar a = true;\nvar a = /\\d/;\n```\n\n注意，{} 和 \\[] 不被包括在内，他们被分别抽离为 ObjectExpression ArrayExpression <a name=\"RL6b3\"></a>\n\n### 4. ObjectExpression\n\n对象表达式\n\n```typescript\ninterface ObjectExpression {\n    type: 'ObjectExpression';\n    properties: Property[];\n}\n```\n\nproperties为属性列表，Property 表示为对象的属性描述。\n\n```typescript\ninterface Property {\n    type: 'Property';\n    key: Expression;\n    computed: boolean;\n    value: Expression | null;\n    kind: 'get' | 'set' | 'init';\n    method: false;\n    shorthand: boolean;\n}\n```\n\n```typescript\nvar a = {\n\tname: 1\n}\n```\n\n```json\n{\n  \"type\": \"ObjectExpression\",\n  \"start\": 8,\n  \"end\": 20,\n  \"properties\": [\n    {\n      \"type\": \"Property\",\n      \"start\": 11,\n      \"end\": 18,\n      \"method\": false,\n      \"shorthand\": false,\n      \"computed\": false,\n      \"key\": {\n        \"type\": \"Identifier\",\n        \"start\": 11,\n        \"end\": 15,\n        \"name\": \"name\"\n      },\n      \"value\": {\n        \"type\": \"Literal\",\n        \"start\": 17,\n        \"end\": 18,\n        \"value\": 1,\n        \"raw\": \"1\"\n      },\n      \"kind\": \"init\"\n    }\n  ]\n}\n```\n\n注意：{} 既可以表示为表达式，也可以表示为Statement语句，需要结合语义。 <a name=\"H0ybq\"></a>\n\n### 5. ArrayExpression\n\n数组表达式\n\n```typescript\ninterface ArrayExpression {\n    type: 'ArrayExpression';\n    elements: ArrayExpressionElement[];\n}\n```\n\nArrayExpressionElement:\n\n```typescript\ntype ArrayExpressionElement = Expression | SpreadElement;\n```\n\n### 6. SpreadElement\n\n扩展运算符\n\n```typescript\ninterface SpreadElement {\n    type: 'SpreadElement';\n    argument: Expression;\n}\n```\n\n```typescript\nvar a = [1, 2, ...list];\nvar b = {foo: 2, ...obj};\n```\n\n### 7. FunctionExpression\n\nFunctionExpress 表示函数表达式。\n\n```typescript\ninterface FunctionExpression {\n    type: 'FunctionExpression';\n    id: Identifier | null;\n    params: FunctionParameter[];\n    body: BlockStatement;\n    generator: boolean;\n    async: boolean;\n    expression: boolean;\n}\n```\n\n在下面的例子中，等号右边就是一个函数表达式:\n\n```typescript\nvar fn = function(){}\nvar fn = function Person(){}\n```\n\n请注意函数声明和函数表达式的区别。 <a name=\"l647H\"></a>\n\n### 8. ArrowFunctionExpression\n\n箭头函数。\n\n```typescript\ninterface ArrowFunctionExpression {\n    type: 'ArrowFunctionExpression';\n    id: Identifier | null;\n    params: FunctionParameter[];\n    body: BlockStatement | Expression;\n    generator: boolean;\n    async: boolean;\n    expression: false;\n}\n```\n\n```typescript\ntype FunctionParameter = AssignmentPattern | Identifier | BindingPattern;\n```\n\n### 9. TaggedTemplateExpression\n\n### 10. MemberExpression\n\n属性成员表达式\n\n```typescript\ninterface MemberExpression {\n    type: 'MemberExpression';\n    computed: boolean;\n    object: Expression;\n    property: Expression;\n}\n```\n\n```typescript\nconst foo = {bar: 'bar'};\nfoo.bar; // // computed 为 false\nfoo['bar']; // computed 为 true\n```\n\n### 11. Super\n\n父类关键字\n\n```typescript\ninterface Super {\n    type: 'Super';\n}\n```\n\n```typescript\nclass Male extends Person {\n    constructor() {\n        super();\n    }\n}\n```\n\n### 12. MetaProperty\n\nimport.meta 是一个给JavaScript模块暴露特定上下文的元数据属性的对象。它包含了这个模块的信息，比如说这个模块的URL。\n\n```typescript\ninterface MetaProperty {\n    type: 'MetaProperty';\n    meta: Identifier;\n    property: Identifier;\n}\n```\n\n```typescript\nimport.meta\n```\n\n```json\n{\n  \"type\": \"Program\",\n  \"start\": 0,\n  \"end\": 11,\n  \"body\": [\n    {\n      \"type\": \"ExpressionStatement\",\n      \"start\": 0,\n      \"end\": 11,\n      \"expression\": {\n        \"type\": \"MetaProperty\",\n        \"start\": 0,\n        \"end\": 11,\n        \"meta\": {\n          \"type\": \"Identifier\",\n          \"start\": 0,\n          \"end\": 6,\n          \"name\": \"import\"\n        },\n        \"property\": {\n          \"type\": \"Identifier\",\n          \"start\": 7,\n          \"end\": 11,\n          \"name\": \"meta\"\n        }\n      }\n    }\n  ],\n  \"sourceType\": \"module\"\n}\n```\n\n### 13. ClassExpression\n\n类表达式\n\n```typescript\ninterface ClassExpression {\n    type: 'ClassExpression';\n    id: Identifier | null;\n    superClass: Identifier | null;\n    body: ClassBody;\n}\n```\n\n```typescript\nvar Fn = class {\n    constructor() {}\n    method() {}\n};\n```\n\n### 14. NewExpression\n\nnew 表达式\n\n```typescript\ninterface NewExpression {\n    type: 'NewExpression';\n    callee: Expression;\n    arguments: ArgumentListElement[];\n}\n```\n\n```typescript\nnew Person(name)\n```\n\n```json\n{\n  \"type\": \"NewExpression\",\n  \"start\": 0,\n  \"end\": 16,\n  \"callee\": {\n    \"type\": \"Identifier\",\n    \"start\": 4,\n    \"end\": 10,\n    \"name\": \"Person\"\n  },\n  \"arguments\": [\n    {\n      \"type\": \"Identifier\",\n      \"start\": 11,\n      \"end\": 15,\n      \"name\": \"name\"\n    }\n  ]\n}\n```\n\n### 15. CallExpression\n\n函数调用表达式\n\n```typescript\ninterface CallExpression {\n    type: 'CallExpression';\n    callee: Expression | Import;\n    arguments: ArgumentListElement[];\n}\n```\n\nImport 的场景：\n\n```typescript\n(import(''))()\n```\n\n```typescript\ninterface Import {\n    type: 'Import'\n}\n```\n\nArgumentListElement 类型:\n\n```typescript\ntype ArgumentListElement = Expression | SpreadElement;\n```\n\n### 15. UpdateExpression\n\n更新操作符表达式，如 `++`、`--`;\n\n```typescript\ninterface UpdateExpression {\n  type: \"UpdateExpression\";\n  operator: '++' | '--';\n  argument: Expression;\n  prefix: boolean;\n}\n```\n\n```typescript\nvar a = 0;\na++;\n++a; // prefix为true\n```\n\n### 16. AwaitExpression\n\nawait表达式，与 async 一起使用\n\n```typescript\ninterface AwaitExpression {\n    type: 'AwaitExpression';\n    argument: Expression;\n}\n```\n\n```typescript\nasync function slepp() {\n\tawait fn()\n}\n```\n\n```typescript\n{\n  \"type\": \"AwaitExpression\",\n  \"start\": 26,\n  \"end\": 36,\n  \"argument\": {\n    \"type\": \"CallExpression\",\n    \"start\": 32,\n    \"end\": 36,\n    \"callee\": {\n      \"type\": \"Identifier\",\n      \"start\": 32,\n      \"end\": 34,\n      \"name\": \"fn\"\n    },\n    \"arguments\": [],\n    \"optional\": false\n  }\n}\n```\n\n### 17. UnaryExpression\n\n一元操作符表达式\n\n```typescript\ninterface UnaryExpression {\n  type: \"UnaryExpression\";\n  operator: UnaryOperator;\n  prefix: boolean;\n  argument: Expression;\n}\n```\n\nUnaryOperator:\n\n```typescript\nenum UnaryOperator {\n  \"-\" | \"+\" | \"!\" | \"~\" | \"typeof\" | \"void\" | \"delete\" | \"throw\"\n}\n```\n\n### 18. BinaryExpression\n\n二元操作符表达式\n\n```typescript\ninterface BinaryExpression {\n    type: 'BinaryExpression';\n    operator: BinaryOperator;\n    left: Expression;\n    right: Expression;\n}\n```\n\nBinaryOperator:\n\n```typescript\nenum BinaryOperator {\n  \"==\" | \"!=\" | \"===\" | \"!==\"\n     | \"<\" | \"<=\" | \">\" | \">=\"\n     | \"<<\" | \">>\" | \">>>\"\n     | \"+\" | \"-\" | \"*\" | \"/\" | \"%\"\n     | \"**\" | \"|\" | \"^\" | \"&\" | \"in\"\n     | \"instanceof\"\n     | \"|>\"\n}\n```\n\n### 19. LogicalExpression\n\n逻辑运算符表达式\n\n```typescript\ninterface LogicalExpression {\n    type: 'LogicalExpression';\n    operator: '||' | '&&';\n    left: Expression;\n    right: Expression;\n}\n```\n\n```typescript\nvar a = '-';\nvar b = a || '-';\nvar c = a && b || 1\n```\n\n### 20. ConditionalExpression\n\n条件运算符\n\n```typescript\ninterface ConditionalExpression {\n    type: 'ConditionalExpression';\n    test: Expression;\n    consequent: Expression;\n    alternate: Expression;\n}\n```\n\n```typescript\nvar a = 1 ? 'consequent' : 'alternate';\n```\n\n### 21. YieldExpression\n\nyield表达式\n\n```typescript\ninterface YieldExpression {\n    type: 'YieldExpression';\n    argument: Expression | null;\n    delegate: boolean;\n}\n```\n\n```typescript\nfunction* gen(x) {\n  return yield x + 1;\n}\n```\n\n### 22. AssignmentExpression\n\n赋值表达式\n\n```typescript\ninterface AssignmentExpression {\n    type: 'AssignmentExpression';\n    operator: '=' | '*=' | '**=' | '/=' | '%=' | '+=' | '-=' |\n        '<<=' | '>>=' | '>>>=' | '&=' | '^=' | '|=';\n    left: Expression;\n    right: Expression;\n}\n```\n\n### 23. SequenceExpression\n\n使用逗号的序列表达式\n\n```typescript\ninterface SequenceExpression {\n  type: 'SequenceExpression';\n  expressions: Expression[];\n}\n```\n\n```typescript\na = 1, b = 2;\n```\n","isLeaf":true},{"key":"/subject/Babel/06 acorn/05.md","path":"/subject/Babel/06 acorn/05.md","route":"/subject/Babel/06 acorn/05.md","leaf":true,"title":"05","depth":3,"content":"---\ntitle: Statement 语句\ntags: acornjs\n---\n\nJS 规范可以参考 <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference>\nstatements，即语句，类型如下：\n\n```typescript\ntype Statement = BlockStatement | BreakStatement | ContinueStatement |\n    DebuggerStatement | DoWhileStatement | EmptyStatement |\n    ExpressionStatement | ForStatement | ForInStatement |\n    ForOfStatement | FunctionDeclaration | IfStatement |\n    LabeledStatement | ReturnStatement | SwitchStatement |\n    ThrowStatement | TryStatement | VariableDeclaration |\n    WhileStatement | WithStatement;\n```\n\n### 1. BlockStatement\n\n表示一个作用域块。\n\n```typescript\ninterface BlockStatement {\n    type: 'BlockStatement';\n    body: Statement[];\n}\n```\n\n```typescript\n{}\n```\n\n```typescript\n{\n  \"type\": \"BlockStatement\",\n  \"start\": 0,\n  \"end\": 2,\n  \"body\": []\n}\n```\n\n<a name=\"ylwvh\"></a>\n\n### 2. IfStatement\n\nIfStatement 用于表示 if 语句\n\n```typescript\ninterface IfStatement {\n    type: 'IfStatement';\n    test: Expression;\n    consequent: Statement;\n    alternate?: Statement;\n}\n```\n\n```typescript\nif (a > b) {}\n```\n\n```json\n{\n  \"type\": \"IfStatement\",\n  \"start\": 0,\n  \"end\": 13,\n  \"test\": {\n    \"type\": \"BinaryExpression\",\n    \"start\": 4,\n    \"end\": 9,\n    \"left\": {\n      \"type\": \"Identifier\",\n      \"start\": 4,\n      \"end\": 5,\n      \"name\": \"a\"\n    },\n    \"operator\": \">\",\n    \"right\": {\n      \"type\": \"Identifier\",\n      \"start\": 8,\n      \"end\": 9,\n      \"name\": \"b\"\n    }\n  },\n  \"consequent\": {\n    \"type\": \"BlockStatement\",\n    \"start\": 11,\n    \"end\": 13,\n    \"body\": []\n  },\n  \"alternate\": null\n}\n```\n\n<a name=\"lkIih\"></a>\n\n### 3. ReturnStatement\n\nReturenStatement 用于表示 return 语句\n\n```typescript\ninterface ReturnStatement {\n    type: 'ReturnStatement';\n    argument: Expression | null;\n}\n```\n\n```typescript\nfunction sleep() {\n\treturn 10;\n}\n```\n\n```typescript\n{\n  \"type\": \"ReturnStatement\",\n  \"start\": 20,\n  \"end\": 30,\n  \"argument\": {\n    \"type\": \"Literal\",\n    \"start\": 27,\n    \"end\": 29,\n    \"value\": 10,\n    \"raw\": \"10\"\n  }\n}\n```\n\n### 4. SwitchStatement\n\nSwitchStatement 用于表示 switch 语句。\n\n```typescript\ninterface SwitchStatement {\n    type: 'SwitchStatement';\n    discriminant: Expression;\n    cases: SwitchCase[];\n}\n```\n\n```typescript\nswitch(b) {\n  case 10:\n    console.log(10);\n    break;\n  case 20:\n    console.log(20);\n    break;\n  default:\n    console.log(\"default\")\n}\n```\n\n![20230608110506](http://s3.airtlab.com/blog/20230608110506.png)\n\n### 5. WhileStatement\n\nwhile 语句。\n\n```typescript\ninterface WhileStatement {\n    type: 'WhileStatement';\n    test: Expression;\n    body: Statement;\n}\n```\n\n<a name=\"zxenD\"></a>\n\n### 6. BreakStatement\n\nbreak 语句。\n\n```typescript\n{\n   \"type\": \"BreakStatement\",\n   \"label\": null | string\n}\n```\n\n```typescript\nfor(;;){\n\tbreak;\n}\n```\n\n<a name=\"pjLpI\"></a>\n\n### 7. ContinueStatement\n\ncontinue 语句。\n\n```typescript\n{\n   \"type\": \"ContinueStatement\",\n   \"label\": null | string\n}\n```\n\n```typescript\nfor(;;){\n\tcontinue;\n}\n```\n\n<a name=\"regOL\"></a>\n\n### 8. DebuggerStatement\n\ndebugger 语句。\n\n```typescript\n{\n   \"type\": \"DebuggerStatement\"\n}\n```\n\n```typescript\ndebugger;\n```\n\n<a name=\"i63zx\"></a>\n\n### 9. DoWhileStatement\n\n```json\ninterface DoWhileStatement {\n    type: 'DoWhileStatement';\n    body: Statement;\n    test: Expression;\n}\n```\n\n```typescript\ndo {} while(1)\n```\n\n```json\n{\n  \"type\": \"DoWhileStatement\",\n  \"start\": 0,\n  \"end\": 14,\n  \"body\": {\n    \"type\": \"BlockStatement\",\n    \"start\": 3,\n    \"end\": 5,\n    \"body\": []\n  },\n  \"test\": {\n    \"type\": \"Literal\",\n    \"start\": 12,\n    \"end\": 13,\n    \"value\": 1,\n    \"raw\": \"1\"\n  }\n}\n```\n\n<a name=\"RK0TE\"></a>\n\n### 10. EmptyStatement\n\n空语句。\n\n```typescript\ninterface EmptyStatement {\n  type: \"EmptyStatement\"\n}\n```\n\n```typescript\n;\n```\n\n<a name=\"yuv0l\"></a>\n\n### 11. ExpressionStatement\n\n表达式语句。\n\n```typescript\ninterface ExpressionStatement {\n  type: \"ExpressionStatement\";\n  expression: Expression\n}\n```\n\n```typescript\n(function() {})\n```\n\n```json\n{\n  \"type\": \"ExpressionStatement\",\n  \"start\": 0,\n  \"end\": 15,\n  \"expression\": {\n    \"type\": \"FunctionExpression\",\n    \"start\": 1,\n    \"end\": 14,\n    \"id\": null,\n    \"expression\": false,\n    \"generator\": false,\n    \"async\": false,\n    \"params\": [],\n    \"body\": {\n      \"type\": \"BlockStatement\",\n      \"start\": 12,\n      \"end\": 14,\n      \"body\": []\n    }\n  }\n}\n```\n\n<a name=\"NzoXy\"></a>\n\n### 12. ForStatement\n\n```typescript\ninterface ForStatement {\n    type: 'ForStatement';\n    init: Expression | VariableDeclaration | null; // 初始化\n    test: Expression | null; // 中间条件\n    update: Expression | null; // 迭代步骤\n    body: Statement; // 主体\n}\n```\n\n<a name=\"CtOnX\"></a>\n\n### 13. ForInStatement\n\nfor...in.. 语句\n\n```typescript\ninterface ForInStatement {\n    type: 'ForInStatement';\n    left: Expression;\n    right: Expression;\n    body: Statement;\n}\n```\n\n```typescript\nfor(let i in a) {}\n```\n\n```typescript\n{\n  \"type\": \"ForInStatement\",\n  \"start\": 0,\n  \"end\": 18,\n  \"left\": {\n    \"type\": \"VariableDeclaration\",\n    \"start\": 4,\n    \"end\": 9,\n    \"declarations\": [\n      {\n        \"type\": \"VariableDeclarator\",\n        \"start\": 8,\n        \"end\": 9,\n        \"id\": {\n          \"type\": \"Identifier\",\n          \"start\": 8,\n          \"end\": 9,\n          \"name\": \"i\"\n        },\n        \"init\": null\n      }\n    ],\n    \"kind\": \"let\"\n  },\n  \"right\": {\n    \"type\": \"Identifier\",\n    \"start\": 13,\n    \"end\": 14,\n    \"name\": \"a\"\n  },\n  \"body\": {\n    \"type\": \"BlockStatement\",\n    \"start\": 16,\n    \"end\": 18,\n    \"body\": []\n  }\n}\n```\n\n<a name=\"RXXqj\"></a>\n\n### 14. ForOfStatement\n\nfor...of 语句\n\n```typescript\ninterface ForOfStatement {\n    type: 'ForOfStatement';\n    left: Expression;\n    right: Expression;\n    body: Statement;\n}\n```\n\n<a name=\"z65t9\"></a>\n\n### 15. ThrowStatement\n\nthrow 语句\n\n```typescript\ninterface ThrowStatement {\n  type: \"ThrowStatement\",\n  argument: S\n}\n```\n\n```typescript\n// throw expression;\n```\n\n```json\n{\n  \"type\": \"ThrowStatement\",\n  \"start\": 0,\n  \"end\": 12,\n  \"argument\": {\n    \"type\": \"Literal\",\n    \"start\": 6,\n    \"end\": 11,\n    \"value\": \"err\",\n    \"raw\": \"\\\"err\\\"\"\n  }\n}\n```\n\n<a name=\"vttj4\"></a>\n\n### 16. TryStatement\n\ntry...catch... 语句\n\n```typescript\ninterface TryStatement {\n    type: 'TryStatement';\n    block: BlockStatement;\n    handler: CatchClause | null;\n    finalizer: BlockStatement | null;\n}\n```\n\n```typescript\ntry {}catch (e) {}\n```\n\n```json\n{\n  \"type\": \"TryStatement\",\n  \"start\": 0,\n  \"end\": 18,\n  \"block\": {\n    \"type\": \"BlockStatement\",\n    \"start\": 4,\n    \"end\": 6,\n    \"body\": []\n  },\n  \"handler\": {\n    \"type\": \"CatchClause\",\n    \"start\": 6,\n    \"end\": 18,\n    \"param\": {\n      \"type\": \"Identifier\",\n      \"start\": 13,\n      \"end\": 14,\n      \"name\": \"e\"\n    },\n    \"body\": {\n      \"type\": \"BlockStatement\",\n      \"start\": 16,\n      \"end\": 18,\n      \"body\": []\n    }\n  },\n  \"finalizer\": null\n}\n```\n\n<a name=\"on7Fu\"></a>\n\n### 17. WithStatement\n\nwith语句（指定块语句的作用域）\n\n```typescript\ninterface WithStatement {\n    type: 'WithStatement';\n    object: Expression;\n    body: Statement;\n}\n```\n","isLeaf":true}]},{"key":"/subject/Babel/_meta.md","path":"/subject/Babel/_meta.md","route":"/subject/Babel/_meta.md","leaf":true,"title":"_meta","depth":2,"content":"","isLeaf":true}]},{"key":"/subject/Javascript","path":"/subject/Javascript","route":"/subject/Javascript","leaf":false,"title":"Javascript","depth":1,"content":"","isLeaf":false,"children":[{"key":"/subject/Javascript/_meta.md","path":"/subject/Javascript/_meta.md","route":"/subject/Javascript/_meta.md","leaf":true,"title":"_meta","depth":2,"content":"","isLeaf":true}]},{"key":"/subject/NodeJS","path":"/subject/NodeJS","route":"/subject/NodeJS","leaf":false,"title":"NodeJS","depth":1,"content":"","isLeaf":false,"children":[{"key":"/subject/NodeJS/_meta.md","path":"/subject/NodeJS/_meta.md","route":"/subject/NodeJS/_meta.md","leaf":true,"title":"_meta","depth":2,"content":"","isLeaf":true}]}]}]