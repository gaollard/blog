[{"key":"/achieve","path":"/achieve","route":"/achieve","leaf":false,"title":"achieve","depth":0,"content":"","isLeaf":false,"children":[{"key":"/achieve/h5-vue-template.md","path":"/achieve/h5-vue-template.md","route":"/achieve/h5-vue-template.md","leaf":true,"title":"h5-vue-template","depth":1,"content":"## 1\n- https://sunniejs.github.io/vue-h5-template/guide/\n\n![20230630104041](http://s3.airtlab.com/blog/20230630104041.png)\n\n## 2\n\n- https://github.com/yulimchen/vue3-h5-template\n\n![20230630104710](http://s3.airtlab.com/blog/20230630104710.png)","isLeaf":true},{"key":"/achieve/nestjs-template.md","path":"/achieve/nestjs-template.md","route":"/achieve/nestjs-template.md","leaf":true,"title":"nestjs-template","depth":1,"content":"一个 C 端 API 快速开发模板，源代码见 https://github.com/fiiai/nestjs-template\n\n## 1. 项目介绍\n\n使用 NestJS 进行 API 通用业务框架最佳实践方案，笔者会定期的更新，欢迎指正。API 文档 👉 https://www.apifox.cn/web/project/2299100\n包含如下特性：\n\n- 【规范】工程目录\n- 【规范】代码风格\n- 【监控】异常监控\n- 【特性】日志打印\n- 【特性】配置管理\n- 【特性】唯一 ID\n- 【特性】socket.io 集成\n- 【特性】redis 封装\n- 【特性】mysql 封装\n- 【特性】mongoose 封装\n- 【特性】mailer 封装\n- 【特性】rabbitmq 封装\n- 【特性】qiniu 集成\n- 【特性】API 文档方案\n- 【特性】代码文档方案\n\n## 2. 内置模块\n\n- [x] 账户模块\n- [x] 图文列表\n- [x] 评论模块\n- [x] 上传模块\n- [x] 数据采集\n- [x] 地址管理\n- [x] 钱包功能\n- [x] 授权登录\n  - [x] 微信登录\n- [x] 支付能力\n  - [x] 支付宝支付\n  - [x] 微信支付\n- [x] 权限管理\n- [x] 短信推送\n- [ ] 站内消息\n\n\n## 3. 技术选型\n\n| 名称     | 方案                                                        |\n| -------- | ----------------------------------------------------------- |\n| 框架     | [nestjs](https://nestjs.com/)                               |\n| 时间处理 | [dayjs](https://day.js.org/docs/en/installation/typescript) |\n| 长连接   | [socket.io](https://socket.io/) & nestjs platform           |\n| 日志     | [pino](https://github.com/pinojs/pino)                      |\n| 大数处理 | [bignumber.js](https://mikemcl.github.io/bignumber.js/)     |\n\n## 4. 技术方案\n\n### 4.0 请求生命周期\n\n![20230301191226](http://s3.airtlab.com/blog/20230301191226.png)\n\n### 4.1 工程目录\n\n```text\n├── config\n│   ├── dev.config.yaml\n│   ├── live.config.yaml\n│   └── local.config.yaml\n├── libs\n│   ├── common\n│   │   ├── filters\n│   │   ├── guard\n│   │   ├── interceptor\n│   │   └── middleware\n│   ├── config\n│   ├── constant\n│   ├── logger\n│   ├── mailer\n│   ├── mongo\n│   ├── redis\n│   ├── request\n│   ├── s3\n│   └── utils\n├── src\n│   ├── app.module.ts\n│   ├── domain-admin\n│   │   ├── admin.module.ts\n│   │   ├── common\n│   │   ├── module\n│   │   └── shared\n│   ├── domain-app\n│   │   ├── app.module.ts\n│   │   ├── common\n│   │   ├── module\n│   │   └── shared\n│   ├── exception.ts\n│   ├── global.d.ts\n│   ├── main.ts\n│   ├── modules\n│       ├── common\n│       │   ├── db\n│       │   ├── entity\n│       │   ├── filters\n│       │   ├── middleware\n│       │   ├── pipes\n│       │   ├── prom\n│       │   └── validate\n│       ├── enums\n│       ├── feature\n│       ├── mock\n│       ├── types\n│       ├── utils\n│       └── vos\n├── tsconfig.build.json\n├── tsconfig.json\n└── yarn.lock\n```\n\n### 4.2 代码风格\n\n[Angular 代码风格指南](https://angular.io/guide/styleguide)\n\n### 4.3 异常监控\n\n数据采集 & 展示采用 Prom + Grafana，监控指标设计 TODO。\n\n### 4.4 日志打印\n\n[winston](https://github.com/winstonjs/winston)\n\n\n### 4.5 项目文档\n```shell\nnpx @compodoc/compodoc -p tsconfig.json -s\n```","isLeaf":true},{"key":"/achieve/react-native-template.md","path":"/achieve/react-native-template.md","route":"/achieve/react-native-template.md","leaf":true,"title":"react-native-template","depth":1,"content":"## 1. 项目介绍\nreact native 快速开发模板，希望有时间的朋友一起来完善，加微信进群：gaoxiong957\n\n## 2. 技术选型\n\n### 2.1 技术选型\n\n| 名称     | 方案                                                                                                                    |\n| -------- | ----------------------------------------------------------------------------------------------------------------------- |\n| 路由库   | [react navigation](https://reactnavigation.org)                                                                         |\n| 状态管理 | mobx + context                                                                                                          |\n| SVG 图标 | react-native-svg 搭配 react-native-iconfont-cli                                                                         |\n| 本地存储 | @react-native-async-storage/async-storage                                                                               |\n| 时间处理 | [dayjs](https://day.js.org/docs/en/installation/typescript)                                                             |\n| UI 库    | [native-base](https://docs.nativebase.io/)                                                                              |\n| 唯一 ID  | uuid & react-native-get-random-values                                                                                   |\n| 消息推送 | [react-native-push-notification](https://github.com/zo0r/react-native-push-notification#readme)                         |\n| 日志工具 | [react-native-logs](https://github.com/onubo/react-native-logs)                                                         |\n| 动画     | [lottie-react-native](https://github.com/lottie-react-native/lottie-react-native) [lottie](https://airbnb.io/lottie/#/) |\n| 文件管理 | [react-native-fs](https://github.com/itinance/react-native-fs) |\n| 扫二维码 | [react-native-camera](https://react-native-camera.github.io/react-native-camera/) |\n| 阴影效果 | [react-native-drop-shadow](https://www.npmjs.com/package/react-native-drop-shadow) |\n| Table | [react-native-table-component](https://github.com/wiiai/react-native-table-component) |\n| network-logger | [react-native-network-logger](https://www.npmjs.com/package/react-native-network-logger) |\n| 分包拆包 | TODO                                                                                                                    |\n\n### 2.2 内部架构\n\n```\nsrc\n├── App.tsx\n├── assets\n│   ├── iconfont 图标\n│   └── img 图片\n├── baseUI 通用UI\n├── config 配置\n│   ├── index.ts 常量配置\n│   ├── theme.ts 主题配置\n│   └── request.ts http 请求配置\n├── global.d.ts 全局类型定义\n├── models 状态管理目录\n│   ├── account.ts\n│   └── index.ts\n├── navigator navigation 配置\n│   ├── MainTab.tsx\n│   ├── MainTabBar.tsx\n│   └── index.tsx\n├── pages 页面\n│   ├── contact\n│   │   └── index.tsx\n│   ├── detail\n│   │   └── index.tsx\n│   ├── h5\n│   │   └── index.tsx\n│   ├── home\n│   │   └── index.tsx\n│   ├── login\n│   │   ├── index.tsx\n│   │   └── style.ts\n│   └── me\n│       └── index.tsx\n├── services 接口\n│   └── account.ts\n├── types 类型目录\n│   ├── ResData.ts\n│   └── UserInfo.ts\n├── utils 工具函数\n│   ├── auth.ts 登录相关\n│   ├── screen.ts 页面相关\n│   ├── storage.ts 本地存储\n└── wrappers\n```\n\n### 2.3 启动流程\n\n```tsx\nimport * as React from 'react';\nimport {rootStore, StoreContext} from './models';\nimport Navigator from './navigator';\nimport {NativeBaseProvider} from 'native-base';\nimport {loadCacheUInfo} from './utils/auth';\nimport {View, Text} from 'react-native';\n\nexport default function App() {\n  const [isLoaded, setIsLoaded] = React.useState(false);\n\n  React.useEffect(() => {\n    beforeBootstrap().then(() => {\n      setIsLoaded(true);\n    });\n  }, []);\n\n  // 在应用主框架启动之前要干的事情\n  // 可以在这里配置你想干的事情\n  const beforeBootstrap = async () => {\n    // 从 storage 中取出数据, 加载到内存中\n    return await loadCacheUInfo();\n  };\n\n  if (!isLoaded) {\n    return (\n      <View style={{flex: 1, justifyContent: 'center', alignItems: 'center'}}>\n        <Text>加载中...</Text>\n      </View>\n    );\n  }\n\n  return (\n    <StoreContext.Provider value={rootStore}>\n      <NativeBaseProvider>\n        <Navigator />\n      </NativeBaseProvider>\n    </StoreContext.Provider>\n  );\n}\n```\n\n### 2.4 部署流程\n\n**Android**\n```shell\n# 构建生产包\ncd android && ./gradlew assembleRelease\n```\n\n**IOS**\n\n## 3. 技术方案\n\n### 3.1 状态管理\n\nmobx + context\n\n### 3.2 SVG 图标处理\n\n参考 https://www.npmjs.com/package/react-native-iconfont-cli\n\n```shell\n# 创建 iconfont.json\nnpx iconfont-init\n\n# 将 SVG 处理为 React Component\nnpx iconfont-rn\n```\n\n### 3.3 react-native-camera\n修改 `ViewPropTypes` 的导入，node_modules/react-native-camera/src/RNCamera.js\n![20230413141005](http://s3.airtlab.com/blog/20230413141005.png)\n\n## 4. 基础页面\n\n<table>\n  <tr>\n    <td><img src=\"https://raw.githubusercontent.com/wiiai/react-native-template/master/screenshot/home.png\" style=\"width: 240px\" /></td>\n    <td><img src=\"https://raw.githubusercontent.com/wiiai/react-native-template/master/screenshot/full_bg.png\" style=\"width: 240px\" /></td>\n    <td><img src=\"https://raw.githubusercontent.com/wiiai/react-native-template/master/screenshot/login_screen.png\" style=\"width: 240px\" /></td>\n  </tr>\n  <tr>\n    <td><img src=\"https://raw.githubusercontent.com/wiiai/react-native-template/master/screenshot/me_un_login.png\" style=\"width: 240px\" /></td>\n    <td><img src=\"https://raw.githubusercontent.com/wiiai/react-native-template/master/screenshot/me_login.png\" style=\"width: 240px\" /></td>\n    <td><img src=\"https://raw.githubusercontent.com/wiiai/react-native-template/master/screenshot/animate.gif\" style=\"width: 240px\" /></td>\n  </tr>\n  <tr>\n    <td><img src=\"https://raw.githubusercontent.com/wiiai/react-native-template/master/screenshot/fs.png\" style=\"width: 240px\" /></td>\n    <td><img src=\"https://raw.githubusercontent.com/wiiai/react-native-template/master/screenshot/scan.png\" style=\"width: 240px\" /></td>\n  </tr>\n</table>","isLeaf":true},{"key":"/achieve/sman.md","path":"/achieve/sman.md","route":"/achieve/sman.md","leaf":true,"title":"sman","depth":1,"content":"> git@github.com:Webang/sman.git\n\n## 1、sman 介绍\nsman 是一个 性能监控 + 异常监控 + 数据埋点 工具，体验地址：http://175.178.48.236:3000\n\n## 2、技术架构\nmysql + redis + elasticsearch + kafka\n\n## 3、模块设计\n- [x] 系统管理\n  - [x] 用户管理\n  - [x] 应用管理 \n- [x] 用户分析\n  - [x] 访问轨迹\n  - [x] 用户分布\n- 异常分析\n  - 整体概览\n  - 代码异常\n  - 接口异常\n  - 资源加载\n- 性能分析\n  - 接口性能\n  - 页面性能\n- 漏斗分析\n- 事件分析\n- 埋点分析\n  - 埋点统计\n- 留存分析\n\n## 4、参考资料\n- http://www.webfunny.cn/demo/home.html\n- https://study.163.com/course/introduction.htm?courseId=1006304007&share=1&shareId=1025552318#/courseDetail?tab=1","isLeaf":true},{"key":"/achieve/wow-admin.md","path":"/achieve/wow-admin.md","route":"/achieve/wow-admin.md","leaf":true,"title":"wow-admin","depth":1,"content":"## 1、admin 基础开发模板\n\n- API https://github.com/fiiai/admin-basic-api\n- UI  https://github.com/fiiai/admin-basic-umi","isLeaf":true},{"key":"/achieve/wow-im.md","path":"/achieve/wow-im.md","route":"/achieve/wow-im.md","leaf":true,"title":"wow-im","depth":1,"content":"> https://github.com/wiiai/wow-im\n\n## 项目介绍\n\n`wow-im` 是一款基于的即时通讯产品，支持的终端包括: H5、PC、IOS & Android (ReactNative)\n\n演示:\n- H5 https://wow-im.airtlab.com/mobile\n- PC https://wow-im.airtlab.com/web\n- 安卓 https://github.com/wiiai/wow-im-rn/release\n- IOS https://github.com/wiiai/wow-im-rn/release\n\n源码：\n- 服务端 https://github.com/wiiai/wow-im/server\n- H5 https://github.com/wiiai/wow-im/ui\n- ReactNative https://github.com/wiiai/wow-im-rn\n\n## 已实现功能\n- 账户\n  - [x] 登录\n- 通讯录\n  - [x] 好友列表\n  - [x] 群\n- 聊天\n  - [x] 单聊\n  - [x] 群聊\n  - [x] 视频单聊\n  - [x] 语音单聊\n- 消息内容\n  - [x] 文字\n- 会话\n  - [x] 会话列表\n  - [x] 历史消息\n\n\n## 会议流程\n1、给在线用户发起会议邀请推送，被邀请者点击同意后进入会议详情\n2、任何用户可以通过会议 URL 进入会议 (DB里面需要创建会议信息，会议ID 标识会议)\n\n## 用户在线状态维护\n---","isLeaf":true},{"key":"/achieve/wow-mall.md","path":"/achieve/wow-mall.md","route":"/achieve/wow-mall.md","leaf":true,"title":"wow-mall","depth":1,"content":"","isLeaf":true}]},{"key":"/default","path":"/default","route":"/default","leaf":false,"title":"default","depth":0,"content":"","isLeaf":false,"children":[{"key":"/default/h5-vue-template.md","path":"/default/h5-vue-template.md","route":"/default/h5-vue-template.md","leaf":true,"title":"h5-vue-template","depth":1,"content":"## 1\n- https://sunniejs.github.io/vue-h5-template/guide/\n\n![20230630104041](http://s3.airtlab.com/blog/20230630104041.png)\n\n## 2\n\n- https://github.com/yulimchen/vue3-h5-template\n\n![20230630104710](http://s3.airtlab.com/blog/20230630104710.png)","isLeaf":true}]},{"key":"/docker","path":"/docker","route":"/docker","leaf":false,"title":"docker","depth":0,"content":"","isLeaf":false,"children":[{"key":"/docker/01-command.md","path":"/docker/01-command.md","route":"/docker/01-command.md","leaf":true,"title":"01-command","depth":1,"content":"---\ntags: Docker\ndate: 2018-05-02\n---\n\n## 1、docker 简介\nDocker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux机器或Windows 机器上，也可以实现虚拟化，容器是完全使用沙箱机制，相互之间不会有任何接口。\n\n一个完整的Docker有以下几个部分组成：\n1. DockerClient 客户端\n2. Docker Daemon 守护进程\n3. Docker Image 镜像\n4. DockerContainer 容器\n\n\n## 2、镜像操作\n\n```shell\n# 制作镜像\ndocker build -t gaollard/hello:v1 .\n\n# 推送镜像\ndocker push gaollard/hello:v1 \n\n# 删除镜像(删除之前，需要先停止相关的容器)\ndocker rmi IMAGE_ID\n\n# 强制删除\ndocker rmi c7309a89f296 -f\n\n# 从远程拉取镜像\ndocker pull nginx\n\n# 搜索镜像\ndocker search httpd\n```\n\n## 3、容器操作\n\n```shell\n# 停止容器\ndocker stop CONTAINER_ID\n\n# 制作容器\ndocker run -p 7001:80 --name tnginx -d gaollard/hello:v1\n\n# 挂载数据卷\ndocker run -p 7002:80 --name tnginx2 -v /Users/arraybuffer/Desktop/html:/usr/share/nginx/html -d nginx\n\n# 查看容器\ndocker ps\n```\n\n**删除容器**\n\n语法：\n\n```shell\ndocker rm [OPTIONS] 容器名，其中options有三种类型：\n```\n\n- -f ：通过SIGKILL信号强制删除一个运行中的容器\n- -l ：移除容器间的网络连接，而非容器本身-v ：-v 删除与容器关联的卷\n\n容器删除举例：\n\n```bash\ndocker rm -v nginx 这句话的意思是删除nginx容器，并解除与nginx容器关联的卷\ndocker rm -l db 这句命令的意思是：移除容器A对容器B的连接db\ndocker rm -f db01 db02 这句命令的意思是删除容器db01和db02\n```\n\n容器的删除可以一次删除一个或多个，在使用时直接以空格隔开就行。\n\n## 4、docker 容器安装 vim\n在使用docker容器时，有时候里边没有安装vim，敲vim命令时提示说：vim: command not found，这个时候就需要安装vim，可是当你敲apt-get install vim命令时，提示：\n\n```text\nReading package lists... Done\nBuilding dependency tree       \nReading state information... Done\nE: Unable to locate package vim\n```\n \n这时候需要敲：apt-get update，这个命令的作用是：同步 /etc/apt/sources.list 和 /etc/apt/sources.list.d 中列出的源的索引，这样才能获取到最新的软件包。\n\n等更新完毕以后再敲命令：apt-get install vim命令即可。\n\n```shell\n$ > apt-get update\n$ > apt-get install vim\n```\n\n## 5、yaml 语法\nhttps://www.jianshu.com/p/cea930923f3d","isLeaf":true},{"key":"/docker/02-deploy-nginx.md","path":"/docker/02-deploy-nginx.md","route":"/docker/02-deploy-nginx.md","leaf":true,"title":"02-deploy-nginx","depth":1,"content":"---\ntags: Docker\ndate: 2018-05-02\n---\n\n## 1. 简单部署\n第一步：前端打包生成 dist 文件\n```shell\nnpm run build\n```\n\n第二步：在项目根目录创建 dockerfile 文件\n```shell\n# 设置基础镜像\nFROM nginx\n\n# 定义作者\nMAINTAINER gaollard\n\n# 将dist文件中的内容复制到 /usr/share/nginx/html/ 这个目录下面\nCOPY dist/  /usr/share/nginx/html/\n```\n\n第三步：构建镜像\n```shell\n# 在项目根目录执行 iname 为镜像名称\ndocker build -t iname .\n\n# 查看镜像\ndocker ps\n```\n\n第四步：启动容器\n```shell\n# -p ：配置端口映射，格式是外部访问端口：容器内端口\n# -d ：后台运行  \n# --name : 给容器取名\n# cname: 容器名称\n# iname: 镜像名称\n\ndocker run -p 3000:80 -d --name cname iname\n```\n\n第五步：查看是否运行成功\n```shell\ndocker ps\n```\n\n![20230512162713](http://s3.airtlab.com/blog/20230512162713.png)\n\n## 2. 脚本化部署\n```shell\n# 备份原代码\ntar -zcvf gentle-vue.tar ./gentle-vue\n \n# 删除原代码文件夹\nrm -rf gentle-vue\n \n# 拉取代码\ngit clone https://gitee.com/FJ_WoMenDeShiJie/gentle-vue.git\necho -e \"\\033[32m\\n代码拉取\\n\\033[0m\"\n \n# 拷贝 node_modules\ncp ./node.tar ./gentle-vue\n \n# build 打包 vue 项目，生成 dist 文件夹\ncd ./gentle-vue\ntar -zxvf node.tar\nnpm run build\necho -e \"\\033[32m\\nvue项目打包完成\\n\\033[0m\"\n \n# 删除原镜像\ndocker rmi gentle-vue &> /dev/null\necho  -e \"\\033[32m\\n删除原镜像文件\\n\\033[0m\"\n \n# 拷贝 dockerfile 到工程目录下\ncp ../dockerfile ./\n \n# 构建镜像\ndocker build -t gentle-vue .\necho -e \"\\033[32m\\n新镜像构建成功\\n\\033[0m\"\n \n# 删除原容器\ndocker rm -f gentle-vue\n \n# 启动容器\ndocker run -p 3000:80 -d --name gentle-vue gentle-vue\necho -e \"\\033[32m\\n前端工程部署完成\\n\\033[0m\"\n```\n\n## 3. 参考文档\n[https://blog.csdn.net/jiangyu1013/article/details/84572582](https://blog.csdn.net/jiangyu1013/article/details/84572582)\n","isLeaf":true},{"key":"/docker/03-deploy-sentry.md","path":"/docker/03-deploy-sentry.md","route":"/docker/03-deploy-sentry.md","leaf":true,"title":"03-deploy-sentry","depth":1,"content":"---\ntags: Docker\ndate: 2018-05-02\n---\n\nhttps://blog.csdn.net/u014265398/article/details/105877084","isLeaf":true},{"key":"/docker/04-install-ssh.md","path":"/docker/04-install-ssh.md","route":"/docker/04-install-ssh.md","leaf":true,"title":"04-install-ssh","depth":1,"content":"---\ntags: Docker\ndate: 2018-05-02\n---\n\n1. https://www.jianshu.com/p/426f0d8e6cbf\n2. https://www.cnblogs.com/mengw/p/11413461.html","isLeaf":true},{"key":"/docker/05-docker-network.md","path":"/docker/05-docker-network.md","route":"/docker/05-docker-network.md","leaf":true,"title":"05-docker-network","depth":1,"content":"---\ntags: Docker\ndate: 2018-05-02\n---\n\n### 1、创建一个新的 Docker 网络\n\n```\n$ docker network create -d bridge test-net\n```\n\n![20230512163028](http://s3.airtlab.com/blog/20230512163028.png)\n\n参数说明：\n- -d：参数指定 Docker 网络类型，有 bridge、overlay。 其中 overlay 网络类型用于 Swarm mode，在本小节中你可以忽略它。\n\n### 2、连接容器\n运行一个容器并连接到新建的 test-net 网络:\n\n```shell\n$ docker run -itd --name test1 --network test-net ubuntu /bin/bash\n```\n\n打开新的终端，再运行一个容器并加入到 test-net 网络:\n\n```shell\n$ docker run -itd --name test2 --network test-net ubuntu /bin/bash\n```\n\n点击图片查看大图：\n\n![20230512163120](http://s3.airtlab.com/blog/20230512163120.png)\n\n下面通过 ping 来证明 test1 容器和 test2 容器建立了互联关系。\n如果 test1、test2 容器内中无 ping 命令，则在容器内执行以下命令安装 ping（即学即用：可以在一个容器里安装好，提交容器到镜像，在以新的镜像重新运行以上俩个容器）。\n\n```shell\napt-get update\napt install iputils-ping\n```\n\n在 test1 容器输入以下命令：\n\n![20230512163154](http://s3.airtlab.com/blog/20230512163154.png)\n\n\n同理在 test2 容器也会成功连接到:\n\n![20230512163213](http://s3.airtlab.com/blog/20230512163213.png)\n\n这样，test1 容器和 test2 容器建立了互联关系。\n如果你有多个容器之间需要互相连接，推荐使用 Docker Compose，后面会介绍。\n","isLeaf":true},{"key":"/docker/06-exec-vs-attach.md","path":"/docker/06-exec-vs-attach.md","route":"/docker/06-exec-vs-attach.md","leaf":true,"title":"06-exec-vs-attach","depth":1,"content":"---\ntags: Docker\ndate: 2018-05-02\n---\n\n![20230512163246](http://s3.airtlab.com/blog/20230512163246.png)","isLeaf":true},{"key":"/docker/07-image-export-import.md","path":"/docker/07-image-export-import.md","route":"/docker/07-image-export-import.md","leaf":true,"title":"07-image-export-import","depth":1,"content":"---\ntags: Docker\ndate: 2018-05-02\n---\n\n参考文档：[https://blog.csdn.net/ncdx111/article/details/79878098](https://blog.csdn.net/ncdx111/article/details/79878098)\n\n> 通过镜像名称导出时，导入镜像时，镜像名称不会丢失，通过镜像ID导出，镜像名称会丢失。\n\n\n### 1、镜像导出\n#### save\n\n```bash\ndocker save -o nginx.tar nginx:latest\ndocker save > nginx.tar nginx:latest\n```\n\nnginx:latest 可以改为镜像 ID\n\n#### export\n\n```bash\ndocker export [options] container\ndocker export -o nginx-test.tar nginx-test\n```\n\n其中-o表示输出到文件，nginx-test.tar为目标文件，nginx-test是源容器名（name）\n\n### 2、镜像导入\n#### load\n\n```bash\ndocker load -i nginx.tar\ndocker load < nginx.tar\n```\n\n#### import\n\n```bash\ndocker import [options] file|URL|- [REPOSITORY[:TAG]]\n```\n\n```bash\ndocker import nginx-test.tar nginx:imp\n\n# 或\ncat nginx-test.tar | docker import - nginx:imp\n```\n","isLeaf":true},{"key":"/docker/08-host-and-container.md","path":"/docker/08-host-and-container.md","route":"/docker/08-host-and-container.md","leaf":true,"title":"08-host-and-container","depth":1,"content":"---\ntags: Docker\ndate: 2018-05-02\n---\n\n容器和宿主机文件互导\n\n```shell\n# 从宿主机拷贝到容器\ndocker cp [宿主机文件路径] [容器名]:[容器路径]\n\n# 从容器中拷贝文件到宿主机\ndocker cp [容器名]:[容器路径] [宿主机文件路径]\n```","isLeaf":true},{"key":"/docker/09-docker-logs.md","path":"/docker/09-docker-logs.md","route":"/docker/09-docker-logs.md","leaf":true,"title":"09-docker-logs","depth":1,"content":"---\ntags: Docker\ndate: 2018-05-02\n---\n\nhttps://www.runoob.com/docker/docker-logs-command.html\n\ndocker logs : 获取容器的日志\n\n```shell\ndocker logs [OPTIONS] CONTAINER\n```\n\nOPTIONS说明：\n- -f : 跟踪日志输出\n- --since :显示某个开始时间的所有日志\n- -t : 显示时间戳\n- --tail :仅列出最新N条容器日志","isLeaf":true},{"key":"/docker/10-enter-container.md","path":"/docker/10-enter-container.md","route":"/docker/10-enter-container.md","leaf":true,"title":"10-enter-container","depth":1,"content":"---\ntags: Docker\ndate: 2018-05-02\n---\n\n### 1. exec\n[https://www.cnblogs.com/xhyan/p/6593075.html](https://www.cnblogs.com/xhyan/p/6593075.html)\n\n在使用 docker 创建容器的时候，我们可以通过 -it 参数指定，直接进入容器：\n\n```bash\n# micro-web 为容器名称, 其他固定写法\ndocker exec -it micro-web /bin/bash\n```\n\n### 2. attach\n\ndocker attach退出容器，容器会停止运行的解决方法 [https://blog.csdn.net/enter89/article/details/89291691](https://blog.csdn.net/enter89/article/details/89291691)\n\n```shell\ndocker attach [OPTIONS] CONTAINER\n```\n","isLeaf":true},{"key":"/docker/11-volume.md","path":"/docker/11-volume.md","route":"/docker/11-volume.md","leaf":true,"title":"11-volume","depth":1,"content":"---\ntags: Docker\ndate: 2018-05-02\n---\n\n```shell\ndocker run -it -v /host/path:/container/path centos /bin/bash\n```\n\n1. https://www.jianshu.com/p/8c22cdfc0ffd\n2. https://blog.csdn.net/hnmpf/article/details/80924494","isLeaf":true},{"key":"/docker/12-dockerfile.md","path":"/docker/12-dockerfile.md","route":"/docker/12-dockerfile.md","leaf":true,"title":"12-dockerfile","depth":1,"content":"---\ntags: Docker\ndate: 2018-05-02\n---\n\nhttps://www.runoob.com/docker/docker-dockerfile.html\n\nARG & ENV 指令\nhttps://www.cnblogs.com/panpanwelcome/p/12604269.html\nhttps://www.cntofu.com/book/139/image/dockerfile/arg.md","isLeaf":true},{"key":"/docker/13-docker-compose.md","path":"/docker/13-docker-compose.md","route":"/docker/13-docker-compose.md","leaf":true,"title":"13-docker-compose","depth":1,"content":"---\ntags: Docker\ndate: 2018-05-02\n---\n\nCompose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。\n\nCompose 使用的三个步骤：\n\n- 使用 Dockerfile 定义应用程序的环境。\n- 使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。\n- 最后，执行 docker-compose up 命令来启动并运行整个应用程序。\n\n### 1、为什么需要 docker-compose\n维护一个容器很简单，通常有以下步骤：\n\n- 获取镜像：从 Dockerfile build image 或者在 dockerhub 拉取 image\n- 创建容器：创建多个 container\n- 管理容器：管理这些 container（启动停止删除）\n\n有时候一个项目很多个容器(10个以上)，如果每个容器的管理都要重新操作一遍，那工作量实在是太大了而且容易出错，那么如何管理和维护这些容器呢？\n\n我们需要一个 **批处理** 工具，docker-compose 正是这样的工具。\n\n### 2、docker-compose 命令\n```bash\nDefine and run multi-container applications with Docker.\n\nUsage:\n  docker-compose [-f <arg>...] [options] [COMMAND] [ARGS...]\n  docker-compose -h|--help\n\nOptions:\n  -f, --file FILE             Specify an alternate compose file\n                              (default: docker-compose.yml)\n  -p, --project-name NAME     Specify an alternate project name\n                              (default: directory name)\n  --verbose                   Show more output\n  --log-level LEVEL           Set log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)\n  --no-ansi                   Do not print ANSI control characters\n  -v, --version               Print version and exit\n  -H, --host HOST             Daemon socket to connect to\n\n  --tls                       Use TLS; implied by --tlsverify\n  --tlscacert CA_PATH         Trust certs signed only by this CA\n  --tlscert CLIENT_CERT_PATH  Path to TLS certificate file\n  --tlskey TLS_KEY_PATH       Path to TLS key file\n  --tlsverify                 Use TLS and verify the remote\n  --skip-hostname-check       Don't check the daemon's hostname against the\n                              name specified in the client certificate\n  --project-directory PATH    Specify an alternate working directory\n                              (default: the path of the Compose file)\n  --compatibility             If set, Compose will attempt to convert keys\n                              in v3 files to their non-Swarm equivalent\n  --env-file PATH             Specify an alternate environment file\n  \n  \n  Commands:\n  build              Build or rebuild services\n  config             Validate and view the Compose file\n  create             Create services\n  down               Stop and remove containers, networks, images, and volumes\n  events             Receive real time events from containers\n  exec               Execute a command in a running container\n  help               Get help on a command\n  images             List images\n  kill               Kill containers\n  logs               View output from containers\n  pause              Pause services\n  port               Print the public port for a port binding\n  ps                 List containers\n  pull               Pull service images\n  push               Push service images\n  restart            Restart services\n  rm                 Remove stopped containers\n  run                Run a one-off command\n  scale              Set number of containers for a service\n  start              Start services\n  stop               Stop services\n  top                Display the running processes\n  unpause            Unpause services\n  up                 Create and start containers\n  version            Show the Docker-Compose version information\n```\n#### up  (Create and start containers)\n```bash\ndocker-compose -f docker-compose-prod.yml up\n```\n#### stop (Stop services)\n```bash\ndocker-compose -f docker-compose-prod.yml stop\n```\n### 3、exmaple project\n\n![20230512163948](http://s3.airtlab.com/blog/20230512163948.png)","isLeaf":true},{"key":"/docker/14-cmd-entrypoint.md","path":"/docker/14-cmd-entrypoint.md","route":"/docker/14-cmd-entrypoint.md","leaf":true,"title":"14-cmd-entrypoint","depth":1,"content":"---\ntags: Docker\ndate: 2018-05-02\n---\n\n> https://www.cnblogs.com/sparkdev/p/8461576.html 这篇文章讲的很好\n\n```\nENTRYPOINT [\"executable\", \"param1\", \"param2\"]   // 这是 exec 模式的写法，注意需要使用双引号。\nENTRYPOINT command param1 param2                // 这是 shell 模式的写法。\n```","isLeaf":true}]},{"key":"/git","path":"/git","route":"/git","leaf":false,"title":"git","depth":0,"content":"","isLeaf":false,"children":[{"key":"/git/01-introduce.md","path":"/git/01-introduce.md","route":"/git/01-introduce.md","leaf":true,"title":"01-introduce","depth":1,"content":"---\ntitle: 01 Git 介绍\ntag: Git\n---\n\n## 1. 可视化客户端\n- mac sourcetree\n- win tortoisegit\n\n## 2. 辅助记忆工具\n![20230512161907](http://s3.airtlab.com/blog/20230512161907.png)","isLeaf":true},{"key":"/git/02-set-proxy.md","path":"/git/02-set-proxy.md","route":"/git/02-set-proxy.md","leaf":true,"title":"02-set-proxy","depth":1,"content":"---\ntitle: 02 Git 设置代理\ntags: Git\n---\n\nhttps://www.cnblogs.com/cscshi/p/15705045.html\n\n`git config http.proxy` 设置 HTTP 协议的代理地址，即指定 Git 在通过 HTTP 协议进行网络连接时所使用的代理服务器。此功能通常用于在公司或组织等内部网络环境中访问外部Git仓库时的需要。\n\n具体来说，当 Git 通过 HTTP 协议进行网络连接时，其会尝试直接连接目标服务器进行通信。但在一些网络环境中，直接连接可能被禁止或无法正常工作。此时，可以通过配置 HTTP 代理服务器来让 Git 通过代理服务器进行网络连接。\n\n使用代理服务器可以实现对网络流量的过滤和控制，加强对网络安全的保护，也可以提高网络连接的稳定性和性能。\n\n```shell\n# 去掉代理设置\ngit config --global --unset http.proxy\ngit config --global --unset https.proxy\n\n# 这里我使用了丰巢客户端\ngit config --global http.proxy http://127.0.0.1:7890\ngit config --global https.proxy https://127.0.0.1:7890\n```","isLeaf":true},{"key":"/git/03-use-submodule.md","path":"/git/03-use-submodule.md","route":"/git/03-use-submodule.md","leaf":true,"title":"03-use-submodule","depth":1,"content":"---\ntitle: 03 Git 使用 submodule\ntags: Git\n---\n\n## submodule 的使用\n\n- 参考文档 [https://git-scm.com/book/zh/v2/Git-工具-子模块](https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97)\n\n```bash\nusage: git submodule [--quiet] [--cached]\n   or: git submodule [--quiet] add [-b <branch>] [-f|--force] [--name <name>] [--reference <repository>] [--] <repository> [<path>]\n   or: git submodule [--quiet] status [--cached] [--recursive] [--] [<path>...]\n   or: git submodule [--quiet] init [--] [<path>...]\n   or: git submodule [--quiet] deinit [-f|--force] (--all| [--] <path>...)\n   or: git submodule [--quiet] update [--init] [--remote] [-N|--no-fetch] [-f|--force] [--checkout|--merge|--rebase] [--[no-]recommend-shallow] [--reference <repository>] [--recursive] [--[no-]single-branch] [--] [<path>...]\n   or: git submodule [--quiet] set-branch (--default|--branch <branch>) [--] <path>\n   or: git submodule [--quiet] set-url [--] <path> <newurl>\n   or: git submodule [--quiet] summary [--cached|--files] [--summary-limit <n>] [commit] [--] [<path>...]\n   or: git submodule [--quiet] foreach [--recursive] <command>\n   or: git submodule [--quiet] sync [--recursive] [--] [<path>...]\n   or: git submodule [--quiet] absorbgitdirs [--] [<path>...]\n```\n\n### 1、添加子模块\n\n```shell\n# 添加子模块\ngit submodule add git@github.com:gaollard/test_submodule_B.git  projectB\n\n# 可设置子模块在当前项目的相对路径\ngit submodule add http://test.com/backend src/vendor/\n```\n\n### 2、检出项目的指定版本\n\n```shell\n# 检出项目的指定版本(HEAD), 注意它并不是指向一个分支\ngit submodule update\n```\n\n### 3、拉取项目时拉取子模块\n\n```shell\n# 可在拉取项目时把依赖的子模块同时拉取下来\ngit clone –recursive\n```\n\n### 4、submodule ignore 选项\n\n```\nuntracked ：忽略在子模块B(projectB目录)新添加的，未受版本控制内容\ndirty     ：忽略对projectB目录下受版本控制的内容进行了修改\nall       ：同时忽略untracked和dirty\n```\n\n### 5、modified: XXX (new commits)\n\n说明当前主仓库依赖的 HEAD 和 本地仓库提交不匹配了，这个时候要特别注意。\n\n- 如果希望使用旧的 `HEAD`，使用 `git submodule update`；\n- 如果希望使用新的 `HEAD`，那么就 `git add` 提交代码；\n\n### 6、git submodule update --remote\n\n更新子模块为远程项目的最新版本\n\n### 7、init & update\n\n```shell\ngit submodule init\ngit submodule update\n\n# 合并\ngit submodule update --init\n```\n\n### 8、git submodule update --remote\n更新为远程\n\n### 9、submodule 冲突怎么办\nsubmodule 冲突时，应先合并 submodule, 再来合并主仓库","isLeaf":true},{"key":"/git/04-what-is-head.md","path":"/git/04-what-is-head.md","route":"/git/04-what-is-head.md","leaf":true,"title":"04-what-is-head","depth":1,"content":"---\ntitle: 04 Git 对 head 的理解\ntags: Git\n---\n\nhttps://www.zsythink.net/archives/3412/ 这篇文章讲的非常详细。\n\n1) 通常情况下 HEAD指针 ——–> 分支指针 ——–> 最新提交。也就是说，HEAD 指针总是通过分支指针，间接的指向了当前分支的最新提交。\n2) 有些情况下，HEAD指针没有指向分支指针，而是直接指向了某个提交，这被称作 detached head 分离头。","isLeaf":true},{"key":"/git/05-cherry-pick.md","path":"/git/05-cherry-pick.md","route":"/git/05-cherry-pick.md","leaf":true,"title":"05-cherry-pick","depth":1,"content":"---\ntitle: 05 cherry-pick\ntags: Git\n---\n\n(1) 拷贝依赖缺失\ncherry-pick 可以拷贝一次 commit 信息，如果你在分支 A 拷贝来自分支 B 的 commit id m1, 但是在代码上 m1 依赖了B分支的 m2，那么这个操作是错误的。","isLeaf":true},{"key":"/git/06-mege-commit.md","path":"/git/06-mege-commit.md","route":"/git/06-mege-commit.md","leaf":true,"title":"06-mege-commit","depth":1,"content":"---\ntitle: 06 Git 合并多个 commit\ntags: Git\n---\n\n## 1、合并方式\n- 使用 git rebase -i head~{number} 不会产生新的 commit\n- 使用 git reset 会产生新的 commit (更不友好的做法)\n\n## 2、坏味道\n`git rebase` 这种方式需要强制推送，它是一种坏味道做法，最好通知到项目的组员","isLeaf":true},{"key":"/git/07-merge-vs-rebase.md","path":"/git/07-merge-vs-rebase.md","route":"/git/07-merge-vs-rebase.md","leaf":true,"title":"07-merge-vs-rebase","depth":1,"content":"---\ntags: Git\ntitle: 07 merge-vs-rebase\n---\n\n使用 rebase 进行代码合并，可以让 git log 更清晰","isLeaf":true},{"key":"/git/08-diff.md","path":"/git/08-diff.md","route":"/git/08-diff.md","leaf":true,"title":"08-diff","depth":1,"content":"---\ntags: Git\ntitle: 08 读懂 diff\n---\n\nGit diff 变更的原因有：\n- 新增文件\n- 修改文件\n- 删除文件\n\n## 1、用法\n```text\nusage: git diff [<options>] [<commit>] [--] [<path>...]\n   or: git diff [<options>] --cached [<commit>] [--] [<path>...]\n   or: git diff [<options>] <commit> [--merge-base] [<commit>...] <commit> [--] [<path>...]\n   or: git diff [<options>] <commit>...<commit>] [--] [<path>...]\n   or: git diff [<options>] <blob> <blob>]\n   or: git diff [<options>] --no-index [--] <path> <path>]\n```\n\n- options 表示可选参数\n- commit 表示 commit id\n- path 设置文件\n\n### 1.1 --no-index\n`--no-index` 用于比较两个独立的文件或文件夹的差异。它告诉 Git diff 命令跳过对 Git 存储库的处理，并将其用于非Git文件。\n当您想要比较两个文件或文件夹而不在Git存储库中时，可以使用 `--no-index` 选项。这对于跨不同Git存储库或在没有Git存储库的环境中进行比较很有用。它提供了一种比较的方式，不依赖于Git存储库的版本控制信息。\n\n以下是使用`--no-index`选项的示例：\n\n1. 比较两个文件的差异：\n   ```\n   git diff --no-index file1.txt file2.txt\n   ```\n\n2. 比较两个文件夹的差异：\n   ```\n   git diff --no-index dir1/ dir2/\n   ```\n\n请注意，`--no-index`选项不会处理Git存储库中的更改历史记录或版本控制信息。它只会提供一种比较两个文件或文件夹之间差异的方式，因此可能会在某些情况下产生不同的输出结果。\n\n### 1.2 常见用法\n\n1. 比较工作目录和暂存区之间的差异：\n   ```\n   git diff\n   ```\n\n2. 比较暂存区和最后一次提交之间的差异：\n   ```\n   git diff --staged\n   ```\n\n3. 比较两个提交之间的差异：\n   ```\n   git diff commit1 commit2\n   ```\n\n4. 比较两个分支之间的差异：\n   ```\n   git diff branch1 branch2\n   ```\n\n5. 显示文件中具体的更改内容：\n   ```\n   git diff --word-diff\n   ```\n\n6. 生成可供打印的简洁差异：\n   ```\n   git diff --color-words\n   ```\n\n这只是一些基本的用法示例。Git diff还有很多其他可选项和参数，可以根据需要进行进一步的定制。您可以通过运行`git diff --help`命令来查看所有可用选项和参数的详细信息。\n\n### 1.3 默认输出格式\n\n执行\n```shell\ngit diff 801aae133e70fe312223faccd97072e8afc07404\n````\n\n其输出是下面这样的一个列表，每一项代表某个文件前后对比\n\n```text\ndiff --git a/libs/grpc/src/grpc.service.ts b/libs/grpc/src/grpc.service.ts\nindex 3b551ff..33b5a94 100644\n--- a/libs/grpc/src/grpc.service.ts\n+++ b/libs/grpc/src/grpc.service.ts\n@@ -12,6 +12,7 @@ import { dynamicProxyUrl, localService } from '@app/config/local.service';\n import { migrationMap } from '@app/shared/migrationMap';\n import { rpcMetrics } from '@/prom/prom.client';\n import { CURRENT_ETCD } from '@app/shared/etcd.config';\n+import { isThDGL } from '@app/shared/utils/getFromContext';\n \n @Injectable()\n export class GrpcService {\n@@ -41,6 +42,10 @@ export class GrpcService {\n       );\n     }\n \n+    if (region === 'th') {\n+      body = { ...body, licenseType: isThDGL() ? 'Digi' : 'CCC' };\n+    }\n+\n     const rpcAction = getRpc(service, rpc, address as string);\n     let makeParam =\n       (body && body['migrationMap']) || service === Service.LoanCoreDebt\n```\n\n**1) diff 格式**\n\n第一行表示结果为 git 格式的 diff:\n```\ndiff --git a/libs/grpc/src/grpc.service.ts b/libs/grpc/src/grpc.service.ts\n```\n\n**2) diff 对象**\n\n第二行表示两个版本的git哈希值\n```\nindex 3b551ff..33b5a94 100644\n```\n\nindex 区域的 3b551ff 对象 与工作目录区域的 33b5a94 对象进行比较，最后的六位数字是对象的模式（普通文件，644权限）\n\n**3) 变动范围**\n\n\"---\"表示变动前的文件，\"+++\"表示变动后的文件，变动的位置用两个@作为起首和结束，`@@ -12,6 +12,7 @@`\n\n前面的\"-12,6\"分成三个部分：减号表示第一个文件（即f1），\"12\"表示第12行，\"6\"表示连续6行。合在一起，就表示下面是第一个文件从第16行开始的连续6行。同样的，\"+12,7\"表示变动后，成为第二个文件从第12行开始的连续7行。\n\n**4) 变动的具体内容**\n\n```text\nimport { dynamicProxyUrl, localService } from '@app/config/local.service';\nimport { migrationMap } from '@app/shared/migrationMap';\nimport { rpcMetrics } from '@/prom/prom.client';\nimport { CURRENT_ETCD } from '@app/shared/etcd.config';\n\n@Injectable()\nexport class GrpcService {\n```\n\n```text\n import { dynamicProxyUrl, localService } from '@app/config/local.service';\n import { migrationMap } from '@app/shared/migrationMap';\n import { rpcMetrics } from '@/prom/prom.client';\n import { CURRENT_ETCD } from '@app/shared/etcd.config';\n+import { isThDGL } from '@app/shared/utils/getFromContext';\n \n @Injectable()\n export class GrpcService {\n```\n\n### 1.4 diff 可视化展示\n\n根据 `@@` 进行分割，进行逐行对比，即可找到某行是被删除、还是增加。\n\n## 2、参数\n\n```text\n  -z            output diff-raw with lines terminated with NUL.\n  -p            output patch format.\n  -u            synonym for -p.\n  --patch-with-raw\n                output both a patch and the diff-raw format.\n  --stat        show diffstat instead of patch.\n  --numstat     show numeric diffstat instead of patch.\n  --patch-with-stat\n                output a patch and prepend its diffstat.\n  --name-only   show only names of changed files.\n  --name-status show names and status of changed files.\n  --full-index  show full object name on index lines.\n  --abbrev=<n>  abbreviate object names in diff-tree header and diff-raw.\n  -R            swap input file pairs.\n  -B            detect complete rewrites.\n  -M            detect renames.\n  -C            detect copies.\n  --find-copies-harder\n                try unchanged files as candidate for copy detection.\n  -l<n>         limit rename attempts up to <n> paths.\n  -O<file>      reorder diffs according to the <file>.\n  -S<string>    find filepair whose only one side contains the string.\n  --pickaxe-all\n                show all files diff when -S is used and hit is found.\n  -a  --text    treat all files as text.\n```\n\n### 2.1 name-only 只展示文件名\n```shell\ngit diff --name-only  master\n```\n\n```text\nlibs/config/src/th/local.config.ts\nlibs/config/src/th/test.config.ts\nlibs/config/src/th/uat.config.ts\nlibs/db/src/db.service.ts\nlibs/elastic/src/elastic.interface.ts\nlibs/elastic/src/elastic.service.ts\nlibs/grpc/src/grpc.service.ts\nlibs/grpc/src/proto/protobuf-uc\n```\n\n看不出文件是改动、删除或者新增\n\n### 2.2 --stat 显示文件差异的摘要信息\n\n使用 `--stat` 选项可以帮助您快速了解文件间的大致差异，以便更好地理解Git存储库中的改动情况。\n\n```shell\ngit diff --stat 801aae133e70fe312223faccd97072e8afc07404\n```\n\n```text\nlibs/grpc/src/grpc.service.ts     | 5 +++++ [增加5行]\nlibs/grpc/src/proto/protobuf-uc   | 2 +-    [增加1行，删除1行]\nlibs/grpc/src/services/BaseRpc.ts | 5 +++++ [增加5行]\n3 files changed, 11 insertions(+), 1 deletion(-)\n```\n\n### 2.3 `--numstat` 以数字形式显示文件差异的摘要信息\n\n用于以数字形式显示文件差异的摘要信息。它会显示出每个文件被添加、删除和修改的行数。\n\n```shell\n$ git diff --numstat 801aae133e70fe312223faccd97072e8afc07404\n5       0       libs/grpc/src/grpc.service.ts\n1       1       libs/grpc/src/proto/protobuf-uc\n5       0       libs/grpc/src/services/BaseRpc.ts\n```\n\n### 2.4 --name-status 展示文件修改类型\n\n```shell\ngit diff --name-status  801aae133e70fe312223faccd97072e8afc07404\nM       libs/grpc/src/grpc.service.ts\nM       libs/grpc/src/proto/protobuf-uc\nM       libs/grpc/src/services/BaseRpc.ts\n```\n\n`--name-status` 用于以文件名和状态的形式显示文件差异的摘要信息。它会显示出每个文件的状态，包括被添加、被修改和被删除。\n当您执行Git diff命令，并添加了`--name-status`选项，Git会为每个文件产生一个摘要，以文件名和其状态的形式显示文件的差异统计信息。输出结果包含两个字段：文件的状态和文件名。\n\n以下是一个使用`--name-status`选项的示例：\n\n```\ngit diff --name-status\n```\n\n这将显示出Git存储库中当前分支和上一个分支之间的文件差异的统计信息。输出结果可能类似于下面的样式：\n\n```\nA       file1.txt\nM       file2.txt\nD       file3.txt\n```\n\n这个示例告诉我们，`file1.txt` 文件是被添加的（Added），`file2.txt` 文件是被修改的（Modified），`file3.txt` 文件是被删除的（Deleted）。\n\n`--name-status` 选项对于需要以文件状态形式获取文件差异统计信息的情况很有用。它可以帮助您了解每个文件的状态，包括添加、修改和删除等操作。\n\n## 3、参考文档\n\n- [读懂diff] https://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html","isLeaf":true},{"key":"/git/09-multile-github.md","path":"/git/09-multile-github.md","route":"/git/09-multile-github.md","leaf":true,"title":"09-multile-github","depth":1,"content":"---\ntags: Git\n---\n\n1台电脑上使用两个github账户，参考 https://juejin.cn/post/6844904086085582862 或者可以通过 github token 来避免这个问题","isLeaf":true},{"key":"/git/10-commit-rule.md","path":"/git/10-commit-rule.md","route":"/git/10-commit-rule.md","leaf":true,"title":"10-commit-rule","depth":1,"content":"---\ntags: Git\n---\n\n## 1、提交格式\n```text\ntype(scope): message\n```\n\n## 2、type\n- feat：新功能的开发\n- fix：bug的修复\n- docs：文档格式的改动\n- style：代码格式改变\n- refactor：对已有的功能进行重构\n- perf：性能优化\n- test：增加测试\n- build：改变了build工具\n- revert：撤销上一次的commit提交\n- chore：日常的一些小更改\n\n## 3、scope\n用于说明 commit 影响的范围，比如：权限模块、还是首页","isLeaf":true},{"key":"/git/11-use-hooks.md","path":"/git/11-use-hooks.md","route":"/git/11-use-hooks.md","leaf":true,"title":"11-use-hooks","depth":1,"content":"---\ntags: Git\n---\n\n参考 https://www.cnblogs.com/woai3c/p/15033530.html 特别注意 hooks 文件的权限问题","isLeaf":true},{"key":"/git/12-file-timeline.md","path":"/git/12-file-timeline.md","route":"/git/12-file-timeline.md","leaf":true,"title":"12-file-timeline","depth":1,"content":"---\ntags: Git\n---\n\n## 1、sourcetree\n使用 git 命令不够直观，可以使用 sourcetree, 点击文件 【查看选中的修改日志】\n\n## 2、vscode\n可以查看当前窗口文件的时间线","isLeaf":true},{"key":"/git/13-git-log.md","path":"/git/13-git-log.md","route":"/git/13-git-log.md","leaf":true,"title":"13-git-log","depth":1,"content":"---\ntags: Git\n---\n\n参考 https://zhuanlan.zhihu.com/p/183131156\n\n```shell\ngit log --oneline\ngit log --stat\n```","isLeaf":true},{"key":"/git/14-gen-ssh-key.md","path":"/git/14-gen-ssh-key.md","route":"/git/14-gen-ssh-key.md","leaf":true,"title":"14-gen-ssh-key","depth":1,"content":"---\ntags: Git\n---\n\n```shell\n# make\nssh-keygen -t rsa -C \"2856116089@qq.com\"\n\n# config\ngit config --global user.name \"waisai\"\ngit config --global user.email \"2856116089@qq.com\"\n```","isLeaf":true},{"key":"/git/15-rm-cached.md","path":"/git/15-rm-cached.md","route":"/git/15-rm-cached.md","leaf":true,"title":"15-rm-cached","depth":1,"content":"---\ntags: Git\n---\n\n有时候，我们需要忽略掉以前提交过的文件，因为git已经索引了该文件，所以我们先要删除掉该文件的缓存，如文件 main.ts 已经提交过了，现在我们想忽略，这是我们先在 .gitignore 中设置该文件为忽略。\n\n- 使用 git rm --cached 从 Git 的数据库中删除对于该文件的追踪\n- 把对应的规则写入 .gitignore，让忽略真正生效\n\n```shell\ngit rm --cached main.ts\n\n# 若是文件夹\ngit rm -r --cached folder/\n```","isLeaf":true},{"key":"/git/16-reset-vs-revert.md","path":"/git/16-reset-vs-revert.md","route":"/git/16-reset-vs-revert.md","leaf":true,"title":"16-reset-vs-revert","depth":1,"content":"---\ntags: Git\n---\n\n- reset 是彻底回退到指定的commit版本，该commit后的所有commit都将被清除，包括提交历史记录；\n- revert 仅仅是撤销指定commit的修改，并不影响后续的commit，但所撤销的commit被后续的commit修改了同一地方则会产生冲突；\n- reset 执行后不会产生记录，revert执行后会产生记录；\n- reset 执行后无法再次恢复，revert执行后因为不会清除记录，并且会产生新纪录，所以文件不会丢失，你可以多次执行revert恢复到某次改变之前的状态；\n- reset 执行后HEAD会后移，而revert的HEAD则一直是向前的；\n\nhttps://blog.csdn.net/baiyuliang2013/article/details/120646835","isLeaf":true},{"key":"/git/17-case-sensitive.md","path":"/git/17-case-sensitive.md","route":"/git/17-case-sensitive.md","leaf":true,"title":"17-case-sensitive","depth":1,"content":"---\ntags: Git\n---\n\n文件系统大小写敏感是非常重要，会带来诸多问题。比如不敏感时，当你希望修改文件目录从小写到大写时，git 状态是未发生变更，意味着你无法提交。","isLeaf":true}]}]