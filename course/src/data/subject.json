[{"key":"/Babel","path":"/Babel","route":"/Babel","leaf":false,"title":"Babel","depth":0,"content":"","isLeaf":false,"children":[{"key":"/Babel/01-Babel 基础","path":"/Babel/01-Babel 基础","route":"/Babel/01-Babel 基础","leaf":false,"title":"01-Babel 基础","depth":1,"content":"","isLeaf":false,"children":[{"key":"/Babel/01-Babel 基础/01 babel 介绍.md","path":"/Babel/01-Babel 基础/01 babel 介绍.md","route":"/Babel/01-Babel 基础/01 babel 介绍.md","leaf":true,"title":"01 babel 介绍","depth":2,"content":"---\ntitle: 01 babel 介绍\ntags: Babel\n---\n\n## 1、Babel 介绍\n\nBabel 是一个开源的 JavaScript 编译器工具，用于将新版本的 JavaScript 代码转换为向后兼容的旧版本，以便在不同的浏览器和环境中运行。它可以将使用最新的 ECMAScript 标准编写的代码转换为支持更旧的版本，以便在不同的浏览器中运行。\n\n## 2、Babel 版本\n\n### 2.1 v6 VS v7\nBabel V7 相对于 Babel V6来说，有以下几个主要的区别：\n\n1. 命令行工具改进：V7 增加了一些新的命令行工具，如 `babel-upgrade` 和 `babel-merge` 等，这些工具让你更方便地维护Babel配置和升级到新的版本。\n\n2. 插件新增：V7 在默认插件集合中新增了一些新的插件，如 `@babel/plugin-transform-runtime` 和 `@babel/plugin-proposal-class-properties` 等，这些插件为开发者提供更多的便利和控制力。\n\n3. 配置文件更改：Babel V7 将配置文件名称从 `.babelrc` 更改为 `babel.config.js`，并支持更复杂的配置选项。\n\n4. 匹配更多的 ECMAScript 特性：Babel V7 支持更多的 ECMAScript 特性，如对象的 Rest 和 Spread 属性，对象的解构赋值，Async 函数和模板字符串标记等。\n\nBabel V7 相对于 Babel V6 的改进主要在于命令行工具、插件集合、配置文件和匹配更多的 ECMAScript 特性等方面。\n\n### 2.2 V7.4.0\n- @babel/polyfill 被弃用，取而代之的是 `\"core-js/stable\"`\n\n### 2.3 v7.6.0\n- 支持 TypeScript 命名空间的编译。\n\n## 3、学习资料\n\n### 3.1 官方文档\n\n- babel 官方网 [https://babeljs.io/docs/en](https://babeljs.io/docs/en/)\n- babel 中文网 [https://www.babeljs.cn/docs](https://www.babeljs.cn/docs/)\n\n### 3.2 调试工具\n\n- AST 在线 <https://astexplorer.net/#/2uBU1BLuJ1>\n- babel 插件开发手册 <https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md>\n\n### 3.3 实践经验\n- babel 腾讯云社区文档 <https://cloud.tencent.com/developer/doc/1260> 介绍babel API\n- 最简单 compiler 教程 [the-super-tiny-compiler](https://github.com/jamiebuilds/the-super-tiny-compiler/blob/master/the-super-tiny-compiler.js)\n- [高级前端基础-JavaScript抽象语法树AST](https://segmentfault.com/a/1190000018532745) <https://segmentfault.com/a/1190000018532745>\n- [AST抽象语法树——最基础的javascript重点知识，99%的人根本不了解](https://segmentfault.com/a/1190000016231512?utm_source=tag-newest#articleHeader10)\n- [从零开始写一个wepy转VUE的工具](http://zzfed.com/#/detail/5c8efc30c476e35308705a5b)\n- Babel是如何读懂JS代码的 <https://zhuanlan.zhihu.com/p/27289600>\n- 网易云课堂 JS编译原理： [https://study.163.com/course/courseMain.htm?courseId=1209486877&*trace\\_c\\_p\\_k2*=8ea58ce894c149179bd099a664c39d08](https://study.163.com/course/courseMain.htm?courseId=1209486877&_trace_c_p_k2_=8ea58ce894c149179bd099a664c39d08)","isLeaf":true},{"key":"/Babel/01-Babel 基础/02 babel 快速开始.md","path":"/Babel/01-Babel 基础/02 babel 快速开始.md","route":"/Babel/01-Babel 基础/02 babel 快速开始.md","leaf":true,"title":"02 babel 快速开始","depth":2,"content":"---\ntitle: 02 babel 快速开始\ntags: Babel\n---\n\n## 1、初始化配置\n\n```shell\nyarn add --dev @babel/core @babel/cli @babel/preset-env\n```\n\n- @babel/core 提供了基本功能，包括 AST 解析 以及 AST visitor\n- @babel/cli 是一个命令行工具\n- @babel/preset-env 是一个插件集合\n\n**创建配置文件**\n\n```js\nconst presets = [\n  [\n    \"@babel/preset-env\",\n    {\n      targets: {\n        edge: \"17\",\n        firefox: \"60\",\n        chrome: \"67\",\n        safari: \"11.1\",\n      },\n      useBuiltIns: \"usage\",\n      corejs: \"3.6.4\",\n    },\n  ],\n];\n\nmodule.exports = { presets };\n```\n\n```\n./node_modules/.bin/babel src --out-dir lib\n```\n\n## 2、配置文件说明\n\n- 项目范围的配置\n  - `babel.config.*` 文件，具有以下扩展名：.json, .js, .cjs, .mjs, .cts.\n- 文件相关配置\n  - `.babelrc.*` 文件，具有以下扩展名：.json, .js, .cjs, .mjs, .cts.\n  - `.babelrc` 文件，没有扩展名。\n  - `package.json` 文件，\"babel\" key\n\n[babeljs.io config](https://babeljs.io/docs/config-files) 在这里了解他们的区别，我们应该用哪种？","isLeaf":true},{"key":"/Babel/01-Babel 基础/03 plugin 和 preset.md","path":"/Babel/01-Babel 基础/03 plugin 和 preset.md","route":"/Babel/01-Babel 基础/03 plugin 和 preset.md","leaf":true,"title":"03 plugin 和 preset","depth":2,"content":"---\ntitle: 03 plugin 和 preset\ntags: Babel\n---\n\nBabel 插件 和 Preset 是用于在 JavaScript 项目中进行代码转换的工具。\n\n## 1、插件 和 Preset 有什么区别？\n\n- 插件是针对 Babel 的具体功能的单个功能，例如“转换箭头函数为普通函数”，“转换 ES6 类成为普通函数”等，而 preset 则是包含另外一些插件的一个集合，这些插件共同完成一些相关的 tasks。\n\n- 软件预设(packaged presets) 可以轻松地执行多项任务，而不必单独安装和配置多个插件。例如，@babel/preset-env 是一个预设，它帮助您将 ES6+代码转换为符合您指定的目标环境的 JavaScript 代码。\n\n## 2、如何使用？\n\n使用 Babel 插件和 Preset，您需要在项目中安装它们并配置 Babel。在您的项目根目录下创建一个 `.babelrc` 文件，为 Babel 提供配置。\n\n## 3、preset\n\n例如，使用 preset-env 转换 ES6 +代码：\n\n1. 安装 `@babel/preset-env`:\n\n```shell\nnpm install --save-dev @babel/preset-env\n```\n\n2. 然后在 .babelrc 文件中配置：\n\n```json\n{\n  \"presets\": [\"@babel/preset-env\"]\n}\n```\n\n这意味着在项目中的所有 ES6+代码都将被转换为适用于您的所需 JavaScript 环境的标准 JavaScript。\n\n## 4、plugin\n\n```shell\nyarn add --dev @babel/plugin-transform-arrow-functions\n```\n\n```shell\n./node_modules/.bin/babel src --out-dir lib --plugins=@babel/plugin-transform-arrow-functions\n```\n\n```js\nconst fn = () => 1;\n\n// converted to\nvar fn = function fn() {\n  return 1;\n};\n```\n\n```js\nconst presets = [\n  [\n    \"@babel/preset-env\",\n    {\n      targets: {\n        edge: \"17\",\n        firefox: \"60\",\n        chrome: \"67\",\n        safari: \"11.1\",\n      },\n      useBuiltIns: \"usage\",\n      corejs: \"3.6.4\",\n    },\n  ],\n];\n\nconst pluginOption = {}\n\nconst plugins = [\n  [\"@babel/plugin-transform-arrow-functions\", pluginOption]\n];\n\nmodule.exports = { presets, plugins };\n```\n\n### 4.1 插件执行顺序\n\nbabel 插件按顺序执行，那么插件的先后顺序是如何决定的呢？比如在一个项目中使用 React 和 Typescript，那么识别 ts 的语法插件在前面，还是识别 jsx 的语法的插件在前面？\n\n- Plugin 会运行在 Preset 之前。\n- Plugin 会从前到后顺序执行。\n- Preset 的顺序则 刚好相反(从后向前)。\n\n\n```json\nconst test1Plugin = require('./test1.plugin');\nconst test2Plugin = require('./test2.plugin');\n\nconst presets = [\n  [\n    '@babel/preset-env',\n    {\n      targets: {\n        edge: '17',\n        firefox: '60',\n        chrome: '67',\n        safari: '11.1',\n      },\n      useBuiltIns: 'usage',\n      corejs: '3.6.4',\n    },\n  ],\n];\n\nconst plugins = [\n  [test1Plugin],\n  [test2Plugin]\n]\n\nmodule.exports = { presets, plugins };\n```\n\n在上面的代码中 test1Plugin 比 test2Plugin 先执行。\n\n### 4.2 jsx 和 ts 语法支持\n\n显然第一个插件必须同时支持 jsx 语法 和 ts 语法，`@babel/preset-typescript` 已经支持了 jsx 语法\n\n![20230705145919](http://s3.airtlab.com/blog/20230705145919.png)\n\n`@babel/preset-typescript` 底层依赖，`plugin-syntax-typescript`","isLeaf":true},{"key":"/Babel/01-Babel 基础/04 plugin ES2015.md","path":"/Babel/01-Babel 基础/04 plugin ES2015.md","route":"/Babel/01-Babel 基础/04 plugin ES2015.md","leaf":true,"title":"04 plugin ES2015","depth":2,"content":"---\ntitle: 04 plugin ES2015\ntags: Babel\n---\n\nBabel 是一个编译器。从宏观角度看，它将运行代码分为3个阶段: 解析，转换，及生成（与其他编译器相同）。\n\n始阶段，Babel 并没有做任何事情。它基本上就相当于 `const babel = code => code;`，先解析代码，然后再次生成相同的代码。你可以为 Babel 添加一些 Plugins 让其去做任何事情( Plugins 会影响 Babel 的第 2 阶段，转换)。\n\n\n## 1、ES3\n\n### [es3-member-expression-literals](https://babel.docschina.org/docs/en/babel-plugin-transform-es3-member-expression-literals)\n\n```javascript\n// 在IE8及以下会报错\nfoo.catch;\n\n// 需要转换为\nfoo[\"catch\"]\n```\n\n### [es3-property-literals](https://babel.docschina.org/docs/en/babel-plugin-transform-es3-property-literals)\n\n```javascript\n// 在IE8及以下会报错\nvar foo = {\n  catch: function () {}\n};\n\n// 需要转换为\nvar foo = {\n  \"catch\": function () {}\n};\n```\n\n\n### [reserved-words](https://babeljs.io/docs/en/babel-plugin-transform-reserved-words)\n\n有些在标识符在ES3为保留字，在ES5及以后就不是了，这个插件可以重命名这些标识符。\n\n```javascript\n// IN\nvar abstract = 1;\nvar x = abstract + 1;\n\n// OUT\nvar _abstract = 1;\nvar x = _abstract + 1;\n```\n\n## 2、ES5\n\n### [property-mutators](https://babeljs.io/docs/en/babel-plugin-transform-property-mutators)\n\n对于 mutate 方法的定义，老版的部分浏览器只支持使用 Object.defineProperties 来定义：\n\n```javascript\n// In\nvar foo = {\n  get bar() {\n    return this._bar;\n  },\n  set bar(value) {\n    this._bar = value;\n  }\n};\n\n// Out\nvar foo = Object.defineProperties({}, {\n  bar: {\n    get: function () {\n      return this._bar;\n    },\n    set: function (value) {\n      this._bar = value;\n    },\n    configurable: true,\n    enumerable: true\n  }\n});\n```\n\n<a name=\"R2DiV\"></a>\n\n## 3、ES2015\n\nES2015 修订文档：<https://www.ecma-international.org/ecma-262/6.0>\n\n### [arrow-functions](https://babeljs.io/docs/en/babel-plugin-transform-arrow-functions)\n\n箭头函数转译\n\n### [block-scoped-functions](https://babeljs.io/docs/en/babel-plugin-transform-block-scoped-functions)\n\n块级作用域函数\n\n```javascript\n// In\n{\n  function name (n) {\n    return n;\n  }\n}\n\nname(\"Steve\");\n\n// Out\n{\n  let name = function (n) {\n    return n;\n  };\n}\nname(\"Steve\");\n```\n\n### [block-scoping](https://babeljs.io/docs/en/babel-plugin-transform-block-scoping)\n\n块及作用域\n\n```javascript\n// In\n{\n  let a = 3\n}\n\nlet a = 3\n\n// Out\n{\n  var _a = 3;\n}\n\nvar a = 3;\n```\n\n### [classes](https://babeljs.io/docs/en/babel-plugin-transform-classes)\n\n使用 class 定义类，如果你的代码包含子类继承 Native class 时，需要额外注意，见文档 [classes](https://babeljs.io/docs/en/babel-plugin-transform-classes)。\n\n```javascript\n// In\nclass Test {\n  constructor(name) {\n    this.name = name;\n  }\n\n  logger () {\n    console.log(\"Hello\", this.name);\n  }\n}\n\n// Out\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar Test = function () {\n  function Test(name) {\n    _classCallCheck(this, Test);\n\n    this.name = name;\n  }\n\n  Test.prototype.logger = function logger() {\n    console.log(\"Hello\", this.name);\n  };\n\n  return Test;\n}();\n```\n\n### [computed-properties](https://babeljs.io/docs/en/babel-plugin-transform-computed-properties)\n\n计算属性或表达式属性\n\n```javascript\n// In\nvar obj = {\n  [\"x\" + foo]: \"heh\",\n  [\"y\" + bar]: \"noo\",\n  foo: \"foo\",\n  bar: \"bar\"\n};\n\n// Out\nvar _obj;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar obj = (\n  _obj = {},\n  _defineProperty(_obj, \"x\" + foo, \"heh\"),\n  _defineProperty(_obj, \"y\" + bar, \"noo\"),\n  _defineProperty(_obj, \"foo\", \"foo\"),\n  _defineProperty(_obj, \"bar\", \"bar\"),\n  _obj\n);\n```\n\n### [destructuring](https://babeljs.io/docs/en/babel-plugin-transform-destructuring)\n\n解构赋值\n\n```javascript\n// In\nlet {x, y} = obj;\nlet [a, b, ...rest] = arr;\n\n// Out\nfunction _toArray(arr) { ... }\n\nlet _obj = obj,\n    x = _obj.x,\n    y = _obj.y;\n\nlet _arr = arr,\n    _arr2 = _toArray(_arr),\n    a = _arr2[0],\n    b = _arr2[1],\n    rest = _arr2.slice(2);\n```\n\n### [duplicate-keys](https://babeljs.io/docs/en/babel-plugin-transform-duplicate-keys)\n\n将重复key转为表达式key，没什么用\n\n```javascript\n// In\nvar x = { a: 5, a: 6 };\nvar y = {\n  get a() {},\n  set a(x) {},\n  a: 3,\n};\n\n// Out\nvar x = { a: 5, [\"a\"]: 6 };\nvar y = {\n  get a() {},\n  set a(x) {},\n  [\"a\"]: 3,\n};\n```\n\n### [for-of](https://babeljs.io/docs/en/babel-plugin-transform-for-of)\n\nfor-of 迭代器\n\n```javascript\n// in\nfor (var i of foo) {}\n\n// out\nvar _iteratorNormalCompletion = true;\nvar _didIteratorError = false;\nvar _iteratorError = undefined;\n\ntry {\n  for (var _iterator = foo[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n    var i = _step.value;\n  }\n} catch (err) {\n  _didIteratorError = true;\n  _iteratorError = err;\n} finally {\n  try {\n    if (!_iteratorNormalCompletion && _iterator.return != null) {\n      _iterator.return();\n    }\n  } finally {\n    if (_didIteratorError) {\n      throw _iteratorError;\n    }\n  }\n}\n```\n\n### [function-name](https://babeljs.io/docs/en/babel-plugin-transform-function-name)\n\n```javascript\n// in\nlet number = (x) => x\n\n// out\nvar number = function number(x) {\n  return x;\n};\n```\n\n### [instanceof](https://babeljs.io/docs/en/babel-plugin-transform-instanceof)\n\nES2015 对 instanceof 操作符进行了修订\n![20230608110441](http://s3.airtlab.com/blog/20230608110441.png)\n\n```javascript\n// in\nfoo instanceof Bar;\n\n// out\nfunction _instanceof(left, right) {\n  if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n    return right[Symbol.hasInstance](left);\n  } else {\n    return left instanceof right;\n  }\n}\n\n_instanceof(foo, Bar);\n```\n\n### [literals](https://babeljs.io/docs/en/babel-plugin-transform-literals)\n\n字面量转换\n\n```javascript\n// in\nvar b = 0b11; // binary integer literal\nvar o = 0o7; // octal integer literal\nconst u = 'Hello\\u{000A}\\u{0009}!'; // unicode string literals, newline and tab\n\n// out\nvar b = 3; // binary integer literal\nvar o = 7; // octal integer literal\nconst u = 'Hello\\n\\t!'; // unicode string literals, newline and tab\n```\n\n### [new-target](https://babeljs.io/docs/en/babel-plugin-transform-new-target)\n\nnew.target返回使用new方法调用类时的类的名称，子类继承父类时，new.target会返回子类。\n\n```javascript\nclass Rectangle {\n  constructor(length, width) {\n    console.log(new.target === Rectangle);\n  }\n}\n \nclass Square extends Rectangle {\n  constructor(length) {\n    super(length, length);\n  }\n}\n```\n\n### [object-super](https://babeljs.io/docs/en/babel-plugin-transform-object-super)\n\nthis 关键字总是指向函数所在的当前对象，ES6 新增了另一个类似的关键字super，指向当前对象的原型对象。\n\n```javascript\nlet obj2 = {\n  say () {\n    // [object Object]World!\n    return super.toString() + \"World!\"\n  }\n}\n```\n\n### [parameters](https://babeljs.io/docs/en/babel-plugin-transform-parameters)\n\n处理 ES2015 函数参数：\n\n- Destructuring parameters 参数解构\n- Default parameters 默认参数\n- Rest parameters 扩展符\n\n```javascript\n// in\nfunction test(x = \"hello\", { a, b }, ...args) {\n  console.log(x, a, b, args);\n}\n\n// out\nfunction test() {\n  var x =\n    arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"hello\";\n  var _ref = arguments[1];\n  var a = _ref.a,\n    b = _ref.b;\n\n  for (\n    var _len = arguments.length,\n      args = Array(_len > 2 ? _len - 2 : 0),\n      _key = 2;\n    _key < _len;\n    _key++\n  ) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  console.log(x, a, b, args);\n}\n```\n\n### [shorthand-properties](https://babeljs.io/docs/en/babel-plugin-transform-shorthand-properties)\n\n```javascript\n// in\nvar o = { a, b, c };\n\n// out\nvar o = { a: a, b: b, c: c };\n```\n\n```javascript\n// in\nvar cat = {\n  getName() {\n    return name;\n  }\n};\n\n// out\nvar cat = {\n  getName: function () {\n    return name;\n  }\n};\n```\n\n### [spread](https://babeljs.io/docs/en/babel-plugin-transform-spread)\n\n扩展运算符，与剩余运算符互为逆运算\n\n```javascript\n// in\nvar a = ['a', 'b', 'c'];\n\nvar b = [...a, 'foo'];\n\nvar c = foo(...a);\n\n// out\nvar a = ['a', 'b', 'c'];\n\nvar b = a.concat(['foo']);\n\nvar c = foo.apply(void 0, a);\n```\n\n### [sticky-regex](https://babeljs.io/docs/en/babel-plugin-transform-sticky-regex)\n\n```javascript\n// in\nconst a = /o+/y;\n\n// out\nvar a = new RegExp(\"o+\", \"y\");\n```\n\ny 修饰符：叫做 “粘连”（sticky）修饰符。用来正确处理匹配粘连的字符串。它的作用和g修饰类似，也是全局匹配。它可以使用新增的正则对象属性sticky来判断正则对象是否设置了y修饰符。y 和 g 的区别\n\n- g 修饰符只要剩余位置中存在匹配的字符串就可以返回成功。而y修饰符确保匹配必须是从剩余的所有位置中的第一个位置开始，这也是粘连的含义。\n- y 修饰符隐含了头部匹配的标志^（^x表示匹配的字符串的首个字符必须是x）\n\n### [template-literals](https://babeljs.io/docs/en/babel-plugin-transform-template-literals)\n\n模版字符串\n\n```javascript\n// in\n`foo${bar}`;\n\n// out\n\"foo\".concat(bar);\n```\n\n### [typeof-symbol](https://babeljs.io/docs/en/babel-plugin-transform-typeof-symbol)\n\nSymbol是原始值，ES6扩展了typeof操作符，返回\"symbol\"。所以可以用typeof来检测变量是否为symbol类型\n\n### [unicode-escapes](https://babeljs.io/docs/en/babel-plugin-transform-unicode-escapes)\n\nCompile ES2015 Unicode escapes to ES5\n\n```javascript\n// in\nvar \\u{1d49c} = \"\\u{Babe1}\";\n\nconsole.log(\\u{1d49c});\n\n// out\nvar _ud835_udc9c = \"\\uDAAA\\uDFE1\";\n\nconsole.log(_ud835_udc9c);\n```\n\n### [unicode-regex](https://babeljs.io/docs/en/babel-plugin-transform-unicode-regex)\n\n```js\n// in\nvar string = \"foo💩bar\";\nvar match = string.match(/foo(.)bar/u);\n```","isLeaf":true},{"key":"/Babel/01-Babel 基础/05 plugin ES2016.md","path":"/Babel/01-Babel 基础/05 plugin ES2016.md","route":"/Babel/01-Babel 基础/05 plugin ES2016.md","leaf":true,"title":"05 plugin ES2016","depth":2,"content":"---\ntitle: 05 plugin ES2016\ntags: Babel\n---\n\n## 1、ES2016\n\n### [exponentiation-operator](https://babeljs.io/docs/en/babel-plugin-transform-exponentiation-operator)\n\n新增指数运算法\n\n```javascript\n// in\nlet x = 10 ** 2;\n\nx **= 3;\n\n// out\nlet x = Math.pow(10, 2);\nx = Math.pow(x, 3);\n```\n\n## 2、ES2017\n\n### [async-to-generator](https://babeljs.io/docs/en/babel-plugin-transform-async-to-generator)\n\n将 async 转换为 generator\n\n```javascript\n// in\nasync function foo() {\n  await bar();\n}\n\n// out\nvar _asyncToGenerator = function (fn) {\n  ...\n};\n\nvar foo = _asyncToGenerator(function* () {\n  yield bar();\n});\n```\n\n\n## 3、ES2018\n\n### [external-helpers](https://babeljs.io/docs/en/babel-plugin-external-helpers)\n\n内部帮助函数\n\n### [object-assign](https://babeljs.io/docs/en/babel-plugin-transform-object-assign)\n\n```javascript\n// in \nObject.assign(a, b);\n\n// out\nvar _extends = ...;\n\n_extends(a, b);\n```\n\n### [regenerator](https://babeljs.io/docs/en/babel-plugin-transform-regenerator)\n\n这是 facebook 下的一个工具，用于编译 ES6 的 generator 函数，一篇非常好的文章见：<https://www.jianshu.com/p/17a4c00d5831> <a name=\"uzkyg\"></a>\n\n![20230608110538](http://s3.airtlab.com/blog/20230608110538.png)\n\n### [runtime](https://babeljs.io/docs/en/babel-plugin-transform-runtime)\n\nruntime 库，用于重用 @babel/runtime 代码.\n\n### [strict-mode](https://babeljs.io/docs/en/babel-plugin-transform-strict-mode)\n\n编译为严格模式\n\n```javascript\n// in\nfoo();\n\n// out\n\"use strict\";\n\nfoo();\n```\n\n## Modules 模块处理\n\n- [modules-amd](https://babeljs.io/docs/en/babel-plugin-transform-modules-amd)\n- [modules-commonjs](https://babeljs.io/docs/en/babel-plugin-transform-modules-commonjs)\n- [modules-systemjs](https://babeljs.io/docs/en/babel-plugin-transform-modules-systemjs)\n- [modules-umd](https://babeljs.io/docs/en/babel-plugin-transform-modules-umd)\n\n### Experimental\n\n- [class-properties](https://babeljs.io/docs/en/babel-plugin-proposal-class-properties)\n\n扩展类的属性定义\n\n```javascript\nclass Bork {\n    //Property initializer syntax\n    instanceProperty = \"bork\";\n\n    boundFunction = () => {\n      return this.instanceProperty;\n    };\n\n    //Static class properties\n    static staticProperty = \"babelIsCool\";\n    static staticFunction = function() {\n      return Bork.staticProperty;\n    };\n}\n```\n\n- [decorators](https://babeljs.io/docs/en/babel-plugin-proposal-decorators)\n\n装饰器的支持\n\n```javascript\n@annotation\nclass MyClass { }\n\nfunction annotation(target) {\n   target.annotated = true;\n}\n```\n\n- [do-expressions](https://babeljs.io/docs/en/babel-plugin-proposal-do-expressions)\n\ndo 表达式\n\n```javascript\nlet a = do {\n  if(x > 10) {\n    'big';\n  } else {\n    'small';\n  }\n};\n// is equivalent to:\nlet a = x > 10 ? 'big' : 'small';\n```\n\n- [export-default-from](https://babeljs.io/docs/en/babel-plugin-proposal-export-default-from)\n\n快捷到出\n\n```javascript\nexport v from 'mod';\n```\n\n- [export-namespace-from](https://babeljs.io/docs/en/babel-plugin-proposal-export-namespace-from)\n\n快捷导出重命名\n\n```javascript\nexport * as ns from 'mod';\n```\n\n- [function-bind](https://babeljs.io/docs/en/babel-plugin-proposal-function-bind)\n\n快捷的函数 context 绑定\n\n```javascript\nobj::func\n// is equivalent to:\nfunc.bind(obj)\n```\n\n- [function-sent](https://babeljs.io/docs/en/babel-plugin-proposal-function-sent)\n- [logical-assignment-operators](https://babeljs.io/docs/en/babel-plugin-proposal-logical-assignment-operators)\n- [nullish-coalescing-operator](https://babeljs.io/docs/en/babel-plugin-proposal-nullish-coalescing-operator)\n- [numeric-separator](https://babeljs.io/docs/en/babel-plugin-proposal-numeric-separator)\n- [optional-chaining](https://babeljs.io/docs/en/babel-plugin-proposal-optional-chaining)\n- [partial-application](https://babeljs.io/docs/en/babel-plugin-proposal-partial-application)\n- [pipeline-operator](https://babeljs.io/docs/en/babel-plugin-proposal-pipeline-operator)\n- [private-methods](https://babeljs.io/docs/en/babel-plugin-proposal-private-methods)\n- [throw-expressions](https://babeljs.io/docs/en/babel-plugin-proposal-throw-expressions)\n- [private-property-in-object](https://babeljs.io/docs/en/babel-plugin-proposal-private-property-in-object)\n\n\n## React 相关语法\n\n- [react-constant-elements](https://babeljs.io/docs/en/babel-plugin-transform-react-constant-elements)\n- [react-display-name](https://babeljs.io/docs/en/babel-plugin-transform-react-display-name)\n- [react-inline-elements](https://babeljs.io/docs/en/babel-plugin-transform-react-inline-elements)\n- [react-jsx](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx)\n- [react-jsx-compat](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx-compat)\n- [react-jsx-self](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx-self)\n- [react-jsx-source](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx-source)\n","isLeaf":true},{"key":"/Babel/01-Babel 基础/06 babel presets.md","path":"/Babel/01-Babel 基础/06 babel presets.md","route":"/Babel/01-Babel 基础/06 babel presets.md","leaf":true,"title":"06 babel presets","depth":2,"content":"---\ntitle: 06 babel presets\ntags: Babel\n---\n\npresets 是一些 plugins 的集合。\n\n\n## 1、官方 Presets\n\n- [@babel/preset-env](https://babeljs.io/docs/en/babel-preset-env)\n- [@babel/preset-flow](https://babeljs.io/docs/en/babel-preset-flow)\n- [@babel/preset-react](https://babeljs.io/docs/en/babel-preset-react)\n- [@babel/preset-typescript](https://babeljs.io/docs/en/babel-preset-typescript)\n\n## 2、实验阶段 Presets\n\n- [Stage 0](https://babeljs.io/docs/en/babel-preset-stage-0) - Strawman: just an idea, possible Babel plugin.\n- [Stage 1](https://babeljs.io/docs/en/babel-preset-stage-1) - Proposal: this is worth working on.\n- [Stage 2](https://babeljs.io/docs/en/babel-preset-stage-2) - Draft: initial spec.\n- [Stage 3](https://babeljs.io/docs/en/babel-preset-stage-3) - Candidate: complete spec and initial browser implementations.\n- Stage 4 - Finished: will be added to the next yearly release.\n\n## 3、自定义 presets\n\n```javascript\nmodule.exports = function() {\n  return {\n    plugins: [\n      \"pluginA\",\n      \"pluginB\",\n      \"pluginC\",\n    ]\n  };\n}\n```\n\npresets 中也可以包含其他 presets：\n\n```javascript\nmodule.exports = () => ({\n  presets: [\n    require(\"@babel/preset-env\"),\n  ],\n  plugins: [\n    [require(\"@babel/plugin-proposal-class-properties\"), { loose: true }],\n    require(\"@babel/plugin-proposal-object-rest-spread\"),\n  ],\n});\n```\n\n使用 presets:\n\n```javascript\n// 非 node_modules\n{\n  \"presets\": [\"./myProject/myPreset\"]\n}\n\n// node_modules 下\n{\n  \"presets\": [\"babel-preset-myPreset\"]\n}\n```","isLeaf":true},{"key":"/Babel/01-Babel 基础/07 preset react.md","path":"/Babel/01-Babel 基础/07 preset react.md","route":"/Babel/01-Babel 基础/07 preset react.md","leaf":true,"title":"07 preset react","depth":2,"content":"---\ntitle: 07 preset react\ntags: Babel\n---\n\nThis preset always includes the following plugins:\n\n- @babel/plugin-syntax-jsx\n- @babel/plugin-transform-react-jsx\n- @babel/plugin-transform-react-display-name\n\nAnd with the development option:\n\nClassic runtime adds:\n\n- @babel/plugin-transform-react-jsx-self\n- @babel/plugin-transform-react-jsx-source\n\n```json\n{\n  \"presets\": [\n    [\n      \"@babel/preset-react\",\n      {\n        \"pragma\": \"dom\", // default pragma is React.createElement (only in classic runtime)\n        \"pragmaFrag\": \"DomFrag\", // default is React.Fragment (only in classic runtime)\n        \"throwIfNamespace\": false, // defaults to true\n        \"runtime\": \"classic\" // defaults to classic\n        // \"importSource\": \"custom-jsx-library\" // defaults to react (only in automatic runtime)\n      }\n    ]\n  ]\n}\n```\n\n## @babel/plugin-syntax-jsx\n\n@babel/plugin-syntax-jsx 是一个用于 Babel 的插件，它的作用是让 Babel 能够识别和转换 JSX 语法的代码。JSX 是一种 JavaScript 的语法扩展，它允许在 JavaScript 中编写类似于 HTML 的标记语言，用于构建用户界面。\n在没有该插件的情况下，Babel 将无法理解 JSX 代码中的标签，会抛出错误。使用 @babel/plugin-syntax-jsx 插件后，Babel 将能够正确地解析并转换 JSX 语法到普通的 JavaScript 代码。\n\n需要注意的是，该插件只是解析 JSX 语法，它并不会将 JSX 转化为真正的 DOM 操作。要将 JSX 转换为可用的 JavaScript 代码，需要使用其他的插件或工具，例如 @babel/preset-react 插件、React 或 Preact 库等。\n\n## @babel/plugin-transform-react-jsx\n\n@babel/plugin-transform-react-jsx 是一个用于 Babel 的插件，它的作用是将 JSX 语法转换为普通的 JavaScript 代码，以便 JavaScript 引擎能够识别和执行这些代码。\nJSX 是一种 JavaScript 的语法扩展，它允许在 JavaScript 中编写类似于 HTML 的标记语言，用于构建用户界面。但是，由于 JavaScript 引擎不能直接执行 JSX 代码，因此需要将其转换为普通的 JavaScript 代码，以便能够在浏览器或 Node.js 等环境中执行。\n\n\n## React 17 介绍全新的 JSX 转换 (React.createElement => jsx)\n\n![20230518151443](http://s3.airtlab.com/blog/20230518151443.png)\n\n![20230518151453](http://s3.airtlab.com/blog/20230518151453.png)\n\n![20230518151506](http://s3.airtlab.com/blog/20230518151506.png)\n\n![20230518151537](http://s3.airtlab.com/blog/20230518151537.png)\n\n![20230518151556](http://s3.airtlab.com/blog/20230518151556.png)","isLeaf":true}]},{"key":"/Babel/02-Babel API","path":"/Babel/02-Babel API","route":"/Babel/02-Babel API","leaf":false,"title":"02-Babel API","depth":1,"content":"","isLeaf":false,"children":[{"key":"/Babel/02-Babel API/01 @babel core.md","path":"/Babel/02-Babel API/01 @babel core.md","route":"/Babel/02-Babel API/01 @babel core.md","leaf":true,"title":"01 @babel core","depth":2,"content":"---\ntitle: 01 @babel core\ntags: Babel\n---\n\n@babel/core 暴露了 `源代码 => AST => 目标代码` 整个过程所需要的方法。\n\n## 1. transform\n\ntransform 方法将源代码处理后返回目标代码，sourcemap 代码，以及ast：\n\n```javascript\n/**\n * @param string code 源代码\n * @param object options 配置项\n * @param function callback 回调函数\n */\nbabel.transform(code: string, options?: Object, callback: Function)\n```\n\n```javascript\nconst babel = require(\"@babel/core\");\nconst code = `const name = 1`\nconst options = {}\n\nbabel.transform(code, options, function(err, result) {\n  result; // => { code, map, ast }\n  console.log(result)\n});\n```\n\n如果需要 ast 和 sourcemap:\n\n```javascript\nconst babel = require(\"@babel/core\");\nconst sourceCode = `var count = 1`\n\nbabel.transform(sourceCode, { ast: true, inputSourceMap: true }, function(err, result) {\n  result; // => { code, map, ast }\n  console.log(result)\n});\n```\n\n这里的 options 用于配置 plugins，helpers 等等，后面会详细介绍。另外 bable 还提供了 transform 的同步方法 transformSync，以及异步Promise API transformAsync:\n\n```javascript\n// 同步API\nvar result = babel.transformSync(\"code();\", options);\nresult.code;\nresult.map;\nresult.ast;\n\n// 异步API\nbabel.transformAsync(\"code();\", options).then(result => {\n  result.code;\n  result.map;\n  result.ast;\n});\n```\n\n## 2. transformFile\n\ntransformFile 用于转换整个JS文件：\n\n```javascript\nbabel.transformFile(filename: string, options?: Object, callback: Function)\n```\n\n其函数签名和 transform 差不多，只是第一个参数从源代码 code 变为了文件路径 filename：\n\n```javascript\nbabel.transformFile(\"filename.js\", options, function (err, result) {\n  result; // => { code, map, ast }\n});\n```\n\n类似的，transformFile 也额外提供了同步和异步API，transformFileSync 和 transformFileAsync。\n\n## 3. parse\n\n该方法会扫码源代码，返回一个 AST，并且 @babel/core 同样额外提供了 parse 方法的异步和同步API: parseAsync 和 parseSync。\n\n```javascript\nbabel.parse(code: string, options?: Object, callback: Function)\n```\n\n```javascript\nconst babel = require(\"@babel/core\");\nconst sourceCode = `var count = 1`\n\nbabel.parse(sourceCode, function(err, result) {\n  console.log(JSON.stringify(result))\n});\n```\n\n结果如下：\n\n```javascript\n{\n\t\"type\": \"File\",\n\t\"start\": 0,\n\t\"end\": 13,\n\t\"loc\": {\n\t\t\"start\": {\n\t\t\t\"line\": 1,\n\t\t\t\"column\": 0\n\t\t},\n\t\t\"end\": {\n\t\t\t\"line\": 1,\n\t\t\t\"column\": 13\n\t\t}\n\t},\n\t\"errors\": [],\n\t\"program\": {\n\t\t\"type\": \"Program\",\n\t\t\"start\": 0,\n\t\t\"end\": 13,\n\t\t\"loc\": {\n\t\t\t\"start\": {\n\t\t\t\t\"line\": 1,\n\t\t\t\t\"column\": 0\n\t\t\t},\n\t\t\t\"end\": {\n\t\t\t\t\"line\": 1,\n\t\t\t\t\"column\": 13\n\t\t\t}\n\t\t},\n\t\t\"sourceType\": \"module\",\n\t\t\"interpreter\": null,\n\t\t\"body\": [{\n\t\t\t\"type\": \"VariableDeclaration\",\n\t\t\t\"start\": 0,\n\t\t\t\"end\": 13,\n\t\t\t\"loc\": {\n\t\t\t\t\"start\": {\n\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\"column\": 0\n\t\t\t\t},\n\t\t\t\t\"end\": {\n\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\"column\": 13\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"declarations\": [{\n\t\t\t\t\"type\": \"VariableDeclarator\",\n\t\t\t\t\"start\": 4,\n\t\t\t\t\"end\": 13,\n\t\t\t\t\"loc\": {\n\t\t\t\t\t\"start\": {\n\t\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\t\"column\": 4\n\t\t\t\t\t},\n\t\t\t\t\t\"end\": {\n\t\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\t\"column\": 13\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"id\": {\n\t\t\t\t\t\"type\": \"Identifier\",\n\t\t\t\t\t\"start\": 4,\n\t\t\t\t\t\"end\": 9,\n\t\t\t\t\t\"loc\": {\n\t\t\t\t\t\t\"start\": {\n\t\t\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\t\t\"column\": 4\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"end\": {\n\t\t\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\t\t\"column\": 9\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"identifierName\": \"count\"\n\t\t\t\t\t},\n\t\t\t\t\t\"name\": \"count\"\n\t\t\t\t},\n\t\t\t\t\"init\": {\n\t\t\t\t\t\"type\": \"NumericLiteral\",\n\t\t\t\t\t\"start\": 12,\n\t\t\t\t\t\"end\": 13,\n\t\t\t\t\t\"loc\": {\n\t\t\t\t\t\t\"start\": {\n\t\t\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\t\t\"column\": 12\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"end\": {\n\t\t\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\t\t\"column\": 13\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\"extra\": {\n\t\t\t\t\t\t\"rawValue\": 1,\n\t\t\t\t\t\t\"raw\": \"1\"\n\t\t\t\t\t},\n\t\t\t\t\t\"value\": 1\n\t\t\t\t}\n\t\t\t}],\n\t\t\t\"kind\": \"var\"\n\t\t}],\n\t\t\"directives\": []\n\t},\n\t\"comments\": []\n}\n```\n\n## 4. transformFromAst\n\n给定一个 [AST](https://astexplorer.net/) ，将它进行转换为和parser方法输入一致的结果，也算是将 parse 方法的输入进行反序列化：\n\n```javascript\nbabel.transformFromAst(ast: Object, code?: string, options?: Object, callback: Function): FileNode | null\n```\n\n```javascript\nvar babel = require(\"@babel/core\");\n\nconst sourceCode = `var count = 1`\n\nbabel.parse(sourceCode, function(err, result) {\n  if (err) {\n    console.log(err);\n    return;\n  }\n\n  // babel.transformFromAst(result, function(err, res) {\n  //   console.log(res) // res === JSON.string(result)\n  // })\n\n  babel.transformFromAst(result, undefined, { ast: true }, function(err, res) {\n    console.log(res)\n  })\n});\n```\n\n## 5. Advanced APIs\n\n许多使用了Babel的系统都喜欢自动注入 plugins 和 presets，或覆盖选项。为了实现此目标，Babel 公开了一些功能，这些功能有助于在不进行转换的情况下部分加载配置。\n\n\n### 5.1 loadOptions\n\n用于解析 Babel 的选项，产生一个 option 对象\n\n```javascript\nbabel.loadOptions(options?: Object)\n```\n\n代码：\n\n```javascript\nvar babel = require(\"@babel/core\");\n\nconst res = babel.loadOptions({\n  \"plugins\": [\"@babel/plugin-transform-arrow-functions\"]\n})\n\nconsole.log(res)\n```\n\n输出：\n\n![20230608023018](http://s3.airtlab.com/blog/20230608023018.png)\n\n### 5.2 loadPartialConfig\n\n```javascript\nbabel.loadPartialConfig(options?: Object): PartialConfig\n```\n\n### 5.3 createConfigItem\n\n```javascript\nbabel.createConfigItem(value: string | {} | Function | [string | {} | Function, {} | void], { dirname?: string, type?: \"preset\" | \"plugin\" }): ConfigItem\n```\n\n## 6. Options 配置\n\n参考文档 <https://babeljs.io/docs/en/options>","isLeaf":true},{"key":"/Babel/02-Babel API/02 @babel generator.md","path":"/Babel/02-Babel API/02 @babel generator.md","route":"/Babel/02-Babel API/02 @babel generator.md","leaf":true,"title":"02 @babel generator","depth":2,"content":"---\ntitle: 02 @babel generator\ntags: Babel\n---\n\n```javascript\nimport {parse} from '@babel/parser';\nimport generate from '@babel/generator';\n\nconst code = 'class Example {}';\nconst ast = parse(code);\n\nconst output = generate(ast, { /* options */ }, code);\n```\n\n## 1、格式化输出的选项\n\n| 选项名 | 类型 | 默认值 | 描述 |\n| :--- | :--- | :--- | :--- |\n| auxiliaryCommentBefore | string |  | 可选字符串，在输出文件的开始添加块注释 |\n| auxiliaryCommentAfter | string |  | 可选字符串，在输出文件的末尾添加块注释 |\n| shouldPrintComment | function | opts.comments | 如果注释需要包含在输出中，该函数则需接受注释（作为字符串）并返回 true 。 默认情况下，如果 opts.commoents 为 true 或者 opts.minifed 为 false 并且注释中包含 @preserve 或 @license，则包含注释。 |\n| retainLines | boolean | false | 尝试在输出的代码中使用与源代码相同的行号(有助于保留栈信息跟踪) |\n| retainFunctionParens | boolean | false | 保留函数表达式的上下级 (可用于更改引擎解析行为) |\n| comments | boolean | true | 输出中是否包含注释 |\n| compact | boolean or 'auto' | opts.minified | 设置为 true 以避免添加用于格式化的空格 |\n| minified | boolean | false | 输出是否被压缩 |\n| concise | boolean | false | 设置为 true 以减少空格 (但效果不如 opts.compact ) |\n| quotes | 'single' or 'double' | 基于 ast.tokens 的自动检测 | 输出中对引号的类型进行保留 |\n| filename | string |  | 在警告信息中使用 |\n| flowCommaSeparator | boolean | false | 设置为 true 以使用逗号而不是分号作为 Flow 属性的分隔符 |\n| jsonCompatibleStrings | boolean | false | 设置为 true，使用 \"json\" 运行 jsesc：正确的将 \"\\u00A9\" 打印为 \"©\" ; |\n\nsource maps 的选项:\n\n| 选项名 | 类型 | 默认值 | 描述 |\n| :--- | :--- | :--- | :--- |\n| sourceMaps | boolean | false | 启用生成 source maps |\n| sourceMapTarget | string |  | source map 会与生成代码的文件名进行关联 |\n| sourceRoot | string |  | source map 中所有对应 URLs 的 root |\n| sourceFileName | string |  | 源代码（例如，  code 参数中的代码）的文件名。只会在 code 为字符串时使用。 |\n\n\n## 2、多个来源构建 AST\n\n在大多数情况下，Babel 会将输入文件与输出文件进行 1:1 转换。然而，你可能正在处理从多个来源构建的 AST - JS 文件，模板等。如果出现这种情况，并且你还希望 source map 为你提供正确的来源，则需要将一个对象作为 `code` 参数传递给 `generate`。其中键应该为源文件名称，值应该为源内容。\n\n```javascript\nconst { parse } = require('@babel/parser');\nconst generate = require('@babel/generator').default;\n\nconst a = 'var a = 1;';\nconst b = 'var b = 2;';\n\nconst astA = parse(a, { sourceFilename: 'a.js' });\nconst astB = parse(b, { sourceFilename: 'b.js' });\n\nconst ast = {\n  type: 'Program',\n  body: [].concat(astA.program.body, astB.program.body)\n};\n\nconst { code, map } = generate(ast, { sourceMaps: true }, {\n  'a.js': a,\n  'b.js': b\n});\n\nconsole.log(code)\nconsole.log(map)\n```\n","isLeaf":true},{"key":"/Babel/02-Babel API/03 @babel helpers.md","path":"/Babel/02-Babel API/03 @babel helpers.md","route":"/Babel/02-Babel API/03 @babel helpers.md","leaf":true,"title":"03 @babel helpers","depth":2,"content":"---\ntitle: 03 @babel helpers\ntags: Babel\n---\n\n该模块用于提供了编译时的一些帮助函数。\n\n```javascript\nimport * as helpers from '@babel/helpers';\nimport * as t from '@babel/types';\n\nconst typeofHelper = helpers.get('typeof');\n\nt.isExpressionStatement(typeofHelper);\n// true\n```","isLeaf":true},{"key":"/Babel/02-Babel API/04 @babel parser.md","path":"/Babel/02-Babel API/04 @babel parser.md","route":"/Babel/02-Babel API/04 @babel parser.md","leaf":true,"title":"04 @babel parser","depth":2,"content":"---\ntitle: 04 @babel parser\ntags: Babel\n---\n\n## 1、@babel/parser 是什么\n\n@babel/parser 主要的任务是将源代码生成AST抽象语法树。按照官网的介绍，@babel/parser 应该在 [acorn](https://github.com/marijnh/acorn) 和 [acorn-jsx](https://github.com/RReverser/acorn-jsx) 的基础上开发的，虽然 @babel/parser 的源码没有依赖 acorn 模块，其中 acorn 主要包含以下3个模块：\n\n> - [acorn](https://github.com/acornjs/acorn/blob/master/acorn/): The main parser 主要的解释器\n> - [acorn-loose](https://github.com/acornjs/acorn/blob/master/acorn-loose/): The error-tolerant parser 错误处理\n> - [acorn-walk](https://github.com/acornjs/acorn/blob/master/acorn-walk/): The syntax tree walker 语法树的遍历\n\n## 2、@babel/parser 源码定义\n\n在 @babel/parser 的 d.ts 文件可以看到，它只提供了两个方法：\n![20230608023126](http://s3.airtlab.com/blog/20230608023126.png)\n\n```typescript\n/**\n * Parse the provided code as an entire ECMAScript program.\n * 解析完整的 ECMAScript 程序\n */\nexport function parse(input: string, options?: ParserOptions): import('@babel/types').File;\n\n/**\n * Parse the provided code as a single expression.\n * 仅仅解析 ECMAScript 表达式\n */\nexport function parseExpression(input: string, options?: ParserOptions): import('@babel/types').Expression;\n```\n\n除此之外还提供了一些 type：\n\n- ParserOptions\n- ParserPlugin\n- ParserPluginWithOptions\n- DecoratorsPluginOptions\n- PipelineOperatorPluginOptions\n- FlowPluginOptions <a name=\"zJB8k\"></a>\n\n## 3、API\n\n### 3.1、parse(code, \\[options])\n\n解析完整的 ECMAScript 程序\n\n```typescript\nconst parser = require('@babel/parser');\n// console.log(parser.parse('const name = 123'))\nconsole.log(JSON.stringify(parser.parse('const name = 123')))\n```\n\n解析后的语法树为：\n\n```javascript\n{\n\t\"type\": \"File\",\n\t\"start\": 0,\n\t\"end\": 16,\n\t\"loc\": {\n\t\t\"start\": {\n\t\t\t\"line\": 1,\n\t\t\t\"column\": 0\n\t\t},\n\t\t\"end\": {\n\t\t\t\"line\": 1,\n\t\t\t\"column\": 16\n\t\t}\n\t},\n\t\"errors\": [],\n\t\"program\": {\n\t\t\"type\": \"Program\",\n\t\t\"start\": 0,\n\t\t\"end\": 16,\n\t\t\"loc\": {\n\t\t\t\"start\": {\n\t\t\t\t\"line\": 1,\n\t\t\t\t\"column\": 0\n\t\t\t},\n\t\t\t\"end\": {\n\t\t\t\t\"line\": 1,\n\t\t\t\t\"column\": 16\n\t\t\t}\n\t\t},\n\t\t\"sourceType\": \"script\",\n\t\t\"interpreter\": null,\n\t\t\"body\": [{\n\t\t\t\"type\": \"VariableDeclaration\",\n\t\t\t\"start\": 0,\n\t\t\t\"end\": 16,\n\t\t\t\"loc\": {\n\t\t\t\t\"start\": {\n\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\"column\": 0\n\t\t\t\t},\n\t\t\t\t\"end\": {\n\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\"column\": 16\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"declarations\": [{\n\t\t\t\t\"type\": \"VariableDeclarator\",\n\t\t\t\t\"start\": 6,\n\t\t\t\t\"end\": 16,\n\t\t\t\t\"loc\": {\n\t\t\t\t\t\"start\": {\n\t\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\t\"column\": 6\n\t\t\t\t\t},\n\t\t\t\t\t\"end\": {\n\t\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\t\"column\": 16\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"id\": {\n\t\t\t\t\t\"type\": \"Identifier\",\n\t\t\t\t\t\"start\": 6,\n\t\t\t\t\t\"end\": 10,\n\t\t\t\t\t\"loc\": {\n\t\t\t\t\t\t\"start\": {\n\t\t\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\t\t\"column\": 6\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"end\": {\n\t\t\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\t\t\"column\": 10\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"identifierName\": \"name\"\n\t\t\t\t\t},\n\t\t\t\t\t\"name\": \"name\"\n\t\t\t\t},\n\t\t\t\t\"init\": {\n\t\t\t\t\t\"type\": \"NumericLiteral\",\n\t\t\t\t\t\"start\": 13,\n\t\t\t\t\t\"end\": 16,\n\t\t\t\t\t\"loc\": {\n\t\t\t\t\t\t\"start\": {\n\t\t\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\t\t\"column\": 13\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"end\": {\n\t\t\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\t\t\"column\": 16\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\"extra\": {\n\t\t\t\t\t\t\"rawValue\": 123,\n\t\t\t\t\t\t\"raw\": \"123\"\n\t\t\t\t\t},\n\t\t\t\t\t\"value\": 123\n\t\t\t\t}\n\t\t\t}],\n\t\t\t\"kind\": \"const\"\n\t\t}],\n\t\t\"directives\": []\n\t},\n\t\"comments\": []\n}\n```\n\n### 3.2、parseExpression(code, \\[options])\n\n仅仅解析 ECMAScript 表达式\n\n### 3.3、options\n\n- allowImportExportEverywhere：默认情况下，import 并 export 声明只能出现在一个程序的 top level scope。将此选项设置为true允许在任何位置使用。\n- allowAwaitOutsideFunction：默认情况下，await 仅允许在异步函数内部使用，或者当 topLevelAwait 插件被启用后，在模块的 top level scope 内使用。将其设置为 true，则在脚本的 top-level scope 内可使用。\n- allowReturnOutsideFunction：默认情况下，顶层的 return 语句会引发错误。设置 true 为接受这样的代码。\n\n下面的代码将会引发错误：\n\n```typescript\nconst parser = require('@babel/parser');\n// console.log(JSON.stringify(parser.parse('const name = 123')))\n\nconsole.log(JSON.stringify(parser.parse('return 6', {\n  allowReturnOutsideFunction: false\n})))\n```\n\n![20230608023157](http://s3.airtlab.com/blog/20230608023157.png)\n\n设置 allowReturnOutsideFunction 为 true，将不会报错。\n\n- **allowSuperOutsideMethod**\n\n默认情况下，super 不允许在类和对象方法之外使用，设置 true 为接受这样的代码\n\n- **allowUndeclaredExports**\n\n默认情况下，导出在当前模块作用域中未声明的标识符将引发错误。尽管 ECMAScript 模块规范要求此行为，但Babel 的解析器无法在以后可能会插入适当声明的插件管道中预期转换，因此有时设置此选项`true`以防止解析器过早地抛出异常未声明的导出会很重要。\n\n## 4、Output\n\nBabel解析器根据 [Babel AST格式](https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md) 生成AST 。它基于 [ESTree规范](https://github.com/estree/estree)，但存在以下差异：\n\n![20230608023257](http://s3.airtlab.com/blog/20230608023257.png)\n\n## 5、Plugins\n### 5.1、语言插件\n\n| Name | Code Example |\n| --- | --- |\n| `flow`\n&#x20;([repo](https://github.com/facebook/flow)) | `var a: string = \"\";` |\n| `flowComments`\n&#x20;([docs](https://flow.org/en/docs/types/comments/)) | `/*:: type Foo = {...}; */` |\n| `jsx`\n&#x20;([repo](https://facebook.github.io/jsx/)) | `<a attr=\"b\">{s}</a>` |\n| `typescript`\n&#x20;([repo](https://github.com/Microsoft/TypeScript)) | `var a: string = \"\";` |\n| `v8intrinsic` | `%DebugPrint(foo);` |\n\n\n### 5.2、ECMAScript [proposals](https://github.com/babel/proposals)\n\n| Name | Code Example |\n| --- | --- |\n| `asyncGenerators`\n&#x20;([proposal](https://github.com/tc39/proposal-async-iteration)) | `async function*() {}`\n, `for await (let a of b) {}` |\n| `bigInt`\n&#x20;([proposal](https://github.com/tc39/proposal-bigint)) | `100n` |\n| `classProperties`\n&#x20;([proposal](https://github.com/tc39/proposal-class-public-fields)) | `class A { b = 1; }` |\n| `classPrivateProperties`\n&#x20;([proposal](https://github.com/tc39/proposal-private-fields)) | `class A { #b = 1; }` |\n| `classPrivateMethods`\n&#x20;([proposal](https://github.com/tc39/proposal-private-methods)) | `class A { #c() {} }` |\n| `decorators`\n&#x20;([proposal](https://github.com/tc39/proposal-decorators))\n`decorators-legacy` | `@a class A {}` |\n| `doExpressions`\n&#x20;([proposal](https://github.com/tc39/proposal-do-expressions)) | `var a = do { if (true) { 'hi'; } };` |\n| `dynamicImport`\n&#x20;([proposal](https://github.com/tc39/proposal-dynamic-import)) | `import('./guy').then(a)` |\n| `exportDefaultFrom`\n&#x20;([proposal](https://github.com/leebyron/ecmascript-export-default-from)) | `export v from \"mod\"` |\n| `exportNamespaceFrom`\n&#x20;([proposal](https://github.com/leebyron/ecmascript-export-ns-from)) | `export * as ns from \"mod\"` |\n| `functionBind`\n&#x20;([proposal](https://github.com/zenparsing/es-function-bind)) | `a::b`\n, `::console.log` |\n| `functionSent` | `function.sent` |\n| `importMeta`\n&#x20;([proposal](https://github.com/tc39/proposal-import-meta)) | `import.meta.url` |\n| `logicalAssignment`\n&#x20;([proposal](https://github.com/tc39/proposal-logical-assignment)) | `a &&= b` |\n| `nullishCoalescingOperator`\n&#x20;([proposal](https://github.com/babel/proposals/issues/14)) | `a ?? b` |\n| `numericSeparator`\n&#x20;([proposal](https://github.com/samuelgoto/proposal-numeric-separator)) | `1_000_000` |\n| `objectRestSpread`\n&#x20;([proposal](https://github.com/tc39/proposal-object-rest-spread)) | `var a = { b, ...c };` |\n| `optionalCatchBinding`\n&#x20;([proposal](https://github.com/babel/proposals/issues/7)) | `try {throw 0;} catch{do();}` |\n| `optionalChaining`\n&#x20;([proposal](https://github.com/tc39/proposal-optional-chaining)) | `a?.b` |\n| `partialApplication`\n&#x20;([proposal](https://github.com/babel/proposals/issues/32)) | `f(?, a)` |\n| `pipelineOperator`\n&#x20;([proposal](https://github.com/babel/proposals/issues/29)) | `a &#124;> b` |\n| `throwExpressions`\n&#x20;([proposal](https://github.com/babel/proposals/issues/23)) | `() => throw new Error(\"\")` |\n| `topLevelAwait`\n&#x20;([proposal](https://github.com/tc39/proposal-top-level-await/)) | `await promise`\n&#x20;in modules |\n\n## 6、sourceType\n\nsourceType 可以是 \"module\" 或者 \"script\"，它表示 Babylon 应该用哪种模式来解析。 \"module\" 将会在严格模式下解析并且允许模块定义，\"script\" 则不会。\n\n## 7、Example\n\n```typescript\nrequire(\"@babel/parser\").parse(\"code\", {\n  // parse in strict mode and allow module declarations\n  sourceType: \"module\",\n\n  plugins: [\n    // enable jsx and flow syntax\n    \"jsx\",\n    \"flow\"\n  ]\n});\n```\n\n## 8、参考文档\n- [1] acorn github <https://github.com/acornjs/acorn>\n- [2] estree 规范 <https://github.com/estree/estree>","isLeaf":true},{"key":"/Babel/02-Babel API/05 @babel runtime.md","path":"/Babel/02-Babel API/05 @babel runtime.md","route":"/Babel/02-Babel API/05 @babel runtime.md","leaf":true,"title":"05 @babel runtime","depth":2,"content":"---\ntitle: 05 @babel runtime\ntags: Babel\n---\n\n5、@babel/runtime\n\n该库提供了一些运行时的帮助函数，避免了在每个文件中都定了一份帮助函数，而统一从 @babel/runtime 中引入。@babel/runtime 主要包含 运行时的 helpers 函数 以及 regenerator runtime。\n\nbabel-plugin-transform-runtime 和 babel-runtime 的区别：\n\n- babel-plugin-transform-runtime 内部依赖了 babel-runtime","isLeaf":true},{"key":"/Babel/02-Babel API/06 @babel traverse.md","path":"/Babel/02-Babel API/06 @babel traverse.md","route":"/Babel/02-Babel API/06 @babel traverse.md","leaf":true,"title":"06 @babel traverse","depth":2,"content":"---\ntitle: 06 @babel traverse\ntags: Babel\n---\n\n## 预备知识\n\n### Paths（路径）\n\nAST 通常会有许多节点，那么节点直接如何相互关联呢？ 我们可以使用一个可操作和访问的巨大可变对象表示节点之间的关联关系，或者也可以用Paths（路径）来简化这件事情。Path 是表示两个节点之间连接的对象。例如，如果有下面这样一个节点及其子节点︰\n\n```json\n{\n  \"parent\": {\n    \"type\": \"FunctionDeclaration\",\n    \"id\": {...},\n    ....\n  },\n  \"node\": {\n    \"type\": \"Identifier\",\n    \"name\": \"square\"\n  }\n}\n```\n\n同时它还包含关于该路径的其他元数据：\n\n```json\n{\n  \"parent\": {...},\n  \"node\": {...},\n  \"hub\": {...},\n  \"contexts\": [],\n  \"data\": {},\n  \"shouldSkip\": false,\n  \"shouldStop\": false,\n  \"removed\": false,\n  \"state\": null,\n  \"opts\": null,\n  \"skipKeys\": null,\n  \"parentPath\": null,\n  \"context\": null,\n  \"container\": null,\n  \"listKey\": null,\n  \"inList\": false,\n  \"parentKey\": null,\n  \"key\": null,\n  \"scope\": null,\n  \"type\": null,\n  \"typeAnnotation\": null\n}\n```\n\n当然路径对象还包含添加、更新、移动和删除节点有关的其他很多方法，稍后我们再来看这些方法。在某种意义上，路径是一个节点在树中的位置以及关于该节点各种信息的响应式 **Reactive** 表示。 当你调用一个修改树的方法后，路径信息也会被更新。 Babel 帮你管理这一切，从而使得节点操作简单，尽可能做到无状态。\n\n### Paths in Visitors（访问者中的路径）\n\n当你有一个 `Identifier()` 成员方法的访问者时，你实际上是在访问路径而非节点。 通过这种方式，你操作的就是节点的响应式表示（译注：即路径）而非节点本身。\n\n```json\nconst MyVisitor = {\n  Identifier(path) {\n    console.log(\"Visiting: \" + path.node.name);\n  }\n};\n```\n\n## Visiting 访问\n\n### Get the Path of Sub-Node\n\n为了得到一个AST节点的属性值，我们一般先访问到该节点，然后利用 path.node.property 方法即可： <a name=\"kxNY7\"></a>\n\n## 转换操作\n\n### 访问\n\n#### 获取子节点的Path\n\n为了得到一个AST节点的属性值，我们一般先访问到该节点，然后利用 `path.node.property` 方法即可：\n\n```javascript\n// 获取子节点的Path\n// 下面的例子遍历所有 BinaryExpression, 这里只有一个\n\nimport * as parser from \"@babel/parser\";\nimport traverse from \"@babel/traverse\";\nimport generate from '@babel/generator';\n\nconst code = `function square(n) {\n  return n * n;\n}`;\n\nconst ast = parser.parse(code);\n\ntraverse(ast, {\n  BinaryExpression(path) {\n    console.log(path.node.left) // Identifier Node\n    console.log(path.node.right) // Identifier Node\n    console.log(path.node.operator) // \"*\"\n  }\n});\n```\n\n#### 检查节点的类型\n\n```js\n// 改变函数参数的例子\n\nimport * as parser from \"@babel/parser\";\nimport traverse from \"@babel/traverse\";\nimport generate from '@babel/generator';\nimport helpers from '@babel/helpers';\nimport * as t from '@babel/types';\n\nconst code = `function square(n) {\n  return n * fn(n);\n}`;\n\nconst ast = parser.parse(code);\n\ntraverse(ast, {\n  BinaryExpression(path) {\n    // path.node.left: Identifier 标识符\n    // path.node.right: CallExpression 函数调用表达式\n    if(t.isIdentifier(path.node.left)) {\n      console.log(path.node)\n    }\n  }\n});\n```\n\n#### 检查路径（Path）类型\n\n```javascript\nBinaryExpression(path) {\n  if (path.get('left').isIdentifier({ name: \"n\" })) {\n    // ...\n  }\n}\n\n// 相当于\nBinaryExpression(path) {\n  if (t.isIdentifier(path.node.left, { name: \"n\" })) {\n    // ...\n  }\n}\n```\n\n#### 检查标识符（Identifier）是否被引用\n\n```javascript\n// 改变函数参数的例子\n\nimport * as parser from \"@babel/parser\";\nimport traverse from \"@babel/traverse\";\nimport generate from '@babel/generator';\nimport * as t from '@babel/types';\n\nconst code = `function square(n) {\n  return n * n;\n}`;\n\nconst ast = parser.parse(code);\n\ntraverse(ast, {\n  Identifier(path) {\n    if (path.isReferencedIdentifier()) {\n      // console.log(path.node)\n    }\n  }\n});\n```\n\n## 演示例子\n\n### 修改函数参数\n\n```javascript\n// 改变函数参数的例子\n\nimport * as parser from \"@babel/parser\";\nimport traverse from \"@babel/traverse\";\nimport generate from '@babel/generator';\n\nconst code = `function square(n) {\n  return n * n;\n}`;\n\nconst ast = parser.parse(code);\n\ntraverse(ast, {\n  enter(path) {\n    if (path.isIdentifier({ name: \"n\" })) {\n      path.node.name = \"x\";\n    }\n  }\n});\n\nconst output = generate(ast, { /* options */ }, code);\n\nconsole.log(output.code);\n\n// function square(x) {\n//   return x * x;\n// }\n```\n","isLeaf":true},{"key":"/Babel/02-Babel API/07 @babel types.md","path":"/Babel/02-Babel API/07 @babel types.md","route":"/Babel/02-Babel API/07 @babel types.md","leaf":true,"title":"07 @babel types","depth":2,"content":"---\ntitle: 07 @babel types\n---\n\n@babel/types 是 Babel 编译器的一个模块，它提供了一组用于处理和操作 AST（抽象语法树）节点的工具函数和对象。它的作用主要有以下几个方面：\n\n1. AST节点创建：@babel/types 提供了多个函数来创建不同类型的AST节点，例如Identifier、ExpressionStatement、FunctionDeclaration等。这些函数可以帮助你方便地构建AST树。\n\n2. AST节点判断：@babel/types 提供了一系列的判断函数，用于检查一个节点是否属于某个特定的AST类型。例如，你可以使用isIdentifier()函数判断一个节点是否是标识符。\n\n3. AST节点操作：@babel/types 还提供了一些方法来操作和修改AST节点。例如，你可以使用cloneNode()方法来复制一个AST节点，使用isExpressionStatement() 方法来判断一个节点是否是表达式语句等。\n\n4. AST节点遍历：@babel/types 提供了一系列的遍历函数，可以帮助你对AST树进行深度优先或广度优先的遍历。例如，你可以使用traverse()函数来遍历整个AST树，并在每个节点上执行自定义的操作。\n\n总的来说，@babel/types为Babel编译器提供了一组用于创建、操作和遍历AST节点的工具函数和对象。它使得开发者可以更方便地处理AST，进而实现代码转换、分析和生成等各种功能。\n\n## Identify 标识符\n\n## Expression 表达式\n\n## Statement 语句\n\n## Literal 字面量\n","isLeaf":true},{"key":"/Babel/02-Babel API/08 @babel template.md","path":"/Babel/02-Babel API/08 @babel template.md","route":"/Babel/02-Babel API/08 @babel template.md","leaf":true,"title":"08 @babel template","depth":2,"content":"---\ntitle: 08 @babel template\n---\n\n- https://babeljs.io/docs/babel-template#templatesmart\n- https://en.wikipedia.org/wiki/Quasi-quotation\n\n@babel/template 是 Babel 内置工具，用于在 JS 代码中构建和生成 AST（抽象语法树）节点。\n@babel/template 为 Babel 编译器提供了一个简洁、灵活和可定制化的方式来操作和生成 AST 节点。\n\n它的作用主要有以下几个方面：\n\n1. 自动生成AST：@babel/template 可以通过传入模板字符串和选项参数，自动解析并生成对应的AST节点。这样可以避免手动构建复杂的AST结构，提高了开发效率。\n2. 代码生成：通过调用模板函数生成的AST，可以将其转换回JavaScript代码字符串。这在编写代码生成器或转换器时非常有用。\n3. AST节点替换：@babel/template 还允许你在生成AST节点时，根据变量或条件情况动态替换其中的某些部分。这使得你可以根据需要生成不同的AST节点，从而实现更灵活的代码转换。\n\n## 1、准引用介绍\n\nquasiquotes 是一种在编程语言中引用代码片段的技术。它们允许程序员以一个类似于模式匹配的方式来处理代码，并在运行时构造和生成代码。\n\n在实现 quasiquotes 的过程中，编程语言会提供一些特殊的语法或API，使得代码可以像数据一样进行引用和操作。这些 quasiquotes 通常包含一个模板，其中包含了一些占位符，程序员可以在需要的时候填充具体的值。\n\nquasiquotes 广泛应用于元编程、宏系统和模板引擎等领域。它们可以简化代码的生成和转换过程，使得代码更加灵活和易于维护。\n\n不同的编程语言可能有不同的实现方式和语法规则，但总体上都旨在提供一种方便的方式来处理代码片段，将其作为数据进行操纵和生成。\n\n## 2、准引用演示\n\n```typescript\nimport template from \"@babel/template\";\nimport generate from \"@babel/generator\";\nimport * as t from \"@babel/types\";\n\nconst buildRequire = template(`\n  var %%importName%% = require(%%source%%);\n`);\n\nconst ast = buildRequire({\n  importName: t.identifier(\"myModule\"),\n  source: t.stringLiteral(\"my-module\"),\n});\n\nconsole.log(generate(ast as t.Statement).code)\n// var myModule = require(\"my-module\");\n```\n\n\n\n## 3、API\n\n### 3.1 .ast\n如果没有使用占位符，并且您只需要一种简单的方法将字符串解析为 AST，则可以使用模板的 .ast 版本。\n\n```js\nconst ast = template.ast(`\n  var myModule = require(\"my-module\");\n`);\n```\n\n### 3.2\n\n```js\nimport template from \"@babel/template\";\nimport generate from \"@babel/generator\";\nimport * as t from \"@babel/types\";\n\nconst source = \"my-module\";\n\nconst fn = template`\n  var IMPORT_NAME = require('${source}');\n`;\n\nconst ast = fn({\n  IMPORT_NAME: t.identifier(\"myModule\"),\n});\n\n// var myModule = require(\"my-module\");\nconsole.log(generate(ast as t.Statement).code);\n```","isLeaf":true}]},{"key":"/Babel/03-Babel 插件开发","path":"/Babel/03-Babel 插件开发","route":"/Babel/03-Babel 插件开发","leaf":false,"title":"03-Babel 插件开发","depth":1,"content":"","isLeaf":false,"children":[{"key":"/Babel/03-Babel 插件开发/01 参考文档.md","path":"/Babel/03-Babel 插件开发/01 参考文档.md","route":"/Babel/03-Babel 插件开发/01 参考文档.md","leaf":true,"title":"01 参考文档","depth":2,"content":"---\ntitle: 01 参考文档\n---\n\n- [插件开发手册](https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-get-the-path-of-a-sub-node)\n","isLeaf":true},{"key":"/Babel/03-Babel 插件开发/02 AST 遍历.md","path":"/Babel/03-Babel 插件开发/02 AST 遍历.md","route":"/Babel/03-Babel 插件开发/02 AST 遍历.md","leaf":true,"title":"02 AST 遍历","depth":2,"content":"---\ntitle: 02 AST 遍历\nurl: https://www.yuque.com/gaollard/ubc1q5/mvu0v5\n---\n\n### Visitors（访问者）\n\n![20230608092029](http://s3.airtlab.com/blog/20230608092029.png)\n\n***\n\n![20230608092045](http://s3.airtlab.com/blog/20230608092045.png)\n\n***\n![20230608092113](http://s3.airtlab.com/blog/20230608092113.png)\n\n***\n\n![20230608092145](http://s3.airtlab.com/blog/20230608092145.png)\n\n***\n\n![20230608092200](http://s3.airtlab.com/blog/20230608092200.png)\n","isLeaf":true},{"key":"/Babel/03-Babel 插件开发/03 Node 节点.md","path":"/Babel/03-Babel 插件开发/03 Node 节点.md","route":"/Babel/03-Babel 插件开发/03 Node 节点.md","leaf":true,"title":"03 Node 节点","depth":2,"content":"---\ntitle: 03 Node 节点\nurl: https://www.yuque.com/gaollard/ubc1q5/vqxtr7\n---\n\n### 1、Node 介绍\n\n![20230608092219](http://s3.airtlab.com/blog/20230608092219.png)\n\n![20230608092257](http://s3.airtlab.com/blog/20230608092257.png)\n\n### 2、Node 定义\n\n```typescript\ninterface BaseNode {\n  type: Node[\"type\"];\n  leadingComments?: Comment[] | null;\n  innerComments?: Comment[] | null;\n  trailingComments?: Comment[] | null;\n  start?: number | null;\n  end?: number | null;\n  loc?: SourceLocation | null;\n  range?: [number, number];\n  extra?: Record<string, unknown>;\n}\n```\n\n```typescript\ndeclare type Node = AnyTypeAnnotation | ArgumentPlaceholder | ArrayExpression | ArrayPattern | ArrayTypeAnnotation | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BigIntLiteral | BinaryExpression | BindExpression | BlockStatement | BooleanLiteral | BooleanLiteralTypeAnnotation | BooleanTypeAnnotation | BreakStatement | CallExpression | CatchClause | ClassAccessorProperty | ClassBody | ClassDeclaration | ClassExpression | ClassImplements | ClassMethod | ClassPrivateMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | ContinueStatement | DebuggerStatement | DecimalLiteral | DeclareClass | DeclareExportAllDeclaration | DeclareExportDeclaration | DeclareFunction | DeclareInterface | DeclareModule | DeclareModuleExports | DeclareOpaqueType | DeclareTypeAlias | DeclareVariable | DeclaredPredicate | Decorator | Directive | DirectiveLiteral | DoExpression | DoWhileStatement | EmptyStatement | EmptyTypeAnnotation | EnumBooleanBody | EnumBooleanMember | EnumDeclaration | EnumDefaultedMember | EnumNumberBody | EnumNumberMember | EnumStringBody | EnumStringMember | EnumSymbolBody | ExistsTypeAnnotation | ExportAllDeclaration | ExportDefaultDeclaration | ExportDefaultSpecifier | ExportNamedDeclaration | ExportNamespaceSpecifier | ExportSpecifier | ExpressionStatement | File | ForInStatement | ForOfStatement | ForStatement | FunctionDeclaration | FunctionExpression | FunctionTypeAnnotation | FunctionTypeParam | GenericTypeAnnotation | Identifier | IfStatement | Import | ImportAttribute | ImportDeclaration | ImportDefaultSpecifier | ImportNamespaceSpecifier | ImportSpecifier | IndexedAccessType | InferredPredicate | InterfaceDeclaration | InterfaceExtends | InterfaceTypeAnnotation | InterpreterDirective | IntersectionTypeAnnotation | JSXAttribute | JSXClosingElement | JSXClosingFragment | JSXElement | JSXEmptyExpression | JSXExpressionContainer | JSXFragment | JSXIdentifier | JSXMemberExpression | JSXNamespacedName | JSXOpeningElement | JSXOpeningFragment | JSXSpreadAttribute | JSXSpreadChild | JSXText | LabeledStatement | LogicalExpression | MemberExpression | MetaProperty | MixedTypeAnnotation | ModuleExpression | NewExpression | Noop | NullLiteral | NullLiteralTypeAnnotation | NullableTypeAnnotation | NumberLiteral$1 | NumberLiteralTypeAnnotation | NumberTypeAnnotation | NumericLiteral | ObjectExpression | ObjectMethod | ObjectPattern | ObjectProperty | ObjectTypeAnnotation | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeInternalSlot | ObjectTypeProperty | ObjectTypeSpreadProperty | OpaqueType | OptionalCallExpression | OptionalIndexedAccessType | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelinePrimaryTopicReference | PipelineTopicExpression | Placeholder | PrivateName | Program | QualifiedTypeIdentifier | RecordExpression | RegExpLiteral | RegexLiteral$1 | RestElement | RestProperty$1 | ReturnStatement | SequenceExpression | SpreadElement | SpreadProperty$1 | StaticBlock | StringLiteral | StringLiteralTypeAnnotation | StringTypeAnnotation | Super | SwitchCase | SwitchStatement | SymbolTypeAnnotation | TSAnyKeyword | TSArrayType | TSAsExpression | TSBigIntKeyword | TSBooleanKeyword | TSCallSignatureDeclaration | TSConditionalType | TSConstructSignatureDeclaration | TSConstructorType | TSDeclareFunction | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSExpressionWithTypeArguments | TSExternalModuleReference | TSFunctionType | TSImportEqualsDeclaration | TSImportType | TSIndexSignature | TSIndexedAccessType | TSInferType | TSInstantiationExpression | TSInterfaceBody | TSInterfaceDeclaration | TSIntersectionType | TSIntrinsicKeyword | TSLiteralType | TSMappedType | TSMethodSignature | TSModuleBlock | TSModuleDeclaration | TSNamedTupleMember | TSNamespaceExportDeclaration | TSNeverKeyword | TSNonNullExpression | TSNullKeyword | TSNumberKeyword | TSObjectKeyword | TSOptionalType | TSParameterProperty | TSParenthesizedType | TSPropertySignature | TSQualifiedName | TSRestType | TSStringKeyword | TSSymbolKeyword | TSThisType | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeLiteral | TSTypeOperator | TSTypeParameter | TSTypeParameterDeclaration | TSTypeParameterInstantiation | TSTypePredicate | TSTypeQuery | TSTypeReference | TSUndefinedKeyword | TSUnionType | TSUnknownKeyword | TSVoidKeyword | TaggedTemplateExpression | TemplateElement | TemplateLiteral | ThisExpression | ThisTypeAnnotation | ThrowStatement | TopicReference | TryStatement | TupleExpression | TupleTypeAnnotation | TypeAlias | TypeAnnotation | TypeCastExpression | TypeParameter | TypeParameterDeclaration | TypeParameterInstantiation | TypeofTypeAnnotation | UnaryExpression | UnionTypeAnnotation | UpdateExpression | V8IntrinsicIdentifier | VariableDeclaration | VariableDeclarator | Variance | VoidTypeAnnotation | WhileStatement | WithStatement | YieldExpression;\n```\n","isLeaf":true},{"key":"/Babel/03-Babel 插件开发/04 Path 路径.md","path":"/Babel/03-Babel 插件开发/04 Path 路径.md","route":"/Babel/03-Babel 插件开发/04 Path 路径.md","leaf":true,"title":"04 Path 路径","depth":2,"content":"---\ntitle: 04 Path 路径\n---\n\n### 1、Path 介绍\n\n![20230608092337](http://s3.airtlab.com/blog/20230608092337.png)\n\n***\n\n![20230608092353](http://s3.airtlab.com/blog/20230608092353.png)\n\n### 2、Paths in Visitors（存在于访问者中的路径）\n\n![20230608092412](http://s3.airtlab.com/blog/20230608092412.png)\n\n### 3、demo 演示\n\n```javascript\nconst fs = require('fs');\nconst babel = require(\"@babel/core\");\n\nconst MyVisitor = {\n  Identifier(path) {\n    console.log(\"Visiting: \" + path.node.name);\n  }\n};\n\nfunction MyPlugin() {\n  return {\n    visitor: MyVisitor\n  }\n}\n\nvar res = babel.transformSync(\"var code = 1; var fn = () => {}\", {\n  ast: true,\n  plugins: [\n    require('@babel/plugin-transform-arrow-functions'),\n    MyPlugin\n  ]\n});\n\nconsole.log(res.code);\n```\n","isLeaf":true},{"key":"/Babel/03-Babel 插件开发/05 Bindings(绑定).md","path":"/Babel/03-Babel 插件开发/05 Bindings(绑定).md","route":"/Babel/03-Babel 插件开发/05 Bindings(绑定).md","leaf":true,"title":"05 Bindings(绑定)","depth":2,"content":"---\ntitle: 05 Bindings（绑定）\n---\n\n一个作用域可以创建变量，这种关系被称为绑定。\n\n```typescript\nfunction scopeOnce() {\n  var ref = \"This is a binding\";\n\n  ref; // This is a reference to a binding\n\n  function scopeTwo() {\n    ref; // This is a reference to a binding from a lower scope\n  }\n}\n```\n\n## 1、Binding 的定义\n\n```typescript\nexport type BindingKind = 'var' | 'let' | 'const' | 'module' | 'hoisted' | 'param' | 'local' | 'unknown';\n\nexport class Binding {\n    constructor(opts: { identifier: t.Identifier; scope: Scope; path: NodePath; kind: BindingKind });\n    identifier: t.Identifier;\n    scope: Scope;\n    path: NodePath;\n    kind: BindingKind;\n    referenced: boolean;            // 是否被引用\n    references: number;             // 被引用次数\n    referencePaths: NodePath[];     // 被引用的路径\n    constant: boolean;              // 是否被修改\n    constantViolations: NodePath[];\n    hasDeoptedValue?: boolean;\n    hasValue?: boolean;\n    value?: any;\n\n    deopValue(): void;\n    setValue(value: any): void;\n    clearValue(): void;\n\n    reassign(path: NodePath): void;\n    reference(path: NodePath): void;\n    dereference(): void;\n}\n```\n\n有了这些信息你就可以查找一个绑定的所有引用，并且知道这是什么类型的绑定(参数，定义等等)，查找它所属的作用域，或者拷贝它的标识符。 你甚至可以知道它是不是常量，如果不是，那么是哪个路径修改了它。 <a name=\"I31IK\"></a>\n\n## 2、代码辅助理解\n\n### 1. 引用次数 \\[references]\n\n```typescript\nfunction test1() {\n  var a = 10;\n  console.log(a);\n}\n```\n\n```typescript\nbindings: [Object: null prototype] {\n  a: Binding {\n    identifier: [Node],\n    scope: [Circular],\n    path: [NodePath],\n    kind: 'var',\n    constantViolations: [],\n    constant: true,\n    referencePaths: [Array],\n    referenced: true,\n    references: 1,\n    hasDeoptedValue: false,\n    hasValue: false,\n    value: null\n  }\n}\n```\n\n### 2. 绑定是否是常量 \\[constant]\n\na 没有修改：\n\n```typescript\nfunction test1() {\n  var a = 10;\n  console.log(a);\n}\n```\n\n```typescript\nbindings: [Object: null prototype] {\n  a: Binding {\n    identifier: [Node],\n    scope: [Circular],\n    path: [NodePath],\n    kind: 'var',\n    constantViolations: [],\n    constant: true,\n    referencePaths: [Array],\n    referenced: true,\n    references: 1,\n    hasDeoptedValue: false,\n    hasValue: false,\n    value: null\n  }\n}\n```\n\na 有被修改：\n\n```typescript\nfunction test1() {\n  var a = 10;\n  a = 20;\n  console.log(a);\n}\n```\n\n```typescript\nBinding {\n  identifier: Node {\n    type: 'Identifier',\n    start: 26,\n    end: 27,\n    loc: SourceLocation {\n      start: [Position],\n      end: [Position],\n      filename: undefined,\n      identifierName: 'a'\n    },\n    name: 'a'\n  },\n  scope: Scope {\n    uid: 1,\n    path: NodePath {\n      contexts: [Array],\n      state: undefined,\n      opts: [Object],\n      _traverseFlags: 0,\n      skipKeys: null,\n      parentPath: [NodePath],\n      container: [Array],\n      listKey: 'body',\n      key: 0,\n      node: [Node],\n      type: 'FunctionDeclaration',\n      parent: [Node],\n      hub: undefined,\n      data: null,\n      context: [TraversalContext],\n      scope: [Circular]\n    },\n    block: Node {\n      type: 'FunctionDeclaration',\n      start: 1,\n      end: 63,\n      loc: [SourceLocation],\n      id: [Node],\n      generator: false,\n      async: false,\n      params: [],\n      body: [Node]\n    },\n    labels: Map {},\n    inited: true,\n    bindings: [Object: null prototype] { a: [Circular] },\n    references: [Object: null prototype] {},\n    globals: [Object: null prototype] {},\n    uids: [Object: null prototype] {},\n    data: [Object: null prototype] {},\n    crawling: undefined\n  },\n  path: NodePath {\n    contexts: [],\n    state: {\n      references: [Array],\n      constantViolations: [],\n      assignments: [Array]\n    },\n    opts: {\n      ForStatement: [Object],\n      ImportDeclaration: [Object],\n      LabeledStatement: [Object],\n      AssignmentExpression: [Object],\n      UpdateExpression: [Object],\n      UnaryExpression: [Object],\n      CatchClause: [Object],\n      ClassExpression: [Object],\n      _exploded: true,\n      _verified: true,\n      Identifier: [Object],\n      JSXIdentifier: [Object],\n      enter: [Array],\n      FunctionDeclaration: [Object],\n      VariableDeclaration: [Object],\n      ClassDeclaration: [Object],\n      ExportAllDeclaration: [Object],\n      ExportDefaultDeclaration: [Object],\n      ExportNamedDeclaration: [Object],\n      DeclareClass: [Object],\n      DeclareFunction: [Object],\n      DeclareInterface: [Object],\n      DeclareModule: [Object],\n      DeclareModuleExports: [Object],\n      DeclareTypeAlias: [Object],\n      DeclareOpaqueType: [Object],\n      DeclareVariable: [Object],\n      DeclareExportDeclaration: [Object],\n      DeclareExportAllDeclaration: [Object],\n      InterfaceDeclaration: [Object],\n      OpaqueType: [Object],\n      TypeAlias: [Object],\n      EnumDeclaration: [Object],\n      TSDeclareFunction: [Object],\n      TSInterfaceDeclaration: [Object],\n      TSTypeAliasDeclaration: [Object],\n      TSEnumDeclaration: [Object],\n      TSModuleDeclaration: [Object],\n      ForInStatement: [Object],\n      ForOfStatement: [Object],\n      FunctionExpression: [Object],\n      ObjectMethod: [Object],\n      ArrowFunctionExpression: [Object],\n      ClassMethod: [Object],\n      ClassPrivateMethod: [Object]\n    },\n    _traverseFlags: 0,\n    skipKeys: null,\n    parentPath: NodePath {\n      contexts: [],\n      state: [Object],\n      opts: [Object],\n      _traverseFlags: 0,\n      skipKeys: null,\n      parentPath: [NodePath],\n      container: [Array],\n      listKey: 'body',\n      key: 0,\n      node: [Node],\n      type: 'VariableDeclaration',\n      parent: [Node],\n      hub: undefined,\n      data: null,\n      context: [TraversalContext],\n      scope: [Scope]\n    },\n    container: [ [Node] ],\n    listKey: 'declarations',\n    key: 0,\n    node: Node {\n      type: 'VariableDeclarator',\n      start: 26,\n      end: 32,\n      loc: [SourceLocation],\n      id: [Node],\n      init: [Node]\n    },\n    type: 'VariableDeclarator',\n    parent: Node {\n      type: 'VariableDeclaration',\n      start: 22,\n      end: 33,\n      loc: [SourceLocation],\n      declarations: [Array],\n      kind: 'var'\n    },\n    hub: undefined,\n    data: null,\n    context: TraversalContext {\n      queue: null,\n      priorityQueue: [],\n      parentPath: [NodePath],\n      scope: [Scope],\n      state: [Object],\n      opts: [Object]\n    },\n    scope: Scope {\n      uid: 1,\n      path: [NodePath],\n      block: [Node],\n      labels: Map {},\n      inited: true,\n      bindings: [Object: null prototype],\n      references: [Object: null prototype] {},\n      globals: [Object: null prototype] {},\n      uids: [Object: null prototype] {},\n      data: [Object: null prototype] {},\n      crawling: undefined\n    }\n  },\n  kind: 'var',\n  constantViolations: [\n    NodePath {\n      contexts: [],\n      state: [Object],\n      opts: [Object],\n      _traverseFlags: 0,\n      skipKeys: null,\n      parentPath: [NodePath],\n      container: [Node],\n      listKey: undefined,\n      key: 'expression',\n      node: [Node],\n      type: 'AssignmentExpression',\n      parent: [Node],\n      hub: undefined,\n      data: null,\n      context: [TraversalContext],\n      scope: [Scope]\n    }\n  ],\n  constant: false,\n  referencePaths: [\n    NodePath {\n      contexts: [],\n      state: [Object],\n      opts: [Object],\n      _traverseFlags: 0,\n      skipKeys: null,\n      parentPath: [NodePath],\n      container: [Array],\n      listKey: 'arguments',\n      key: 0,\n      node: [Node],\n      type: 'Identifier',\n      parent: [Node],\n      hub: undefined,\n      data: null,\n      context: [TraversalContext],\n      scope: [Scope]\n    }\n  ],\n  referenced: true,\n  references: 1,\n  hasDeoptedValue: false,\n  hasValue: false,\n  value: null\n}\n\n```\n\n### 3. 只有 变量定义 和 函数定义 拥有 binding\n\n```typescript\nlet binding = scope.getBinding(name);\n// 例如: var a = 123; 这里的 a 就拥有 binding。\n\nfunction test(a,b,c) {};\n// 函数名test以及形参a，b，c均拥有 binding。\n```\n\n### 4. binding.path\n\n用于定位初始拥有binding的path; <a name=\"hn5qZ\"></a>\n\n### 5. binding.referenced\n\n用于判断当前变量是否被引用，true表示代码下面有引用该变量的地方，false表示没有地方引用该变量。注意，引用和改变是分开的。 <a name=\"Y9Wns\"></a>\n\n### 6. binding.referencePaths\n\n它是一个Array类型，包含所有引用的path，多用于替换。\n\n### 7. binding.constantViolations\n\n它是一个Array类型，包含所有改变的path，多用于判断。\n","isLeaf":true},{"key":"/Babel/03-Babel 插件开发/06 Scopes(作用域).md","path":"/Babel/03-Babel 插件开发/06 Scopes(作用域).md","route":"/Babel/03-Babel 插件开发/06 Scopes(作用域).md","leaf":true,"title":"06 Scopes(作用域)","depth":2,"content":"---\ntitle: 06 Scopes（作用域）\nurl: https://www.yuque.com/gaollard/ubc1q5/wt5qg7\n---\n\n## 1、Scope 介绍\n\n接下来让我们介绍 [作用域（scope）](https://en.wikipedia.org/wiki/Scope_\\(computer_science\\))的概念。 JavaScript 支持[词法作用域](https://en.wikipedia.org/wiki/Scope_\\(computer_science\\)#Lexical_scoping_vs._dynamic_scoping)，在树状嵌套结构中代码块创建出新的作用域。\n\n```javascript\n// global scope\n\nfunction scopeOne() {\n  // scope 1\n  function scopeTwo() {\n    // scope 2\n  }\n}\n```\n\n在 JavaScript 中，每当你创建了一个引用，不管是通过变量（variable）、函数（function）、类型（class）、参数（params）、模块导入（import）还是标签（label）等，它都属于当前作用域。\n\n```javascript\nvar global = \"I am in the global scope\";\n\nfunction scopeOne() {\n  var one = \"I am in the scope created by `scopeOne()`\";\n\n  function scopeTwo() {\n    var two = \"I am in the scope created by `scopeTwo()`\";\n  }\n}\n```\n\n更深的内部作用域代码可以使用外层作用域中的引用。\n\n```javascript\nfunction scopeOne() {\n  var one = \"I am in the scope created by `scopeOne()`\";\n\n  function scopeTwo() {\n    one = \"I am updating the reference in `scopeOne` inside `scopeTwo`\";\n  }\n}\n```\n\n内层作用域也可以创建和外层作用域同名的引用。\n\n```javascript\nfunction scopeOne() {\n  var one = \"I am in the scope created by `scopeOne()`\";\n\n  function scopeTwo() {\n    var one = \"I am creating a new `one` but leaving reference in `scopeOne()` alone.\";\n  }\n}\n```\n\n当编写一个转换时，必须小心作用域。我们得确保在改变代码的各个部分时不会破坏已经存在的代码。\n我们在添加一个新的引用时需要确保新增加的引用名字和已有的所有引用不冲突。 或者我们仅仅想找出使用一个变量的所有引用， 我们只想在给定的作用域（Scope）中找出这些引用。\n作用域可以被表示为如下形式：\n\n```javascript\n{\n  path: path,\n  block: path.node,\n  parentBlock: path.parent,\n  parent: parentScope,\n  bindings: [...]\n}\n```\n\n当你创建一个新的作用域时，需要给出它的路径和父作用域，之后在遍历过程中它会在该作用域内收集所有的引用(“绑定”)。\n一旦引用收集完毕，你就可以在作用域（Scopes）上使用各种方法，稍后我们会了解这些方法。\n\n## 2、Scope 定义\n\nScope 表示作用域\n\n```typescript\nexport class Scope {\n    constructor(path: NodePath, parentScope?: Scope);\n    path: NodePath;\n    block: Node;\n    parentBlock: Node;\n    parent: Scope;\n    hub: HubInterface;\n    bindings: { [name: string]: Binding };\n\n    /** Traverse node with current scope and path. */\n    traverse<S>(node: Node | Node[], opts: TraverseOptions<S>, state: S): void;\n    traverse(node: Node | Node[], opts?: TraverseOptions, state?: any): void;\n\n    /** Generate a unique identifier and add it to the current scope. */\n    generateDeclaredUidIdentifier(name?: string): t.Identifier;\n\n    /** Generate a unique identifier. */\n    generateUidIdentifier(name?: string): t.Identifier;\n\n    /** Generate a unique `_id1` binding. */\n    generateUid(name?: string): string;\n\n    /** Generate a unique identifier based on a node. */\n    generateUidIdentifierBasedOnNode(parent: Node, defaultName?: string): t.Identifier;\n\n    /**\n     * Determine whether evaluating the specific input `node` is a consequenceless reference. ie.\n     * evaluating it wont result in potentially arbitrary code from being ran. The following are\n     * whitelisted and determined not to cause side effects:\n     *\n     *  - `this` expressions\n     *  - `super` expressions\n     *  - Bound identifiers\n     */\n    isStatic(node: Node): boolean;\n\n    /** Possibly generate a memoised identifier if it is not static and has consequences. */\n    maybeGenerateMemoised(node: Node, dontPush?: boolean): t.Identifier;\n\n    checkBlockScopedCollisions(local: Binding, kind: BindingKind, name: string, id: object): void;\n\n    rename(oldName: string, newName?: string, block?: Node): void;\n\n    dump(): void;\n\n    toArray(node: Node, i?: number): Node;\n\n    registerDeclaration(path: NodePath): void;\n\n    buildUndefinedNode(): Node;\n\n    registerConstantViolation(path: NodePath): void;\n\n    registerBinding(kind: string, path: NodePath, bindingPath?: NodePath): void;\n\n    addGlobal(node: Node): void;\n\n    hasUid(name: string): boolean;\n\n    hasGlobal(name: string): boolean;\n\n    hasReference(name: string): boolean;\n\n    isPure(node: Node, constantsOnly?: boolean): boolean;\n\n    setData(key: string, val: any): any;\n\n    getData(key: string): any;\n\n    removeData(key: string): void;\n\n    crawl(): void;\n\n    push(opts: {\n        id: t.LVal;\n        init?: t.Expression | undefined;\n        unique?: boolean | undefined;\n        kind?: 'var' | 'let' | 'const' | undefined;\n    }): void;\n\n    getProgramParent(): Scope;\n\n    getFunctionParent(): Scope | null;\n\n    getBlockParent(): Scope;\n\n    /** Walks the scope tree and gathers **all** bindings. */\n    getAllBindings(...kinds: string[]): object;\n\n    bindingIdentifierEquals(name: string, node: Node): boolean;\n\n    getBinding(name: string): Binding | undefined;\n\n    getOwnBinding(name: string): Binding | undefined;\n\n    getBindingIdentifier(name: string): t.Identifier;\n\n    getOwnBindingIdentifier(name: string): t.Identifier;\n\n    hasOwnBinding(name: string): boolean;\n\n    hasBinding(name: string, noGlobals?: boolean): boolean;\n\n    parentHasBinding(name: string, noGlobals?: boolean): boolean;\n\n    /** Move a binding of `name` to another `scope`. */\n    moveBindingTo(name: string, scope: Scope): void;\n\n    removeOwnBinding(name: string): void;\n\n    removeBinding(name: string): void;\n}\n\n```\n\n## 3、代码辅助理解\n\n### 1. 查看 scope 结构\n\n```typescript\nimport * as fs from \"fs\";\nimport * as path from 'path';\nimport * as babel from \"@babel/core\";\n\nconst code = `\nfunction test1() {\n  var a = 10;\n}\n`\n\nconst data = babel.parse(code, {\n  presets: [\"@babel/preset-typescript\"],\n  plugins: [\n    [\n      \"@babel/plugin-proposal-decorators\",\n      {\n        legacy: true,\n      },\n    ],\n  ],\n  filename: 'sss',\n});\n\n\nbabel.traverse(data, {\n  FunctionDeclaration(path) {\n    console.log(path.scope)\n  }\n})\n```\n\n```typescript\nScope {\n  uid: 1,\n  path: NodePath {\n    contexts: [ [TraversalContext] ],\n    state: undefined,\n    opts: { FunctionDeclaration: [Object], _exploded: true, _verified: true },\n    _traverseFlags: 0,\n    skipKeys: null,\n    parentPath: NodePath {\n      contexts: [Array],\n      state: undefined,\n      opts: [Object],\n      _traverseFlags: 0,\n      skipKeys: null,\n      parentPath: null,\n      container: [Node],\n      listKey: undefined,\n      key: 'program',\n      node: [Node],\n      type: 'Program',\n      parent: [Node],\n      hub: undefined,\n      data: null,\n      context: [TraversalContext],\n      scope: [Scope]\n    },\n    container: [ [Node] ],\n    listKey: 'body',\n    key: 0,\n    node: Node {\n      type: 'FunctionDeclaration',\n      start: 1,\n      end: 35,\n      loc: [SourceLocation],\n      id: [Node],\n      generator: false,\n      async: false,\n      params: [],\n      body: [Node]\n    },\n    type: 'FunctionDeclaration',\n    parent: Node {\n      type: 'Program',\n      start: 0,\n      end: 36,\n      loc: [SourceLocation],\n      sourceType: 'module',\n      interpreter: null,\n      body: [Array],\n      directives: []\n    },\n    hub: undefined,\n    data: null,\n    context: TraversalContext {\n      queue: [Array],\n      priorityQueue: [],\n      parentPath: [NodePath],\n      scope: [Scope],\n      state: undefined,\n      opts: [Object]\n    },\n    scope: [Circular]\n  },\n  block: Node {\n    type: 'FunctionDeclaration',\n    start: 1,\n    end: 35,\n    loc: SourceLocation {\n      start: [Position],\n      end: [Position],\n      filename: undefined,\n      identifierName: undefined\n    },\n    id: Node {\n      type: 'Identifier',\n      start: 10,\n      end: 15,\n      loc: [SourceLocation],\n      name: 'test1'\n    },\n    generator: false,\n    async: false,\n    params: [],\n    body: Node {\n      type: 'BlockStatement',\n      start: 18,\n      end: 35,\n      loc: [SourceLocation],\n      body: [Array],\n      directives: []\n    }\n  },\n  labels: Map {},\n  inited: true,\n  bindings: [Object: null prototype] {\n    a: Binding {\n      identifier: [Node],\n      scope: [Circular],\n      path: [NodePath],\n      kind: 'var',\n      constantViolations: [],\n      constant: true,\n      referencePaths: [],\n      referenced: false,\n      references: 0,\n      hasDeoptedValue: false,\n      hasValue: false,\n      value: null\n    }\n  },\n  references: [Object: null prototype] {},\n  globals: [Object: null prototype] {},\n  uids: [Object: null prototype] {},\n  data: [Object: null prototype] {},\n  crawling: undefined\n}\n```\n\n- block  该作用域所属的 code block\n- path   该作用域所属的 NodePath\n- bindings  该作用域能够访问变量 <a name=\"Bi4FK\"></a>\n\n### 2. 查看 binding\n\n```typescript\nimport * as fs from \"fs\";\nimport * as path from 'path';\nimport * as babel from \"@babel/core\";\n\nconst code = `\nfunction test1() {\n  var a = 10;\n}\n\nfunction test2() {\n  var b = 10;\n}\n`\n\nconst data = babel.parse(code, {\n  presets: [\"@babel/preset-typescript\"],\n  plugins: [\n    [\n      \"@babel/plugin-proposal-decorators\",\n      {\n        legacy: true,\n      },\n    ],\n  ],\n  filename: 'sss',\n});\n\n\nbabel.traverse(data, {\n  FunctionDeclaration(path) {\n    if (babel.types.isIdentifier(path.node.id)) {\n      console.log(path.node.id.name, path.scope.hasBinding(\"a\"))\n    }\n  }\n})\n\n// test1 true\n// test2 false\n```","isLeaf":true},{"key":"/Babel/03-Babel 插件开发/07 State 状态.md","path":"/Babel/03-Babel 插件开发/07 State 状态.md","route":"/Babel/03-Babel 插件开发/07 State 状态.md","leaf":true,"title":"07 State 状态","depth":2,"content":"---\ntitle: 07 State 状态\n---\n\n状态是抽象语法树AST转换的敌人，状态管理会不断牵扯你的精力，而且几乎所有你对状态的假设，总是会有一些未考虑到的语法最终证明你的假设是错误的。\n考虑下列代码：\n\n```javascript\nfunction square(n) {\n  return n * n;\n}\n```\n\n让我们写一个把 n 重命名为 x 的访问者的快速实现:\n\n```javascript\nlet paramName;\n\nconst MyVisitor = {\n  FunctionDeclaration(path) {\n    const param = path.node.params[0];\n    paramName = param.name;\n    param.name = \"x\";\n  },\n\n  Identifier(path) {\n    if (path.node.name === paramName) {\n      path.node.name = \"x\";\n    }\n  }\n};\n```\n\n对上面的例子代码这段访问者代码也许能工作，但它很容易被打破：\n\n```javascript\nfunction square(n) {\n  return n * n;\n}\nn;\n```\n\n更好的处理方式是使用递归，下面让我们来像克里斯托佛·诺兰的电影盗梦空间那样来把一个访问者放进另外一个访问者里面:\n\n```javascript\nconst updateParamNameVisitor = {\n  Identifier(path) {\n    if (path.node.name === this.paramName) {\n      path.node.name = \"x\";\n    }\n  }\n};\n\nconst MyVisitor = {\n  FunctionDeclaration(path) {\n    const param = path.node.params[0];\n    const paramName = param.name;\n    param.name = \"x\";\n\n    path.traverse(updateParamNameVisitor, { paramName });\n  }\n};\n\npath.traverse(MyVisitor);\n```\n\n注意例子中 `path.traverse(updateParamNameVisitor, { paramName })` 第二个参数，在 visitor 中通过 this 可以访问。\n\n这个例子演示了如何从访问者中消除全局状态。","isLeaf":true}]},{"key":"/Babel/04-Babel 练习","path":"/Babel/04-Babel 练习","route":"/Babel/04-Babel 练习","leaf":false,"title":"04-Babel 练习","depth":1,"content":"","isLeaf":false,"children":[{"key":"/Babel/04-Babel 练习/01 遍历 jsx 节点.md","path":"/Babel/04-Babel 练习/01 遍历 jsx 节点.md","route":"/Babel/04-Babel 练习/01 遍历 jsx 节点.md","leaf":true,"title":"01 遍历 jsx 节点","depth":2,"content":"我在写一个 babel 插件，用于给每一个 div 标签都加一个 css class。现在出现了两种场景。\n\n## 1、`React.createElement('div', {})`\n\n![20230511185255](http://s3.airtlab.com/blog/20230511185255.png)\n\n```js\nmodule.exports = function (api) {\n  api && api.cache(false);\n  return {\n    presets: [\n      [\"@babel/preset-react\", { runtime: \"classic\" }],\n    ],\n    plugins: [\n      // 注意 prefix 中的空格\n      [\"./src/babel-plugin-change-jsx-className\", {\n        prefix: 'f6 '\n      }]\n    ]\n  };\n};\n\n```\n\n```js\nconst fs = require('fs');\nconst { Console } = require('console');\nconst logFile = process.cwd() + '/' + 'a.log'\n\nconst std = fs.createWriteStream(logFile, { flags: 'a' });\nconst console = new Console(std);\nconst types = require('@babel/types');\nlet config = {};\n\nmodule.exports = function (\n  _,\n  options = {\n    prefix: '',\n  },\n) {\n  config = options;\n  return {\n    visitor: {\n      CallExpression,\n      JSXElement(path) {\n        const node = path.node;\n        if (node.openingElement.name.name === \"div\") {\n          console.log(\"Found div:\", node);\n        }\n      },\n      BinaryExpression(path) {\n        console.log(path.node.left); // Identifier Node\n        console.log(path.node.right); // Identifier Node\n        console.log(path.node.operator); // \"*\"\n      },\n    },\n  };\n};\n\nfunction CallExpression(path) {\n  // debugger;\n  const _this = this;\n  const callee = path.node.callee;\n  console.log(444, callee);\n\n  if (callee.type === 'MemberExpression') {\n    const callFn = callee.object.name + '.' + callee.property.name;\n    if (callFn === 'React.createElement') {\n      path.skip();\n\n      const arg1 = path.get('arguments.1');\n\n      if (arg1.node.type === 'NullLiteral') {\n        // null\n        arg1.replaceWith(\n          types.objectExpression([\n            types.objectProperty(\n              types.identifier('className'),\n              types.stringLiteral(config.prefix),\n            ),\n            types.objectProperty(\n              types.identifier('data-code'),\n              types.stringLiteral(_this.filename),\n            ),\n          ]),\n        );\n      } else {\n        // {}\n        if (arg1.node.type === 'ObjectExpression') {\n          const index = arg1.node.properties.findIndex((it) => {\n            return it.key.name === 'className';\n          });\n          if (index !== -1) {\n            const proPath = arg1.get(`properties.${index}`);\n            proPath.node.value = types.binaryExpression(\n              '+',\n              types.StringLiteral(config.prefix),\n              proPath.node.value,\n            );\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n```json\n{\n  \"name\": \"f6\",\n  \"version\": \"0.0.0\",\n  \"description\": \"> TODO: description\",\n  \"author\": \"gaollard <1056834607@qq.com>\",\n  \"homepage\": \"\",\n  \"license\": \"ISC\",\n  \"main\": \"src/index.js\",\n  \"directories\": {\n    \"lib\": \"lib\",\n    \"test\": \"__tests__\"\n  },\n  \"files\": [\n    \"lib\",\n    \"src\"\n  ],\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: run tests from root\\\" && exit 1\",\n    \"build\": \"babel demo/index.js\"\n  },\n  \"dependencies\": {\n    \"@babel/generator\": \"^7.16.5\",\n    \"@babel/preset-react\": \"^7.16.5\",\n    \"@babel/runtime\": \"^7.16.5\",\n    \"@types/react-transition-group\": \"^4.4.4\"\n  },\n  \"devDependencies\": {\n    \"@babel/cli\": \"^7.16.0\",\n    \"@babel/core\": \"^7.16.5\",\n    \"@babel/plugin-syntax-dynamic-import\": \"^7.0.0\",\n    \"@babel/plugin-transform-modules-commonjs\": \"^7.16.5\",\n    \"@babel/plugin-transform-object-assign\": \"^7.0.0\",\n    \"@babel/plugin-transform-runtime\": \"^7.4.4\",\n    \"@babel/polyfill\": \"^7.4.4\",\n    \"@babel/preset-env\": \"^7.16.5\",\n    \"@babel/preset-typescript\": \"^7.3.3\",\n    \"@types/react\": \"^17.0.34\",\n    \"@types/react-dom\": \"^17.0.11\",\n    \"style-loader\": \"^3.3.1\",\n    \"css-loader\": \"^6.5.1\",\n    \"react\": \"^17.0.2\",\n    \"react-dom\": \"^17.0.2\",\n    \"rimraf\": \"^3.0.2\",\n    \"typescript\": \"^4.4.4\"\n  },\n  \"peerDependencies\": {\n    \"classnames\": \"^2.3.1\",\n    \"react\": \"^17.0.2\",\n    \"react-dom\": \"^17.0.2\"\n  }\n}\n```\n\n## 2、_jsx('div', {})\n\n![20230511190028](http://s3.airtlab.com/blog/20230511190028.png)\n\n## 3、遍历 JSXElement 更合理\n\n![20230511191205](http://s3.airtlab.com/blog/20230511191205.png)","isLeaf":true},{"key":"/Babel/04-Babel 练习/02 plugin-transform-react-jsx.md","path":"/Babel/04-Babel 练习/02 plugin-transform-react-jsx.md","route":"/Babel/04-Babel 练习/02 plugin-transform-react-jsx.md","leaf":true,"title":"02 plugin-transform-react-jsx","depth":2,"content":"- 原理\n- 源码分析","isLeaf":true},{"key":"/Babel/04-Babel 练习/03 add-prop-to-jsx.md","path":"/Babel/04-Babel 练习/03 add-prop-to-jsx.md","route":"/Babel/04-Babel 练习/03 add-prop-to-jsx.md","leaf":true,"title":"03 add-prop-to-jsx","depth":2,"content":"https://www.johno.com/add-a-prop-to-jsx-elements-with-babel\n\n```js\nexport default (api) => {\n  const { types: t } = api;\n\n  return {\n    visitor: {\n      JSXOpeningElement(path) {\n        const existingProp = path.node.attributes.find(\n          (node) => node.name && node.name.name === \"favoriteColor\"\n        );\n\n        if (existingProp) {\n          existingProp.node.value.value === \"tomato\";\n          return;\n        }\n\n        const newProp = t.jSXAttribute(\n          t.jSXIdentifier(\"favoriteColor\"),\n          t.stringLiteral(\"tomato\")\n        );\n\n        path.node.attributes.push(newProp);\n      },\n    },\n  };\n};\n```\n","isLeaf":true},{"key":"/Babel/04-Babel 练习/04 how-comipler-typescript.md","path":"/Babel/04-Babel 练习/04 how-comipler-typescript.md","route":"/Babel/04-Babel 练习/04 how-comipler-typescript.md","leaf":true,"title":"04 how-comipler-typescript","depth":2,"content":"---\ntitle: 05 如何编译 typescript\n---\n\n- 如果没有使用 Babel，首选 TypeScript 自带编译器（配合 ts-loader 使用）\n- 如果项目中有 Babel，安装 @babel/preset-typescript，配合 tsc 做类型检查。\n\n两种编译器不要混用。参考 https://juejin.cn/post/6954304242093932557#heading-7","isLeaf":true},{"key":"/Babel/04-Babel 练习/05 rename-function-param.md","path":"/Babel/04-Babel 练习/05 rename-function-param.md","route":"/Babel/04-Babel 练习/05 rename-function-param.md","leaf":true,"title":"05 rename-function-param","depth":2,"content":"```js\nmodule.exports = function({ types: t }) {\n  return {\n    visitor: {\n      FunctionDeclaration(path, state) {\n        path.scope.rename('age', path.scope.generateUidIdentifier(\"age\").name)\n      }\n    }\n  }\n}\n```\n\n```js\nmodule.exports = function({ types: t }) {\n  return {\n    visitor: {\n      FunctionDeclaration(path, state) {\n        const { replaceMap } = state.opts;\n        const params = path.get('params');\n\n        params.forEach((idPath) => {\n          if (replaceMap[idPath.node.name]) {\n            idPath.replaceWith(t.identifier(replaceMap[idPath.node.name]))\n          }\n        })\n\n        Object.keys(path.scope.bindings).forEach((name) => {\n          const referencePaths = path.scope.bindings[name].referencePaths\n          referencePaths.forEach((idPath) => {\n            if (replaceMap[idPath.node.name]) {\n              idPath.replaceWith(t.identifier(replaceMap[idPath.node.name]))\n            }\n          })\n        })\n      }\n    }\n  }\n}\n```\n","isLeaf":true},{"key":"/Babel/04-Babel 练习/06 生成 AST.md","path":"/Babel/04-Babel 练习/06 生成 AST.md","route":"/Babel/04-Babel 练习/06 生成 AST.md","leaf":true,"title":"06 生成 AST","depth":2,"content":"```javascript\nconst fs = require('fs');\nconst babel = require(\"@babel/core\");\n\nvar res = babel.transformSync(\"var code = 1; var fn = () => {}\", {\n  ast: true,\n  plugins: [\n    require('@babel/plugin-transform-arrow-functions')\n  ]\n});\n\nconsole.log(res.code);\n```","isLeaf":true},{"key":"/Babel/04-Babel 练习/07 插入节点.md","path":"/Babel/04-Babel 练习/07 插入节点.md","route":"/Babel/04-Babel 练习/07 插入节点.md","leaf":true,"title":"07 插入节点","depth":2,"content":"---\ntitle: 09 插入节点\n---\n\n### 1. 插入 Node\n\n### 2. 插入 字符串代码\n","isLeaf":true}]},{"key":"/Babel/05-acorn","path":"/Babel/05-acorn","route":"/Babel/05-acorn","leaf":false,"title":"05-acorn","depth":1,"content":"","isLeaf":false,"children":[{"key":"/Babel/05-acorn/00.md","path":"/Babel/05-acorn/00.md","route":"/Babel/05-acorn/00.md","leaf":true,"title":"00","depth":2,"content":"---\ntitle: acorn 源码分析\ntags: acorn\n---\n\n- AST 在线 <https://astexplorer.net/#/2uBU1BLuJ1>\n","isLeaf":true},{"key":"/Babel/05-acorn/01-the-super-tiny-compiler.md","path":"/Babel/05-acorn/01-the-super-tiny-compiler.md","route":"/Babel/05-acorn/01-the-super-tiny-compiler.md","leaf":true,"title":"01-the-super-tiny-compiler","depth":2,"content":"---\ntitle: 01 the-super-tiny-compiler 源码分析\ntags: acornjs\n---\n\n<https://github.com/jamiebuilds/the-super-tiny-compiler>，这个设计库实在太过简单（比如：不支持取反操作），只能用作学习 compiler 的流程设计。\n\n- tokenizer(词法分析器)：划分 token，产生一个 token 数组\n- parser(语法分析器)：接受 token 数组，然后把它转化为 AST <a name=\"bsEHt\"></a>\n\n### 1. 测试 the-super-tiny-compiler\n\n    (add 21 (subtract 4 2))\n\n- (op v1 v2) 括号表示一个 CallExpression 调用表达式\n- add +\n- subtract -\n- token 只包含\n  - NumberLiteral 数字字面量\n  - StringLiteral 字符串字面量\n  - CallExpression 调用表达式\n    - add\n    - subtract\n\n#### 1.1 tokens\n\n```json\n[\n  {\n    \"type\": \"paren\",\n    \"value\": \"(\"\n  },\n  {\n    \"type\": \"name\",\n    \"value\": \"add\"\n  },\n  {\n    \"type\": \"number\",\n    \"value\": \"21\"\n  },\n  {\n    \"type\": \"paren\",\n    \"value\": \"(\"\n  },\n  {\n    \"type\": \"name\",\n    \"value\": \"subtract\"\n  },\n  {\n    \"type\": \"number\",\n    \"value\": \"4\"\n  },\n  {\n    \"type\": \"number\",\n    \"value\": \"2\"\n  },\n  {\n    \"type\": \"paren\",\n    \"value\": \")\"\n  },\n  {\n    \"type\": \"paren\",\n    \"value\": \")\"\n  }\n]\n```\n\n#### 1.2 AST\n\n```json\n{\n  \"type\": \"Program\",\n  \"body\": [\n    {\n      \"type\": \"CallExpression\",\n      \"name\": \"add\",\n      \"params\": [\n        {\n          \"type\": \"NumberLiteral\",\n          \"value\": \"21\"\n        },\n        {\n          \"type\": \"CallExpression\",\n          \"name\": \"subtract\",\n          \"params\": [\n            {\n              \"type\": \"NumberLiteral\",\n              \"value\": \"4\"\n            },\n            {\n              \"type\": \"NumberLiteral\",\n              \"value\": \"2\"\n            }\n          ]\n        }\n      ]\n    }\n  ]\n}\n```\n\n<a name=\"RKRFw\"></a>\n\n### 2. 自己实现\n\n<a name=\"fQ8XC\"></a>\n\n#### 2.1 tokenizer\n\n```javascript\n/**\n * @param {string} input \n */\nfunction tokenizer(input) {\n  let current = 0;\n  let tokens = [];\n\n  const lt_parent_l = '(';\n  const lt_parent_r = ')';\n\n  const type_paren = 'paren';\n  const type_number = 'number';\n  const type_string = 'string';\n  const type_name = 'name';\n\n  const reg_whitespcae = /\\s/;\n  const reg_numbers = /[0-9]/;\n  const reg_letters = /[a-z]/i;\n\n  const isEof = () => current >= input.length;\n\n  const genToken = (type, value, start) => {\n    const token = {\n      type,\n      value\n    }\n    token.loc = {\n      start,\n      end: token.value.length + start\n    }\n    tokens.push(token)\n  } \n\n  while(!isEof()) {\n    let c_char = input[current];\n\n    if (c_char === lt_parent_l) {\n      genToken(type_paren, c_char, current)\n      current++;\n      continue;\n    }\n\n    if (c_char === lt_parent_r) {\n      genToken(type_paren, c_char, current)\n      current++;\n      continue;\n    }\n\n    if (reg_whitespcae.test(c_char)) {\n      current++;\n      continue;\n    }\n\n    if (reg_numbers.test(c_char)) {\n      // 解析出当前的整型字面量\n\n      let value = '';\n      let start = current;\n\n      while(reg_numbers.test(c_char)) {\n        value += c_char;\n        c_char = input[++current];\n      }\n\n      genToken(type_number, value, start)\n      continue;\n    }\n\n    if (c_char === '\"') {\n      // 找出完整的字符串\n\n      let start = current\n      let value = '';\n      c_char = input[current++]; \n\n      while(c_char !== '\"') {\n        value += c_char;\n        c_char = input[++current];\n      }\n\n      // 跳过闭合的双引号\n      c_char = input[++current];\n\n      genToken(type_string, value, start)\n      continue;\n    }\n\n    if (reg_letters.test(c_char)) {\n      // 找出完整的关键字\n      let start = current;\n      let value = '';\n      while(reg_letters.test(c_char)) {\n        value += c_char;\n        c_char = input[++current];\n      }\n\n      genToken(type_name, value, start)\n      continue;\n    }\n\n    // 如果还剩一些字符，说明表达式语法有错误\n    throw new TypeError('I dont know what this character is: ' + char);\n  }\n\n  return tokens;\n}\n```\n\n```javascript\n// (add 21 (subtract 4 2))\n[\n  { type: 'paren', value: '(', loc: { start: 0, end: 1 } },\n  { type: 'name', value: 'add', loc: { start: 1, end: 4 } },\n  { type: 'number', value: '21', loc: { start: 5, end: 7 } },\n  { type: 'paren', value: '(', loc: { start: 8, end: 9 } },\n  { type: 'name', value: 'subtract', loc: { start: 9, end: 17 } },\n  { type: 'number', value: '4', loc: { start: 18, end: 19 } },\n  { type: 'number', value: '2', loc: { start: 20, end: 21 } },\n  { type: 'paren', value: ')', loc: { start: 21, end: 22 } },\n  { type: 'paren', value: ')', loc: { start: 22, end: 23 } }\n]\n```\n\n#### 2.2 parser","isLeaf":true},{"key":"/Babel/05-acorn/01.md","path":"/Babel/05-acorn/01.md","route":"/Babel/05-acorn/01.md","leaf":true,"title":"01","depth":2,"content":"---\ntitle: 简易表达式\ntags: acornjs\n---\n\n### 1. 条件表达式 Condition\n\n```javascript\na = b ? 1 : 2 + 1  // =>  a = b ? 1 : (2 + 1)\n```\n\n### 2. 赋值表达式 Assign\n\n```javascript\na == b ? 1 : 2 + 1 // => (a == b) ? 1 : (2+1)\na += b ? 1 : 0     // => a += (b ? 1 : 0 )\n```\n\n### 3. 更新表达式 Update\n\n```javascript\na++\na--\n```\n\n### 4. 逻辑运算符 Logical\n\n```javascript\na || b\na == b ? 1 : 2 + 1 // => (a == b) ? 1 : (2+1)\n```\n\n### 5. 一元运算符\n\n```javascript\n-5\n+5\n```\n\n### 6. 运算符优先级","isLeaf":true},{"key":"/Babel/05-acorn/02.md","path":"/Babel/05-acorn/02.md","route":"/Babel/05-acorn/02.md","leaf":true,"title":"02","depth":2,"content":"---\ntitle: acorn 解析\ntags: acornjs\n---\n\n## 1. 基础类和接口\n\n### 1.1 Node\n\n所有节点类型都实现以下接口：\n\n```typescript\ninterface Node {\n  type: string; // AST变体类型\n  start: number; // 起始位置\n  end: number; // 结束位置\n  range?: [number, number]; // [起始位置, 结束位置]\n  loc?: SourceLocation;\n}\n```\n\nloc字段表示节点的位置信息。如果解析器没有生成有关节点源位置的信息，则该字段为null。否则它是一个对象，包括一个起始位置 和一个结束位置。每个Position对象由一个line数字（1索引）和一个column数字（0索引）组成：\n\n```typescript\ninterface SourceLocation {\n    start: Position;\n    end: Position;\n    source?: string | null;\n}\n```\n\n```typescript\ninterface Position {\n    line: number >= 1;\n    column: number >= 0;\n}\n```\n\n### 1.2 Programs\n\n```typescript\ninterface Program <: Node {\n    type: \"Program\";\n    sourceType: 'script' | 'module';\n    body: StatementListItem[] | ModuleItem[];\n}\n```\n\n表示一个完整的源代码树。 <a name=\"PB0xS\"></a>\n\n## 2. 脚本和模块\n\n源代码数的来源包括两种，一种是script脚本，一种是modules模块\n\n- 当为script时，body为StatementListItem。\n- 当为modules时，body为ModuleItem。\n\n类型 StatementListItem 和 ModuleItem 类型如下：\n\n```typescript\ntype StatementListItem = Declaration | Statement;\ntype ModuleItem = ImportDeclaration | ExportDeclaration | StatementListItem;\n```\n\n### 2.1 ImportDeclaration\n\nimport语法，导入模块\n\n```typescript\ntype ImportDeclaration {\n    type: 'ImportDeclaration';\n    specifiers: ImportSpecifier[];\n    source: Literal;\n}\n```\n\nImportSpecifier：\n\n```typescript\ninterface ImportSpecifier {\n    type: 'ImportSpecifier' | 'ImportDefaultSpecifier' | 'ImportNamespaceSpecifier';\n    local: Identifier;\n    imported?: Identifier;\n}\n```\n\n#### 2.1.1 ImportSpecifier\n\nimport 部分模块\n\n```typescript\nimport { foo } from './foo';\n```\n\n#### 2.1.2 ImportDefaultSpecifier\n\nimport default 方式\n\n```typescript\nimport foo from './foo';\n```\n\n##### 2.1.3 ImportNamespaceSpecifier\n\n模块重命名\n\n```typescript\nimport * as foo from './foo';\n```\n\n### 2.2 ExportDeclaration\n\n```typescript\ntype ExportDeclaration = ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration;\n```\n\n#### 2.2.1 ExportAllDeclaration\n\n从指定模块中导出\n\n```typescript\ninterface ExportAllDeclaration {\n    type: 'ExportAllDeclaration';\n    source: Literal;\n}\n```\n\n```typescript\nexport * from './foo';\n```\n\n#### 2.2.2 ExportDefaultDeclaration\n\n导出默认模块\n\n```typescript\ninterface ExportDefaultDeclaration {\n    type: 'ExportDefaultDeclaration';\n    declaration: Identifier | BindingPattern | ClassDeclaration | Expression | FunctionDeclaration;\n}\n```\n\n```typescript\nexport default 'foo';\n```\n\n#### 2.2.3 ExportNamedDeclaration\n\n导出部分模块\n\n```typescript\ninterface ExportNamedDeclaration {\n    type: 'ExportNamedDeclaration';\n    declaration: ClassDeclaration | FunctionDeclaration | VariableDeclaration;\n    specifiers: ExportSpecifier[];\n    source: Literal;\n}\n```\n\n```typescript\nexport const foo = 'foo';\n```\n","isLeaf":true},{"key":"/Babel/05-acorn/03.md","path":"/Babel/05-acorn/03.md","route":"/Babel/05-acorn/03.md","leaf":true,"title":"03","depth":2,"content":"---\ntitle: Declarations 声明\ntags: acornjs\nurl: https://www.yuque.com/gaollard/ubc1q5/wluqrk\n---\n\n### 1. VariableDeclarator\n\n变量声明\n\n```typescript\ninterface VariableDeclaration <: Declaration {\n    type: \"VariableDeclaration\";\n    declarations: [ VariableDeclarator ];\n    kind: \"var\" | \"let\" | \"const\";\n}\n```\n\nVariableDeclarator 表示一个变量声明:\n\n```typescript\ninterface VariableDeclarator {\n  type: \"VariableDeclarator\";\n  id: Identifier;\n  init: Expression;\n}\n```\n\n```typescript\nvar c = 30\n```\n\n```json\n{\n  \"type\": \"VariableDeclarator\",\n  \"start\": 28,\n  \"end\": 34,\n  \"id\": {\n    \"type\": \"Identifier\",\n    \"start\": 28,\n    \"end\": 29,\n    \"name\": \"c\"\n  },\n  \"init\": {\n    \"type\": \"Literal\",\n    \"start\": 32,\n    \"end\": 34,\n    \"value\": 30,\n    \"raw\": \"30\"\n  }\n}\n```\n\n### 2. FunctionDeclaration\n\n函数声明，注意与函数表达式的区别\n\n```typescript\ninterface FunctionDeclaration {\n    type: 'FunctionDeclaration';\n    id: Identifier | null;\n    params: FunctionParameter[];\n    body: BlockStatement;\n    generator: boolean;\n    async: boolean;\n    expression: false;\n}\n```\n\n```javascript\n{\n  \"type\": \"Program\",\n  \"start\": 0,\n  \"end\": 17,\n  \"body\": [\n    {\n      \"type\": \"ClassDeclaration\",\n      \"start\": 0,\n      \"end\": 17,\n      \"id\": {\n        \"type\": \"Identifier\",\n        \"start\": 6,\n        \"end\": 12,\n        \"name\": \"Person\"\n      },\n      \"superClass\": null,\n      \"body\": {\n        \"type\": \"ClassBody\",\n        \"start\": 13,\n        \"end\": 17,\n        \"body\": []\n      }\n    }\n  ],\n  \"sourceType\": \"module\"\n}\n```\n\n####\n\n```javascript\nclass Person extends Object {\n\tsleep() {}\n}\n```\n\n### 3. ClassDeclaration\n\n类声明，注意和类表达式的区别\n\n```typescript\ninterface ClassDeclaration {\n  type: 'ClassDeclaration';\n  id: Identifier | null;\n  superClass: Identifier | null;\n  body: ClassBody;\n}\n```\n\nClassBody 类主体:\n\n```typescript\ninterface ClassBody {\n  type: 'ClassBody';\n  body: MethodDefinition[];\n}\n```\n\nMethodDefinition 表示方法定义：\n\n```typescript\ninterface MethodDefinition {\n  type: 'MethodDefinition';\n  key: Expression | null;\n  computed: boolean;\n  value: FunctionExpression | null;\n  kind: 'method' | 'constructor';\n  static: boolean;\n}\n```\n\n```typescript\nclass Fn {\n  constructor() {}\n  method() {}\n};\n```\n","isLeaf":true},{"key":"/Babel/05-acorn/04.md","path":"/Babel/05-acorn/04.md","route":"/Babel/05-acorn/04.md","leaf":true,"title":"04","depth":2,"content":"---\ntitle: Expressions 表达式\ntags: acornjs\nurl: https://www.yuque.com/gaollard/ubc1q5/slzv6w\n---\n\nExpressions 可用类型如下：\n\n```typescript\ntype Expression = ThisExpression | Identifier | Literal |\n    ArrayExpression | ObjectExpression | FunctionExpression | ArrowFunctionExpression | ClassExpression |\n    TaggedTemplateExpression | MemberExpression | Super | MetaProperty |\n    NewExpression | CallExpression | UpdateExpression | AwaitExpression | UnaryExpression |\n    BinaryExpression | LogicalExpression | ConditionalExpression |\n    YieldExpression | AssignmentExpression | SequenceExpression;\n```\n\nJS 中的表达式除了常见的表达式外，还可以是：\n\n- Identifier 标识符\n- Literal 字面量\n- Super\n\n### 1. ThisExpression\n\nthis 表达式\n\n```typescript\ninterface ThisExpression {\n  type: \"ThisExpression\";\n}\n```\n\n```typescript\n(function(ctx){})(this);\n```\n\n```typescript\n{\n  \"type\": \"Program\",\n  \"start\": 0,\n  \"end\": 29,\n  \"body\": [\n    {\n      \"type\": \"ExpressionStatement\",\n      \"start\": 0,\n      \"end\": 29,\n      \"expression\": {\n        \"type\": \"CallExpression\",\n        \"start\": 0,\n        \"end\": 28,\n        \"callee\": {\n          \"type\": \"FunctionExpression\",\n          \"start\": 5,\n          \"end\": 20,\n          \"id\": null,\n          \"expression\": false,\n          \"generator\": false,\n          \"async\": false,\n          \"params\": [\n            {\n              \"type\": \"Identifier\",\n              \"start\": 14,\n              \"end\": 17,\n              \"name\": \"ctx\"\n            }\n          ],\n          \"body\": {\n            \"type\": \"BlockStatement\",\n            \"start\": 18,\n            \"end\": 20,\n            \"body\": []\n          }\n        },\n        \"arguments\": [\n          {\n            \"type\": \"ThisExpression\",\n            \"start\": 23,\n            \"end\": 27\n          }\n        ],\n        \"optional\": false\n      }\n    }\n  ],\n  \"sourceType\": \"module\"\n}\n```\n\n### 2. Identifier\n\n标识符，比如变量名、函数名\n\n```typescript\ninterface Identifier {\n    type: 'Identifier';\n    name: string;\n}\n```\n\n### 3. Literal\n\n基础的字面量，比如\n\n- 字符串\n- 数字\n- 布尔\n- 正则\n\n```typescript\ninterface Literal {\n    type: 'Literal';\n    value: boolean | number | string | RegExp | null;\n    raw: string;\n    regex?: { pattern: string, flags: string };\n}\n```\n\n```typescript\nvar a = 10;\nvar a = 'string';\nvar a = true;\nvar a = /\\d/;\n```\n\n注意，{} 和 \\[] 不被包括在内，他们被分别抽离为 ObjectExpression ArrayExpression <a name=\"RL6b3\"></a>\n\n### 4. ObjectExpression\n\n对象表达式\n\n```typescript\ninterface ObjectExpression {\n    type: 'ObjectExpression';\n    properties: Property[];\n}\n```\n\nproperties为属性列表，Property 表示为对象的属性描述。\n\n```typescript\ninterface Property {\n    type: 'Property';\n    key: Expression;\n    computed: boolean;\n    value: Expression | null;\n    kind: 'get' | 'set' | 'init';\n    method: false;\n    shorthand: boolean;\n}\n```\n\n```typescript\nvar a = {\n\tname: 1\n}\n```\n\n```json\n{\n  \"type\": \"ObjectExpression\",\n  \"start\": 8,\n  \"end\": 20,\n  \"properties\": [\n    {\n      \"type\": \"Property\",\n      \"start\": 11,\n      \"end\": 18,\n      \"method\": false,\n      \"shorthand\": false,\n      \"computed\": false,\n      \"key\": {\n        \"type\": \"Identifier\",\n        \"start\": 11,\n        \"end\": 15,\n        \"name\": \"name\"\n      },\n      \"value\": {\n        \"type\": \"Literal\",\n        \"start\": 17,\n        \"end\": 18,\n        \"value\": 1,\n        \"raw\": \"1\"\n      },\n      \"kind\": \"init\"\n    }\n  ]\n}\n```\n\n注意：{} 既可以表示为表达式，也可以表示为Statement语句，需要结合语义。 <a name=\"H0ybq\"></a>\n\n### 5. ArrayExpression\n\n数组表达式\n\n```typescript\ninterface ArrayExpression {\n    type: 'ArrayExpression';\n    elements: ArrayExpressionElement[];\n}\n```\n\nArrayExpressionElement:\n\n```typescript\ntype ArrayExpressionElement = Expression | SpreadElement;\n```\n\n### 6. SpreadElement\n\n扩展运算符\n\n```typescript\ninterface SpreadElement {\n    type: 'SpreadElement';\n    argument: Expression;\n}\n```\n\n```typescript\nvar a = [1, 2, ...list];\nvar b = {foo: 2, ...obj};\n```\n\n### 7. FunctionExpression\n\nFunctionExpress 表示函数表达式。\n\n```typescript\ninterface FunctionExpression {\n    type: 'FunctionExpression';\n    id: Identifier | null;\n    params: FunctionParameter[];\n    body: BlockStatement;\n    generator: boolean;\n    async: boolean;\n    expression: boolean;\n}\n```\n\n在下面的例子中，等号右边就是一个函数表达式:\n\n```typescript\nvar fn = function(){}\nvar fn = function Person(){}\n```\n\n请注意函数声明和函数表达式的区别。 <a name=\"l647H\"></a>\n\n### 8. ArrowFunctionExpression\n\n箭头函数。\n\n```typescript\ninterface ArrowFunctionExpression {\n    type: 'ArrowFunctionExpression';\n    id: Identifier | null;\n    params: FunctionParameter[];\n    body: BlockStatement | Expression;\n    generator: boolean;\n    async: boolean;\n    expression: false;\n}\n```\n\n```typescript\ntype FunctionParameter = AssignmentPattern | Identifier | BindingPattern;\n```\n\n### 9. TaggedTemplateExpression\n\n### 10. MemberExpression\n\n属性成员表达式\n\n```typescript\ninterface MemberExpression {\n    type: 'MemberExpression';\n    computed: boolean;\n    object: Expression;\n    property: Expression;\n}\n```\n\n```typescript\nconst foo = {bar: 'bar'};\nfoo.bar; // // computed 为 false\nfoo['bar']; // computed 为 true\n```\n\n### 11. Super\n\n父类关键字\n\n```typescript\ninterface Super {\n    type: 'Super';\n}\n```\n\n```typescript\nclass Male extends Person {\n    constructor() {\n        super();\n    }\n}\n```\n\n### 12. MetaProperty\n\nimport.meta 是一个给JavaScript模块暴露特定上下文的元数据属性的对象。它包含了这个模块的信息，比如说这个模块的URL。\n\n```typescript\ninterface MetaProperty {\n    type: 'MetaProperty';\n    meta: Identifier;\n    property: Identifier;\n}\n```\n\n```typescript\nimport.meta\n```\n\n```json\n{\n  \"type\": \"Program\",\n  \"start\": 0,\n  \"end\": 11,\n  \"body\": [\n    {\n      \"type\": \"ExpressionStatement\",\n      \"start\": 0,\n      \"end\": 11,\n      \"expression\": {\n        \"type\": \"MetaProperty\",\n        \"start\": 0,\n        \"end\": 11,\n        \"meta\": {\n          \"type\": \"Identifier\",\n          \"start\": 0,\n          \"end\": 6,\n          \"name\": \"import\"\n        },\n        \"property\": {\n          \"type\": \"Identifier\",\n          \"start\": 7,\n          \"end\": 11,\n          \"name\": \"meta\"\n        }\n      }\n    }\n  ],\n  \"sourceType\": \"module\"\n}\n```\n\n### 13. ClassExpression\n\n类表达式\n\n```typescript\ninterface ClassExpression {\n    type: 'ClassExpression';\n    id: Identifier | null;\n    superClass: Identifier | null;\n    body: ClassBody;\n}\n```\n\n```typescript\nvar Fn = class {\n    constructor() {}\n    method() {}\n};\n```\n\n### 14. NewExpression\n\nnew 表达式\n\n```typescript\ninterface NewExpression {\n    type: 'NewExpression';\n    callee: Expression;\n    arguments: ArgumentListElement[];\n}\n```\n\n```typescript\nnew Person(name)\n```\n\n```json\n{\n  \"type\": \"NewExpression\",\n  \"start\": 0,\n  \"end\": 16,\n  \"callee\": {\n    \"type\": \"Identifier\",\n    \"start\": 4,\n    \"end\": 10,\n    \"name\": \"Person\"\n  },\n  \"arguments\": [\n    {\n      \"type\": \"Identifier\",\n      \"start\": 11,\n      \"end\": 15,\n      \"name\": \"name\"\n    }\n  ]\n}\n```\n\n### 15. CallExpression\n\n函数调用表达式\n\n```typescript\ninterface CallExpression {\n    type: 'CallExpression';\n    callee: Expression | Import;\n    arguments: ArgumentListElement[];\n}\n```\n\nImport 的场景：\n\n```typescript\n(import(''))()\n```\n\n```typescript\ninterface Import {\n    type: 'Import'\n}\n```\n\nArgumentListElement 类型:\n\n```typescript\ntype ArgumentListElement = Expression | SpreadElement;\n```\n\n### 15. UpdateExpression\n\n更新操作符表达式，如 `++`、`--`;\n\n```typescript\ninterface UpdateExpression {\n  type: \"UpdateExpression\";\n  operator: '++' | '--';\n  argument: Expression;\n  prefix: boolean;\n}\n```\n\n```typescript\nvar a = 0;\na++;\n++a; // prefix为true\n```\n\n### 16. AwaitExpression\n\nawait表达式，与 async 一起使用\n\n```typescript\ninterface AwaitExpression {\n    type: 'AwaitExpression';\n    argument: Expression;\n}\n```\n\n```typescript\nasync function slepp() {\n\tawait fn()\n}\n```\n\n```typescript\n{\n  \"type\": \"AwaitExpression\",\n  \"start\": 26,\n  \"end\": 36,\n  \"argument\": {\n    \"type\": \"CallExpression\",\n    \"start\": 32,\n    \"end\": 36,\n    \"callee\": {\n      \"type\": \"Identifier\",\n      \"start\": 32,\n      \"end\": 34,\n      \"name\": \"fn\"\n    },\n    \"arguments\": [],\n    \"optional\": false\n  }\n}\n```\n\n### 17. UnaryExpression\n\n一元操作符表达式\n\n```typescript\ninterface UnaryExpression {\n  type: \"UnaryExpression\";\n  operator: UnaryOperator;\n  prefix: boolean;\n  argument: Expression;\n}\n```\n\nUnaryOperator:\n\n```typescript\nenum UnaryOperator {\n  \"-\" | \"+\" | \"!\" | \"~\" | \"typeof\" | \"void\" | \"delete\" | \"throw\"\n}\n```\n\n### 18. BinaryExpression\n\n二元操作符表达式\n\n```typescript\ninterface BinaryExpression {\n    type: 'BinaryExpression';\n    operator: BinaryOperator;\n    left: Expression;\n    right: Expression;\n}\n```\n\nBinaryOperator:\n\n```typescript\nenum BinaryOperator {\n  \"==\" | \"!=\" | \"===\" | \"!==\"\n     | \"<\" | \"<=\" | \">\" | \">=\"\n     | \"<<\" | \">>\" | \">>>\"\n     | \"+\" | \"-\" | \"*\" | \"/\" | \"%\"\n     | \"**\" | \"|\" | \"^\" | \"&\" | \"in\"\n     | \"instanceof\"\n     | \"|>\"\n}\n```\n\n### 19. LogicalExpression\n\n逻辑运算符表达式\n\n```typescript\ninterface LogicalExpression {\n    type: 'LogicalExpression';\n    operator: '||' | '&&';\n    left: Expression;\n    right: Expression;\n}\n```\n\n```typescript\nvar a = '-';\nvar b = a || '-';\nvar c = a && b || 1\n```\n\n### 20. ConditionalExpression\n\n条件运算符\n\n```typescript\ninterface ConditionalExpression {\n    type: 'ConditionalExpression';\n    test: Expression;\n    consequent: Expression;\n    alternate: Expression;\n}\n```\n\n```typescript\nvar a = 1 ? 'consequent' : 'alternate';\n```\n\n### 21. YieldExpression\n\nyield表达式\n\n```typescript\ninterface YieldExpression {\n    type: 'YieldExpression';\n    argument: Expression | null;\n    delegate: boolean;\n}\n```\n\n```typescript\nfunction* gen(x) {\n  return yield x + 1;\n}\n```\n\n### 22. AssignmentExpression\n\n赋值表达式\n\n```typescript\ninterface AssignmentExpression {\n    type: 'AssignmentExpression';\n    operator: '=' | '*=' | '**=' | '/=' | '%=' | '+=' | '-=' |\n        '<<=' | '>>=' | '>>>=' | '&=' | '^=' | '|=';\n    left: Expression;\n    right: Expression;\n}\n```\n\n### 23. SequenceExpression\n\n使用逗号的序列表达式\n\n```typescript\ninterface SequenceExpression {\n  type: 'SequenceExpression';\n  expressions: Expression[];\n}\n```\n\n```typescript\na = 1, b = 2;\n```\n","isLeaf":true},{"key":"/Babel/05-acorn/05.md","path":"/Babel/05-acorn/05.md","route":"/Babel/05-acorn/05.md","leaf":true,"title":"05","depth":2,"content":"---\ntitle: Statement 语句\ntags: acornjs\n---\n\nJS 规范可以参考 <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference>\nstatements，即语句，类型如下：\n\n```typescript\ntype Statement = BlockStatement | BreakStatement | ContinueStatement |\n    DebuggerStatement | DoWhileStatement | EmptyStatement |\n    ExpressionStatement | ForStatement | ForInStatement |\n    ForOfStatement | FunctionDeclaration | IfStatement |\n    LabeledStatement | ReturnStatement | SwitchStatement |\n    ThrowStatement | TryStatement | VariableDeclaration |\n    WhileStatement | WithStatement;\n```\n\n### 1. BlockStatement\n\n表示一个作用域块。\n\n```typescript\ninterface BlockStatement {\n    type: 'BlockStatement';\n    body: Statement[];\n}\n```\n\n```typescript\n{}\n```\n\n```typescript\n{\n  \"type\": \"BlockStatement\",\n  \"start\": 0,\n  \"end\": 2,\n  \"body\": []\n}\n```\n\n<a name=\"ylwvh\"></a>\n\n### 2. IfStatement\n\nIfStatement 用于表示 if 语句\n\n```typescript\ninterface IfStatement {\n    type: 'IfStatement';\n    test: Expression;\n    consequent: Statement;\n    alternate?: Statement;\n}\n```\n\n```typescript\nif (a > b) {}\n```\n\n```json\n{\n  \"type\": \"IfStatement\",\n  \"start\": 0,\n  \"end\": 13,\n  \"test\": {\n    \"type\": \"BinaryExpression\",\n    \"start\": 4,\n    \"end\": 9,\n    \"left\": {\n      \"type\": \"Identifier\",\n      \"start\": 4,\n      \"end\": 5,\n      \"name\": \"a\"\n    },\n    \"operator\": \">\",\n    \"right\": {\n      \"type\": \"Identifier\",\n      \"start\": 8,\n      \"end\": 9,\n      \"name\": \"b\"\n    }\n  },\n  \"consequent\": {\n    \"type\": \"BlockStatement\",\n    \"start\": 11,\n    \"end\": 13,\n    \"body\": []\n  },\n  \"alternate\": null\n}\n```\n\n<a name=\"lkIih\"></a>\n\n### 3. ReturnStatement\n\nReturenStatement 用于表示 return 语句\n\n```typescript\ninterface ReturnStatement {\n    type: 'ReturnStatement';\n    argument: Expression | null;\n}\n```\n\n```typescript\nfunction sleep() {\n\treturn 10;\n}\n```\n\n```typescript\n{\n  \"type\": \"ReturnStatement\",\n  \"start\": 20,\n  \"end\": 30,\n  \"argument\": {\n    \"type\": \"Literal\",\n    \"start\": 27,\n    \"end\": 29,\n    \"value\": 10,\n    \"raw\": \"10\"\n  }\n}\n```\n\n### 4. SwitchStatement\n\nSwitchStatement 用于表示 switch 语句。\n\n```typescript\ninterface SwitchStatement {\n    type: 'SwitchStatement';\n    discriminant: Expression;\n    cases: SwitchCase[];\n}\n```\n\n```typescript\nswitch(b) {\n  case 10:\n    console.log(10);\n    break;\n  case 20:\n    console.log(20);\n    break;\n  default:\n    console.log(\"default\")\n}\n```\n\n![20230608110506](http://s3.airtlab.com/blog/20230608110506.png)\n\n### 5. WhileStatement\n\nwhile 语句。\n\n```typescript\ninterface WhileStatement {\n    type: 'WhileStatement';\n    test: Expression;\n    body: Statement;\n}\n```\n\n<a name=\"zxenD\"></a>\n\n### 6. BreakStatement\n\nbreak 语句。\n\n```typescript\n{\n   \"type\": \"BreakStatement\",\n   \"label\": null | string\n}\n```\n\n```typescript\nfor(;;){\n\tbreak;\n}\n```\n\n<a name=\"pjLpI\"></a>\n\n### 7. ContinueStatement\n\ncontinue 语句。\n\n```typescript\n{\n   \"type\": \"ContinueStatement\",\n   \"label\": null | string\n}\n```\n\n```typescript\nfor(;;){\n\tcontinue;\n}\n```\n\n<a name=\"regOL\"></a>\n\n### 8. DebuggerStatement\n\ndebugger 语句。\n\n```typescript\n{\n   \"type\": \"DebuggerStatement\"\n}\n```\n\n```typescript\ndebugger;\n```\n\n<a name=\"i63zx\"></a>\n\n### 9. DoWhileStatement\n\n```json\ninterface DoWhileStatement {\n    type: 'DoWhileStatement';\n    body: Statement;\n    test: Expression;\n}\n```\n\n```typescript\ndo {} while(1)\n```\n\n```json\n{\n  \"type\": \"DoWhileStatement\",\n  \"start\": 0,\n  \"end\": 14,\n  \"body\": {\n    \"type\": \"BlockStatement\",\n    \"start\": 3,\n    \"end\": 5,\n    \"body\": []\n  },\n  \"test\": {\n    \"type\": \"Literal\",\n    \"start\": 12,\n    \"end\": 13,\n    \"value\": 1,\n    \"raw\": \"1\"\n  }\n}\n```\n\n<a name=\"RK0TE\"></a>\n\n### 10. EmptyStatement\n\n空语句。\n\n```typescript\ninterface EmptyStatement {\n  type: \"EmptyStatement\"\n}\n```\n\n```typescript\n;\n```\n\n<a name=\"yuv0l\"></a>\n\n### 11. ExpressionStatement\n\n表达式语句。\n\n```typescript\ninterface ExpressionStatement {\n  type: \"ExpressionStatement\";\n  expression: Expression\n}\n```\n\n```typescript\n(function() {})\n```\n\n```json\n{\n  \"type\": \"ExpressionStatement\",\n  \"start\": 0,\n  \"end\": 15,\n  \"expression\": {\n    \"type\": \"FunctionExpression\",\n    \"start\": 1,\n    \"end\": 14,\n    \"id\": null,\n    \"expression\": false,\n    \"generator\": false,\n    \"async\": false,\n    \"params\": [],\n    \"body\": {\n      \"type\": \"BlockStatement\",\n      \"start\": 12,\n      \"end\": 14,\n      \"body\": []\n    }\n  }\n}\n```\n\n<a name=\"NzoXy\"></a>\n\n### 12. ForStatement\n\n```typescript\ninterface ForStatement {\n    type: 'ForStatement';\n    init: Expression | VariableDeclaration | null; // 初始化\n    test: Expression | null; // 中间条件\n    update: Expression | null; // 迭代步骤\n    body: Statement; // 主体\n}\n```\n\n<a name=\"CtOnX\"></a>\n\n### 13. ForInStatement\n\nfor...in.. 语句\n\n```typescript\ninterface ForInStatement {\n    type: 'ForInStatement';\n    left: Expression;\n    right: Expression;\n    body: Statement;\n}\n```\n\n```typescript\nfor(let i in a) {}\n```\n\n```typescript\n{\n  \"type\": \"ForInStatement\",\n  \"start\": 0,\n  \"end\": 18,\n  \"left\": {\n    \"type\": \"VariableDeclaration\",\n    \"start\": 4,\n    \"end\": 9,\n    \"declarations\": [\n      {\n        \"type\": \"VariableDeclarator\",\n        \"start\": 8,\n        \"end\": 9,\n        \"id\": {\n          \"type\": \"Identifier\",\n          \"start\": 8,\n          \"end\": 9,\n          \"name\": \"i\"\n        },\n        \"init\": null\n      }\n    ],\n    \"kind\": \"let\"\n  },\n  \"right\": {\n    \"type\": \"Identifier\",\n    \"start\": 13,\n    \"end\": 14,\n    \"name\": \"a\"\n  },\n  \"body\": {\n    \"type\": \"BlockStatement\",\n    \"start\": 16,\n    \"end\": 18,\n    \"body\": []\n  }\n}\n```\n\n<a name=\"RXXqj\"></a>\n\n### 14. ForOfStatement\n\nfor...of 语句\n\n```typescript\ninterface ForOfStatement {\n    type: 'ForOfStatement';\n    left: Expression;\n    right: Expression;\n    body: Statement;\n}\n```\n\n<a name=\"z65t9\"></a>\n\n### 15. ThrowStatement\n\nthrow 语句\n\n```typescript\ninterface ThrowStatement {\n  type: \"ThrowStatement\",\n  argument: S\n}\n```\n\n```typescript\n// throw expression;\n```\n\n```json\n{\n  \"type\": \"ThrowStatement\",\n  \"start\": 0,\n  \"end\": 12,\n  \"argument\": {\n    \"type\": \"Literal\",\n    \"start\": 6,\n    \"end\": 11,\n    \"value\": \"err\",\n    \"raw\": \"\\\"err\\\"\"\n  }\n}\n```\n\n<a name=\"vttj4\"></a>\n\n### 16. TryStatement\n\ntry...catch... 语句\n\n```typescript\ninterface TryStatement {\n    type: 'TryStatement';\n    block: BlockStatement;\n    handler: CatchClause | null;\n    finalizer: BlockStatement | null;\n}\n```\n\n```typescript\ntry {}catch (e) {}\n```\n\n```json\n{\n  \"type\": \"TryStatement\",\n  \"start\": 0,\n  \"end\": 18,\n  \"block\": {\n    \"type\": \"BlockStatement\",\n    \"start\": 4,\n    \"end\": 6,\n    \"body\": []\n  },\n  \"handler\": {\n    \"type\": \"CatchClause\",\n    \"start\": 6,\n    \"end\": 18,\n    \"param\": {\n      \"type\": \"Identifier\",\n      \"start\": 13,\n      \"end\": 14,\n      \"name\": \"e\"\n    },\n    \"body\": {\n      \"type\": \"BlockStatement\",\n      \"start\": 16,\n      \"end\": 18,\n      \"body\": []\n    }\n  },\n  \"finalizer\": null\n}\n```\n\n<a name=\"on7Fu\"></a>\n\n### 17. WithStatement\n\nwith语句（指定块语句的作用域）\n\n```typescript\ninterface WithStatement {\n    type: 'WithStatement';\n    object: Expression;\n    body: Statement;\n}\n```\n","isLeaf":true}]}]},{"key":"/Elasticsearch","path":"/Elasticsearch","route":"/Elasticsearch","leaf":false,"title":"Elasticsearch","depth":0,"content":"","isLeaf":false,"children":[{"key":"/Elasticsearch/01-介绍和应用场景","path":"/Elasticsearch/01-介绍和应用场景","route":"/Elasticsearch/01-介绍和应用场景","leaf":false,"title":"01-介绍和应用场景","depth":1,"content":"","isLeaf":false,"children":[{"key":"/Elasticsearch/01-介绍和应用场景/01-概述.md","path":"/Elasticsearch/01-介绍和应用场景/01-概述.md","route":"/Elasticsearch/01-介绍和应用场景/01-概述.md","leaf":true,"title":"01-概述","depth":2,"content":"---\ntitle: 01-概述\n---\n\nElasticsearch（简称ES）是一个开源的、高扩展的、分布式的、提供多用户能力的全文搜索引擎，也是一个基于Lucene 搜索的服务器，可以近乎实时地存储和搜索数据。\n\n> 只能是接近实时，默认有1秒的延迟(可通过API刷新)\n","isLeaf":true},{"key":"/Elasticsearch/01-介绍和应用场景/02-应用场景.md","path":"/Elasticsearch/01-介绍和应用场景/02-应用场景.md","route":"/Elasticsearch/01-介绍和应用场景/02-应用场景.md","leaf":true,"title":"02-应用场景","depth":2,"content":"---\ntitle: 02-主要功能和应用场景\nurl: https://www.yuque.com/gaollard/efekv4/hbu362\n---\n\n\n\n### 1. 主要功能\n\n1）海量数据的分布式存储以及集群管理，能达到服务与数据的高可用以及系统架构的水平扩展。\n2）近实时的数据搜索能力，能够对结构化数据、全文数据、地理位置等类型的数据进行处理和分析。\n3）海量数据的实时分析功能和各种强大的聚合功能。 \n\n### 2. 应用场景\n\nElasticsearch的主要应用场景如下：\n1）网站搜索、代码搜索等。\n2）日志管理、日志分析、日志安全指标监控、应用性能监控、Web抓取舆情分析等。\n3）利用Elasticsearch的高性能和分布式部署特征，可以对海量的业务订单数据进行分析和处理，还能利用Elasticsearch的聚合函数和分析能力统计出各种各样的数据报表。 \n\n### 3. ELK\n\nElasticsearch是与Logstash（数据收集和日志解析引擎）和Kibana（数据分析和可视化平台）一起开发的，这3个产品被设计成一个集成的解决方案（ELK），被广泛运用于大数据近实时分析领域，包括日志分析、指标监控、信息安全等\n![image.png](https://s3.airtlab.com/elasticsearch/1654416514292-9d547b27-9b78-4ae2-adfa-0c94c2b68d78.png) \n\n### 4. ELK + Beats\n\n![image.png](https://s3.airtlab.com/elasticsearch/1654416594003-938a09e5-5276-47a8-9487-9d7c2b41f6c7.png)\nBeats结合Logstash带来的优势如下：\n1）Beats和Logstash结合可以实现节点之间的负载均衡。\n2）Logstash结合使用Beats或Winlogbeat进行日志收集时，可以保证至少一次交付，而且Logstash持久队列提供跨节点故障的保护。\n3）数据从Beats传输到Logstash和从Logstash传输到Elasticsearch都可以使用加密方式，保证了数据的安全性。 \n\n### 5. MQ + ELK + Beats\n\n![image.png](https://s3.airtlab.com/elasticsearch/1654416693301-231cc3d7-79de-42e8-8751-aa0f5fa6da12.png)\n用户可以在Beats和Logstash中间添加诸如Redis、Kafka、RabbitMQ等中间件。添加中间件会给系统架构带来许多好处，比如，当有很多台机器需要进行日志收集时，让每台机器都向Elasticsearch中持续写入数据，必然会对Elasticsearch造成压力，因此需要对数据进行缓冲。使用Redis、Kafka、RabbitMQ等中间件可以在数据写入时起到缓冲作用，并且能够在一定程度上保护数据不丢失。\n","isLeaf":true}]},{"key":"/Elasticsearch/02-基础实例操作","path":"/Elasticsearch/02-基础实例操作","route":"/Elasticsearch/02-基础实例操作","leaf":false,"title":"02-基础实例操作","depth":1,"content":"","isLeaf":false,"children":[{"key":"/Elasticsearch/02-基础实例操作/01-PUT创建或替换文档.md","path":"/Elasticsearch/02-基础实例操作/01-PUT创建或替换文档.md","route":"/Elasticsearch/02-基础实例操作/01-PUT创建或替换文档.md","leaf":true,"title":"01-PUT创建或替换文档","depth":2,"content":"---\ntitle: 01-PUT创建或替换文档\nurl: https://www.yuque.com/gaollard/efekv4/qckve1\n---\n\n\n\n### 1. 使用语法\n\n```shell\n# id 是必须的\nPUT index/_doc/id\n{\n\n}\n```\n\n\n\n### 2. 创建文档\n\n![](https://s3.airtlab.com/elasticsearch/20220427121251.png)\n\n\n\n### 3. 替换文档\n\n![](https://s3.airtlab.com/elasticsearch/20220427121539.png)\n","isLeaf":true},{"key":"/Elasticsearch/02-基础实例操作/02-POST创建文档.md","path":"/Elasticsearch/02-基础实例操作/02-POST创建文档.md","route":"/Elasticsearch/02-基础实例操作/02-POST创建文档.md","leaf":true,"title":"02-POST创建文档","depth":2,"content":"---\ntitle: 02-POST创建文档\nurl: https://www.yuque.com/gaollard/efekv4/wn65sx\n---\n\n通过 POST 进行文档插入时，用户不需要关注 \\_id 字段值（系统会自动生成唯一的\\_id字段值），操作语法如下：\n\n![](https://s3.airtlab.com/elasticsearch/20220427121812.png)\n\n在使用POST新增文档的时候不能指定文档\\_id（主键字段），只能由系统自动生成。\n","isLeaf":true},{"key":"/Elasticsearch/02-基础实例操作/03-使用POST修改文档.md","path":"/Elasticsearch/02-基础实例操作/03-使用POST修改文档.md","route":"/Elasticsearch/02-基础实例操作/03-使用POST修改文档.md","leaf":true,"title":"03-使用POST修改文档","depth":2,"content":"---\ntitle: 03-使用POST修改文档\nurl: https://www.yuque.com/gaollard/efekv4/bgd3ne\n---\n\n前面的范例中我们直接使用 `PUT` 根据 `_id` 对文档内容进行修改，`Elasticsearch` 也支持使用 `POST` 对文档进行修改，语法如下：\n\n![](https://s3.airtlab.com/elasticsearch/20220427121959.png)\n\n- PUT执行修改操作时，会对文档的整个内容进行替换。\n- POST执行修改操作时，如果字段在文档中，则修改此字段的值；如果字段不在文档中，则把此字段加入文档信息中。\n","isLeaf":true},{"key":"/Elasticsearch/02-基础实例操作/04-POST查询数据.md","path":"/Elasticsearch/02-基础实例操作/04-POST查询数据.md","route":"/Elasticsearch/02-基础实例操作/04-POST查询数据.md","leaf":true,"title":"04-POST查询数据","depth":2,"content":"---\ntitle: 04-POST查询数据\nurl: https://www.yuque.com/gaollard/efekv4/ri8rgs\n---\n\n![](https://s3.airtlab.com/elasticsearch/20220427122420.png)\n","isLeaf":true},{"key":"/Elasticsearch/02-基础实例操作/05-使用DELETE删除文档.md","path":"/Elasticsearch/02-基础实例操作/05-使用DELETE删除文档.md","route":"/Elasticsearch/02-基础实例操作/05-使用DELETE删除文档.md","leaf":true,"title":"05-使用DELETE删除文档","depth":2,"content":"---\ntitle: 05-使用DELETE删除文档\nurl: https://www.yuque.com/gaollard/efekv4/bha8ei\n---\n\n    DELETE /$index/_doc/$id\n","isLeaf":true},{"key":"/Elasticsearch/02-基础实例操作/06-使用GET查询.md","path":"/Elasticsearch/02-基础实例操作/06-使用GET查询.md","route":"/Elasticsearch/02-基础实例操作/06-使用GET查询.md","leaf":true,"title":"06-使用GET查询","depth":2,"content":"---\ntitle: 06-使用GET查询\nurl: https://www.yuque.com/gaollard/efekv4/nvraar\n---\n\nGET语句不仅可以查询文档信息，还可以查询服务中所有的索引库以及索引库的结构信息。如下是常用的GET查询语句。\n\n```shell\n#根据_id查询文档详情\nGET索引库名称/_doc/文档_id\n\n#查询指定索引库中所有的文档信息\nGET索引库名称/_doc/_search\n\n#查询当前集群中所有的索引库信息\nGET /_cat/indices\n\n#查询当前集群中所有的别名索引信息\nGET /_cat/aliases\n\n#查询当前集群的颜色信息\nGET /_cat/health\n\n#查询当前集群中主节点的信息\nGET /_cat/master\n\n#查询当前集群中所有的节点信息\nGET /_cat/nodes\n\n#查询当前集群中索引分片的信息\nGET /_cat/shards\n\n#查询当前集群的健康状态\nGET _cluster/health?pretty=true\n\n#查询当前集群的运行状态信息\nGET _cluster/stats?pretty\n\n#查询当前集群中所有节点的监控信息\nGET _nodes/stats?pretty\n\n#查询当前集群中所有索引的监控信息\nGET _stats?pretty\n```\n","isLeaf":true},{"key":"/Elasticsearch/02-基础实例操作/07-数字字段禁用创建索引.md","path":"/Elasticsearch/02-基础实例操作/07-数字字段禁用创建索引.md","route":"/Elasticsearch/02-基础实例操作/07-数字字段禁用创建索引.md","leaf":true,"title":"07-数字字段禁用创建索引","depth":2,"content":"---\ntitle: 07-数字字段禁用创建索引\nurl: https://www.yuque.com/gaollard/efekv4/cdu4hc\n---\n\n通常会有许多数字字段，用户一般会对这些字段进行聚合计算，并不会通过这些字段进行搜索。在这种情况下，我们可以关闭对这些字段创建索引的功能，这样做不仅可以节省磁盘空间，还可以提升索引库的性能\n\n```json\nPUT myindex5\n{\n  \"mappings\": {\n    \"dynamic_templates\": [\n      {\n        \"unindexed_longs\": {\n          \"match_mapping_type\": \"long\",\n          \"mapping\": {\n            \"type\": \"long\",\n            \"index\": false #禁止创建索引（本质是禁止该字段中的字符串被分词建立索引）\n          }\n        }\n      },\n      {\n        \"unindexed_doubles\": {\n          \"match_mapping_type\": \"double\",\n          \"mapping\": {\n            \"type\": \"float\", \n            \"index\": false\n          }\n        }\n      }\n    ]\n  }\n}\n```\n","isLeaf":true},{"key":"/Elasticsearch/02-基础实例操作/08-不评分搜索.md","path":"/Elasticsearch/02-基础实例操作/08-不评分搜索.md","route":"/Elasticsearch/02-基础实例操作/08-不评分搜索.md","leaf":true,"title":"08-不评分搜索","depth":2,"content":"---\ntitle: 08-不评分搜索\nurl: https://www.yuque.com/gaollard/efekv4/xpqbn4\n---\n\n```json\nPUT test_07\n{\n \"mappings\": {\n   \"dynamic\": \"strict\",\n   \"properties\": {\n      \"name\": {\n        \"type\" : \"text\",\n        \"norms\": true, # here\n        \"fields\" : {\n          \"keyword\" : {\n            \"type\" : \"keyword\",\n            \"ignore_above\" : 256\n          }\n        }\n      }\n   }\n }\n}\n```\n","isLeaf":true},{"key":"/Elasticsearch/02-基础实例操作/09-删除索引下所有数据.md","path":"/Elasticsearch/02-基础实例操作/09-删除索引下所有数据.md","route":"/Elasticsearch/02-基础实例操作/09-删除索引下所有数据.md","leaf":true,"title":"09-删除索引下所有数据","depth":2,"content":"---\ntitle: 09-删除索引下所有数据\nurl: https://www.yuque.com/gaollard/efekv4/kvnt52\n---\n\n```shell\nPOST ${index}/_delete_by_query\n{ \"query\": { \"match_all\": {} } }\n```\n","isLeaf":true}]},{"key":"/Elasticsearch/03-字段类型","path":"/Elasticsearch/03-字段类型","route":"/Elasticsearch/03-字段类型","leaf":false,"title":"03-字段类型","depth":1,"content":"","isLeaf":false,"children":[{"key":"/Elasticsearch/03-字段类型/01-字段类型.md","path":"/Elasticsearch/03-字段类型/01-字段类型.md","route":"/Elasticsearch/03-字段类型/01-字段类型.md","leaf":true,"title":"01-字段类型","depth":2,"content":"---\ntitle: 01-字段类型\nurl: https://www.yuque.com/gaollard/efekv4/bhkl1u\n---\n\ntext 和 keyword 的区别：text 字段的值用于全文搜索；keyword 字段的值存储时不会被分词建立索引，主要用于统计计算等操作。\n\n**1) 常用类型**\n\n- binary：表示可以存储编码为 Base64 的字符串或者二进制值。\n- boolean：表示可以存储 true 和 false 的布尔值。\n- keyword：该字段类型的数据在存储时不会进行分词处理，适合进行统计分析，不能进行全文搜索。\n- numbers：用于表示数字类型，例如 long 和 double。\n- date：表示可以存储日期类型的数据。\n- alias：表示为现有字段定义别名。\n- text：该字段类型的数据在存储时会进行分词并建立索引，适合进行全文搜索，不能进行统计分析。\n\n**2) 对象和关系类型**\n\n- object：表示一个 JSON 对象。\n- nested：嵌套类型，对象中可以嵌套对象。\n- array：在 Elasticsearch 中，数组不需要专用的字段类型。默认情况下，任何字段都可以包含 0 个或多个值，但是数组中的所有值必须具有相同的字段类型。\n\n**3）其余类型**\n\n- range：表示范围类型。\n- rank\\_feature：表示排名类型。\n- token\\_count：表示令牌计数类型。\n- ip：用于 IP 地址的存储和查询的类型。\n- geo\\_point, geo\\_shape：用于地理位置和空间位置的存储与搜索的类型。\n\n\n\n### alias\n\n    #创建名为userinfo的索引库并为其创建映射关系\n    PUT userinfo\n    {\n      \"mappings\": {\n        \"properties\": {\n          \"age\": {\n            \"type\": \"long\"\n          },\n          \"aliasage\": {\n            \"type\": \"alias\",#别名类型\n            \"path\": \"age\"\n          },\n          \"transit_mode\": {\n            \"type\": \"keyword\"\n          }\n        }\n      }\n    }\n\n在使用别名时需要注意的是，可以使用别名进行数据的搜索，但是不能使用别名进行数据的写入\n\n\n\n### 数组类型\n\n在 Elasticsearch 中，没有专用的数组数据类型。默认情况下，任何字段都可以包含 0 个或多个值，不过数组中的所有值必须具有相同的数据类型。\n\n只要保证插入的数组字段中的数据类型是同一个类型，就能把数据写入此数组字段中。\n\n\n\n### binary 类型\n\nbinary 定义的字段类型可以存储编码为 Base64 的字符串或者二进制值。范例如下：\n\n```json\n#创建索引映射并指定blob字段的类型为二进制类型\nPUT myindex-2_02\n{\n  \"mappings\": {\n    \"properties\": {\n      \"name\": {\n        \"type\": \"text\"\n      },\n      \"blob\": {\n        \"type\": \"binary\"\n      }\n    }\n  }\n}\n\n#在索引库中插入数据，blob的内容是Base64编码的字符串\nPUT myindex-2_02/_doc/1\n{\n  \"name\": \"Some binary blob\",\n  \"blob\": \"U29tZSBiaW5hcnkgYmxvYg==\"\n}\n```\n\n\n\n### 布尔类型\n\n布尔字段类型可以存储 true 和 false 的布尔值，也可以存储 \"true\" 和 \"false\" 的字符串。范例如下：\n\n    #创建索引映射并指定is_published字段类型为布尔类型\n    PUT myindex-2_03\n    {\n      \"mappings\": {\n        \"properties\": {\n          \"is_published\": {\n            \"type\": \"boolean\"\n          }\n        }\n      }\n    }\n\n    #新增数据，字段值必须和映射类型匹配\n    POST myindex-2_03/_doc/1?refresh\n    {\n      \"is_published\": \"true\"\n    }\n\n    #查询索引库中is_published字段的值是true的数据\n    GET myindex-2_03/_search\n    {\n      \"query\": {\n        \"term\": {\n          \"is_published\": true\n        }\n      }\n    }\n\n如果需要对布尔值进行转换，可以使用“运行时”脚本来处理，范例如下：\n\n```json\nGET myindex-2_03/_search\n{\n  \"fields\": [\n    {\"field\": \"weight\"}\n  ],\n  \"runtime_mappings\": {\n    \"weight\": {\n      \"type\": \"long\",\n      \"script\": \"emit(doc['is_published'].value ? 1: 0)\"#使用\"运行时\"脚本转换布尔值\n    }\n  }\n}\n```\n\n\n\n### 日期类型\n\nElasticsearch 中的日期类型可以是包含日期格式的字符串，例如 `\"2021-01-01\"`或 `\"2021/01/01 12:10:30\"` 等格式，也可以使用自纪元以来的毫秒数来表示（注：在 Unix 中，纪元是指 UTC 时间 1970 年 1 月 1 日 00:00:00）。范例如下：\n\n```json\n#创建索引映射并指定date字段的字段类型为日期类型\nPUT myindex-2_04\n{\n  \"mappings\": {\n    \"properties\": {\n      \"date\": {\n        \"type\": \"date\"\n      }\n    }\n  }\n}\n\n#插入文档数据\nPUT  myindex-2_04/_doc/1\n{\n  \"date\": \"2015-01-01\"\n}\n\n#插入文档数据\nPUT  myindex-2_04/_doc/2\n{\n  \"date\": \"2015-01-01T12:10:30Z\"\n}\n\n#插入文档数据\nPUT  myindex-2_04/_doc/3\n{\n  \"date\": 1420070400001\n}\n```\n","isLeaf":true},{"key":"/Elasticsearch/03-字段类型/02-设置日期的插入格式.md","path":"/Elasticsearch/03-字段类型/02-设置日期的插入格式.md","route":"/Elasticsearch/03-字段类型/02-设置日期的插入格式.md","leaf":true,"title":"02-设置日期的插入格式","depth":2,"content":"---\ntitle: 02-设置日期的插入格式\nurl: https://www.yuque.com/gaollard/efekv4/freqgf\n---\n\n```json\n#创建索引并为日期类型的字段指定具体的日期格式\nPUT myindex-2_05\n{\n  \"mappings\": {\n    \"properties\": {\n      \"date\": {\n        \"type\": \"date\",\n         \"format\":\"yyyy-MM-dd HH:mm:ss\"\n      }\n    }\n  }\n}\n\n#以下语句插入文档数据时将会抛出异常，因为日期内容不符合映射格式\nPUT  myindex-2_05/_doc/1\n{ \n  \"date\": \"2015-01-01\" \n}\n\n#以下语句插入文档数据时将会抛出异常，因为日期内容不符合映射格式\nPUT  myindex-2_05/_doc/2\n{ \n  \"date\": \"2015-01-01T12:10:30Z\" \n}\n\n#以下语句插入文档数据时将会抛出异常，因为日期内容不符合映射格式\nPUT  myindex-2_05/_doc/3\n{ \n  \"date\": 1420070400001\n}\n \n#以下语句文档数据正常插入，因为日期内容符合字段指定的日期格式\nPUT  myindex-2_05/_doc/4\n{ \n  \"date\": \"2015-01-01 12:02:56\" \n}\n```\n","isLeaf":true},{"key":"/Elasticsearch/03-字段类型/03-字段类型-text-keyword.md","path":"/Elasticsearch/03-字段类型/03-字段类型-text-keyword.md","route":"/Elasticsearch/03-字段类型/03-字段类型-text-keyword.md","leaf":true,"title":"03-字段类型-text-keyword","depth":2,"content":"---\ntitle: 03-字段类型-text-keyword\nurl: https://www.yuque.com/gaollard/efekv4/yxcau6\n---\n\n\n\n### keyword 类型\n\nkeyword（关键字）类型用于存储结构化的内容，例如 ID、电子邮件地址、主机名、状态代码、邮政编码或标签。此类型的字段通常用于排序、聚合查询等。范例如下：\n\n    #创建索引映射并指定tag字段的字段类型为keyword类型\n    PUT myindex-2_11\n    {\n      \"mappings\": {\n        \"properties\": {\n          \"tag\": {\n            \"type\":  \"keyword\"\n          }\n        }\n      }\n    }\n\n    #插入文档数据\n    PUT myindex-2_11/_doc/1\n    {\n      \" tag \":\"北京\"\n    }\n\n    #插入文档数据\n    PUT myindex-2_11/_doc/2\n    {\n      \" tag \":\"北京人\"\n    }\n\n    #查询索引库中tag字段是\"北京\"且完全匹配的内容\n    GET myindex-2_11/_doc/_search?q=tag:北京\n\n\n\n### text 类型\n\n`text` 类型用于进行全文搜索（也称为全文检索），例如电子邮件正文或产品描述的全文，它们在被搜索之前通过分词器将全部文字内容转换为单词（term）表。txt 类型允许用户在每个全文字段中搜索单个单词。\n\n`text` 类型的字段不适合进行排序，也不适合进行聚合计算。如果字段需要聚合计算或者排序，推荐使用 keyword 类型。需要特别注意的是，keyword 类型和 text 类型的区别是：keyword 类型的字段内容不会被分词，text 类型的字段内容会被分词\n\n```json\n#创建索引映射并指定tagname字段的字段类型为text类型\nPUT myindex-2_12\n{\n  \"mappings\": {\n    \"properties\": {\n      \"tagname\": {\n        \"type\":  \"text\"\n      }\n    }\n  }\n}\n\n#插入文档数据\nPUT myindex-2_12/_doc/1\n{\n  \"tagname\":\"江苏省\"\n}\n\n#插入文档数据\nPUT myindex-2_12/_doc/2\n{\n  \"tagname\":\"河北省\"\n}\n\n#根据tagname字段内容分词，然后对所有分词进行匹配搜索\nGET myindex-2_12/_doc/_search\n{\n  \"query\":{\n     \"match\": {\n       \"tagname\": \"河南省\"\n     }\n  }\n}\n\n\n{\n  \"took\" : 0,\n  \"timed_out\" : false,\n  \"_shards\" : {\n    \"total\" : 1,\n    \"successful\" : 1,\n    \"skipped\" : 0,\n    \"failed\" : 0\n  },\n  \"hits\" : {\n    \"total\" : {\n      \"value\" : 2,\n      \"relation\" : \"eq\"\n    },\n    \"max_score\" : 0.19856803,\n    \"hits\" : [\n      {\n        \"_index\" : \"myindex-2_12\",\n        \"_type\" : \"_doc\",\n        \"_id\" : \"1\",\n        \"_score\" : 0.19856803,\n        \"_source\" : {\n          \"tagname\" : \"江苏省\"\n        }\n      },\n      {\n        \"_index\" : \"myindex-2_12\",\n        \"_type\" : \"_doc\",\n        \"_id\" : \"2\",\n        \"_score\" : 0.16853255,\n        \"_source\" : {\n          \"tagname\" : \"河北省\"\n        }\n      }\n    ]\n  }\n}\n```\n\n以上搜索结果中把\"江苏省\"和\"河北省\"这两行数据都返回了，这是因为目前默认的分词器把\"河南省\"分成了\"河南\"和\"省\"两个词，而\"河北省\"和\"江苏省\"分别分成\"河北\"、\"省\"和\"江苏\"、\"省\"，这两个词被分词后都有一个\"省\"字，所以搜索时被全文匹配到了。在实际业务中，如果我们要对字段的内容进行全文搜索，可以使用 text 类型；如果要聚合查询或者精准匹配，则尽量使用 keyword 类型。\n\n对于大多数想要对文本字段执行更多操作的用户，也可以使用多字段映射，其中既有 text 类型可以用于全文搜索，又有 keyword 类型可以用于聚合分析，语法如下：\n\n    PUT索引库名称\n    {\n      \"mappings\": {\n        \"properties\": {\n          \"my_field\": {\n            \"type\": \"text\",\n            \"fields\": {\n              \"keyword\": {\n                \"type\": \"keyword\"\n              }\n            }\n          }\n        }\n      }\n    }\n\n由以上语句可知，my\\_field字段的映射关系是：父字段类型是text类型，子字段类型是keyword类型。范例如下：\n\n```json\nGET myindex-2_13/_doc/_search\n{\n  \"query\":{\n     \"match\": {\n       \"tagname.keyword\": \"河南省\"\n     }\n  }\n}\n```\n","isLeaf":true},{"key":"/Elasticsearch/03-字段类型/04-runtime_mappings & script_fields.md","path":"/Elasticsearch/03-字段类型/04-runtime_mappings & script_fields.md","route":"/Elasticsearch/03-字段类型/04-runtime_mappings & script_fields.md","leaf":true,"title":"04-runtime_mappings & script_fields","depth":2,"content":"---\ntitle: 04-runtime_mappings & script_fields\nurl: https://www.yuque.com/gaollard/efekv4/ma5lc7\n---\n\n```typescript\n{\n  \"took\" : 1,\n  \"timed_out\" : false,\n  \"_shards\" : {\n    \"total\" : 1,\n    \"successful\" : 1,\n    \"skipped\" : 0,\n    \"failed\" : 0\n  },\n  \"hits\" : {\n    \"total\" : {\n      \"value\" : 3,\n      \"relation\" : \"eq\"\n    },\n    \"max_score\" : 1.0,\n    \"hits\" : [\n      {\n        \"_index\" : \"index_02\",\n        \"_type\" : \"_doc\",\n        \"_id\" : \"UiPsXoMByQPvkdn1ZDUN\",\n        \"_score\" : 1.0,\n        \"_source\" : {\n          \"is_published\" : 1\n        }\n      },\n      {\n        \"_index\" : \"index_02\",\n        \"_type\" : \"_doc\",\n        \"_id\" : \"UyPsXoMByQPvkdn1eTUO\",\n        \"_score\" : 1.0,\n        \"_source\" : {\n          \"is_published\" : 2\n        }\n      },\n      {\n        \"_index\" : \"index_02\",\n        \"_type\" : \"_doc\",\n        \"_id\" : \"VCPsXoMByQPvkdn1pTWj\",\n        \"_score\" : 1.0,\n        \"_source\" : {\n          \"is_published\" : 0\n        }\n      }\n    ]\n  }\n}\n```\n\n\n\n### 1、runtime\\_mappings\n\n如果需要对布尔值进行转换，可以使用“运行时”脚本来处理，范例如下：\n\n```json\nGET index_02/_search\n{\n  \"fields\": [\n    {\"field\": \"weight\"}\n  ],\n  \"runtime_mappings\": {\n    \"weight\": {\n      \"type\": \"long\",\n      \"script\": \"emit(doc['is_published'].value > 1 ? 1: 0)\"\n    }\n  },\n  \"query\": {\n    \"term\": {\n      \"weight\": {\n        \"value\": 0\n      }\n    }\n  }\n}\n```\n\n```json\n{\n  \"took\" : 4,\n  \"timed_out\" : false,\n  \"_shards\" : {\n    \"total\" : 1,\n    \"successful\" : 1,\n    \"skipped\" : 0,\n    \"failed\" : 0\n  },\n  \"hits\" : {\n    \"total\" : {\n      \"value\" : 2,\n      \"relation\" : \"eq\"\n    },\n    \"max_score\" : 1.0,\n    \"hits\" : [\n      {\n        \"_index\" : \"index_02\",\n        \"_type\" : \"_doc\",\n        \"_id\" : \"UiPsXoMByQPvkdn1ZDUN\",\n        \"_score\" : 1.0,\n        \"_source\" : {\n          \"is_published\" : 1\n        },\n        \"fields\" : {\n          \"weight\" : [\n            0\n          ]\n        }\n      },\n      {\n        \"_index\" : \"index_02\",\n        \"_type\" : \"_doc\",\n        \"_id\" : \"VCPsXoMByQPvkdn1pTWj\",\n        \"_score\" : 1.0,\n        \"_source\" : {\n          \"is_published\" : 0\n        },\n        \"fields\" : {\n          \"weight\" : [\n            0\n          ]\n        }\n      }\n    ]\n  }\n}\n\n```\n\n\n\n### 2、script\\_fileds\n\n<https://www.elastic.co/guide/en/elasticsearch/reference/8.2/search-fields.html#script-fields>\n\n```json\nGET index_02/_search\n{\n  \"query\": {\n    \"match_all\": {}\n  },\n  \"script_fields\": {\n    \"test1\": {\n      \"script\": {\n        \"lang\": \"painless\",\n        \"source\": \"doc['is_published'].value * 2\"\n      }\n    }\n  },\n  \"_source\": [\"is_published\"]\n}\n```\n\n```json\n#! Elasticsearch built-in security features are not enabled. Without authentication, your cluster could be accessible to anyone. See https://www.elastic.co/guide/en/elasticsearch/reference/7.17/security-minimal-setup.html to enable security.\n{\n  \"took\" : 1,\n  \"timed_out\" : false,\n  \"_shards\" : {\n    \"total\" : 1,\n    \"successful\" : 1,\n    \"skipped\" : 0,\n    \"failed\" : 0\n  },\n  \"hits\" : {\n    \"total\" : {\n      \"value\" : 3,\n      \"relation\" : \"eq\"\n    },\n    \"max_score\" : 1.0,\n    \"hits\" : [\n      {\n        \"_index\" : \"index_02\",\n        \"_type\" : \"_doc\",\n        \"_id\" : \"UiPsXoMByQPvkdn1ZDUN\",\n        \"_score\" : 1.0,\n        \"_source\" : {\n          \"is_published\" : 1\n        },\n        \"fields\" : {\n          \"test1\" : [\n            2\n          ]\n        }\n      },\n      {\n        \"_index\" : \"index_02\",\n        \"_type\" : \"_doc\",\n        \"_id\" : \"UyPsXoMByQPvkdn1eTUO\",\n        \"_score\" : 1.0,\n        \"_source\" : {\n          \"is_published\" : 2\n        },\n        \"fields\" : {\n          \"test1\" : [\n            4\n          ]\n        }\n      },\n      {\n        \"_index\" : \"index_02\",\n        \"_type\" : \"_doc\",\n        \"_id\" : \"VCPsXoMByQPvkdn1pTWj\",\n        \"_score\" : 1.0,\n        \"_source\" : {\n          \"is_published\" : 0\n        },\n        \"fields\" : {\n          \"test1\" : [\n            0\n          ]\n        }\n      }\n    ]\n  }\n}\n```\n","isLeaf":true}]},{"key":"/Elasticsearch/03-映射规则","path":"/Elasticsearch/03-映射规则","route":"/Elasticsearch/03-映射规则","leaf":false,"title":"03-映射规则","depth":1,"content":"","isLeaf":false,"children":[{"key":"/Elasticsearch/03-映射规则/01-ES的映射.md","path":"/Elasticsearch/03-映射规则/01-ES的映射.md","route":"/Elasticsearch/03-映射规则/01-ES的映射.md","leaf":true,"title":"01-ES的映射","depth":2,"content":"---\ntitle: 01-ES的映射\nurl: https://www.yuque.com/gaollard/efekv4/npao96\n---\n\n\n\n### 1. 映射的介绍\n\n映射（Mapping）是定义文档及其包含的字段如何存储在索引库中的过程。\n\n映射定义还包括元数据字段（如\\_source字段），它自定义如何处理文档关联的元数据，而Elasticsearch支持 `动态映射` 和 `显式映射`。\n\n> 动态映射\n>\n> ES 会根据写入的文档内容自动添加字段和字段类型，用户只负责写入具体的数据即可。\n\n> 显式映射\n>\n> 显式映射需要用户精确地选择如何定义映射，例如哪些字符串字段应被视为全文字段，哪些字段是数字或者日期格式。显式索引是用于控制动态添加字段映射的自定义规则，而且在显示映射中使用 runtime（运行时映射）时无须重新创建索引就可以更改数据存储的规则。\n","isLeaf":true},{"key":"/Elasticsearch/03-映射规则/02-显式映射.md","path":"/Elasticsearch/03-映射规则/02-显式映射.md","route":"/Elasticsearch/03-映射规则/02-显式映射.md","leaf":true,"title":"02-显式映射","depth":2,"content":"---\ntitle: 02-显式映射\nurl: https://www.yuque.com/gaollard/efekv4/an5hpo\n---\n\n尽管动态映射很有用，但是为了满足业务的各种需求，有时还是需要为索引显式创建映射关系。语法如下：\n\n```json\n#创建名为 `myindex007` 的索引库并为其创建映射关系\nPUT /myindex007\n{\n  \"mappings\": {\n     \"properties\": {\n         \"name\":{\n            \"type\": \"text\"\n         },\n         \"age\":{\n           \"type\": \"long\"\n         },\n          \"actiontime\":\n          {\n            \"type\": \"date\",\n            \"format\":\"yyyy-MM-dd HH:mm:ss\" \n          },\n          \"describe\":\n          {\n            \"type\": \"keyword\"\n          }\n     }\n  } \n}\n```\n","isLeaf":true},{"key":"/Elasticsearch/03-映射规则/03-动态映射.md","path":"/Elasticsearch/03-映射规则/03-动态映射.md","route":"/Elasticsearch/03-映射规则/03-动态映射.md","leaf":true,"title":"03-动态映射","depth":2,"content":"---\ntitle: 03-动态映射\nurl: https://www.yuque.com/gaollard/efekv4/cugcsc\n---\n\n\n\n### 1. 动态映射\n\n使用动态映射在写入索引文档数据时，不需要先创建索引和定义字段。索引中的字段和字段类型都将自动创建。\n\n`Elasticsearch` 在用户写入数据时检测到新的字段时，会动态地将该字段添加到类型映射中，由 `dynamic` 参数来控制此行为。\n\n\n\n### 2. 动态模式 dynamic: true\n\n根据输入文档的内容，自动推断字段和类型，创建 mapping。\n\n```shell\n# 假设不存 test_04 索引\nPOST /test_04/_doc\n{\n  \"name\": \"hi\"\n}\n\n# 获取索引信息\nGET /test_04\n{\n  \"test_04\" : {\n    \"aliases\" : { },\n    \"mappings\" : {\n      \"properties\" : {\n        \"name\" : {\n          \"type\" : \"text\",\n          \"fields\" : {\n            \"keyword\" : {\n              \"type\" : \"keyword\",\n              \"ignore_above\" : 256\n            }\n          }\n        }\n      }\n    },\n    # 省略\n    \"settings\" : {}\n  }\n}\n```\n\n\n\n### 3. 非动态模式 dynamic: false\n\n无法根据输入文档的内容自动创建 mapping，需要手动创建 mapping。\n\n```shell\n# 假设不存 test_05 索引\nPUT test_05\n{\n \"mappings\": {\n   \"dynamic\": false,\n   \"properties\": {\n      \"name\": {\n        \"type\" : \"text\",\n        \"fields\" : {\n          \"keyword\" : {\n            \"type\" : \"keyword\",\n            \"ignore_above\" : 256\n          }\n        }\n      }\n   }\n }\n}\n\nGET /test_05\n{\n  \"test_05\" : {\n    \"aliases\" : { },\n    \"mappings\" : {\n      \"dynamic\" : \"false\",\n      \"properties\" : {\n        \"name\" : {\n          \"type\" : \"text\",\n          \"fields\" : {\n            \"keyword\" : {\n              \"type\" : \"keyword\",\n              \"ignore_above\" : 256\n            }\n          }\n        }\n      }\n    },\n    \"settings\" : {}\n  }\n}\n```\n\n如果有字段不在mapping中，依然可以存储和读取，但是该字段不在mapping中，因此也无法根据该字段进行检索。\n\n\n\n### 3. 严格模式 dynamic:strict\n\n类似非动态模式，如果有字段不在mapping中，无法存储，会直接报错，严格模式实际上就类似于关系型数据库中的表了；\n\n```shell\n# 假设不存 test_06 索引\nPUT test_06\n{\n \"mappings\": {\n   \"dynamic\": \"strict\",\n   \"properties\": {\n      \"name\": {\n        \"type\" : \"text\",\n        \"fields\" : {\n          \"keyword\" : {\n            \"type\" : \"keyword\",\n            \"ignore_above\" : 256\n          }\n        }\n      }\n   }\n }\n}\n\nGET /test_06\n{\n  \"test_06\" : {\n    \"aliases\" : { },\n    \"mappings\" : {\n      \"dynamic\" : \"strict\",\n      \"properties\" : {\n        \"name\" : {\n          \"type\" : \"text\",\n          \"fields\" : {\n            \"keyword\" : {\n              \"type\" : \"keyword\",\n              \"ignore_above\" : 256\n            }\n          }\n        }\n      }\n    },\n  }\n}\n```\n\n```shell\nPOST /test_06/_doc\n{\n  \"name\": \"hi\",\n  \"wife\": \"world\"\n}\n\n# 无法插入\n{\n  \"error\": {\n    \"root_cause\": [\n      {\n        \"type\": \"strict_dynamic_mapping_exception\",\n        \"reason\": \"mapping set to strict, dynamic introduction of [wife] within [_doc] is not allowed\"\n      }\n    ],\n    \"type\": \"strict_dynamic_mapping_exception\",\n    \"reason\": \"mapping set to strict, dynamic introduction of [wife] within [_doc] is not allowed\"\n  },\n  \"status\": 400\n}\n```\n\n\n\n#### 日期检测\n\n启用date\\_detection选项（默认启用），在检查新添加的字符串字段内容是否与指定的任何日期模式匹配时，如果找到匹配项，则会添加一个具有date格式的新字段。\n\n如果想要禁用日期检测，把date\\_detection参数设置为false即可：\n\n```shell\nPUT myindex\n{\n  \"mappings\": {\n    \"date_detection\": false\n  }\n}\n```\n\n禁用日期检测后，如果插入的数据为日期格式，那么其类型是text，而子类型是keyword。\n\n\n\n#### 数字检测\n\n```shell\n#创建映射并使用数字检测模式\nPUT myindex\n{\n  \"mappings\": {\n    \"numeric_detection\": true\n  }\n}\n\n#添加文档数据（默认使用动态映射）\nPUT myindex/_doc/1\n{\n  \"my_float\":   \"1.0\", \n  \"my_integer\": \"1\" \n}\n\n#查询映射信息\nGET myindex/_mapping\n{\n  \"myindex\" : {\n    \"mappings\" : {\n      \"numeric_detection\" : true,\n      \"properties\" : {\n        \"my_float\" : {\n          \"type\" : \"float\"\n        },\n        \"my_integer\" : {\n          \"type\" : \"long\"\n        }\n      }\n    }\n  }\n}\n```\n\n在没有开启数字检测模式时，无论是字段的父类型，还是子类型，都不会被映射为数字类型。\n","isLeaf":true},{"key":"/Elasticsearch/03-映射规则/04-动态映射模板.md","path":"/Elasticsearch/03-映射规则/04-动态映射模板.md","route":"/Elasticsearch/03-映射规则/04-动态映射模板.md","leaf":true,"title":"04-动态映射模板","depth":2,"content":"---\ntitle: 04-动态映射模板\nurl: https://www.yuque.com/gaollard/efekv4/lhry0u\n---\n\n\n\n### 1. 动态映射模板\n\n动态映射模板使得在默认的动态字段映射规则之外能够更好地控制 Elasticsearch 如何映射数据。\n\n用户可以通过将 `dynamic` 参数设置为 `true` 来启用动态映射模式，然后使用动态模板来定义自定义映射，这些映射可以根据匹配条件应用于动态添加的字段。\n\n\n\n### 2. 相关参数\n\n- match\\_mapping\\_type：表示对 Elasticsearch 检测到的数据类型进行操作。\n- match 和 unmatch：表示使用模式匹配来匹配字段名称。\n\n**语法**\n\n```json\n{\n  \"dynamic_templates\": [\n    {\n      \"my_template_name\": {\n        ... match conditions ...\n        \"mapping\": { ... }\n      }\n    },\n    ...\n  ]\n}\n```\n\n需要注意的是，如果动态映射模板未定义 match\\_mapping\\_type 或者 match 参数，则不会匹配任何字段。\n\n\n\n### 3. 使用范例\n\n```json\nPUT myindex\n{\n  \"mappings\": {\n    \"dynamic_templates\": [\n      {\n        \"one\": {\n          \"match_mapping_type\": \"long\",\n          \"mapping\": {\n            \"type\": \"integer\"\n          }\n        }\n      },\n      {\n        \"two\": {\n          \"match_mapping_type\": \"string\",\n          \"mapping\": {\n            \"type\": \"text\",\n            \"fields\": {\n              \"raw\": {\n                \"type\": \"keyword\",\n                \"ignore_above\": 256\n              }\n            }\n          }\n        }\n      }\n    ]\n  }\n}\n```\n\n当添加文档的时候，如果Elasticsearch程序中的JsonParser对象解析出来的类型是match\\_mapping\\_type指定的类型，程序就会使用对应的mapping作为映射规则。\n","isLeaf":true}]},{"key":"/Elasticsearch/04-分词器","path":"/Elasticsearch/04-分词器","route":"/Elasticsearch/04-分词器","leaf":false,"title":"04-分词器","depth":1,"content":"","isLeaf":false,"children":[{"key":"/Elasticsearch/04-分词器/01-分词器.md","path":"/Elasticsearch/04-分词器/01-分词器.md","route":"/Elasticsearch/04-分词器/01-分词器.md","leaf":true,"title":"01-分词器","depth":2,"content":"---\ntitle: 01-分词器\nurl: https://www.yuque.com/gaollard/efekv4/ypgn4p\n---\n\n“分词” 是在 Elasticsearch 中进行存储和全文搜索的一个很重要的部分，因为只有选择合适的分词器才能更高效地进行全文搜索。Elasticsearch 中提供了多种内置的分词器，针对不同的场景可以使用不同的分词器。这些分词器只对 `text` 类型字段有效，而对于 `keyword` 类型字段无效。本章主要内容\n\n- simple 分词器详解\n- simple\\_pattern 分词器详解\n- simple\\_pattern\\_split 分词器详解\n- text类型和keyword类型的区别\n- IK分词器插件的各种环境安装\n- IK分词器的使用模式和范例\n\n\n\n### simple 分词器\n\nsimple 分词器是对字母文本进行分词拆分，并将分词后的内容转换成小写格式。范例如下：\n\n```shell\n#对指定内容根据\"simple\"分词器进行分词\nPOST _analyze\n{\n  \"analyzer\": \"simple\",\n  \"text\": \"Our usual study and experience are our most powerful support at a critical moment\"\n}\n```\n\n\"Our usual study and experience are our most powerful support at acritical moment\"被分成了14个关键字并且所有字母都是小写的。\n\n\n\n### simple\\_pattern 分词器\n\n根据正则表达式进行分词的分词器:\n\n```shell\n#创建映射并定义字段内容分词的正则表达式\nPUT myindex-simple_pattern\n{\n  \"settings\": {\n    \"analysis\": {\n      \"analyzer\": {\n        \"my_analyzer\": {\n          \"tokenizer\": \"my_tokenizer\"\n        }\n      },\n      \"tokenizer\": {\n        \"my_tokenizer\": {\n          \"type\": \"simple_pattern\", #正则表达式表示，如果连续有3个数字在一起，则可以被当作一个单词\n          \"pattern\": \"[0123456789]{3}\" \n        }\n      }\n    }\n  }\n}\n\n#对指定内容根据\"my_analyzer\"分词器进行分词\nPOST myindex-simple_pattern/_analyze\n{\n  \"analyzer\": \"my_analyzer\",\n  \"text\": \"fd-123-4567-890-xxd9-689-x987\"\n}\n\n\n{\n  \"tokens\" : [\n    {\n      \"token\" : \"123\",\n      \"start_offset\" : 3,\n      \"end_offset\" : 6,\n      \"type\" : \"word\",\n      \"position\" : 0\n    },\n    {\n      \"token\" : \"456\",\n      \"start_offset\" : 7,\n      \"end_offset\" : 10,\n      \"type\" : \"word\",\n      \"position\" : 1\n    },\n    {\n      \"token\" : \"890\",\n      \"start_offset\" : 12,\n      \"end_offset\" : 15,\n      \"type\" : \"word\",\n      \"position\" : 2\n    },\n    {\n      \"token\" : \"689\",\n      \"start_offset\" : 21,\n      \"end_offset\" : 24,\n      \"type\" : \"word\",\n      \"position\" : 3\n    },\n    {\n      \"token\" : \"987\",\n      \"start_offset\" : 26,\n      \"end_offset\" : 29,\n      \"type\" : \"word\",\n      \"position\" : 4\n    }\n  ]\n}\n```\n\n\n\n### simple\\_pattern\\_split 分词器\n\nsimple\\_pattern\\_split（指定分词符号）分词器比 `simple_pattern` 分词器功能更有限，但是分词效率较高。默认模式下，它的分词匹配符号是空字符串。需要注意的是，使用此分词器应该根据业务进行配置，而不是简单地使用默认匹配模式。范例如下：\n\n```shell\n#创建索引映射并指定字段内容分词匹配符号\nPUT myindex-simple_pattern_split\n{\n  \"settings\": {\n    \"analysis\": {\n      \"analyzer\": {\n        \"my_analyzer\": {\n          \"tokenizer\": \"my_tokenizer\"\n        }\n      },\n      \"tokenizer\": {\n        \"my_tokenizer\": {\n          \"type\": \"simple_pattern_split\",\n          #当遇到\"-\"符号就进行分词\n          \"pattern\": \"-\"\n        }\n      }\n    }\n  }\n}\n\n#对指定内容根据\"-\"分隔符匹配规则进行分词\nPOST myindex-simple_pattern_split/_analyze\n{\n  \"analyzer\": \"my_analyzer\",\n  \"text\": \"fd-123-4567896-890-xxd9-689-x987\"\n}\n\n{\n  \"tokens\" : [\n    {\n      \"token\" : \"fd\",\n      \"start_offset\" : 0,\n      \"end_offset\" : 2,\n      \"type\" : \"word\",\n      \"position\" : 0\n    },\n    {\n      \"token\" : \"123\",\n      \"start_offset\" : 3,\n      \"end_offset\" : 6,\n      \"type\" : \"word\",\n      \"position\" : 1\n    },\n    {\n      \"token\" : \"4567896\",\n      \"start_offset\" : 7,\n      \"end_offset\" : 14,\n      \"type\" : \"word\",\n      \"position\" : 2\n    },\n    {\n      \"token\" : \"890\",\n      \"start_offset\" : 15,\n      \"end_offset\" : 18,\n      \"type\" : \"word\",\n      \"position\" : 3\n    },\n    {\n      \"token\" : \"xxd9\",\n      \"start_offset\" : 19,\n      \"end_offset\" : 23,\n      \"type\" : \"word\",\n      \"position\" : 4\n    },\n    {\n      \"token\" : \"689\",\n      \"start_offset\" : 24,\n      \"end_offset\" : 27,\n      \"type\" : \"word\",\n      \"position\" : 5\n    },\n    {\n      \"token\" : \"x987\",\n      \"start_offset\" : 28,\n      \"end_offset\" : 32,\n      \"type\" : \"word\",\n      \"position\" : 6\n    }\n  ]\n}\n```\n\n\n\n### standard 分词器\n\nstandard（标准）分词器是Elasticsearch中默认的分词器，它是基于Unicode文本分割算法进行分词的。范例如下：\n\n```shell\n#对指定内容根据standard分词器进行分词\nPOST _analyze\n{\n  \"analyzer\": \"standard\",\n  \"text\": \"Our usual study and experience are our most powerful support at a critical moment\"\n}\n\n[\"Our\",\"usual\",\"study\",\"and\",\"experience\",\"are\",\"our\",\"most\",\"powerful \",\"support\",\" at\",\" a\",\" critical\",\" moment\"]\n```\n\nstandard分词器还提供了表4-1所示的两种参数。\n\n![](https://s3.airtlab.com/elasticsearch/20220428213706.png)\n\n```shell\n#创建索引映射，对分词规则进行配置，规则是分词后单词的最大长度是6，根据英语语法进行分析\nPUT standard_index\n{\n  \"settings\": {\n    \"analysis\": {\n      \"analyzer\": {\n        \"english_analyzer\":{\n          \"type\":\"standard\",\n          \"max_token_length\":6,\n          \"stopwords\":\"_english_\"\n        }\n      }\n    }\n  }\n}\n\n#对指定内容根据如上规则进行分词\nPOST standard_index/_analyze\n{\n  \"analyzer\": \"english_analyzer\",\n  \"text\": \"Our usual study and experience are our most powerful support at a critical moment\"\n}\n```\n","isLeaf":true},{"key":"/Elasticsearch/04-分词器/02-自定义与standard类似的分词器.md","path":"/Elasticsearch/04-分词器/02-自定义与standard类似的分词器.md","route":"/Elasticsearch/04-分词器/02-自定义与standard类似的分词器.md","leaf":true,"title":"02-自定义与standard类似的分词器","depth":2,"content":"---\ntitle: 02-自定义与standard类似的分词器\nurl: https://www.yuque.com/gaollard/efekv4/lex3et\n---\n\n如果希望自定义一个与standard类似的分词器，用户只需要在原定义中配置参数即可。范例如下：\n\n```shell\n#创建索引映射，自定义一个分词器规则：根据关键字（keyword）类型分词，将单词全部转成小写\nPUT custom_standard_analyzer_index\n{\n  \"settings\": {\n    \"analysis\": {\n      \"analyzer\": {\n        \"rebuild_analyzer\":{\n          \"type\":\"keyword\",          #根据关键字类型分词\n          \"tokenizer\":\"standard\",\n          \"filter\":[\"lowercase\"]    #单词都转成小写\n        }\n      }\n    }\n  }\n}\n\n#对指定内容根据如上自定义的分词规则进行分词\nPOST custom_standard_analyzer_index/_analyze\n{\n  \"text\": \"Our usual study and experience are our most powerful support at a critical moment\"\n}\n```\n","isLeaf":true},{"key":"/Elasticsearch/04-分词器/03-keyword类型和text类型的区别.md","path":"/Elasticsearch/04-分词器/03-keyword类型和text类型的区别.md","route":"/Elasticsearch/04-分词器/03-keyword类型和text类型的区别.md","leaf":true,"title":"03-keyword类型和text类型的区别","depth":2,"content":"---\ntitle: 03-keyword类型和text类型的区别\nurl: https://www.yuque.com/gaollard/efekv4/bypwst\n---\n\n- text字段类型会进行分词处理，然后根据分词后的单词建立倒排索引（反向索引），因而不支持聚合计算。\n- keyword字段类型不会进行分词处理，直接根据字符串的内容建立倒排索引（反向索引），支持聚合计算和排序操作。\n","isLeaf":true},{"key":"/Elasticsearch/04-分词器/04-IK分词器.md","path":"/Elasticsearch/04-分词器/04-IK分词器.md","route":"/Elasticsearch/04-分词器/04-IK分词器.md","leaf":true,"title":"04-IK分词器","depth":2,"content":"---\ntitle: 04-IK分词器\nurl: https://www.yuque.com/gaollard/efekv4/zpv14b\n---\n\n前面的范例创建索引、搜索数据时都是使用默认的分词器，因为存储的都是中文，所以分词效果不太理想，会把 text 的字段分成`一个个汉字`，为了更好地对中文内容进行分词，需要更加智能的 IK 分词器。\n\n```shell\n#对内容\"内心没有分别心，就是真正的苦行\"利用IK分词器进行分析\nPOST _analyze\n{\n  \"analyzer\": \"ik_max_word\",\n  \"text\": \"内心没有分别心，就是真正的苦行\"\n}\n\n{\n  \"tokens\" : [\n    {\n      \"token\" : \"内心\",\n      \"start_offset\" : 0,\n      \"end_offset\" : 2,\n      \"type\" : \"CN_WORD\",\n      \"position\" : 0\n    },\n    {\n      \"token\" : \"没有\",\n      \"start_offset\" : 2,\n      \"end_offset\" : 4,\n      \"type\" : \"CN_WORD\",\n      \"position\" : 1\n    },\n    {\n      \"token\" : \"分别\",\n      \"start_offset\" : 4,\n      \"end_offset\" : 6,\n      \"type\" : \"CN_WORD\",\n      \"position\" : 2\n    },\n    {\n      \"token\" : \"心\",\n      \"start_offset\" : 6,\n      \"end_offset\" : 7,\n      \"type\" : \"CN_CHAR\",\n      \"position\" : 3\n    },\n    {\n      \"token\" : \"就是\",\n      \"start_offset\" : 8,\n      \"end_offset\" : 10,\n      \"type\" : \"CN_WORD\",\n      \"position\" : 4\n    },\n    {\n      \"token\" : \"真正\",\n      \"start_offset\" : 10,\n      \"end_offset\" : 12,\n      \"type\" : \"CN_WORD\",\n      \"position\" : 5\n    },\n    {\n      \"token\" : \"的\",\n      \"start_offset\" : 12,\n      \"end_offset\" : 13,\n      \"type\" : \"CN_CHAR\",\n      \"position\" : 6\n    },\n    {\n      \"token\" : \"苦行\",\n      \"start_offset\" : 13,\n      \"end_offset\" : 15,\n      \"type\" : \"CN_WORD\",\n      \"position\" : 7\n    }\n  ]\n}\n```\n\nIK 分词器的两种分词模式:\n\n1）ik\\_max\\_word：对文本进行最细粒度的拆分。\n\n2）ik\\_smart：对文本进行最粗粒度的拆分。\n\n\n\n### ik\\_max\\_word\n\n- 使用 ik\\_max\\_word 模式将\"中华人民共和国国歌\"拆分为 `\"[中华人民共和国，中华人民，中华，华人，人民共和国，人民，共和国，共和，国，国歌]\"`，产生了各种可能的组合，即不同的词。\n- 使用 ik\\_max\\_word 模式将\"我是中国人\"拆分为 `\"[我，是，中国人，中国，国人]\"`，产生了各种可能的组合\n\n\n\n### ik\\_smart\n\n- 使用 ik\\_smart 模式将\"中华人民共和国国歌\"拆分为\"\\[中华人民共和国，国歌]\"，产生了尽可能少的组合。\n- 使用 ik\\_smart 模式将\"我是中国人\"拆分为 `\"[我，是，中国人]\"`，产生尽可能少的组合\n\n\n\n### 创建使用 IK 分词器的索引映射\n\n一般在创建索引时会明确指定分词的模式，总共有两种操作：一种是让所有 text 类型的字段都使用分词模式，另一种是给每一种 text 类型的字段指定分词模式。\n\n\n\n#### 让所有 text 类型的字段都使用分词模式\n\n```shell\n#创建索引模板，所有\"text\"类型的字段都使用IK分词器的\"ik_max_word\"模式\nPUT myindex_ik\n{\n  \"settings\":{\n    \"analysis\":{\n      \"analyzer\":{\n        \"ik\":{\n          \"tokenizer\":\"ik_max_word\"\n        }\n      }\n    }\n  },\n  \"mappings\":{\n      \"properties\":{\n        \"field1\":{\n          \"type\":\"text\"\n        },\n        \"field2\":{\n          \"type\":\"integer\"\n        },\n        \"field3\":{\n          \"type\":\"text\"\n        },\n        \"field4\":{\n          \"type\":\"text\"\n        }\n    }\n  }\n}\n```\n\n\n\n#### 给每一种 text 类型的字段指定分词模式\n\n```shell\nPUT myindex_ik_01\n{\n  \"mappings\":{\n      \"properties\":{\n        \"field1\":{\n          \"type\":\"text\",\n          \"analyzer\": \"ik_max_word\",\n                     \"search_analyzer\": \"ik_max_word\"\n        },\n        \"field2\":{\n          \"type\":\"integer\"\n        },\n        \"field3\":{\n          \"type\":\"text\",\n          \"analyzer\": \"standard\",\n             \"search_analyzer\": \"standard\"\n        },\n        \"field4\":{\n          \"type\":\"text\",\n          \"analyzer\": \"ik_max_word\",\n            \"search_analyzer\": \" ik_smart \"\n        }\n    }\n  }\n}\n```\n\n\n\n### 存储和搜索使用不同的分词模式\n\n```shell\n#创建索引映射，存储时使用IK分词器的ik_max_word模式，搜索时使用IK分词器的ik_smart模式\nPUT /clayindex_ik\n{\n  \"mappings\": {\n    \"properties\": {\n    \"name\":{\n      \"type\": \"keyword\"\n    },\n    \"address\":{\n      \"type\": \"text\",\n      \"analyzer\": \"ik_max_word\",\n      \"search_analyzer\": \"ik_smart\" #设置默认的搜索分词模式\n    },\n    \"age\":{\n      \"type\": \"integer\"\n    }\n  }\n}\n\n#插入文档数据\nPOST  /clayindex_ik/_doc\n{\n  \"name\":\"曹操\",\n  \"address\":\"魏国\",\n  \"age\":18\n}\n\n#插入文档数据\nPOST  /clayindex_ik/_doc\n{\n  \"name\":\"贾诩\",\n  \"address\":\"魏国\",\n  \"age\":19\n}\n\n#插入文档数据\nPOST  /clayindex_ik/_doc\n{\n  \"name\":\"诸葛亮\",\n  \"address\":\"蜀国\",\n  \"age\":37\n}\n\n#插入文档数据\nPOST  /clayindex_ik/_doc\n{\n  \"name\":\"关羽\",\n  \"address\":\"蜀国\",\n  \"age\":35\n}\n\n#插入文档数据\nPOST  /clayindex_ik/_doc\n{\n  \"name\":\"周瑜\",\n  \"address\":[\"吴国\",\"蜀国\"],\n  \"age\":25\n}\n\n#全文搜索address等于\"魏国\"的数据，并指定分词模式\nPOST clayindex_ik/_doc/_search\n{\n  \"query\":{\n     \"match\": {\n       \"address\": {\n         \"query\": \"魏国\",\n          \"analyzer\": \"ik_smart\" #这句可以不写，因为默认就是这种模式\n       }\n     }\n  }\n}\n```\n\n需要注意的是，因为我们在设置映射模板时使用最细粒度进行分词存储（分词尽可能多），所以在搜索时可以指定对最细粒度的分词模式和最粗粒度的分词模式分别搜索。在正式项目的使用中也推荐这种做法，存储时选择尽量细的分词规则，这样在搜索时可以指定符合具体项目要求的分词模式。\n","isLeaf":true}]},{"key":"/Elasticsearch/05-基础查询","path":"/Elasticsearch/05-基础查询","route":"/Elasticsearch/05-基础查询","leaf":false,"title":"05-基础查询","depth":1,"content":"","isLeaf":false,"children":[{"key":"/Elasticsearch/05-基础查询/01-批量插入数据.md","path":"/Elasticsearch/05-基础查询/01-批量插入数据.md","route":"/Elasticsearch/05-基础查询/01-批量插入数据.md","leaf":true,"title":"01-批量插入数据","depth":2,"content":"---\ntitle: 01-批量插入数据\nurl: https://www.yuque.com/gaollard/efekv4/gn8t8g\n---\n\n```shell\nPOST /userinfo/_doc/_bulk\n{ \"index\": {}}\n{\"name\":\"张三\",\"address\":\"中国\",\"age\":18}\n{ \"index\": {}}\n{\"name\":\"李四\",\"address\":\"中国\",\"age\":19}\n{ \"index\": {}}\n{\"name\":\"王五\",\"address\":\"美国\",\"age\":20}\n{ \"index\": {}}\n{\"name\":\"赵六\",\"address\":\"美国\",\"age\":21}\n```\n","isLeaf":true},{"key":"/Elasticsearch/05-基础查询/02-查询所有数据.md","path":"/Elasticsearch/05-基础查询/02-查询所有数据.md","route":"/Elasticsearch/05-基础查询/02-查询所有数据.md","leaf":true,"title":"02-查询所有数据","depth":2,"content":"---\ntitle: 02-查询所有数据\nurl: https://www.yuque.com/gaollard/efekv4/ob3gn2\n---\n\n```shell\n#查询userinfo索引库中所有的文档数据\nGET /userinfo/_search\n{\n  \"query\": { \"match_all\": {} }\n}\n\n{\n  \"took\" : 3,\n  \"timed_out\" : false,\n  \"_shards\" : {\n    \"total\" : 1,\n    \"successful\" : 1,\n    \"skipped\" : 0,\n    \"failed\" : 0\n  },\n  \"hits\" : {\n    \"total\" : {\n      \"value\" : 4,\n      \"relation\" : \"eq\"\n    },\n    \"max_score\" : 1.0,\n    \"hits\" : [\n      {\n        \"_index\" : \"userinfo\",\n        \"_type\" : \"_doc\",\n        \"_id\" : \"FhDqW3oBiBO67ReogO86\",\n        \"_score\" : 1.0,\n        \"_source\" : {\n          \"name\" : \"张三\",\n          \"address\" : \"中国\",\n          \"age\" : 18\n        }\n      },\n      {\n        \"_index\" : \"userinfo\",\n        \"_type\" : \"_doc\",\n        \"_id\" : \"FxDqW3oBiBO67ReogO86\",\n        \"_score\" : 1.0,\n        \"_source\" : {\n          \"name\" : \"李四\",\n          \"address\" : \"中国\",\n          \"age\" : 19\n        }\n      },\n      {\n        \"_index\" : \"userinfo\",\n        \"_type\" : \"_doc\",\n        \"_id\" : \"GBDqW3oBiBO67ReogO86\",\n        \"_score\" : 1.0,\n        \"_source\" : {\n          \"name\" : \"王五\",\n          \"address\" : \"美国\",\n          \"age\" : 20\n        }\n      },\n      {\n        \"_index\" : \"userinfo\",\n        \"_type\" : \"_doc\",\n        \"_id\" : \"GRDqW3oBiBO67ReogO86\",\n        \"_score\" : 1.0,\n        \"_source\" : {\n          \"name\" : \"赵六\",\n          \"address\" : \"美国\",\n          \"age\" : 21\n        }\n      }\n    ]\n  }\n}\n```\n\n- took：表示查询所花费的时间，以毫秒为单位。\n- timed\\_out：表示查询请求是否超时。\n- shards：表示总共查询了多少个分片，以及是否成功。\n- max\\_score：表示查询到的相关文档的分数，分数越高，匹配度就越高。\n- hits.total.value：表示找到了多少个匹配的文档。\n- hits.\\_score：表示当前文档和查询内容的匹配度，使用match\\_all时，此字段的值没有任何意义。\n\n```shell\nGET /test_01/_search\n{\n  \"size\": 15000, #size 不能超过阈值(默认 10000，可以修改)\n  \"query\": { \"match_all\": {} }\n}\n\n{\n  \"error\": {\n    \"root_cause\": [\n      {\n        \"type\": \"illegal_argument_exception\",\n        \"reason\": \"Result window is too large, from + size must be less than or equal to: [10000] but was [15000]. See the scroll api for a more efficient way to request large data sets. This limit can be set by changing the [index.max_result_window] index level setting.\"\n      }\n    ],\n    \"type\": \"search_phase_execution_exception\",\n    \"reason\": \"all shards failed\",\n    \"phase\": \"query\",\n    \"grouped\": true,\n    \"failed_shards\": [\n      {\n        \"shard\": 0,\n        \"index\": \"test_01\",\n        \"node\": \"6JMu0nfCS5-dMb93AppHeQ\",\n        \"reason\": {\n          \"type\": \"illegal_argument_exception\",\n          \"reason\": \"Result window is too large, from + size must be less than or equal to: [10000] but was [15000]. See the scroll api for a more efficient way to request large data sets. This limit can be set by changing the [index.max_result_window] index level setting.\"\n        }\n      }\n    ],\n    \"caused_by\": {\n      \"type\": \"illegal_argument_exception\",\n      \"reason\": \"Result window is too large, from + size must be less than or equal to: [10000] but was [15000]. See the scroll api for a more efficient way to request large data sets. This limit can be set by changing the [index.max_result_window] index level setting.\",\n      \"caused_by\": {\n        \"type\": \"illegal_argument_exception\",\n        \"reason\": \"Result window is too large, from + size must be less than or equal to: [10000] but was [15000]. See the scroll api for a more efficient way to request large data sets. This limit can be set by changing the [index.max_result_window] index level setting.\"\n      }\n    }\n  },\n  \"status\": 400\n}\n```\n","isLeaf":true},{"key":"/Elasticsearch/05-基础查询/03-排序查询.md","path":"/Elasticsearch/05-基础查询/03-排序查询.md","route":"/Elasticsearch/05-基础查询/03-排序查询.md","leaf":true,"title":"03-排序查询","depth":2,"content":"---\ntitle: 03-排序查询\nurl: https://www.yuque.com/gaollard/efekv4/xgv2yr\n---\n\n```shell\n#查询userinfo索引库中所有的文档数据，根据age字段进行倒序输出\nGET /userinfo/_search\n{\n  \"query\": { \"match_all\": {} },\n  \"sort\":[\n    {\"age\":{\"order\":\"desc\"}}\n  ]\n}\n```\n\n如果需要根据多个字段排序，则可以使用下面的语句：\n\n```shell\nGET /索引名称/_search\n{\n  \"query\": { \"match_all\": {} },\n   \"sort\":[\n    {\"field1\":{\"order\":\"desc\"}},\n    {\"field2\":{\"order\":\"asc\"}}\n    ]\n}\n```\n\n以上语句表示先根据field1字段进行倒序排序，再根据field2字段进行顺序排序。\n\n要注意的是，排序字段不可以是text等特殊类型，一般是整数类型和keyword类型。\n","isLeaf":true},{"key":"/Elasticsearch/05-基础查询/04-根据需求返回相应的字段.md","path":"/Elasticsearch/05-基础查询/04-根据需求返回相应的字段.md","route":"/Elasticsearch/05-基础查询/04-根据需求返回相应的字段.md","leaf":true,"title":"04-根据需求返回相应的字段","depth":2,"content":"---\ntitle: 04-根据需求返回相应的字段\nurl: https://www.yuque.com/gaollard/efekv4/urovh6\n---\n\n```shell\nGET /索引名称/_search\n{\n  \"query\": { 查询语句 },\n  \"_source\":[\"字段1\",\"字段2\",…]\n}\n```\n","isLeaf":true},{"key":"/Elasticsearch/05-基础查询/05-分页查询.md","path":"/Elasticsearch/05-基础查询/05-分页查询.md","route":"/Elasticsearch/05-基础查询/05-分页查询.md","leaf":true,"title":"05-分页查询","depth":2,"content":"---\ntitle: 05-分页查询\nurl: https://www.yuque.com/gaollard/efekv4/uf8gc4\n---\n\n```shell\nGET /索引库名称/_search\n{\n  \"query\": { 查询语句 },\n  \"_source\":[\"字段1\",\"字段2\",…],\n  \"from\":0,\n  \"size\":10\n}\n```\n\n以上语句将查询userinfo索引库的所有文档数据，并根据age字段按顺序排序，返回从第0条到第2条的文档数据，只包含name和age字段的内容。\n\n注意，from 和 size 只起到过滤的作用\n","isLeaf":true},{"key":"/Elasticsearch/05-基础查询/06-特定字词匹配(match).md","path":"/Elasticsearch/05-基础查询/06-特定字词匹配(match).md","route":"/Elasticsearch/05-基础查询/06-特定字词匹配(match).md","leaf":true,"title":"06-特定字词匹配(match)","depth":2,"content":"---\ntitle: 06-特定字词匹配(match)\nurl: https://www.yuque.com/gaollard/efekv4/tqhg6b\n---\n\n```shell\nGET /索引库名称/_search\n{\n  \"query\": {\n    \"match\": {\n      \"address\": \"查询内容\"\n    }\n  }\n}\n```\n\n```shell\nGET /userinfo/_search\n{\n  \"query\": {\n    \"match\": {\n      \"address\": \"中国，美国\"\n    }\n  }\n}\n```\n\n搜索 address 字段中包含\"中国\"或者\"美国\"的文档数据\n","isLeaf":true},{"key":"/Elasticsearch/05-基础查询/07-段落匹配查询(match_phrase).md","path":"/Elasticsearch/05-基础查询/07-段落匹配查询(match_phrase).md","route":"/Elasticsearch/05-基础查询/07-段落匹配查询(match_phrase).md","leaf":true,"title":"07-段落匹配查询(match_phrase)","depth":2,"content":"---\ntitle: 07-段落匹配查询(match_phrase)\nurl: https://www.yuque.com/gaollard/efekv4/lm7e38\n---\n\n因为查询的时候两个内容之间有空格，所以被当作分隔符处理，查询内容被分词，如果想要查询的内容不被分词，可使用match\\_phrase查询。\n\n```shell\nGET /userinfo_002/_search\n{\n   \"query\": { \n     \"match_phrase\": \n     { \n       \"address\": \"中国 上海\" \n     } \n   }\n}\n```\n","isLeaf":true},{"key":"/Elasticsearch/05-基础查询/08-term精准查询.md","path":"/Elasticsearch/05-基础查询/08-term精准查询.md","route":"/Elasticsearch/05-基础查询/08-term精准查询.md","leaf":true,"title":"08-term精准查询","depth":2,"content":"---\ntitle: 08-term精准查询\nurl: https://www.yuque.com/gaollard/efekv4/skwyge\n---\n\n在Elasticsearch中使用term和前面使用match\\_phrase的效果类似\n","isLeaf":true}]},{"key":"/Elasticsearch/06-全文检索","path":"/Elasticsearch/06-全文检索","route":"/Elasticsearch/06-全文检索","leaf":false,"title":"06-全文检索","depth":1,"content":"","isLeaf":false,"children":[{"key":"/Elasticsearch/06-全文检索/01-全文搜索match匹配.md","path":"/Elasticsearch/06-全文检索/01-全文搜索match匹配.md","route":"/Elasticsearch/06-全文检索/01-全文搜索match匹配.md","leaf":true,"title":"01-全文搜索match匹配","depth":2,"content":"---\ntitle: 01-全文搜索match匹配\nurl: https://www.yuque.com/gaollard/efekv4/gmzg5h\n---\n\n在 Elasticsearch 中进行全文搜索时，如果要给字段指定要查询的特定字词，可以使用 match 类型的查询\n\n```shell\n#数据准备\nPOST /myindex-test-match/_bulk\n{ \"index\": { \"_id\": 1 }}\n{ \"title\": \"The flower and the dog\" }\n{ \"index\": { \"_id\": 2 }}\n{ \"title\": \"The flower and the dog are beautiful\" }\n{ \"index\": { \"_id\": 3 }}\n{ \"title\": \"the dog are beautiful\" }\n\n#使用match类型的查询\nGET /myindex-test-match/_search\n{\n  \"query\": {\n    \"match\": {\n      \"title\": \"flower\"\n    }\n  }\n}\n```\n\n以上语句执行match查询的步骤如下：\n\n- 1）检查字段类型。title字段是text类型（内容会被分词），说明此字段在存储时和查询时都会进行分词，而且在存储时会建立倒排索引。\n- 2）分析查询字符串。将查询的字符串\"flower\"传入标准分词器中，输出的结果是单词\"flower\"。因为只有一个单词，所以match查询执行的是单个底层term查询。\n- 3）查找匹配的文档。用term查询在倒排索引中查找\"flower\"，然后获取一组包含该单词的文档数据。\n- 4）为每个文档评分。用term查询计算出每个文档的评分。\n\n使用match查询时，返回结果中文档的评分是和该文档中字段的内容长度有关的，即字段内容越短，评分就越高。\n","isLeaf":true},{"key":"/Elasticsearch/06-全文检索/02-match多个词查询.md","path":"/Elasticsearch/06-全文检索/02-match多个词查询.md","route":"/Elasticsearch/06-全文检索/02-match多个词查询.md","leaf":true,"title":"02-match多个词查询","depth":2,"content":"---\ntitle: 02-match多个词查询\nurl: https://www.yuque.com/gaollard/efekv4/tuzpdq\n---\n\n```shell\n#数据准备\nPOST /myindex-test-match/_bulk\n{ \"index\": { \"_id\": 1 }}\n{ \"title\": \"The flower and the dog\" }\n{ \"index\": { \"_id\": 2 }}\n{ \"title\": \"The flower and the dog are beautiful\" }\n{ \"index\": { \"_id\": 3 }}\n{ \"title\": \"the dog are beautiful\" }\n\n#使用match类型的查询\nGET /myindex-test-match/_search\n{\n  \"query\": {\n    \"match\": {\n      \"title\": \"flower dog\" # 这里不支持数组啊 [\"dog\", \"and\"]\n    }\n  }\n}\n```\n\nmatch查询必须查找两个单词（\"flower\"和\"dog\"），它在内部实际上先执行两次term查询，然后将两次查询的结果合并起来作为最终的查询结果\n","isLeaf":true},{"key":"/Elasticsearch/06-全文检索/03-全文搜索的query_string查询.md","path":"/Elasticsearch/06-全文检索/03-全文搜索的query_string查询.md","route":"/Elasticsearch/06-全文检索/03-全文搜索的query_string查询.md","leaf":true,"title":"03-全文搜索的query_string查询","depth":2,"content":"---\ntitle: 03-全文搜索的query_string查询\nurl: https://www.yuque.com/gaollard/efekv4/gqeh3s\n---\n\nquery\\_string查询是根据运算符（AND/OR）来解析和拆分要搜索的字符串。范例如下：\n\n```shell\nGET /myindex-test-match/_search\n{\n  \"query\": {\n    \"query_string\": {\n      \"query\": \"(dog and) AND (beautiful)\",\n      \"default_field\": \"title\"\n    }\n  }\n}\n```\n\n在以上语句中，查询索引库的title字段，必须匹配到beautiful单词，并且必须匹配dog和and其中任何一个单词的字段。\n","isLeaf":true},{"key":"/Elasticsearch/06-全文检索/04-全文搜索的simple_query_string查询.md","path":"/Elasticsearch/06-全文检索/04-全文搜索的simple_query_string查询.md","route":"/Elasticsearch/06-全文检索/04-全文搜索的simple_query_string查询.md","leaf":true,"title":"04-全文搜索的simple_query_string查询","depth":2,"content":"---\ntitle: 04-全文搜索的simple_query_string查询\nurl: https://www.yuque.com/gaollard/efekv4/brdsn9\n---\n\nsimple\\_query\\_string查询是一种使用简单的语法来解析要查询的字符串，并将其拆分为基于特殊运算符的查询方式。其语法比query\\_string查询更受限制，但simple\\_query\\_string查询在遭遇无效语法事不会返回错误提示信息\n","isLeaf":true},{"key":"/Elasticsearch/06-全文检索/05-全文搜索的顺序匹配查询.md","path":"/Elasticsearch/06-全文检索/05-全文搜索的顺序匹配查询.md","route":"/Elasticsearch/06-全文检索/05-全文搜索的顺序匹配查询.md","leaf":true,"title":"05-全文搜索的顺序匹配查询","depth":2,"content":"---\ntitle: 05-全文搜索的顺序匹配查询\nurl: https://www.yuque.com/gaollard/efekv4/xiwkc5\n---\n\nintervals是时间间隔的意思，在Elasticsearch中它本质上是将多个规则按照顺序匹配。范例如下：\n\n```shell\nGET /myindex-test-match/_search\n{\n  \"query\": {\n    \"intervals\" : {\n      \"title\" : {\n        \"all_of\" : {\n          \"ordered\" : true,\n          \"intervals\" : [\n            {\n              \"match\" : {\n                \"query\" : \"flower\",#文档内容先匹配\"flower\"单词\n                \"max_gaps\" : 0,\n                \"ordered\" : true\n              }\n            },\n            {\n              \"any_of\" : {\n                \"intervals\" : [  #文档内容再匹配\"beautiful\"和\"dog\"两个单词中的其中一个\n                  { \"match\" : { \"query\" : \"beautiful\" } },\n                  { \"match\" : { \"query\" : \"dog\" } }\n                ]\n              }\n            }\n          ]\n        }\n      }\n    }\n  }\n}\n```\n","isLeaf":true},{"key":"/Elasticsearch/06-全文检索/06-全文搜索的高亮查询.md","path":"/Elasticsearch/06-全文检索/06-全文搜索的高亮查询.md","route":"/Elasticsearch/06-全文检索/06-全文搜索的高亮查询.md","leaf":true,"title":"06-全文搜索的高亮查询","depth":2,"content":"---\ntitle: 06-全文搜索的高亮查询\nurl: https://www.yuque.com/gaollard/efekv4/zptqc0\n---\n\n```shell\n#准备数据\nPOST  /myindex_highlight/_doc\n{\n  \"name\":\"贾诩\",\n  \"address\":\"魏国\",\n  \"age\":19\n}\nPOST  /myindex_highlight/_doc\n{\n  \"name\":\"诸葛亮\",\n  \"address\":\"蜀国\",\n  \"age\":37\n}\n\n#查询索引库中name字段的内容中包含\"贾诩\"的文档，并且高亮显示查询的结果\nGET myindex_highlight/_doc/_search\n{\n  \"query\":{\n    \"match\": {\n      \"name\": \"贾诩\"\n    }\n  },\n  \"highlight\":{\n    \"fields\": {\n      \"name\": {}\n    }\n  }\n}\n```\n\n```shell\n{\n  \"took\" : 6,\n  …\n  \"hits\" : {\n    \"total\" : {\n      \"value\" : 1,\n      \"relation\" : \"eq\"\n    },\n    \"max_score\" : 1.5098253,\n    \"hits\" : [\n      {\n        \"_index\" : \"myindex_highlight\",\n        \"_type\" : \"_doc\",\n        \"_id\" : \"UhAeYXoBiBO67Reoue-V\",\n        \"_score\" : 1.5098253,\n        \"_source\" : {\n          \"name\" : \"贾诩\",\n          \"address\" : \"魏国\",\n          \"age\" : 19\n        },\n        //高亮标签\n        \"highlight\" : {\n          \"name\" : [\n            \"<em>贾</em><em>诩</em>\"\n          ]\n        }\n      }\n    ]\n  }\n}\n```\n","isLeaf":true},{"key":"/Elasticsearch/06-全文检索/07-全文搜索的自定义高亮查询.md","path":"/Elasticsearch/06-全文检索/07-全文搜索的自定义高亮查询.md","route":"/Elasticsearch/06-全文检索/07-全文搜索的自定义高亮查询.md","leaf":true,"title":"07-全文搜索的自定义高亮查询","depth":2,"content":"---\ntitle: 07-全文搜索的自定义高亮查询\nurl: https://www.yuque.com/gaollard/efekv4/mlk5gx\n---\n\n```shell\n#查询索引库中name字段的内容中包含\"贾诩\"的文档，并使用自定义标签来定义高亮显示的效果\nGET myindex_highlight/_doc/_search\n{\n  \"query\":{\n  \"match\": {\n    \"name\": \"贾诩\"\n  }\n  },\n  \"highlight\":{\n    \"pre_tags\": \"<p class='gaoliang'>\", #自定义高亮显示效果的标签\n    \"post_tags\": \"</p>\", \n    \"fields\": {\n      \"name\": {}\n    }\n  }\n}\n```\n","isLeaf":true}]},{"key":"/Elasticsearch/07-term-level 查询","path":"/Elasticsearch/07-term-level 查询","route":"/Elasticsearch/07-term-level 查询","leaf":false,"title":"07-term-level 查询","depth":1,"content":"","isLeaf":false,"children":[{"key":"/Elasticsearch/07-term-level 查询/01-term level的exists查询.md","path":"/Elasticsearch/07-term-level 查询/01-term level的exists查询.md","route":"/Elasticsearch/07-term-level 查询/01-term level的exists查询.md","leaf":true,"title":"01-term level的exists查询","depth":2,"content":"---\ntitle: 01-term level的exists查询\nurl: https://www.yuque.com/gaollard/efekv4/wwbnrq\n---\n\n```shell\n#查询索引库中存在remarks字段的文档数据\nGET /myindex-term-level/_search\n{\n  \"query\": {\n    \"exists\": \n    {\n      \"field\": \"remarks\" # 存在该字段才返回\n    }\n  }\n}\n```\n","isLeaf":true},{"key":"/Elasticsearch/07-term-level 查询/02-term level的ids查询.md","path":"/Elasticsearch/07-term-level 查询/02-term level的ids查询.md","route":"/Elasticsearch/07-term-level 查询/02-term level的ids查询.md","leaf":true,"title":"02-term level的ids查询","depth":2,"content":"---\ntitle: 02-term level的ids查询\nurl: https://www.yuque.com/gaollard/efekv4/obscyz\n---\n\nids就是通过id进行批量查询。我们在写SQL的时候，可能会经常这样写：\"select *from table where id in(1,2,3)\"，通过id匹配，一次性返回多行数据。而在Elasticsearch中，可以使用ids查询。\n\n```shell\n#返回_id等于1和_id等于3的文档数据\nGET /myindex-term-level/_search\n{\n  \"query\": {\n    \"ids\": \n    {\n      \"values\": [1,3]\n    }\n  }\n}\n```\n\n```shell\n{\n …\n    \"hits\" : [\n      {\n        \"_index\" : \"myindex-term-level\",\n        \"_type\" : \"_doc\",\n        \"_id\" : \"1\",\n        \"_score\" : 1.0,\n        \"_source\" : {\n          \"name\" : \"张三\",\n          \"programming_languages\" : [\n            \"c++\",\n            \"java\",\n            \"dotnet\"\n          ],\n          \"required_matches\" : 2\n        }\n      },\n      {\n        \"_index\" : \"myindex-term-level\",\n        \"_type\" : \"_doc\",\n        \"_id\" : \"3\",\n        \"_score\" : 1.0,\n        \"_source\" : {\n          \"name\" : \"王五\",\n          \"programming_languages\" : [\n            \"java\",\n            \"c++\",\n            \"dotnet\"\n          ],\n          \"required_matches\" : 3,\n          \"remarks\" : \"hello world\"\n        }\n      }\n    ]\n  }\n}\n```\n\n需要注意的是，返回结果的顺序和我们查找时设置的顺序没有任何关系。\n","isLeaf":true},{"key":"/Elasticsearch/07-term-level 查询/03-term level的prefix查询.md","path":"/Elasticsearch/07-term-level 查询/03-term level的prefix查询.md","route":"/Elasticsearch/07-term-level 查询/03-term level的prefix查询.md","leaf":true,"title":"03-term level的prefix查询","depth":2,"content":"---\ntitle: 03-term level的prefix查询\nurl: https://www.yuque.com/gaollard/efekv4/mfmqql\n---\n\n在Elasticsearch中，使用prefix可以根据前缀来查找某个字段。范例如下：\n\n```shell\n#查询索引库中name字段的内容中前缀是\"张\"的所有文档信息\nGET /myindex-term-level/_search\n{\n  \"query\": {\n    \"prefix\": {\n      \"name\": {\n        \"value\": \"张\"\n      }\n    }\n  }\n}\n```\n","isLeaf":true},{"key":"/Elasticsearch/07-term-level 查询/04-term单个单词查询.md","path":"/Elasticsearch/07-term-level 查询/04-term单个单词查询.md","route":"/Elasticsearch/07-term-level 查询/04-term单个单词查询.md","leaf":true,"title":"04-term单个单词查询","depth":2,"content":"---\ntitle: 04-term单个单词查询\nurl: https://www.yuque.com/gaollard/efekv4/zgcop3\n---\n\n以下范例是利用term（搜索的内容不会被分词）进行单词查询。\n\n```shell\n#查询索引库中\"programming_languages\"字段内容中包含\"dotnet\"的文档数据\nGET /myindex-term-level/_search\n{\n  \"query\": {\n    \"term\": {\n      \"programming_languages\": \"dotnet\"\n    }\n  }\n}\n```\n","isLeaf":true},{"key":"/Elasticsearch/07-term-level 查询/05-terms多个单词查询.md","path":"/Elasticsearch/07-term-level 查询/05-terms多个单词查询.md","route":"/Elasticsearch/07-term-level 查询/05-terms多个单词查询.md","leaf":true,"title":"05-terms多个单词查询","depth":2,"content":"---\ntitle: 05-terms多个单词查询\nurl: https://www.yuque.com/gaollard/efekv4/lqx2s8\n---\n\n```shell\n#查询索引库中programming_languages字段的内容，包含php和java任何一个单词的文档都会被返回\nGET /myindex-term-level/_search\n{\n  \"query\": {\n    \"terms\": {\n      \"programming_languages\": [\"php\",\"java\"]\n    }\n  }\n}\n```\n","isLeaf":true},{"key":"/Elasticsearch/07-term-level 查询/06-通配符查询-wildcard.md","path":"/Elasticsearch/07-term-level 查询/06-通配符查询-wildcard.md","route":"/Elasticsearch/07-term-level 查询/06-通配符查询-wildcard.md","leaf":true,"title":"06-通配符查询-wildcard","depth":2,"content":"---\ntitle: 06-通配符查询-wildcard\nurl: https://www.yuque.com/gaollard/efekv4/gxldzq\n---\n\n在Elasticsearch中，如果需要通过通配符进行查询，可使用wildcard来进行处理。范例如下：\n\n```shell\n#在索引中programming_languages字段的内容中查询匹配\"p*p\"和\"*\"（可以表示任何内容）的文档数据\nGET /myindex-term-level/_search\n{\n  \"query\": {\n    \"wildcard\": {\n      \"programming_languages\": {\n        \"value\": \"p*p\"\n      }\n    }\n  }\n}\n```\n\n\"*\"可以表示多个字母\n","isLeaf":true},{"key":"/Elasticsearch/07-term-level 查询/07-范围查询-range.md","path":"/Elasticsearch/07-term-level 查询/07-范围查询-range.md","route":"/Elasticsearch/07-term-level 查询/07-范围查询-range.md","leaf":true,"title":"07-范围查询-range","depth":2,"content":"---\ntitle: 07-范围查询-range\nurl: https://www.yuque.com/gaollard/efekv4/cy0rly\n---\n\n我们在编写SQL查询语句时，会经常对数字或者日期进行范围查询。在Elasticsearch中，range通常被用于数字或者日期范围的查询中\n\n```shell\n#根据范围查询required_matches字段的值大于等于3且小于等于4的文档数据\nGET /myindex-term-level/_search\n{\n  \"query\": {\n    \"range\": {\n      \"required_matches\": {\n        \"gte\": 3,\n        \"lte\": 4\n      }\n    }\n  }\n}\n```\n","isLeaf":true},{"key":"/Elasticsearch/07-term-level 查询/08-搜索词相似的词-fuzzy.md","path":"/Elasticsearch/07-term-level 查询/08-搜索词相似的词-fuzzy.md","route":"/Elasticsearch/07-term-level 查询/08-搜索词相似的词-fuzzy.md","leaf":true,"title":"08-搜索词相似的词-fuzzy","depth":2,"content":"---\ntitle: 08-搜索词相似的词-fuzzy\nurl: https://www.yuque.com/gaollard/efekv4/miggql\n---\n\n    GET /myindex-term-level/_search\n    {\n      \"query\": {\n        \"fuzzy\": {\n          \"remarks\": {\n            \"value\": \"powerf\"\n          }\n        }\n      }\n    }\n","isLeaf":true},{"key":"/Elasticsearch/07-term-level 查询/09-正则表达式-regexp.md","path":"/Elasticsearch/07-term-level 查询/09-正则表达式-regexp.md","route":"/Elasticsearch/07-term-level 查询/09-正则表达式-regexp.md","leaf":true,"title":"09-正则表达式-regexp","depth":2,"content":"---\ntitle: 09-正则表达式-regexp\nurl: https://www.yuque.com/gaollard/efekv4/pm3a7i\n---\n\n```shell\n#查询remarks字段内容匹配po开头的文档数据\nGET /myindex-term-level/_search\n{\n  \"query\": {\n    \"regexp\": {\n      \"remarks\": {\n        \"value\": \"po.*\",\n        \"case_insensitive\": true\n      }\n   }\n  }\n}\n```\n\n![](https://s3.airtlab.com/elasticsearch/20220429092451.png)\n","isLeaf":true}]},{"key":"/Elasticsearch/08-多条件查询","path":"/Elasticsearch/08-多条件查询","route":"/Elasticsearch/08-多条件查询","leaf":false,"title":"08-多条件查询","depth":1,"content":"","isLeaf":false,"children":[{"key":"/Elasticsearch/08-多条件查询/01-bool多条件查询.md","path":"/Elasticsearch/08-多条件查询/01-bool多条件查询.md","route":"/Elasticsearch/08-多条件查询/01-bool多条件查询.md","leaf":true,"title":"01-bool多条件查询","depth":2,"content":"---\ntitle: 01-bool多条件查询\nurl: https://www.yuque.com/gaollard/efekv4/qctre0\n---\n\n- must：必须匹配（返回结果中评分字段的结果有意义）。全部匹配才保留\n- must\\_not：过滤子句，必须不能匹配（返回结果中评分字段的结果无意义）。匹配任何一条就过滤\n- should：选择性匹配，至少满足一条（返回结果中评分字段的结果有意义）。至少匹配一条才保留\n- filter：过滤子句，必须匹配（返回结果中评分字段的结果无意义）。全部匹配才保留\n\n在使用 Elasticsearch 查询时，如果想要构造更复杂的查询（即搜索），可以使用\"bool\"来组合多个查询条件。使用语法如下：\n\n```shell\nGET /索引库名称/_search\n{\n  \"query\": {\n    \"bool\": {\n      \"must\": [\n        { \"match\": { \"字段1\": \"数据1\" } }\n      ],\n      \"must_not\": [\n        { \"match\": { \"字段2\": \"数据2\" } }\n      ]\n    }\n  }\n}\n```\n\n```shell\n#搜索索引库中age字段内容等于18并且address字段内容中不包含\"中国上海\"的数据\nGET /userinfo_003/_search\n{\n  \"query\": {\n    \"bool\": {\n      \"must\": [\n        { \"match\": { \"age\": \"18\" } }\n      ],\n      \"must_not\": [\n        { \"match_phrase\": { \"address\": \"中国上海\" } }\n      ]\n    }\n  }\n}\n```\n\n```shell\n#搜索索引库中age字段内容等于18并且address字段内容中不包含\"中国上海\"的数据\nGET /userinfo_003/_search\n{\n  \"query\": {\n    \"bool\": {\n      \"must\": [\n        { \"match\": { \"age\": \"18\" } }\n      ],\n      \"must_not\": [\n        # 任何其中一个匹配就过滤\n        # 区分都要满足才过滤\n        { \"match_phrase\": { \"address\": \"中国上海\" } },\n      ]\n    }\n  }\n}\n```\n\n如果有多个 must\\_not 呢？比如 address 不能为中国，age 不能为 18:\n\n```shell\nGET mindex/_doc/_search\n{\n  \"query\": {\n    \"bool\": {\n      \"must\": [\n        {\n          \"bool\": {\n              \"must_not\": [\n              {\n                \"match_phrase\": {\n                  \"address\": \"中国\"\n                }\n              }\n            ]\n          }\n        },\n        {\n          \"bool\": {\n              \"must_not\": [\n              {\n                \"match_phrase\": {\n                  \"name\": \"18\"\n                }\n              }\n            ]\n          }\n        }\n      ]\n    }\n  }\n}\n```\n","isLeaf":true},{"key":"/Elasticsearch/08-多条件查询/02-bool和filter组合查询.md","path":"/Elasticsearch/08-多条件查询/02-bool和filter组合查询.md","route":"/Elasticsearch/08-多条件查询/02-bool和filter组合查询.md","leaf":true,"title":"02-bool和filter组合查询","depth":2,"content":"---\ntitle: 02-bool和filter组合查询\nurl: https://www.yuque.com/gaollard/efekv4/yg1dkt\n---\n\n```shell\n#搜索address字段内容中包含\"杭州\"并且满足age大于等于10、小于等于20的文档数据\nGET userinfo_003/_doc/_search\n{\n\n  \"query\":{\n    \"bool\": {\n      \"must\": [\n        {\n          \"match\": {\n            \"address\": \"杭州\"\n          }\n        }\n      ],\n      \"filter\": {\n        # 不满足的都会被过滤\n        \"range\": {\n          \"age\": {\n            \"gte\": 10,\n            \"lte\": 20\n          }\n        }\n      }\n    }\n  }\n}\n```\n","isLeaf":true}]},{"key":"/Elasticsearch/09-分组查询","path":"/Elasticsearch/09-分组查询","route":"/Elasticsearch/09-分组查询","leaf":false,"title":"09-分组查询","depth":1,"content":"","isLeaf":false,"children":[{"key":"/Elasticsearch/09-分组查询/00-数据准备.md","path":"/Elasticsearch/09-分组查询/00-数据准备.md","route":"/Elasticsearch/09-分组查询/00-数据准备.md","leaf":true,"title":"00-数据准备","depth":2,"content":"---\ntitle: 00-数据准备\nurl: https://www.yuque.com/gaollard/efekv4/wgwseq\n---\n\n    #批量新增数据，数据是关于汽车交易的信息：制造商、售价、出售时间\n    POST /myindex-aggtest/_bulk\n    { \"index\": {}}\n    { \"price\" : 10000, \"color\" : \"red\", \"make\" : \"honda\", \"soldtime\" : \"2021-11-21\" }\n    { \"index\": {}}\n    { \"price\" : 15000, \"color\" : \"red\", \"make\" : \"honda\", \"soldtime\" : \"2021-9-06\" }\n    { \"index\": {}}\n    { \"price\" : 30000, \"color\" : \"green\", \"make\" : \"ford\", \"soldtime\" : \"2021-06-18\" }\n    { \"index\": {}}\n    { \"price\" : 15000, \"color\" : \"blue\", \"make\" : \"toyota\", \"soldtime\" : \"2021-08-02\" }\n    { \"index\": {}}\n    { \"price\" : 16000, \"color\" : \"green\", \"make\" : \"toyota\", \"soldtime\" : \"2014-08-19\" }\n    { \"index\": {}}\n    { \"price\" : 20000, \"color\" : \"red\", \"make\" : \"honda\", \"soldtime\" : \"2021-11-08\" }\n    { \"index\": {}}\n    { \"price\" : 80000, \"color\" : \"red\", \"make\" : \"bmw\", \"soldtime\" : \"2021-01-03\" }\n    { \"index\": {}}\n","isLeaf":true},{"key":"/Elasticsearch/09-分组查询/01-简单的聚合.md","path":"/Elasticsearch/09-分组查询/01-简单的聚合.md","route":"/Elasticsearch/09-分组查询/01-简单的聚合.md","leaf":true,"title":"01-简单的聚合","depth":2,"content":"---\ntitle: 01-简单的聚合\nurl: https://www.yuque.com/gaollard/efekv4/gdbgxi\n---\n\n\n\n### 1. 分组语法\n\n```shell\nGET /myindex-aggtest/_search\n{\n    \"size\" : 0,\n    \"aggs\" : { \n        \"popular_colors\" : { \n            \"terms\" : { \n              \"field\" : \"color.keyword\"\n            }\n        }\n    }\n}\n```\n\n- size:0：表示只要统计后的结果，原始数据不需要返回，如果是大于0的，则会返回对应数量的文档数据。如果只需要聚合统计的结果，建议把size选项设置为0，避免返回没必要的数据。\n- aggs：固定语法，聚合分析都要声明aggs或者aggregations。\n- song\\_qty\\_by\\_language：聚合的名称，可以随便命名，但建议规范命名。\n- terms：表示按哪个字段进行分组。\n- field：表示具体的字段名称。\n\n\n\n### 2. 分组演示\n\n```shell\n#批量考试成绩数据，并使用程序自动生成索引映射\nPOST /myindex_aggs/_doc/_bulk\n{ \"index\": {}}\n{\"name\":\"张三\",\"address\":\"上海\",\"age\":18,\"score\":60}\n{ \"index\": {}}\n{\"name\":\"李四\",\"address\":\"杭州\",\"age\":18,\"score\":70}\n{ \"index\": {}}\n{\"name\":\"王五\",\"address\":\"杭州\",\"age\":20,\"score\":80}\n{ \"index\": {}}\n{\"name\":\"大刀王五\",\"address\":\"上海\",\"age\":21,\"score\":90}\n```\n\n```shell\nGET /myindex_aggs/_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"group_by_address\": {\n      \"terms\": {\n        \"field\": \"address.keyword\"\n      }\n    }\n  }\n}\n```\n\n```shell\n{\n  \"took\" : 2,\n  \"timed_out\" : false,\n  …\n  \"hits\" : {\n    \"total\" : {\n      \"value\" : 4,\n      \"relation\" : \"eq\"\n    },\n    \"max_score\" : null,\n    \"hits\" : [ ]\n  },\n  \"aggregations\" : {\n    \"group_by_address\" : {\n      \"doc_count_error_upper_bound\" : 0,\n      \"sum_other_doc_count\" : 0,\n      \"buckets\" : [\n        {\n          \"key\" : \"上海\",\n          \"doc_count\" : 2\n        },\n        {\n          \"key\" : \"杭州\",\n          \"doc_count\" : 2\n        }\n      ]\n    }\n  }\n}\n```\n","isLeaf":true},{"key":"/Elasticsearch/09-分组查询/02-多字段聚合.md","path":"/Elasticsearch/09-分组查询/02-多字段聚合.md","route":"/Elasticsearch/09-分组查询/02-多字段聚合.md","leaf":true,"title":"02-多字段聚合","depth":2,"content":"---\ntitle: 02-多字段聚合\nurl: https://www.yuque.com/gaollard/efekv4/zwqaao\n---\n\n如果想要知道哪个颜色和哪个厂商的汽车销量最好，可以对颜色和厂商两个字段进行聚合计算\n\n    GET /myindex-aggtest/_search\n    {\n        \"size\" : 0,\n        \"aggs\" : { \n            \"colors\" : { \n                \"terms\" : { \n                  \"field\" : \"color.keyword\"\n                }\n            },\n            \"make\" : { \n                \"terms\" : { \n                  \"field\" : \"make.keyword\"\n                }\n            }\n        }\n    }\n\n<!---->\n\n    {\n      …\n      \"aggregations\" : {\n        \"make\" : {   // 厂商字段聚合统计结果\n          \"doc_count_error_upper_bound\" : 0,\n          \"sum_other_doc_count\" : 0,\n          \"buckets\" : [\n            {\n              \"key\" : \"honda\",\n              \"doc_count\" : 2\n            },\n            {\n              \"key\" : \"toyota\",\n              \"doc_count\" : 2\n            },\n            {\n              \"key\" : \"bmw\",\n              \"doc_count\" : 1\n            },\n            {\n              \"key\" : \"ford\",\n              \"doc_count\" : 1\n            }\n          ]\n        },\n        \"colors\" : {  // 颜色聚合结果\n          \"doc_count_error_upper_bound\" : 0,\n          \"sum_other_doc_count\" : 0,\n          \"buckets\" : [\n            {\n              \"key\" : \"red\",\n              \"doc_count\" : 3\n            },\n            {\n              \"key\" : \"green\",\n              \"doc_count\" : 2\n            },\n            {\n              \"key\" : \"blue\",\n              \"doc_count\" : 1\n            }\n          ]\n        }\n      }\n    }\n","isLeaf":true},{"key":"/Elasticsearch/09-分组查询/03-动态脚本聚合.md","path":"/Elasticsearch/09-分组查询/03-动态脚本聚合.md","route":"/Elasticsearch/09-分组查询/03-动态脚本聚合.md","leaf":true,"title":"03-动态脚本聚合","depth":2,"content":"---\ntitle: 03-动态脚本聚合\nurl: https://www.yuque.com/gaollard/efekv4/ga8lm5\n---\n\n    #根据索引库中厂商名称的长度进行分组，计算每种长度的文档数量\n    GET /myindex-aggtest/_search\n    {\n      \"runtime_mappings\": {\n        \"make_content_length\": {\n          \"type\": \"long\",\n          \"script\": \"emit(doc['make.keyword'].value.length())\" #运行时脚本计算make字段内容的长度\n        }\n      },\n      \"size\" : 0,\n      \"aggs\": {\n        \"make_length\": {\n          \"histogram\": {\n            \"interval\": 1,\n            \"field\": \"make_content_length\" #根据运行时make字段的内容长度进行聚合统计\n          }\n        }\n      }\n    }\n\n<!---->\n\n    {\n      …\n      \"aggregations\" : {\n        \"make_length\" : {\n          \"buckets\" : [\n            {\n              \"key\" : 3.0,                  // 表示厂商名称的长度\n              \"doc_count\" : 1               // 厂商名称长度等于3的文档数量\n            },\n            {\n              \"key\" : 4.0,                  // 表示厂商名称的长度\n              \"doc_count\" : 1\n            },\n            {\n              \"key\" : 5.0,                  // 表示厂商名称的长度\n              \"doc_count\" : 2\n            },\n            {\n              \"key\" : 6.0,                  // 表示厂商名称的长度\n              \"doc_count\" : 2\n            }\n          ]\n        }\n      }\n    }\n","isLeaf":true},{"key":"/Elasticsearch/09-分组查询/04-过滤聚合-filter.md","path":"/Elasticsearch/09-分组查询/04-过滤聚合-filter.md","route":"/Elasticsearch/09-分组查询/04-过滤聚合-filter.md","leaf":true,"title":"04-过滤聚合-filter","depth":2,"content":"---\ntitle: 04-过滤聚合-filter\nurl: https://www.yuque.com/gaollard/efekv4/eh4rse\n---\n\nElasticsearch中也支持先筛选再聚合。范例如下\n\n```shell\n#聚合计算厂商toyota出售车的平均价格和出售的总数量\nGET /myindex-aggtest/_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"make_by\": {\n      \"filter\": { \"term\": { \"make\": \"toyota\" } },\n      \"aggs\": {\n        \"avg_price\": { \"avg\": { \"field\": \"price\" } }\n      }\n    }\n  }\n}\n```\n","isLeaf":true},{"key":"/Elasticsearch/09-分组查询/05-filters分组聚合.md","path":"/Elasticsearch/09-分组查询/05-filters分组聚合.md","route":"/Elasticsearch/09-分组查询/05-filters分组聚合.md","leaf":true,"title":"05-filters分组聚合","depth":2,"content":"---\ntitle: 05-filters分组聚合\nurl: https://www.yuque.com/gaollard/efekv4/fp5ybn\n---\n\n相当于灵活分组 `filters-aggs`\n\n    GET /myindex-aggtest/_search\n    {\n      \"size\": 0,\n      \"aggs\" : {\n        \"messages\" : {\n          \"filters\" : {\n            \"other_bucket_key\": \"other_color\", \n            \"filters\" : {\n              \"reds\" :   { \"match\" : { \"color\" : \"red\"   }},\n              \"greens\" : { \"match\" : { \"color\" : \"green\" }}\n            }\n          }\n        }\n      }\n    }\n\n```shell\n{\n …\n  \"aggregations\" : {\n    \"messages\" : {\n      \"buckets\" : {\n        \"greens\" : {\n          \"doc_count\" : 2 // 绿色车辆的数量\n        },\n        \"reds\" : {\n          \"doc_count\" : 3 // 红色车辆的颜色\n        },\n        \"other_color\" : {\n          \"doc_count\" : 1 // 其他车辆的颜色\n        }\n      }\n    }\n  }\n}\n```\n","isLeaf":true},{"key":"/Elasticsearch/09-分组查询/06-range数值范围聚合.md","path":"/Elasticsearch/09-分组查询/06-range数值范围聚合.md","route":"/Elasticsearch/09-分组查询/06-range数值范围聚合.md","leaf":true,"title":"06-range数值范围聚合","depth":2,"content":"---\ntitle: 06-range数值范围聚合\nurl: https://www.yuque.com/gaollard/efekv4/wcnmgz\n---\n\n`range-aggs`\n\nElasticsearch提供了基于多桶值源的聚合方式。通过这种方式可以定义一组范围，每个范围代表一个桶。范例如下：\n\n    GET /myindex-aggtest/_search\n    {\n      \"size\": 0,\n      \"aggs\": {\n        \"price_ranges\": {\n          \"range\": {\n            \"field\": \"price\",\n            \"ranges\": [#如下是一组范围条件\n              { \"to\": 10000 },\n              { \"from\": 10000, \"to\": 20000 },\n               { \"from\": 20000, \"to\": 30000 },\n              { \"from\": 40000 }\n            ]\n          }\n        }\n      }\n    }\n","isLeaf":true},{"key":"/Elasticsearch/09-分组查询/07-histrogram范围间隔聚合.md","path":"/Elasticsearch/09-分组查询/07-histrogram范围间隔聚合.md","route":"/Elasticsearch/09-分组查询/07-histrogram范围间隔聚合.md","leaf":true,"title":"07-histrogram范围间隔聚合","depth":2,"content":"---\ntitle: 07-histrogram范围间隔聚合\nurl: https://www.yuque.com/gaollard/efekv4/cf3k8p\n---\n\n在前面的范例中，我们可以指定具体的范围来进行聚合，但是当范围很多时，可以直接指定范围间隔（Histrogram）来进行聚合统计\n\n    #聚合统计，根据出售价格范围进行分组，每一组之间价格相差40000\n    GET /myindex-aggtest/_search\n    {\n       \"size\" : 0,\n       \"aggs\":{\n          \"price\":{\n             \"histogram\":{ \n                \"field\": \"price\",\n                \"interval\": 40000\n             } \n          }\n       }\n    }\n","isLeaf":true},{"key":"/Elasticsearch/09-分组查询/08-日期范围聚合.md","path":"/Elasticsearch/09-分组查询/08-日期范围聚合.md","route":"/Elasticsearch/09-分组查询/08-日期范围聚合.md","leaf":true,"title":"08-日期范围聚合","depth":2,"content":"---\ntitle: 08-日期范围聚合\nurl: https://www.yuque.com/gaollard/efekv4/ied9ua\n---\n\n    #根据出售车的各个时间段来聚合\n    GET /myindex-aggtest/_search\n    {\n      \"size\": 0,\n      \"aggs\": {\n        \"range\": {\n          \"date_range\": {\n            \"field\": \"soldtime\",\n            \"format\": \"yyyy-MM-dd\",\n            \"ranges\": [\n              { \"from\": \"2021-06-30\" },  \n              { \"to\": \"2021-07-01\" } \n            ]\n          }\n        }\n      }\n    }\n\n日期范围统计还支持根据\"Date Math\"表达式进行范围分解统计\n\n    #计算5个月之前和之后的销售车辆数量\n    GET /myindex-aggtest/_search\n    {\n      \"size\": 0,\n      \"aggs\": {\n        \"range\": {\n          \"date_range\": {\n            \"field\": \"soldtime\",\n            \"format\": \"yyyy-MM-dd\",\n            \"ranges\": [\n              { \"from\": \"now-5M/M\" },  \n              { \"to\": \"now-5M/M\" } \n            ]\n          }\n        }\n      }\n    }\n\n```\n```\n","isLeaf":true},{"key":"/Elasticsearch/09-分组查询/09-ES不支持分组后分页.md","path":"/Elasticsearch/09-分组查询/09-ES不支持分组后分页.md","route":"/Elasticsearch/09-分组查询/09-ES不支持分组后分页.md","leaf":true,"title":"09-ES不支持分组后分页","depth":2,"content":"---\ntitle: 09-ES不支持分组后分页\nurl: https://www.yuque.com/gaollard/efekv4/gzyfh8\n---\n\n<https://blog.csdn.net/laoyang360/article/details/79112946>\n","isLeaf":true},{"key":"/Elasticsearch/09-分组查询/10-分组-排序.md","path":"/Elasticsearch/09-分组查询/10-分组-排序.md","route":"/Elasticsearch/09-分组查询/10-分组-排序.md","leaf":true,"title":"10-分组-排序","depth":2,"content":"---\ntitle: 10-分组-排序\nurl: https://www.yuque.com/gaollard/efekv4/vgwf2i\n---\n\n\n\n### 分组统计每组的最小值并按统计结果排序\n\n```shell\nGET /myindex_aggs/_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"group_by_address\": {\n      \"terms\": {\n        \"field\": \"address.keyword\",\n        \"order\": {\n          \"score_min\": \"desc\"\n        }\n      },\n      \"aggs\": {\n        \"score_min\": {\n          \"min\": {\n            \"field\": \"score\"\n          }\n        }\n      }\n    }\n  }\n}\n```\n","isLeaf":true}]},{"key":"/Elasticsearch/10-聚合函数","path":"/Elasticsearch/10-聚合函数","route":"/Elasticsearch/10-聚合函数","leaf":false,"title":"10-聚合函数","depth":1,"content":"","isLeaf":false,"children":[{"key":"/Elasticsearch/10-聚合函数/01-聚合函数介绍.md","path":"/Elasticsearch/10-聚合函数/01-聚合函数介绍.md","route":"/Elasticsearch/10-聚合函数/01-聚合函数介绍.md","leaf":true,"title":"01-聚合函数介绍","depth":2,"content":"---\ntitle: 01-聚合函数介绍\nurl: https://www.yuque.com/gaollard/efekv4/cr3cfl\n---\n\n\n\n### 分组统计每组的最大值 aggs & terms & max\n\n```shell\nGET /myindex_aggs/_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"group_by_address\": {\n      \"terms\": {\n        \"field\": \"address.keyword\",\n        \"order\": {\n          \"score_max\": \"desc\"\n        }\n      },\n      \"aggs\": {\n        \"score_max\": {\n          \"max\": {\n            \"field\": \"score\"\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n```shell\n{\n  \"took\" : 2,\n…\n  \"hits\" : {\n    \"total\" : {\n      \"value\" : 4,\n      \"relation\" : \"eq\"\n    },\n    \"max_score\" : null,\n    \"hits\" : [ ]\n  },\n  \"aggregations\" : {\n    \"group_by_address\" : {\n      \"doc_count_error_upper_bound\" : 0,\n      \"sum_other_doc_count\" : 0,\n      \"buckets\" : [\n        {\n          \"key\" : \"上海\",\n          \"doc_count\" : 2,\n          \"score_max\" : {\n            \"value\" : 90.0\n          }\n        },\n        {\n          \"key\" : \"杭州\",\n          \"doc_count\" : 2,\n          \"score_max\" : {\n            \"value\" : 80.0\n          }\n        }\n      ]\n    }\n  }\n}\n```\n","isLeaf":true},{"key":"/Elasticsearch/10-聚合函数/02-计算加权平均值-weighted_avg.md","path":"/Elasticsearch/10-聚合函数/02-计算加权平均值-weighted_avg.md","route":"/Elasticsearch/10-聚合函数/02-计算加权平均值-weighted_avg.md","leaf":true,"title":"02-计算加权平均值-weighted_avg","depth":2,"content":"---\ntitle: 02-计算加权平均值-weighted_avg\nurl: https://www.yuque.com/gaollard/efekv4/cs31li\n---\n\n    #数据准备\n    POST /myindex-metrics_test/_bulk\n    { \"index\": {}}\n    { \"grade\" : 80, \"weight\" : 0.5}\n    { \"index\": {}}\n    { \"grade\" : 90, \"weight\" : 0.2}\n    { \"index\": {}}\n    { \"grade\" : 60, \"weight\" : 0.3}\n\n    #计算grade字段的加权平均值\n    POST /myindex-metrics_test/_search\n    {\n      \"size\": 0,\n      \"aggs\": {\n        \"weighted_grade\": {\n          \"weighted_avg\": {\n            \"value\": { # 设置值的字段\n              \"field\": \"grade\"\n            },\n            \"weight\": { # 设置权重字段\n              \"field\": \"weight\"\n            }\n          }\n        }\n      }\n    }\n\n但是在实际业务中，有可能出现索引结构不一致的情况，那么需要在“运行时字段”上进行聚合。范例如下：\n\n    #数据准备\n    POST /myindex-metrics_test1/_doc?refresh\n    {\n      \"grade\": 90,\n      \"weight\": [2, 3]\n    }\n    POST /myindex-metrics_test1/_doc?refresh\n    {\n      \"grade\": 80,\n      \"weight\": 3\n    }\n    #在\"运行时字段\"上进行聚合统计，查询加权平均值\n    POST /myindex-metrics_test1/_search?filter_path=aggregations\n    {\n      \"size\": 0,\n      \"runtime_mappings\": {\n        \"weight.combined\": {\n          \"type\": \"double\",\n          \"script\": \"\"\"\n            double s = 0;\n            for (double w : doc['weight']) {\n              s += w;\n            }\n            emit(s);\n          \"\"\"\n        }\n      },\n      \"aggs\": {\n        \"weighted_grade\": {\n          \"weighted_avg\": {\n            \"value\": {\n              \"script\": \"doc.grade.value \"\n            },\n            \"weight\": {\n              \"field\": \"weight.combined\"\n            }\n          }\n        }\n      }\n    }\n","isLeaf":true},{"key":"/Elasticsearch/10-聚合函数/03-去重后求总数量-cardinality.md","path":"/Elasticsearch/10-聚合函数/03-去重后求总数量-cardinality.md","route":"/Elasticsearch/10-聚合函数/03-去重后求总数量-cardinality.md","leaf":true,"title":"03-去重后求总数量-cardinality","depth":2,"content":"---\ntitle: 03-去重后求总数量-cardinality\nurl: https://www.yuque.com/gaollard/efekv4/mu6f7o\n---\n\n    #数据准备\n    POST /myindex_cardinality/_bulk\n    { \"index\": {}}\n    { \"name\" : \"张三\", \"weight\" : 60}\n    { \"index\": {}}\n    { \"name\" : \"李四\", \"weight\" : 70}\n    { \"index\": {}}\n    { \"name\" : \"张三\", \"weight\" : 80}\n    #统计计算不重名的姓名总数量\n    POST /myindex_cardinality/_search\n    {\n      \"size\":0,\n      \"aggs\": {\n        \"type_count\": {\n          \"cardinality\": {\n            \"field\": \"name.keyword\"\n          }\n        }\n      }\n    }\n","isLeaf":true},{"key":"/Elasticsearch/10-聚合函数/04-绝对中位差.md","path":"/Elasticsearch/10-聚合函数/04-绝对中位差.md","route":"/Elasticsearch/10-聚合函数/04-绝对中位差.md","leaf":true,"title":"04-绝对中位差","depth":2,"content":"---\ntitle: 04-绝对中位差\nurl: https://www.yuque.com/gaollard/efekv4/kebrio\n---\n\n绝对中位差是用原数据减去中位数后得到的新数据的绝对值之中位数。Elasticsearch中也提供了这种计算方式，使用median\\_absolute\\_deviation关键字进行统计。\n\n    #数据准备，如下是不同的价格\n    POST /myindex_median_absolute_deviation/_bulk\n    { \"index\": {}}\n    {  \"price\" : 60}\n    { \"index\": {}}\n    {  \"price\" : 70}\n    { \"index\": {}}\n    {  \"price\" : 80}\n    #计算价格的绝对中位数\n    GET myindex_median_absolute_deviation/_search\n    {\n      \"size\": 0,\n      \"aggs\": {\n        \"review_average\": {\n          \"avg\": { # 平均值\n            \"field\": \"price\"\n          }\n        },\n        \"review_variability\": { \n          \"median_absolute_deviation\": { # 绝对中位差\n            \"field\": \"price\" \n          }\n        }\n      }\n    }\n","isLeaf":true},{"key":"/Elasticsearch/10-聚合函数/05-最大最小平均值等.md","path":"/Elasticsearch/10-聚合函数/05-最大最小平均值等.md","route":"/Elasticsearch/10-聚合函数/05-最大最小平均值等.md","leaf":true,"title":"05-最大最小平均值等","depth":2,"content":"---\ntitle: 05-最大最小平均值等\nurl: https://www.yuque.com/gaollard/efekv4/utpawx\n---\n\n\n\n### 1. stats\n\n使用stats关键字一次性统计出最大值、最小值、平均值、总和、总条数等信息\n\n    #数据准备\n    POST /myindex_stats/_bulk\n    { \"index\": {}}\n    { \"grade\" : 80}\n    { \"index\": {}}\n    { \"grade\" : 90}\n    { \"index\": {}}\n    { \"grade\" : 60}\n         \n     #查询grade字段的最大值、最小值、平均值、总和、总条数等信息\n    POST myindex_stats/_search\n    {  \"size\":0,\n      \"aggs\": {\n        \"grades_stats\": { \"stats\": { \"field\": \"grade\" } }\n      }\n    }\n\n<!---->\n\n    {\n     …\n      \"hits\" : {\n        \"total\" : {\n          \"value\" : 3,\n          \"relation\" : \"eq\"\n        },\n        \"max_score\" : null,\n        \"hits\" : [ ]\n      },\n      \"aggregations\" : {\n        \"grades_stats\" : {\n          \"count\" : 3,\n          \"min\" : 60.0,\n          \"max\" : 90.0,\n          \"avg\" : 76.66666666666667,\n          \"sum\" : 230.0\n        }\n      }\n    }\n\n\n\n### 2. extended\\_stats\n\n统计其他扩展状态值，可以使用extended\\_stats关键字进行统计\n\n    POST myindex_stats/_search\n    {  \"size\":0,\n      \"aggs\": {\n        \"grades_stats\": { \"extended_stats\": { \"field\": \"grade\" } }\n      }\n    }\n\n<!---->\n\n    {\n      …\n        \"hits\" : [ ]\n      },\n      \"aggregations\" : {\n        \"grades_stats\" : {\n          \"count\" : 3,\n          \"min\" : 60.0,\n          \"max\" : 90.0,\n          \"avg\" : 76.66666666666667,\n          \"sum\" : 230.0,\n          \"sum_of_squares\" : 18100.0,\n          \"variance\" : 155.55555555555597,\n          \"variance_population\" : 155.55555555555597,\n          \"variance_sampling\" : 233.33333333333394,\n          \"std_deviation\" : 12.472191289246489,\n          \"std_deviation_population\" : 12.472191289246489,\n          \"std_deviation_sampling\" : 15.275252316519486,\n          \"std_deviation_bounds\" : {\n            \"upper\" : 101.61104924515965,\n            \"lower\" : 51.722284088173694,\n            \"upper_population\" : 101.61104924515965,\n            \"lower_population\" : 51.722284088173694,\n            \"upper_sampling\" : 107.21717129970564,\n            \"lower_sampling\" : 46.1161620336277\n          }\n        }\n      }\n    }\n","isLeaf":true},{"key":"/Elasticsearch/10-聚合函数/06-字符串统计.md","path":"/Elasticsearch/10-聚合函数/06-字符串统计.md","route":"/Elasticsearch/10-聚合函数/06-字符串统计.md","leaf":true,"title":"06-字符串统计","depth":2,"content":"---\ntitle: 06-字符串统计\nurl: https://www.yuque.com/gaollard/efekv4/eadsy5\n---\n\n    #数据准备\n    POST /myindex_string_stats/_bulk\n    { \"index\": {}}\n    { \"body\" : \"Do one thing at a time, and do well\"}\n    { \"index\": {}}\n    { \"body\" : \"Believe in yourself\"}\n    { \"index\": {}}\n    { \"body\" : \"Keep on going never give up\"}\n         \n    #聚合统计body.keyword字段中内容的长度 \n    POST myindex_string_stats/_search\n    { \n      \"size\":0,\n      \"aggs\": {\n        \"message_stats\": {\n          \"string_stats\": {\n            \"field\": \"body.keyword\"\n          }\n        }\n      }\n    }\n\n    {\n      …\n      },\n      \"aggregations\" : {\n        \"message_stats\" : {\n          \"count\" : 3,\n          \"min_length\" : 19,\n          \"max_length\" : 35,\n          \"avg_length\" : 27.0,\n          \"entropy\" : 3.987274621250932\n        }\n      }\n    }\n\n返回了所有文档中对应字段的内容最大长度、最小长度等\n","isLeaf":true},{"key":"/Elasticsearch/10-聚合函数/07-百分位数统计-不精确.md","path":"/Elasticsearch/10-聚合函数/07-百分位数统计-不精确.md","route":"/Elasticsearch/10-聚合函数/07-百分位数统计-不精确.md","leaf":true,"title":"07-百分位数统计-不精确","depth":2,"content":"---\ntitle: 07-百分位数统计-不精确\nurl: https://www.yuque.com/gaollard/efekv4/qks5gd\n---\n\n统计学术语，如果将一组数据从小到大排序，并计算相应的累计百分位，则某一百分位所对应数据的值就称为这一百分位的百分位数。可表示为：一组n个观测值按数值大小排列。如，处于p%位置的值称第p百分位数。\n\n\n\n### 1. 默认百分位数\n\n    #数据准备\n    POST /myindex_percentiles/_doc/_bulk\n    { \"index\": {}}\n    {\"name\":\"张三\",\"address\":\"中国\",\"age\":18}\n    { \"index\": {}}\n    {\"name\":\"李四\",\"address\":\"中国\",\"age\":19}\n    { \"index\": {}}\n    {\"name\":\"王五\",\"address\":\"美国\",\"age\":20}\n    { \"index\": {}}\n    {\"name\":\"赵六\",\"address\":\"美国\",\"age\":21}\n\n    #计算索引库中age字段的百分位数\n    GET myindex_percentiles/_search\n    {\n      \"size\": 0,\n      \"aggs\": {\n        \"age_outlier\": {\n          \"percentiles\": {\n            \"field\": \"age\" \n          }\n        }\n      }\n    }\n\n<!---->\n\n    {\n      …\n      \"hits\" : {\n        \"total\" : {\n          \"value\" : 4,\n          \"relation\" : \"eq\"\n        },\n        \"max_score\" : null,\n        \"hits\" : [ ]\n      },\n      \"aggregations\" : {\n        \"age_outlier\" : {\n          \"values\" : {\n            \"1.0\" : 18.000000000000004, # 搞不懂为什么不准确\n            \"5.0\" : 18.0,\n            \"25.0\" : 18.5,\n            \"50.0\" : 19.5,\n            \"75.0\" : 20.5,\n            \"95.0\" : 21.0,\n            \"99.0\" : 21.0\n          }\n        }\n      }\n    }\n\n\n\n### 2. 自定义百分位数\n\n    GET myindex_percentiles/_search\n    {\n      \"size\": 0,\n      \"aggs\": {\n        \"age_outlier\": {\n          \"percentiles\": {\n            \"field\": \"age\"  ,\n            \"percents\": [\n                  50,\n                  95,\n                  99\n                ]\n         \n          }\n        }\n      }\n    }\n","isLeaf":true},{"key":"/Elasticsearch/10-聚合函数/08-百分位等级计算-不精确.md","path":"/Elasticsearch/10-聚合函数/08-百分位等级计算-不精确.md","route":"/Elasticsearch/10-聚合函数/08-百分位等级计算-不精确.md","leaf":true,"title":"08-百分位等级计算-不精确","depth":2,"content":"---\ntitle: 08-百分位等级计算-不精确\nurl: https://www.yuque.com/gaollard/efekv4/rtxlfi\n---\n\n    #数据准备\n    POST /myindex_percentile_ranks/_doc/_bulk\n    { \"index\": {}}\n    {\"name\":\"张三\",\"address\":\"中国\",\"age\":10}\n    { \"index\": {}}\n    {\"name\":\"李四\",\"address\":\"中国\",\"age\":20}\n    { \"index\": {}}\n    {\"name\":\"王五\",\"address\":\"美国\",\"age\":30}\n    { \"index\": {}}\n    {\"name\":\"赵六\",\"address\":\"美国\",\"age\":40}\n    { \"index\": {}}\n    {\"name\":\"李白\",\"address\":\"美国\",\"age\":50}\n         \n    #计算age字段值等于30和50的百分位等级\n    GET myindex_percentile_ranks/_search\n    {\n      \"size\": 0,\n      \"aggs\": {\n        \"age_ranks\": {\n          \"percentile_ranks\": {\n            \"field\": \"age\",   \n            \"values\": [ 30, 50 ]\n          }\n        }\n      }\n    }\n","isLeaf":true},{"key":"/Elasticsearch/10-聚合函数/09-聚合后返回前N条数据.md","path":"/Elasticsearch/10-聚合函数/09-聚合后返回前N条数据.md","route":"/Elasticsearch/10-聚合函数/09-聚合后返回前N条数据.md","leaf":true,"title":"09-聚合后返回前N条数据","depth":2,"content":"---\ntitle: 09-聚合后返回前N条数据\nurl: https://www.yuque.com/gaollard/efekv4/iqku4s\n---\n\n    # 1. 根据address字段进行聚合\n    # 2. 再根据age字段倒序输出，输出每一个地址中age字段值排名前1的数据\n    POST /myindex_percentile_ranks/_search?size=0\n    {\n      // 第一层聚合：先按照address.keyword将数据聚合成多个Bucket（聚合桶）\n      \"aggs\": {\n        \"top_tags\": {\n          \"terms\": {\n            \"field\": \"address.keyword\" \n          },\n          \"aggs\": {\n            \"top_sales_hits\": {\n              // 第二层聚合：在第一层聚合结果中的每个Bucket内进行top_hits操作\n              \"top_hits\": {\n                \"sort\": [\n                  {\n                    \"age\": {\n                      // 排序条件按照age倒序\n                      \"order\": \"desc\"\n                    }\n                  }\n                ],\n                \"_source\": {\n                  //只返回name和age字段的值\n                  \"includes\": [ \"name\", \"age\" ] \n                },\n                \"size\": 1 // 仅返回前1条记录\n              }\n            }\n          }\n        }\n      }\n    }\n\n<!---->\n\n      {\n      …\n      \"aggregations\" : {\n       …\n          \"buckets\" : [\n            {\n              \"key\" : \"美国\",\n              \"doc_count\" : 3,\n               …\n                  \"hits\" : [\n                    {\n                       …\n                      \"_source\" : {\n                        \"name\" : \"李白\",\n                        \"age\" : 50\n                      },\n                      \"sort\" : [\n                        50\n                      ]\n                    }\n                  ]\n                }\n              }\n            },\n            {\n              \"key\" : \"中国\",\n              \"doc_count\" : 2,\n              \"top_sales_hits\" : {\n                …\n                  \"hits\" : [\n                    {\n                      \"_index\" : \"myindex_percentile_ranks\",\n                      …\n                      \"_source\" : {\n                        \"name\" : \"李四\",\n                        \"age\" : 20\n                      },\n                      \"sort\" : [\n                        20\n                      ]\n                     …\n                     ```\n","isLeaf":true},{"key":"/Elasticsearch/10-聚合函数/10-top_metrics.md","path":"/Elasticsearch/10-聚合函数/10-top_metrics.md","route":"/Elasticsearch/10-聚合函数/10-top_metrics.md","leaf":true,"title":"10-top_metrics","depth":2,"content":"---\ntitle: 10-top_metrics\nurl: https://www.yuque.com/gaollard/efekv4/mgeg7k\n---\n\ntop\\_metrics 关键字与 top\\_hits 关键字非常相似，但它能够使用更少的内存来完成聚合，性能更高。\n\n    #数据准备\n    POST /myindex-top_metrics_test/_bulk?refresh\n    {\"index\": {}}\n    {\"num\": 1, \"score\": 3.1415}\n    {\"index\": {}}\n    {\"num\": 2, \"score\": 1.0}\n    {\"index\": {}}\n    {\"num\": 3, \"score\": 2.71828}\n\n    #获取索引库中num字段的最大值和对应的score信息\n    POST /myindex-top_metrics_test/_search?filter_path=aggregations\n    {\n      \"aggs\": {\n        \"tm\": {\n          \"top_metrics\": {\n            \"metrics\": {\"field\": \"score\"},\n            \"sort\": {\"num\": \"desc\"}\n          }\n        }\n      }\n    }\n\n<!---->\n\n    {\n      \"aggregations\" : {\n        \"tm\" : {\n          \"top\" : [\n            {\n              \"sort\" : [\n                3\n              ],\n              \"metrics\" : {\n                \"score\" : 2.718280076980591\n              }\n            }\n          ]\n        }\n      }\n    }\n\n<!---->\n\n    POST /myindex-top_metrics_test/_search?filter_path=aggregations\n    {\n      \"aggs\": {\n        \"tm\": {\n          \"top_metrics\": {\n            \"metrics\": {\"field\": \"score\"},\n            \"sort\": {\"num\": \"desc\"},\n            \"size\":2\n          }\n        }\n      }\n     }\n\n    {\n      \"aggregations\" : {\n        \"tm\" : {\n          \"top\" : [\n            {\n              \"sort\" : [3],\"metrics\" : {\"score\" : 2.718280076980591}\n            },\n            {\n              \"sort\" : [2],\"metrics\" : {\"score\" : 1.0}\n            }\n          ]\n        }\n      }\n    }\n\n以上结果中，根据num字段进行排序，返回前两条文档数据。\n","isLeaf":true},{"key":"/Elasticsearch/10-聚合函数/11-聚合数据结果不精确.md","path":"/Elasticsearch/10-聚合函数/11-聚合数据结果不精确.md","route":"/Elasticsearch/10-聚合函数/11-聚合数据结果不精确.md","leaf":true,"title":"11-聚合数据结果不精确","depth":2,"content":"---\ntitle: 11-聚合数据结果不精确\nurl: https://www.yuque.com/gaollard/efekv4/aowigk\n---\n\n<https://www.freesion.com/article/40661095425/>\n","isLeaf":true},{"key":"/Elasticsearch/10-聚合函数/12-聚合不支持分页码.md","path":"/Elasticsearch/10-聚合函数/12-聚合不支持分页码.md","route":"/Elasticsearch/10-聚合函数/12-聚合不支持分页码.md","leaf":true,"title":"12-聚合不支持分页码","depth":2,"content":"---\ntitle: 12-聚合不支持分页码\nurl: https://www.yuque.com/gaollard/efekv4/ruzfxn\n---\n\n    https://cloud.tencent.com/developer/article/1066373\n","isLeaf":true}]},{"key":"/Elasticsearch/11-高可用集群","path":"/Elasticsearch/11-高可用集群","route":"/Elasticsearch/11-高可用集群","leaf":false,"title":"11-高可用集群","depth":1,"content":"","isLeaf":false,"children":[{"key":"/Elasticsearch/11-高可用集群/01-多节点集群环境搭建.md","path":"/Elasticsearch/11-高可用集群/01-多节点集群环境搭建.md","route":"/Elasticsearch/11-高可用集群/01-多节点集群环境搭建.md","leaf":true,"title":"01-多节点集群环境搭建","depth":2,"content":"---\ntitle: 01-多节点集群环境搭建\nurl: https://www.yuque.com/gaollard/efekv4/eo9c9d\n---\n\n1. 客户端节点\n2. 数据节点\n3. 主节点\n","isLeaf":true},{"key":"/Elasticsearch/11-高可用集群/02-生产环境集群推荐方案.md","path":"/Elasticsearch/11-高可用集群/02-生产环境集群推荐方案.md","route":"/Elasticsearch/11-高可用集群/02-生产环境集群推荐方案.md","leaf":true,"title":"02-生产环境集群推荐方案","depth":2,"content":"---\ntitle: 02-生产环境集群推荐方案\nurl: https://www.yuque.com/gaollard/efekv4/evwq2x\n---\n\n1. 在一个生产环境集群中，我们可以对节点的职责进行划分，建议集群中设置3个以上的节点作为主节点，当现有的主节点出现故障时，这些节点可以被选举成为主节点，从而维护整个集群的状态。\n2. 然后可以根据数据量设置一批数据节点，这些节点只负责存储数据，如果集群中索引数量较大，推荐在集群中再设置一批客户端节点（在配置文件中设置node.master: false和node.data: false），这些节点只负责处理用户请求，实现请求转发、负载均衡等功能。\n","isLeaf":true},{"key":"/Elasticsearch/11-高可用集群/03-节点发现.md","path":"/Elasticsearch/11-高可用集群/03-节点发现.md","route":"/Elasticsearch/11-高可用集群/03-节点发现.md","leaf":true,"title":"03-节点发现","depth":2,"content":"---\ntitle: 03-节点发现\nurl: https://www.yuque.com/gaollard/efekv4/rtgx5w\n---\n\n当Elasticsearch集群中的节点启动后，它们会利用多播或者单播（如果用户更改了配置）寻找集群中的其他节点，并与之建立连接\n\n![](https://s3.airtlab.com/elasticsearch/20220430212947.png)\n","isLeaf":true},{"key":"/Elasticsearch/11-高可用集群/04-节点故障.md","path":"/Elasticsearch/11-高可用集群/04-节点故障.md","route":"/Elasticsearch/11-高可用集群/04-节点故障.md","leaf":true,"title":"04-节点故障","depth":2,"content":"---\ntitle: 04-节点故障\nurl: https://www.yuque.com/gaollard/efekv4/ienygf\n---\n\n在正常工作时，主节点会监控所有的节点，查看各个节点是否正常工作。如果在指定的时间某个节点无法被访问，该节点就会被视为出故障了。\n\n![](https://s3.airtlab.com/elasticsearch/20220430213044.png)\n\n当主节点发现超过3次Ping不通某一个节点，就会认为此节点宕机。节点故障的相关配置如表10-1所示。\n\n![](https://s3.airtlab.com/elasticsearch/20220430213126.png)\n","isLeaf":true},{"key":"/Elasticsearch/11-高可用集群/05-集群状态更新.md","path":"/Elasticsearch/11-高可用集群/05-集群状态更新.md","route":"/Elasticsearch/11-高可用集群/05-集群状态更新.md","leaf":true,"title":"05-集群状态更新","depth":2,"content":"---\ntitle: 05-集群状态更新\nurl: https://www.yuque.com/gaollard/efekv4/oug7g7\n---\n\n如前两节内容所述，无论是集群中新添加节点，还是节点有异常，都需要维护集群状态。而主节点是唯一一个能够更新集群状态的节点。\n\n一个时间段内主节点只能更新一个集群状态，并且将更改的集群状态发送给其他节点，当其他节点接收到状态时，先确认收到消息，但是此时并不更新到最新状态。如果主节点在规定时间（discovery.zen.commit\\_timeout默认30秒）内没有收到大多数节点（大多数节点数量=discovery.zen.minimum\\_master\\_nodes参数的值）的确认，那么集群状态更新请求不会被通过。\n\n一旦足够的节点响应了更新的消息，新的集群状态才会被提交，并且会发送一条消息给所有的节点。随后这些节点开始在内部更新至新的集群状态，如图10-6所示。\n\n![](https://s3.airtlab.com/elasticsearch/20220430213309.png)\n\n当集群状态有了新的变化，都是主节点主动通知其他节点来同步集群状态的信息。\n","isLeaf":true},{"key":"/Elasticsearch/11-高可用集群/06-主节点选举.md","path":"/Elasticsearch/11-高可用集群/06-主节点选举.md","route":"/Elasticsearch/11-高可用集群/06-主节点选举.md","leaf":true,"title":"06-主节点选举","depth":2,"content":"---\ntitle: 06-主节点选举\nurl: https://www.yuque.com/gaollard/efekv4/fnb46s\n---\n\n在集群运行过程中，主节点有可能会出现异常：\n\n![](https://s3.airtlab.com/elasticsearch/20220430213416.png)\n\n当主节点出现宕机或者网络异常时，如果造成其他节点超过3次都没有Ping通主节点，则认为当前主节点出现了异常，集群会重新选举新的主节点。\n\n如果一些节点的node.master参数事先被配置为true，则表示这种节点在主节点发生故障的时候会参加选举。在多个节点选举的过程中，节点唯一标识值越小，则越有可能被选举为主节点，如图10-8所示为代码片段。\n\n![](https://s3.airtlab.com/elasticsearch/20220430213450.png)\n\n上述代码片段是主节点进行选举的一部分代码，通过上述代码我们会发现，对于有资格被选举为主节点的各个节点，将它们的节点唯一标识进行排序，然后优先选择标识值小的节点作为主节点。\n","isLeaf":true},{"key":"/Elasticsearch/11-高可用集群/07-脑裂问题不再成为问题.md","path":"/Elasticsearch/11-高可用集群/07-脑裂问题不再成为问题.md","route":"/Elasticsearch/11-高可用集群/07-脑裂问题不再成为问题.md","leaf":true,"title":"07-脑裂问题不再成为问题","depth":2,"content":"---\ntitle: 07-脑裂问题不再成为问题\nurl: https://www.yuque.com/gaollard/efekv4/hah28e\n---\n\n当前集群中有6个节点，左边3个节点和右边3个节点不在同一个网络分区，如果两个网络分区之间出现异常，就会导致左边的3个节点重新选举一个新的主节点\n\n![](https://s3.airtlab.com/elasticsearch/20220430213622.png)\n\n可以看到，集群中出现了两个主节点，这种情况就是“脑裂”。造成“脑裂”的原因有如下几种：\n\n1）网络原因。内网一般不会出现此问题，因为可以监控内网流量状态。外网出现网络问题的可能性更大一些，会导致其他节点认为主节点宕机了，从而重新选择主节点。\n\n2）节点负载。主节点既要负责管理集群又要存储数据，当访问量大的时候，可能会导致Elasticsearch实例反应不过来而停止响应，此时其他节点在向主节点发送消息时得不到主节点的响应，就会认为主节点宕机了，从而重新选择主节点。\n\n3）内存回收。大规模回收内存也会导致Elasticsearch集群失去响应，进而导致其他节点认为主节点宕机了，从而重新选择主节点。\n\n解决脑裂问题的方案如下：只需要在配置文件中新增下面的配置即可：\n\n    discovery.zen.minimum_master_nodes: (n/2)+1\n\n在Elasticsearch 7.13版本中，Elasticsearch内部创建了一个可插拔的集群协调系统，其默认实现称为Zen Discovery。它对集群协调层进行了彻底的重建，并表示不会出现“脑裂”问题。\n","isLeaf":true},{"key":"/Elasticsearch/11-高可用集群/08-分片.md","path":"/Elasticsearch/11-高可用集群/08-分片.md","route":"/Elasticsearch/11-高可用集群/08-分片.md","leaf":true,"title":"08-分片","depth":2,"content":"---\ntitle: 08-分片\nurl: https://www.yuque.com/gaollard/efekv4/hgxy0q\n---\n\n\n\n### 1. 分片设置\n\n    #分片设置如下\n    PUT /索引库名称/_settings\n    {\n      \"number_of_shards\": 1,\n      \"number_of_replicas\": 4\n    }\n\n<!---->\n\n    PUT /clayindex\n    {\n       \"settings\": {\n        \"number_of_shards\": 2,      #主分片数量是2\n        \"number_of_replicas\": 1     #副本分片数量是1\n       }, \n       \"mappings\": {\n         \"properties\": {\n         \"name\":{\n           \"type\": \"keyword\"\n         },\n         \"address\":{\n            \"type\": \"text\"\n         },\n         \"age\":{\n            \"type\": \"integer\"\n         }\n         }\n       }\n    }\n\n在创建索引映射的时候，可以在settings参数中指定分片数量。需要注意的是，如果有索引已经建立，那么修改的时候只能修改副本分片的数量，主分片数量不可以修改\n\n\n\n### 2. 多少个分片数量才合理\n\n**1. 避免分片过大**\n\n因为这样会对集群“从故障中恢复”造成不利的影响。尽管并没有关于分片大小的固定限值，但是开发和运维人员通常将50GB作为分片上限，而且这一限值在各种用例中都已得到了验证。\n\n**2. 分片不可过小**\n\n分片过小会导致“段”（Segment，Elasticsearch中存储数据的空间块）过小，进而导致开销增加。用户要尽量将分片的平均大小控制在几GB到几十GB。对于时序型数据而言，分片大小通常介于20GB～40GB。\n\n**3. 文档归并**\n\n由于单个分片的开销取决于“段”的数量和“段”的大小，因此通过文档归并（forcemerge）操作强制将较小的“段”合并为较大的“段”。这样做能够减少开销并改善查询的性能。理想状况下，应当在索引内无数据写入的时候完成此操作。但是需要注意的是，文档归并操作是一个极其耗费资源的操作，所以应该在非高峰时段进行。\n\n**4. 分片数量限制**\n\n每个节点上可以存储的分片数量与可用的堆内存大小成正比，但是Elasticsearch并未强制规定固定限值。推荐将单个分片存储索引数据的大小控制在20GB左右，绝对不要超过50GB，分片的数量可以根据如下公式计算：\n\n    分片数量=数据总量 / 20GB\n\n\n\n### 3. 数据存储分片机制应对扩容和分片故障的方式\n\n如图10-11所示，集群中有3个主分片，3个副本分片，每个主分片对应一个副本分片，而且主分片和副本分片分布在不同的节点。\n\n所以当集群中内任何一个节点出现问题的时候，我们的数据都完好无损。当我们写入文档时，这些文档都会保存在主分片上，然后被并行地复制到对应的副本分片上。\n\n这样就保证了既可以从主分片上获得文档数据，又可以从副本分片上获得文档数据，也提高了查询效率。\n\n![](https://s3.airtlab.com/elasticsearch/20220430214308.png)\n\n当新加入Node3节点对集群进行扩容时，Node1和Node2上各有一个分片被迁移到了新的Node 3节点上。此时，每个节点上都拥有两个分片，而不是之前的3个分片。这样每个节点的硬件资源将被更少的分片所使用，每个分片的性能将会得到提升。\n\n![](https://s3.airtlab.com/elasticsearch/20220430214430.png)\n\n我们发现，Node1和Node2组合后的分片是（R0,R1,P1,P2），Node1和Node3组合后的分片是（R2,P0,P1,P2），Node2和Node3组合后的分片是（R0,R1,P0,R2）。所以当这3个节点中有任何一个节点出现异常时，其余两个节点中的分片都完整地保留了分片0、分片1、分片2的数据。也就是说，当出现任何一个节点宕机时，也不会导致服务异常，只不过新的主节点会把副本分片提升为主分片。但是当出现两个节点同时出现异常时，则此集群状态就不能正确提供服务，因为集群数据不完整。\n","isLeaf":true},{"key":"/Elasticsearch/11-高可用集群/09-数据存储段合并详情.md","path":"/Elasticsearch/11-高可用集群/09-数据存储段合并详情.md","route":"/Elasticsearch/11-高可用集群/09-数据存储段合并详情.md","leaf":true,"title":"09-数据存储段合并详情","depth":2,"content":"---\ntitle: 09-数据存储段合并详情\nurl: https://www.yuque.com/gaollard/efekv4/phxgsz\n---\n\n当客户端写入数据时，同时把数据写入translog日志（防止服务重启导致内存数据库丢失）和索引缓存（index buffer）中。在用户读取数据的时候，读取的是“段”中的数据。在Elasticsearch中，写入和打开一个新段（Segment）的过程叫作刷新（Refresh）。\n\nElasticsearch数据写入流程: ![](https://s3.airtlab.com/elasticsearch/20220430214729.png)\n\n在默认情况下，每个分片每秒会自动刷新一次。这就是我们说 Elasticsearch 是近实时搜索引擎的原因（`文档的变化并不是立即对搜索可见，但会在一秒之内变为可见`）。每个数据分片是由很多段组成的，每个段都需要占用内存等资源。\n\n为了提高性能，Elasticsearch会定期将小的段进行合并，生成较大的段。由于自动刷新流程每秒会创建一个新的段，这样会导致短时间内段的数量暴增。而段的数量太多会带来比较大的麻烦，因为每一个段都会消耗IO、内存和CPU等资源。更重要的是，每个搜索请求都必须轮流检查每个段，所以段越多，搜索也就越慢。Elasticsearch通过在后台进行段合并来解决这个问题。小的段被合并到大的段里面，然后这些大的段再被合并到更大的段里面。当段合并的时候，会将那些旧的已删除的文档从文件系统中清除。旧的文档（或被更新文档的旧版本）不会被复制到新的大段中去。以下是段相关的一些操作：\n\n1）当写入索引数据的时候，刷新操作会创建新的段并且将段的状态设置为打开以供搜索使用。\n\n2）段合并的时候会选择一小部分大小相似的段，并且在后台将它们合并到更大的段中。\n\n3）段合并结束时，旧的段中的数据会被删除。\n\n刷新操作并不需要每秒进行一次。如果有业务正在使用Elasticsearch索引中大量的日志文件，此时用户想要优化数据写入性能，可以通过设置refresh\\_interval参数进行优化，以降低索引的刷新频率，提高数据写入的性能。语法如下：\n\n    #设置时间时间为30秒，表示每30秒进行一次刷新\n    PUT /索引库名称\n    {\n      \"settings\": {\n        \"refresh_interval\": \"30s\"\n      }\n    }\n\n    #关闭自动刷新操作\n    PUT /索引库名称/_settings\n    { \"refresh_interval\": -1 }\n\n    #开启刷新且刷新时间为1秒\n    PUT /索引库名称/_settings\n    { \"refresh_interval\": \"1s\" }\n","isLeaf":true}]},{"key":"/Elasticsearch/12-高级操作和性能调优","path":"/Elasticsearch/12-高级操作和性能调优","route":"/Elasticsearch/12-高级操作和性能调优","leaf":false,"title":"12-高级操作和性能调优","depth":1,"content":"","isLeaf":false,"children":[{"key":"/Elasticsearch/12-高级操作和性能调优/01-概要介绍.md","path":"/Elasticsearch/12-高级操作和性能调优/01-概要介绍.md","route":"/Elasticsearch/12-高级操作和性能调优/01-概要介绍.md","leaf":true,"title":"01-概要介绍","depth":2,"content":"---\ntitle: 01-概要介绍\nurl: https://www.yuque.com/gaollard/efekv4/tlu5g3\n---\n\n- 索引别名使用详情\n- 索引模板别名使用详情\n- 实现滚动查询\n- 实现跨集群查询\n- 实现SQL操作\n- 性能优化详解\n","isLeaf":true},{"key":"/Elasticsearch/12-高级操作和性能调优/02-索引别名.md","path":"/Elasticsearch/12-高级操作和性能调优/02-索引别名.md","route":"/Elasticsearch/12-高级操作和性能调优/02-索引别名.md","leaf":true,"title":"02-索引别名","depth":2,"content":"---\ntitle: 02-索引别名\nurl: https://www.yuque.com/gaollard/efekv4/ree60u\n---\n\n假设有一个学生的原始索引 student\\_index\\_v1，我们给它起一个别名 student\\_index，程序中也是用别名 student\\_index 进行查询，当业务需求发生改变，需要修改索引库名称的时候，重新创建一个索引库 student\\_index\\_v2，将别名 student\\_index 指向新的索引库 student\\_index\\_v2，同时将 student\\_index\\_v1 索引库的数据迁移到新的 student\\_index\\_v2 索引库中，这样我们就可以做到在零停机下从旧索引库切换到新索引库。索引别名就像一个快捷方式或者软链接。\n\n    #给索引库test1创建别名alias1\n    POST /_aliases\n    {\n        \"actions\" : [\n            { \"add\" : { \"index\" : \"test1\", \"alias\" : \"alias1\" } }\n        ]\n    }\n\n    #删除索引库对应的别名\n    POST /_aliases\n    {\n        \"actions\" : [\n            { \"remove\" : { \"index\" : \"test1\", \"alias\" : \"alias1\" } }\n        ]\n    }\n\n    #索引别名指向新的索引库\n    POST /_aliases\n    {\n        \"actions\" : [\n            { \"remove\" : { \"index\" : \"test1\", \"alias\" : \"alias1\" } },\n            { \"add\" : { \"index\" : \"test2\", \"alias\" : \"alias1\" } }\n        ]\n    }\n\n以上语句先进行索引别名移除，然后创建索引别名。这个操作是具有原子性的，因此不需要担心短时间内别名不指向一个索引库。\n\n    #一个别名关联多个索引库\n    POST /_aliases\n    {\n      \"actions\" : [\n        { \"add\" : { \"indices\" : [\"test1\", \"test2\"], \"alias\" : \"alias1\" } }\n      ]\n    }\n","isLeaf":true},{"key":"/Elasticsearch/12-高级操作和性能调优/03-索引模板别名.md","path":"/Elasticsearch/12-高级操作和性能调优/03-索引模板别名.md","route":"/Elasticsearch/12-高级操作和性能调优/03-索引模板别名.md","leaf":true,"title":"03-索引模板别名","depth":2,"content":"---\ntitle: 03-索引模板别名\nurl: https://www.yuque.com/gaollard/efekv4/nvemx8\n---\n\n在Elasticsearch中，如果想要根据索引模板为索引库指定别名，需要使用aliases关键字\n\n    #创建索引模板并指定别名\n    PUT _template/templateds\n    {\n        \"template\": \"log*\",\n        \"order\": 0,\n        \"settings\": {\n            \"number_of_shards\":2\n        },\n         \"aliases\": {\n           \"log-query\":{}  #别名名称\n         },\n        \"mappings\": {\n                     \n                \"properties\": {\n                    \"name\": {\n                        \"type\": \"keyword\"\n                    },\n                    \"id\": {\n                        \"type\": \"long\"\n                    }\n                }\n                  \n        }\n    }\n\n以上语句创建了一个名为templateds的索引模板名，索引模板的匹配值是\"log*\"。根据这个模板创建的索引，它们的别名都是log-query。也就是说，当我们执行下面两个语句时，会自动为log1索引库和log2索引库创建相同的索引映射信息，而且log1和log2索引库的别名都是log-query：\n\n    POST /log1/_doc/1\n    {\n      \"person_name\": \"张三\",\n      \"id\": 1\n    }\n\n    GET log1\n\n    POST /log2/_doc/1\n    {\n      \"person_name\": \"李四\",\n      \"id\": 2\n    }\n\n在以上语句中，当我们给log1和log2索引库写入数据时，log1和log2匹配到了log*。所以系统会根据模板自动生成log1和log2索引映射。我们需要同时查询两个索引库的数据时，可以使用别名通过一条语句来查询，语句如下：\n\n    POST /log-query/_search\n    {\n        \"size\": 10\n    }\n\n以上语句会同时查询log1和log2索引库的数据。\n","isLeaf":true},{"key":"/Elasticsearch/12-高级操作和性能调优/04-滚动查询.md","path":"/Elasticsearch/12-高级操作和性能调优/04-滚动查询.md","route":"/Elasticsearch/12-高级操作和性能调优/04-滚动查询.md","leaf":true,"title":"04-滚动查询","depth":2,"content":"---\ntitle: 04-滚动查询\nurl: https://www.yuque.com/gaollard/efekv4/qp076g\n---\n\n当索引库中数据量特别大的时候，`深度分页的操作` 会给Elasticsearch集群的性能带来极大损耗。为了解决这个问题，Elasticsearch提供了滚动查询来避免这种情况。范例如下：\n\n    #创建索引库并指定映射关系\n    PUT scrolldb\n    {\n      \"mappings\" : {\n        \"properties\" : {\n          \"name\" : {\n            \"type\" : \"keyword\"\n          },\n          \"age\" : {\n            \"type\" : \"integer\"\n          }\n        }\n      }\n    }\n\n    #批量新增数据\n    POST _bulk\n    { \"index\" : { \"_index\" : \"scrolldb\", \"_id\" : \"1\" } }\n    { \"name\" : \"张三\", \"age\": 12}\n    { \"index\" : { \"_index\" : \"scrolldb\", \"_id\" : \"2\" } }\n    { \"name\" : \"李四\", \"age\": 10 }\n    { \"index\" : { \"_index\" : \"scrolldb\", \"_id\" : \"3\" } }\n    { \"name\" : \"王五\", \"age\": 11 }\n    { \"index\" : { \"_index\" : \"scrolldb\", \"_id\" : \"4\" } }\n\n    #滚动查询，每次查询返回2条文档，并且数据量不能超过1MB，也就是说当一条文档信息超过1MB的时候，只会返回1条文档信息\n    POST /scrolldb/_search?scroll=1m\n    {\n        \"size\": 2,\n        \"query\": {\n            \"match_all\": {\n                   \n            }\n        }\n    }\n\n结果：\n\n    {\n      #下次进行滚动查询需要带的标识\n      \"_scroll_id\" : \"FGluY2x1ZGVfY29udGV4dF91dWlkDXF1ZXJ5QW5kRmV0Y2gBFjZnWUJ1RTJYUmZhTzhCMVNUemNIX2cAAAAAAAFmQxZ5UWdMX25LNlJYR1JMeHltWlhkcVVR\",\n      \"took\" : 4,\n      \"timed_out\" : false,\n      \"_shards\" : {\n        \"total\" : 1,\n        \"successful\" : 1,\n        \"skipped\" : 0,\n        \"failed\" : 0\n      },\n      \"hits\" : {\n        \"total\" : {\n          \"value\" : 3,\n          \"relation\" : \"eq\"\n        },\n        \"max_score\" : 1.0,\n        \"hits\" : [\n          {\n            \"_index\" : \"scrolldb\",\n            \"_type\" : \"_doc\",\n            \"_id\" : \"1\",\n            \"_score\" : 1.0,\n            \"_source\" : {\n              \"name\" : \"张三\",\n              \"age\" : 12\n            }\n          },\n          {\n            \"_index\" : \"scrolldb\",\n            \"_type\" : \"_doc\",\n            \"_id\" : \"2\",\n            \"_score\" : 1.0,\n            \"_source\" : {\n              \"name\" : \"李四\",\n              \"age\" : 10\n            }\n          }\n        ]\n      }\n    }\n    #使用滚动查询返回信息的scroll_id继续查询，直到查不出为止，一般情况下当查询结果数量小于第一次查询执行的size时，结束查询\n    POST /_search/scroll \n    {\n        \"scroll\" : \"1m\", \n        \"scroll_id\" : \" FGluY2x1ZGVfY29udGV4dF91dWlkDXF1ZXJ5QW5kRmV0Y2gBFjZnWUJ1RTJYUmZhTzhCMVNUemNIX2cAAAAAAAFmQxZ5UWdMX25LNlJYR1JMeHltWlhkcVVR \" \n    }\n","isLeaf":true},{"key":"/Elasticsearch/12-高级操作和性能调优/05-跨集群查询.md","path":"/Elasticsearch/12-高级操作和性能调优/05-跨集群查询.md","route":"/Elasticsearch/12-高级操作和性能调优/05-跨集群查询.md","leaf":true,"title":"05-跨集群查询","depth":2,"content":"---\ntitle: 05-跨集群查询\nurl: https://www.yuque.com/gaollard/efekv4/emtsb1\n---\n\n<https://weread.qq.com/web/reader/52332a607280c170523409ek7323297027173278a4a8f1d>\n\n\n\n### 1. 远程集群配置\n\n通过执行如下语句配置3个远程集群，分别是cluster\\_one、cluster\\_two和cluster\\_three。\n\n    PUT _cluster/settings\n        {\n          \"persistent\": {\n            \"cluster\": {\n              \"remote\": {\n                \"cluster_one\": {\n                  \"seeds\": [\n                    \"127.0.0.1:9300\"\n                  ]\n                },\n                \"cluster_two\": {\n                  \"seeds\": [\n                    \"127.0.0.1:9301\"\n                  ]\n                },\n                \"cluster_three\": {\n                  \"seeds\": [\n                    \"127.0.0.1:9302\"\n                  ]\n                }\n              }\n            }\n          }\n        }\n\n\n\n### 2. 跨集群查询\n\n    #筛选查询cluster_one集群中索引名称是clay1的数据\n    GET /cluster_one:clay1/_search\n    {\n      \"query\": {\n        \"match\": {\n          \"name\": \"张三\"\n        }\n      }\n    }\n","isLeaf":true},{"key":"/Elasticsearch/12-高级操作和性能调优/06-使用SQL语句操作Elasticsearch.md","path":"/Elasticsearch/12-高级操作和性能调优/06-使用SQL语句操作Elasticsearch.md","route":"/Elasticsearch/12-高级操作和性能调优/06-使用SQL语句操作Elasticsearch.md","leaf":true,"title":"06-使用SQL语句操作Elasticsearch","depth":2,"content":"---\ntitle: 06-使用SQL语句操作Elasticsearch\nurl: https://www.yuque.com/gaollard/efekv4/qusmsi\n---\n\n    #数据准备\n    POST /sqldbindex/_doc\n    {\n      \"name\":\"clay\",\n      \"age\":18,\n      \"address\":\"江苏省\",\n      \"birth\":\"1998-01-0\"\n    }\n\n    POST /sqldbindex/_doc\n    {\n      \"name\":\"jick\",\n      \"age\":17,\n      \"address\":\"江苏省\",\n      \"birth\":\"1999-01-0\"\n    }\n\n    #使用SQL操作Elasticsearch中的数据\n    POST /_xpack/sql?format=txt\n    {\n      \"query\":\"select * from sqldbindex\"\n    }\n\n<!---->\n\n    #! Deprecation: [POST /_xpack/sql] is deprecated! Use [POST /_sql] instead.\n        address    |      age      |     birth     |     name      \n    ---------------+---------------+---------------+---------------\n    江苏省            |18             |1998-01-0      |clay           \n    江苏省            |17             |1999-01-0      |jick\n\n<!---->\n\n    #使用SQL操作Elasticsearch中的数据\n    POST /_sql\n    {\n      \"query\":\"select * from sqldbindex\"\n    }\n\n<!---->\n\n    {\n      \"columns\" : [\n        {\n          \"name\" : \"address\",\n          \"type\" : \"text\"\n        },\n        {\n          \"name\" : \"age\",\n          \"type\" : \"long\"\n        },\n        {\n          \"name\" : \"birth\",\n          \"type\" : \"text\"\n        },\n        {\n          \"name\" : \"name\",\n          \"type\" : \"text\"\n        }\n      ],\n      \"rows\" : [\n        [\n          \"江苏省\",\n          18,\n          \"1998-01-0\",\n          \"clay\"\n        ],\n        [\n          \"江苏省\",\n          17,\n          \"1999-01-0\",\n          \"jick\"\n        ]\n      ]\n    }\n\n需要注意的是，SQL语句中的表名称就是Elasticsearch中索引库的名称。只要懂SQL语句，就能很方便地操作Elasticsearch。sum函数和count函数的使用如图11-4所示。\n\n    #使用SQL操作Elasticsearch中的数据\n    POST /_sql\n    {\n      \"query\":\"select name as ns from sqldbindex\"\n    }\n\n![](https://s3.airtlab.com/elasticsearch/20220430221524.png)\n","isLeaf":true},{"key":"/Elasticsearch/12-高级操作和性能调优/07-Elasticsearch性能优化详解.md","path":"/Elasticsearch/12-高级操作和性能调优/07-Elasticsearch性能优化详解.md","route":"/Elasticsearch/12-高级操作和性能调优/07-Elasticsearch性能优化详解.md","leaf":true,"title":"07-Elasticsearch性能优化详解","depth":2,"content":"---\ntitle: 07-Elasticsearch性能优化详解\nurl: https://www.yuque.com/gaollard/efekv4/xkev1d\n---\n\n\n\n### 1. 数据结构优化\n\n基于Elasticsearch的使用场景，文档数据的结构尽量和使用场景相结合，去掉没用的和不合理的数据。下面介绍数据结构优化需要注意的地方。\n\n- 尽量减少不需要的字段\n- 尽量使用静态映射, 使用动态映射有可能会导致集群崩溃\n\n\n\n### 2. 查询优化\n\n**Cache的设置及使用**\n\nElasticsearch在查询的时候，使用filter查询会用到querycache，如果业务场景中的过滤查询比较多，建议将querycache设置得大一些，以提高查询速度。设置如下：\n\n    indices.queries.cache.size： 10%\n\n以上设置是默认的，可以设置成百分比，也可以设置成具体的值，如256MB。\n\n**合理使用深度翻页**\n\n在使用 Elasticsearch 的过程中，应尽量避免深度翻页的出现。正常翻页查询都是从from开始size条数据，需要在每个分片中查询文档评分在前面的from+size条数据，然后协同节点收集每个分配的前from+size条数据，协同节点一共会收到N*(from+size)条数据，然后进行排序，再将其中from到from+size条数据返回。如果from或者size很大的话，会导致参加排序的数量过大，最终会导致CPU资源消耗增大。对于这种深度翻页的业务，推荐使用Elasticsearch中的滚动查询来解决。\n\n\n\n### 3. 索引优化设置\n\n索引优化主要是在Elasticsearch的数据插入层面优化。下面介绍索引优化设置需要注意的地方。\n\n**合理批量提交**\n\n当有大量数据需要提交时，建议采用批量提交（Bulk操作）的方式。此外，使用Bulk请求时，每个请求的数据量不宜过大，因为太大会导致内存使用过多，尽量控制在几十MB之内。\n\n**增加刷新时间间隔**\n\n为了提高搜索性能，Elasticsearch在写入数据的时候采用延迟写入的策略，即数据先写到内存中，当超过默认的1秒（index.refresh\\_interval）后会进行一次写入操作，就是将内存中的段数据刷新到磁盘中，此时才能将数据搜索出来，所以这就是Elasticsearch提供的是近实时搜索功能，而不是实时搜索功能的原因。如果系统对数据延迟要求不高的话，可以通过延长刷新时间间隔来有效地减少段合并的压力，提高索引的性能。比如在做全链路日志跟踪的过程中，我们就将index.refresh\\_interval设置为30秒，减少刷新次数。再如，在进行数据导入时，可以将“刷新”临时关闭，即把index.refresh\\_interval设置为设1，数据导入成功后再打开为正常模式。\n\n**注意\\_id字段的使用**\n\n在创建索引或者写入文档数据时，应该尽可能避免使用自定义的\\_id，建议使用Elasticsearch的默认ID生成策略，这样对于Elasticsearch内部进行数据负载有很大作用。\n\n**注意\\_all和\\_source字段的使用**\n\n\\_all和\\_source字段的使用应该注意场景和需要，\\_all字段包含所有的索引字段，方便做全文搜索，如果无此需求，可以禁用；\\_source存储了原始的文档内容，如果没有获取原始文档数据的需求，可通过设置includes、excludes属性来定义放入\\_source的字段。\n\n\n\n### 4. 硬件配置优化\n\n升级硬件设备的配置一直都是提高服务能力最快速有效的手段之一。在系统层面能够影响应用性能的因素一般有3个：CPU、内存和IO，可以从这3个方面对Elasticsearch的性能进行优化。下面介绍硬件配置优化方面需要注意的地方。\n\n**磁盘的选择**\n\n硬盘对所有的集群都很重要，对大量写入数据的集群更是加倍重要。硬盘是服务器上最慢的子系统，这意味着那些写入量很大的集群很容易让硬盘饱和，使得它成为集群的瓶颈。在经济压力能承受的范围内，尽量使用固态硬盘（Solid StateDrive，SSD）。固态硬盘相比任何旋转介质，无论是随机写还是顺序写，都会对IO有较大的提升。\n\n**禁止swap**\n\n在使用Elasticsearch的时候，推荐做法是禁用swap，一旦允许内存与磁盘交换，就会引起致命的性能问题。可以通过在config/elasticsearch.yml配置文件中修改bootstrap.memory\\_lock: true来保持JVM锁定内存，以保证Elasticsearch的性能。\n\n**内存配置**\n\n在Elasticsearch中，排序和聚合都很耗内存，所以有足够的堆空间来应付它们是很重要的。即使堆空间比较小，也能为操作系统文件缓存提供额外的内存。因为Lucene使用的许多数据结构都是基于磁盘的格式，Elasticsearch利用操作系统缓存对性能的提升能产生很大的效果。如果机器内存等于64GB，可以给Elasticsearch分配32GB，留下32GB给Lucene。当服务内存是32GB和16GB时，最少也需要给Elasticsearch分配8GB。\n","isLeaf":true},{"key":"/Elasticsearch/12-高级操作和性能调优/08-refresh-and-flush.md","path":"/Elasticsearch/12-高级操作和性能调优/08-refresh-and-flush.md","route":"/Elasticsearch/12-高级操作和性能调优/08-refresh-and-flush.md","leaf":true,"title":"08-refresh-and-flush","depth":2,"content":"---\ntitle: 08-refresh-and-flush\nurl: https://www.yuque.com/gaollard/efekv4/mmp7p5\n---\n\n\n\n### Refresh\n\n默认情况下，ES会每秒refresh一次，每次操作都会把内存缓冲区的内容拷贝到新创建的 segment 中去，这一步是在内存中操作的，这个时候新的文档就会被搜索了。也就是说ES是近实时性的搜索，差不多1s钟，才能让数据可以被搜索到。\n\n\n\n### Flush\n\nFlush操作意味着，所有在内存缓冲区的文档被写到新的 Lucene Segment 中，也就是所有在内存中的segment被提交到了磁盘，同时清除translog。\n\n\n\n### 总结\n\n- 一般Flush的时间间隔会比较久，默认30分钟，或者当translog达到了一定的大小，也会触发flush操作。\n- refresh 操作是为了让最新的数据可以立即被搜索到，而 flush 操作则是为了让数据持久化到磁盘中，另外ES的搜索是在内存中处理的，因此Flush操作不影响数据能否被搜索到。\n","isLeaf":true}]},{"key":"/Elasticsearch/13-一些疑问","path":"/Elasticsearch/13-一些疑问","route":"/Elasticsearch/13-一些疑问","leaf":false,"title":"13-一些疑问","depth":1,"content":"","isLeaf":false,"children":[{"key":"/Elasticsearch/13-一些疑问/01-diffrent-result-in-twice-query-if-not-set-sort.md","path":"/Elasticsearch/13-一些疑问/01-diffrent-result-in-twice-query-if-not-set-sort.md","route":"/Elasticsearch/13-一些疑问/01-diffrent-result-in-twice-query-if-not-set-sort.md","leaf":true,"title":"01-diffrent-result-in-twice-query-if-not-set-sort","depth":2,"content":"---\ntags: elasticsearch\n---\n\n一个奇怪的现象，如果 ES 查询时不设置排序时，测试两次的查询结果可能不一致，为了保持一致，最好设置排序规则。\n\n```json\n{\n  \"sort\": [\n    { \"create_time\": { \"order\": \"DESC\" } },\n  ],\n  \"from\": 0,\n  \"size\": 10\n}\n```","isLeaf":true},{"key":"/Elasticsearch/13-一些疑问/02-mysql-to-es-dsl.md","path":"/Elasticsearch/13-一些疑问/02-mysql-to-es-dsl.md","route":"/Elasticsearch/13-一些疑问/02-mysql-to-es-dsl.md","leaf":true,"title":"02-mysql-to-es-dsl","depth":2,"content":"https://printlove.cn/tools/sql2es","isLeaf":true}]},{"key":"/Elasticsearch/ES 学习教程.md","path":"/Elasticsearch/ES 学习教程.md","route":"/Elasticsearch/ES 学习教程.md","leaf":true,"title":"ES 学习教程","depth":1,"content":"---\ntitle: ES 学习教程\nurl: https://www.yuque.com/gaollard/efekv4/trxkus\n---\n\n\n\n### 1. 参考资料\n\n- <https://blog.csdn.net/weixin_44715126/article/details/117402616>\n- <https://mm.edrawsoft.cn/template/143601>\n- <https://github.com/elastic/elasticsearch-js>\n- <https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/index.html>\n- <https://weread.qq.com/web/reader/52332a607280c170523409ek636320102206364d3f0ffdc>\n- \\[基础] [Elasticsearch 菜鸟教程](https://www.knowledgedict.com/tutorial/elasticsearch-intro.html)\n- \\[基础] [ElasticSearch 全面分析与实践](https://weread.qq.com/web/reader/52332a607280c170523409e)\n- \\[进阶] [Elasticsearch源码解析与优化实战](https://weread.qq.com/web/reader/f9c32dc07184876ef9cdeb6kc81322c012c81e728d9d180)\n\n笔记资料：<https://github.com/gaollard/learb-db>\n\n\n\n### 2. 学习工具\n\n- chrome elasticsearch 插件\n- [bodybuilder](https://www.npmjs.com/package/bodybuilder)\n- kibana <http://8.135.111.215:5601/app/kibana#/dev_tools/console?_g=()>\n\n\n\n### 3. 套件安装\n\n- elasticsearch\n- logstash\n- kibana\n\n\n\n### 4. 常见问题\n\n\n\n#### 1.  [elasticsearch如何结合mysql一起使用？](https://www.zhihu.com/question/451680402/answer/1806594948)\n\n\n\n#### 2. No spaces match search criteria\n","isLeaf":true}]},{"key":"/Mysql","path":"/Mysql","route":"/Mysql","leaf":false,"title":"Mysql","depth":0,"content":"","isLeaf":false,"children":[{"key":"/Mysql/01 学习资料.md","path":"/Mysql/01 学习资料.md","route":"/Mysql/01 学习资料.md","leaf":true,"title":"01 学习资料","depth":1,"content":"---\ntitle: 学习资料\n---\n\n- [菜鸟教程](https://www.runoob.com/mysql/mysql-tutorial.html)\n- [B站动力节点](https://www.bilibili.com/video/BV1a3411N7CE?spm_id_from=333.337.search-card.all.click)\n- [慕课网 MySQL 开发技巧](https://www.imooc.com/learn/398)\n- [美化 SQL 在线](https://www.dpriver.com/pp/sqlformat.htm)","isLeaf":true},{"key":"/Mysql/01-基础认识","path":"/Mysql/01-基础认识","route":"/Mysql/01-基础认识","leaf":false,"title":"01-基础认识","depth":1,"content":"","isLeaf":false,"children":[{"key":"/Mysql/01-基础认识/01-my.conf.md","path":"/Mysql/01-基础认识/01-my.conf.md","route":"/Mysql/01-基础认识/01-my.conf.md","leaf":true,"title":"01-my.conf","depth":2,"content":"---\ntitle: 01-my.conf\n---\n\n```typescript\n[client]\nport = 3306\nsocket = /tmp/mysql.sock\n\n \n\n[mysqld]\nport = 3306\nsocket = /tmp/mysql.sock\n\nbasedir = /usr/local/mysql\ndatadir = /data/mysql\npid-file = /data/mysql/mysql.pid\nuser = mysql\nbind-address = 0.0.0.0\nserver-id = 1 #表示是本机的序号为1,一般来讲就是master的意思\n\nskip-name-resolve\n# 禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。但需要注意，如果开启该选项，\n# 则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求\n\n#skip-networking\n\nback_log = 600\n# MySQL能有的连接数量。当主要MySQL线程在一个很短时间内得到非常多的连接请求，这就起作用，\n# 然后主线程花些时间(尽管很短)检查连接并且启动一个新线程。back_log值指出在MySQL暂时停止回答新请求之前的短时间内多少个请求可以被存在堆栈中。\n# 如果期望在一个短时间内有很多连接，你需要增加它。也就是说，如果MySQL的连接数据达到max_connections时，新来的请求将会被存在堆栈中，\n# 以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源。\n# 另外，这值（back_log）限于您的操作系统对到来的TCP/IP连接的侦听队列的大小。\n# 你的操作系统在这个队列大小上有它自己的限制（可以检查你的OS文档找出这个变量的最大值），试图设定back_log高于你的操作系统的限制将是无效的。\n\nmax_connections = 1000\n# MySQL的最大连接数，如果服务器的并发连接请求量比较大，建议调高此值，以增加并行连接数量，当然这建立在机器能支撑的情况下，因为如果连接数越多，介于MySQL会为每个连接提供连接缓冲区，就会开销越多的内存，所以要适当调整该值，不能盲目提高设值。可以过'conn%'通配符查看当前状态的连接数量，以定夺该值的大小。\n\nmax_connect_errors = 6000\n# 对于同一主机，如果有超出该参数值个数的中断错误连接，则该主机将被禁止连接。如需对该主机进行解禁，执行：FLUSH HOST。\n\nopen_files_limit = 65535\n# MySQL打开的文件描述符限制，默认最小1024;当open_files_limit没有被配置的时候，比较max_connections*5和ulimit -n的值，哪个大用哪个，\n# 当open_file_limit被配置的时候，比较open_files_limit和max_connections*5的值，哪个大用哪个。\n\ntable_open_cache = 128\n# MySQL每打开一个表，都会读入一些数据到table_open_cache缓存中，当MySQL在这个缓存中找不到相应信息时，才会去磁盘上读取。默认值64\n# 假定系统有200个并发连接，则需将此参数设置为200*N(N为每个连接所需的文件描述符数目)；\n# 当把table_open_cache设置为很大时，如果系统处理不了那么多文件描述符，那么就会出现客户端失效，连接不上\n\nmax_allowed_packet = 4M\n# 接受的数据包大小；增加该变量的值十分安全，这是因为仅当需要时才会分配额外内存。例如，仅当你发出长查询或MySQLd必须返回大的结果行时MySQLd才会分配更多内存。\n# 该变量之所以取较小默认值是一种预防措施，以捕获客户端和服务器之间的错误信息包，并确保不会因偶然使用大的信息包而导致内存溢出。\n\nbinlog_cache_size = 1M\n# 一个事务，在没有提交的时候，产生的日志，记录到Cache中；等到事务提交需要提交的时候，则把日志持久化到磁盘。默认binlog_cache_size大小32K\n\nmax_heap_table_size = 8M\n# 定义了用户可以创建的内存表(memory table)的大小。这个值用来计算内存表的最大行数值。这个变量支持动态改变\n\ntmp_table_size = 16M\n# MySQL的heap（堆积）表缓冲大小。所有联合在一个DML指令内完成，并且大多数联合甚至可以不用临时表即可以完成。\n# 大多数临时表是基于内存的(HEAP)表。具有大的记录长度的临时表 (所有列的长度的和)或包含BLOB列的表存储在硬盘上。\n# 如果某个内部heap（堆积）表大小超过tmp_table_size，MySQL可以根据需要自动将内存中的heap表改为基于硬盘的MyISAM表。还可以通过设置tmp_table_size选项来增加临时表的大小。也就是说，如果调高该值，MySQL同时将增加heap表的大小，可达到提高联接查询速度的效果\n\nread_buffer_size = 2M\n# MySQL读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySQL会为它分配一段内存缓冲区。read_buffer_size变量控制这一缓冲区的大小。\n# 如果对表的顺序扫描请求非常频繁，并且你认为频繁扫描进行得太慢，可以通过增加该变量值以及内存缓冲区大小提高其性能\n\nread_rnd_buffer_size = 8M\n# MySQL的随机读缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，\n# MySQL会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySQL会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大\n\nsort_buffer_size = 8M\n# MySQL执行排序使用的缓冲大小。如果想要增加ORDER BY的速度，首先看是否可以让MySQL使用索引而不是额外的排序阶段。\n# 如果不能，可以尝试增加sort_buffer_size变量的大小\n\njoin_buffer_size = 8M\n# 联合查询操作所能使用的缓冲区大小，和sort_buffer_size一样，该参数对应的分配内存也是每连接独享\n\nthread_cache_size = 8\n# 这个值（默认8）表示可以重新利用保存在缓存中线程的数量，当断开连接时如果缓存中还有空间，那么客户端的线程将被放到缓存中，\n# 如果线程重新被请求，那么请求将从缓存中读取,如果缓存中是空的或者是新的请求，那么这个线程将被重新创建,如果有很多新的线程，\n# 增加这个值可以改善系统性能.通过比较Connections和Threads_created状态的变量，可以看到这个变量的作用。(–>表示要调整的值)\n# 根据物理内存设置规则如下：\n# 1G  —> 8\n# 2G  —> 16\n# 3G  —> 32\n# 大于3G  —> 64\n\nquery_cache_size = 8M\n#MySQL的查询缓冲大小（从4.0.1开始，MySQL提供了查询缓冲机制）使用查询缓冲，MySQL将SELECT语句和查询结果存放在缓冲区中，\n# 今后对于同样的SELECT语句（区分大小写），将直接从缓冲区中读取结果。根据MySQL用户手册，使用查询缓冲最多可以达到238%的效率。\n# 通过检查状态值'Qcache_%'，可以知道query_cache_size设置是否合理：如果Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况，\n# 如果Qcache_hits的值也非常大，则表明查询缓冲使用非常频繁，此时需要增加缓冲大小；如果Qcache_hits的值不大，则表明你的查询重复率很低，\n# 这种情况下使用查询缓冲反而会影响效率，那么可以考虑不用查询缓冲。此外，在SELECT语句中加入SQL_NO_CACHE可以明确表示不使用查询缓冲\n\nquery_cache_limit = 2M\n#指定单个查询能够使用的缓冲区大小，默认1M\n\nkey_buffer_size = 4M\n#指定用于索引的缓冲区大小，增加它可得到更好处理的索引(对所有读和多重写)，到你能负担得起那样多。如果你使它太大，\n# 系统将开始换页并且真的变慢了。对于内存在4GB左右的服务器该参数可设置为384M或512M。通过检查状态值Key_read_requests和Key_reads，\n# 可以知道key_buffer_size设置是否合理。比例key_reads/key_read_requests应该尽可能的低，\n# 至少是1:100，1:1000更好(上述状态值可以使用SHOW STATUS LIKE 'key_read%'获得)。注意：该参数值设置的过大反而会是服务器整体效率降低\n\nft_min_word_len = 4\n# 分词词汇最小长度，默认4\n\ntransaction_isolation = REPEATABLE-READ\n# MySQL支持4种事务隔离级别，他们分别是：\n# READ-UNCOMMITTED, READ-COMMITTED, REPEATABLE-READ, SERIALIZABLE.\n# 如没有指定，MySQL默认采用的是REPEATABLE-READ，ORACLE默认的是READ-COMMITTED\n\nlog_bin = mysql-bin\nbinlog_format = mixed\nexpire_logs_days = 30 #超过30天的binlog删除\n\nlog_error = /data/mysql/mysql-error.log #错误日志路径\nslow_query_log = 1\nlong_query_time = 1 #慢查询时间 超过1秒则为慢查询\nslow_query_log_file = /data/mysql/mysql-slow.log\n\nperformance_schema = 0\nexplicit_defaults_for_timestamp\n\n#lower_case_table_names = 1 #不区分大小写\n\nskip-external-locking #MySQL选项以避免外部锁定。该选项默认开启\n\ndefault-storage-engine = InnoDB #默认存储引擎\n\ninnodb_file_per_table = 1\n# InnoDB为独立表空间模式，每个数据库的每个表都会生成一个数据空间\n# 独立表空间优点：\n# 1．每个表都有自已独立的表空间。\n# 2．每个表的数据和索引都会存在自已的表空间中。\n# 3．可以实现单表在不同的数据库中移动。\n# 4．空间可以回收（除drop table操作处，表空不能自已回收）\n# 缺点：\n# 单表增加过大，如超过100G\n# 结论：\n# 共享表空间在Insert操作上少有优势。其它都没独立表空间表现好。当启用独立表空间时，请合理调整：innodb_open_files\n\ninnodb_open_files = 500\n# 限制Innodb能打开的表的数据，如果库里的表特别多的情况，请增加这个。这个值默认是300\n\ninnodb_buffer_pool_size = 64M\n# InnoDB使用一个缓冲池来保存索引和原始数据, 不像MyISAM.\n# 这里你设置越大,你在存取表里面数据时所需要的磁盘I/O越少.\n# 在一个独立使用的数据库服务器上,你可以设置这个变量到服务器物理内存大小的80%\n# 不要设置过大,否则,由于物理内存的竞争可能导致操作系统的换页颠簸.\n# 注意在32位系统上你每个进程可能被限制在 2-3.5G 用户层面内存限制,\n# 所以不要设置的太高.\n\ninnodb_write_io_threads = 4\ninnodb_read_io_threads = 4\n# innodb使用后台线程处理数据页上的读写 I/O(输入输出)请求,根据你的 CPU 核数来更改,默认是4\n# 注:这两个参数不支持动态改变,需要把该参数加入到my.cnf里，修改完后重启MySQL服务,允许值的范围从 1-64\n\ninnodb_thread_concurrency = 0\n# 默认设置为 0,表示不限制并发数，这里推荐设置为0，更好去发挥CPU多核处理能力，提高并发量\n\ninnodb_purge_threads = 1\n# InnoDB中的清除操作是一类定期回收无用数据的操作。在之前的几个版本中，清除操作是主线程的一部分，这意味着运行时它可能会堵塞其它的数据库操作。\n# 从MySQL5.5.X版本开始，该操作运行于独立的线程中,并支持更多的并发数。用户可通过设置innodb_purge_threads配置参数来选择清除操作是否使用单\n# 独线程,默认情况下参数设置为0(不使用单独线程),设置为 1 时表示使用单独的清除线程。建议为1\n\ninnodb_flush_log_at_trx_commit = 2\n# 0：如果innodb_flush_log_at_trx_commit的值为0,log buffer每秒就会被刷写日志文件到磁盘，提交事务的时候不做任何操作（执行是由mysql的master thread线程来执行的。\n# 主线程中每秒会将重做日志缓冲写入磁盘的重做日志文件(REDO LOG)中。不论事务是否已经提交）默认的日志文件是ib_logfile0,ib_logfile1\n# 1：当设为默认值1的时候，每次提交事务的时候，都会将log buffer刷写到日志。\n# 2：如果设为2,每次提交事务都会写日志，但并不会执行刷的操作。每秒定时会刷到日志文件。要注意的是，并不能保证100%每秒一定都会刷到磁盘，这要取决于进程的调度。\n# 每次事务提交的时候将数据写入事务日志，而这里的写入仅是调用了文件系统的写入操作，而文件系统是有 缓存的，所以这个写入并不能保证数据已经写入到物理磁盘\n# 默认值1是为了保证完整的ACID。当然，你可以将这个配置项设为1以外的值来换取更高的性能，但是在系统崩溃的时候，你将会丢失1秒的数据。\n# 设为0的话，mysqld进程崩溃的时候，就会丢失最后1秒的事务。设为2,只有在操作系统崩溃或者断电的时候才会丢失最后1秒的数据。InnoDB在做恢复的时候会忽略这个值。\n# 总结\n# 设为1当然是最安全的，但性能页是最差的（相对其他两个参数而言，但不是不能接受）。如果对数据一致性和完整性要求不高，完全可以设为2，如果只最求性能，例如高并发写的日志服务器，设为0来获得更高性能\n\ninnodb_log_buffer_size = 2M\n# 此参数确定些日志文件所用的内存大小，以M为单位。缓冲区更大能提高性能，但意外的故障将会丢失数据。MySQL开发人员建议设置为1－8M之间\n\ninnodb_log_file_size = 32M\n# 此参数确定数据日志文件的大小，更大的设置可以提高性能，但也会增加恢复故障数据库所需的时间\n\ninnodb_log_files_in_group = 3\n# 为提高性能，MySQL可以以循环方式将日志文件写到多个文件。推荐设置为3\n\ninnodb_max_dirty_pages_pct = 90\n# innodb主线程刷新缓存池中的数据，使脏数据比例小于90%\n\ninnodb_lock_wait_timeout = 120 \n# InnoDB事务在被回滚之前可以等待一个锁定的超时秒数。InnoDB在它自己的锁定表中自动检测事务死锁并且回滚事务。InnoDB用LOCK TABLES语句注意到锁定设置。默认值是50秒\n\nbulk_insert_buffer_size = 8M\n# 批量插入缓存大小， 这个参数是针对MyISAM存储引擎来说的。适用于在一次性插入100-1000+条记录时， 提高效率。默认值是8M。可以针对数据量的大小，翻倍增加。\n\nmyisam_sort_buffer_size = 8M\n# MyISAM设置恢复表之时使用的缓冲区的尺寸，当在REPAIR TABLE或用CREATE INDEX创建索引或ALTER TABLE过程中排序 MyISAM索引分配的缓冲区\n\nmyisam_max_sort_file_size = 10G\n# 如果临时文件会变得超过索引，不要使用快速排序索引方法来创建一个索引。注释：这个参数以字节的形式给出\n\nmyisam_repair_threads = 1\n# 如果该值大于1，在Repair by sorting过程中并行创建MyISAM表索引(每个索引在自己的线程内) \n\ninteractive_timeout = 28800\n# 服务器关闭交互式连接前等待活动的秒数。交互式客户端定义为在mysql_real_connect()中使用CLIENT_INTERACTIVE选项的客户端。默认值：28800秒（8小时）\n\nwait_timeout = 28800\n# 服务器关闭非交互连接之前等待活动的秒数。在线程启动时，根据全局wait_timeout值或全局interactive_timeout值初始化会话wait_timeout值，\n# 取决于客户端类型(由mysql_real_connect()的连接选项CLIENT_INTERACTIVE定义)。参数默认值：28800秒（8小时）\n# MySQL服务器所支持的最大连接数是有上限的，因为每个连接的建立都会消耗内存，因此我们希望客户端在连接到MySQL Server处理完相应的操作后，\n# 应该断开连接并释放占用的内存。如果你的MySQL Server有大量的闲置连接，他们不仅会白白消耗内存，而且如果连接一直在累加而不断开，\n# 最终肯定会达到MySQL Server的连接上限数，这会报'too many connections'的错误。对于wait_timeout的值设定，应该根据系统的运行情况来判断。\n# 在系统运行一段时间后，可以通过show processlist命令查看当前系统的连接状态，如果发现有大量的sleep状态的连接进程，则说明该参数设置的过大，\n# 可以进行适当的调整小些。要同时设置interactive_timeout和wait_timeout才会生效。\n\n[mysqldump]\nquick\nmax_allowed_packet = 16M #服务器发送和接受的最大包长度\n\n[myisamchk]\nkey_buffer_size = 8M\nsort_buffer_size = 8M\nread_buffer = 4M\nwrite_buffer = 4M\n```\n","isLeaf":true},{"key":"/Mysql/01-基础认识/02-安装部署.md","path":"/Mysql/01-基础认识/02-安装部署.md","route":"/Mysql/01-基础认识/02-安装部署.md","leaf":true,"title":"02-安装部署","depth":2,"content":"---\ntitle: 02-安装部署\n---\n\n### 1. docker 安装\n\n镜像地址 <https://hub.docker.com/_/mysql?tab=tags>\n\n```shell\ndocker pull mysql\ndocker run -itd --name mysql-test -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql\n```\n\n- 3306:3306 ：`宿主机端口:容器端口`，外部主机可以直接通过 `宿主机ip:3306` 访问到 MySQL 的服务。\n- MYSQL\\_ROOT\\_PASSWORD=123456：设置 MySQL 服务 root 用户的密码。\n\n### 2. 服务启动\n\n**MacOS**\n\n```bash\nbrew services start mysql\n```\n\n**window**\n\n```bash\nmysql> net stop mysql\nmysql> net start mysql\n```\n\n**docker**\n```shell\ndocker stop $containerId\ndocker start $containerId\n```\n\n### Windows\n\nMySQL启动，停止，重启方法：\n\n一、启动方式\n\n1、使用 service 启动：service mysqld start\n\n2、使用 mysqld 脚本启动：/etc/inint.d/mysqld start\n\n3、使用 safe_mysqld 启动：safe_mysqld&\n\n二、停止\n\n1、使用 service 启动：service mysqld stop\n\n2、使用 mysqld 脚本启动：/etc/inint.d/mysqld stop\n\n3、mysqladmin shutdown\n\n三、重启\n\n1、使用 service 启动：service mysqld restart\n\n2、使用 mysqld 脚本启动：/etc/inint.d/mysqld restart","isLeaf":true},{"key":"/Mysql/01-基础认识/03-登录操作.md","path":"/Mysql/01-基础认识/03-登录操作.md","route":"/Mysql/01-基础认识/03-登录操作.md","leaf":true,"title":"03-登录操作","depth":2,"content":"---\ntitle: 03-登录操作\n---\n\n## 1. 登陆 mysql\n\n### 1.1 本机登录\n\n```bash\nmysql> mysql -uroot -p # 回车输入密码再回车\n```\n\n### 1.2 远程登录\n\n```bash\n# 格式\nmysql -h ip -u root -p -P 3306\n\n# 例如\nmysql -h 127.0.0.1 -u root -p -P 3306\n\nmysql -h 39.108.138.156 -u root -p -P 3306\n```\n\n## 2. 允许远程登录\n\n初始化的mysql用户权限只能localhost访问，外部机器访问需要添加权限。\n\n### 2.1 mysql 5\n\n```bash\nmysql> Grant all privileges on *.* to 'root'@'%' identified by 'password' with grant option;\n```\n\n(%表示任意ip，如果指定ip，改为对应ip即可；‘root’是指要使用的用户名)\n\n```bash\nmysql> flush privileges;  # (刷新权限或者重启mysql)\n```\n\n1. GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'password' ;\n   这里的 123456 为你给新增权限用户设置的密码，%代表所有主机，也可以具体到你的主机ip地址\n2. flush privileges;  这一步一定要做，不然无法成功！ 这句表示从 mysql 数据库的grant表中重新加载权限数据\n   因为MySQL把权限都放在了 cache 中，所以在做完更改后需要重新加载。\n   执行完这两步，再次查询用户表命令：select User,authentication\\_string,Host from user\n   发现多了一个用户，该用户所有的主机都可以访问，此时再次用sqlyog访问连接成功！ \n\n### 2.2 mysql 8\n\nmysql8 版本执行 `grant all privileges on *.*  to  'root'@'%'  identified by 'root'  with grant option;`\n\n会报语法错误  ERROR 1064 (42000)\n\n应先创建新用户\n\n```sql\ncreate user 'admin'@'%' identified by 'password';\n```\n\n执行授权\n\n```sql\nGRANT ALL PRIVILEGES ON *.* TO 'admin'@'%';\n```\n\n刷新\n```sql\nflush privileges;\n```\n\n授权远程\n\n```sql\nALTER USER 'admin'@'%' IDENTIFIED WITH mysql_native_password BY 'password';\n```\n\n刷新\n\n```sql\nflush privileges;\n```\n## 3. 修改登录密码的加密方式\n<https://www.cnblogs.com/zhurong/p/9898675.html>\n<https://www.cnblogs.com/wpf0419/p/15466752.html>","isLeaf":true},{"key":"/Mysql/01-基础认识/04-辅助命令.md","path":"/Mysql/01-基础认识/04-辅助命令.md","route":"/Mysql/01-基础认识/04-辅助命令.md","leaf":true,"title":"04-辅助命令","depth":2,"content":"---\ntitle: 04-辅助命令\n---\n\n## 1、显示数据库列表\n\n```bash\nshow databases;\n```\n\n![](http://s3.airtlab.com/mysql/20220522215927.png)\n\n## 2、显示数据表的结构\n\n```bash\nmysql>describe 表名;\n\n# (或者)\nmysql>desc 表名;\n```\n\n![](http://s3.airtlab.com/mysql/20220522220033.png)\n\n## 3、建库与删库\n\n```bash\nmysql> create database 库名;\nmysql> drop database 库名;\n```\n\n![](http://s3.airtlab.com/mysql/20220522220055.png)\n\n## 4、建表\n\n```bash\nmysql> use 库名;\nmysql> create table 表名(字段列表);\nmysql> drop table 表名；\n```\n\n![](http://s3.airtlab.com/mysql/20220522220206.png)\n\n## 5. 查看 mysql 版本\n\n    mysql> select version();\n    +-----------+\n    | version() |\n    +-----------+\n    | 8.0.21    |\n    +-----------+\n    1 row in set (0.00 sec)\n\n## 6. 查看当前使用的数据库\n\n    mysql> select database();\n    +------------+\n    | database() |\n    +------------+\n    | test       |\n    +------------+\n    1 row in set (0.00 sec)\n\n## 7. 查看表结构\n\n    mysql> desc student;\n    +--------------+--------------+------+-----+---------+----------------+\n    | Field        | Type         | Null | Key | Default | Extra          |\n    +--------------+--------------+------+-----+---------+----------------+\n    | id           | int unsigned | NO   | PRI | NULL    | auto_increment |\n    | student_name | varchar(11)  | YES  |     | NULL    |                |\n    | class_id     | int          | YES  |     | NULL    |                |\n    +--------------+--------------+------+-----+---------+----------------+\n    3 rows in set (0.00 sec)\n\n## 8. 查看建表语句\n\n    mysql> show create table student;\n    +---------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n    | Table   | Create Table                                                                                                                                                                                                                                             |\n    +---------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n    | student | CREATE TABLE `student` (\n      `id` int unsigned NOT NULL AUTO_INCREMENT,\n      `student_name` varchar(11) DEFAULT NULL,\n      `class_id` int DEFAULT NULL,\n      PRIMARY KEY (`id`)\n    ) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci |\n    +---------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n    1 row in set (0.00 sec)\n\n## 9. 导入数据库\n\n    mysql > source [sql_file_path]\n\n## 10. 取消一条语句\n\n    mysql> select \n        -> \n        -> \\c\n    mysql> \n    mysql> select \n        -> \n        -> ^C\n    mysql>\n\n## 11. 退出 mysql\n\n    mysql> \\q\n    Bye\n\n    mysql> exit\n    Bye\n","isLeaf":true},{"key":"/Mysql/01-基础认识/05-语句分类.md","path":"/Mysql/01-基础认识/05-语句分类.md","route":"/Mysql/01-基础认识/05-语句分类.md","leaf":true,"title":"05-语句分类","depth":2,"content":"---\ntitle: 05-语句分类\n---\n\n**DQL 数据查询**\n\n```bash\n# 凡是 select 开头\nselect ...\n```\n\n**DML 数据操作**\n\n```bash\n# 数据的增删改\ninset  ***\nupdate ***\ndelete ***\n```\n\n**DDL 数据定义**\n\n```bash\n# 对表结构的增删改\ncreate\ndrop\nalert\n```\n\n**TCL 事务控制**\n\n```bash\n# 提交事物 回滚事物\ncommit\nrollback\n```\n\n**DCL 数据控制**\n\n```bash\n# 授权/取消授权\ngrant\nrevoke\n```\n","isLeaf":true},{"key":"/Mysql/01-基础认识/06-数据库管理.md","path":"/Mysql/01-基础认识/06-数据库管理.md","route":"/Mysql/01-基础认识/06-数据库管理.md","leaf":true,"title":"06-数据库管理","depth":2,"content":"---\ntitle: 06-数据库管理\n---\n\n## 1. 用户管理\n\n![](http://s3.airtlab.com/mysql/20220522221950.png)\n![](http://s3.airtlab.com/mysql/20220522222004.png)\n如果需要访问其他库或表，需外额外授权。比如建表也要对应的建表权限：\n\n![image.png](http://s3.airtlab.com/mysql/1661781061517-827578e9-b541-4f95-a53f-482cec80b3dd.png)\n\n## 2. 权限管理\n\n### 2.1 增加权限\n\n![](http://s3.airtlab.com/mysql/20220522222117.png)\n![](http://s3.airtlab.com/mysql/20220522222129.png)\n\n### 2.2 撤销权限\n\n![](http://s3.airtlab.com/mysql/20220522222137.png)\n\n## 3. 导入导出\n\n![](http://s3.airtlab.com/mysql/20220522222145.png)\n","isLeaf":true},{"key":"/Mysql/01-基础认识/07-存储引擎.md","path":"/Mysql/01-基础认识/07-存储引擎.md","route":"/Mysql/01-基础认识/07-存储引擎.md","leaf":true,"title":"07-存储引擎","depth":2,"content":"---\ntitle: 07-存储引擎\n---\n\n## 1. 查看当前mysql支持的存储引擎\n\n![image.png](http://s3.airtlab.com/mysql/1601970720136-d8704cdf-de7a-414f-a92d-e4b6722021dd.png) \n\n## 2. 什么是存储引擎\n\n![image.png](http://s3.airtlab.com/mysql/1601970624945-4b06a5fe-0b92-4a31-a6c4-66a63134da4e.png) \n\n## 3. 常见存储引擎\n\n### 3.1 MYISAM\n\n![image.png](http://s3.airtlab.com/mysql/1601970964228-806f5cd4-f923-44d5-ae1f-6caeb105f696.png)\n![image.png](http://s3.airtlab.com/mysql/1601971297877-ae810ab2-e111-400b-9898-d8629384b5de.png) \n\n### 3.2 innoDB\n\n![image.png](http://s3.airtlab.com/mysql/1601971418135-b9aa2c54-9afb-4583-9406-1cf4cc50202a.png)\n![image.png](http://s3.airtlab.com/mysql/1601971695968-db89d3eb-6bf0-4636-bf31-0c57e9fe714d.png) \n\n#### 3.2.1 级联删除和更新\n\n在具有主外键的父子表中，提供删除父表时，同时删除字表的功能。\n\n### 3.3 MEMORY\n\n![image.png](http://s3.airtlab.com/mysql/1601971760236-24541d92-d434-4d8d-b82c-598ed02c9cc9.png)\n![image.png](http://s3.airtlab.com/mysql/1601971796616-7f3525d1-5b66-470e-bbb2-dc6e18f12d82.png)\n","isLeaf":true},{"key":"/Mysql/01-基础认识/08-数据操作.md","path":"/Mysql/01-基础认识/08-数据操作.md","route":"/Mysql/01-基础认识/08-数据操作.md","leaf":true,"title":"08-数据操作","depth":2,"content":"---\ntitle: 08-数据操作\n---\n\n## 1. 建表语句\n\n### 1.1 简单用法\n\n![image.png](http://s3.airtlab.com/mysql/1601908348937-91b4e3ca-3cbd-4199-9a35-c0bf441ed945.png)\n![image.png](http://s3.airtlab.com/mysql/1601908524229-e532c80a-f39d-4d25-938d-914ec4d70c4c.png) \n\n### 1.2 字段默认值\n\n![image.png](http://s3.airtlab.com/mysql/1601908863955-f6ddc28a-941e-487d-90b8-ea324fd5b6ad.png) \n\n## 2. 插入数据\n\n### 2.1 常用写法\n\n![image.png](http://s3.airtlab.com/mysql/1601908658192-2a84e38b-b707-4639-b654-5df9ec8d2ad9.png)![image.png](http://s3.airtlab.com/mysql/1601908673495-dbf776f8-4c94-4c21-a7da-2301723a921c.png)\n![image.png](http://s3.airtlab.com/mysql/1601908737038-5ff5c405-ab89-4411-855e-33d469380124.png)\n\n### 2.2 省略字段名\n\n可以省略字段名，但是要保证 values 的列以及顺序：\n![image.png](http://s3.airtlab.com/mysql/1601909044000-e89f9579-9ff0-4d2f-bcb7-189b0cab46d6.png) \n\n### 2.3 批量插入\n\n![image.png](http://s3.airtlab.com/mysql/1601909161876-242d4b31-8dfb-4f4b-958d-83e25a0c10bc.png) \n\n## 3. 表的复制\n\n![image.png](http://s3.airtlab.com/mysql/1601909315690-1ae48412-b540-497f-8e51-ce34d004c5c3.png)\n![image.png](http://s3.airtlab.com/mysql/1601909348517-e4adea1a-82b4-45e2-9cd9-7a6fea71791a.png)\n\n## 4. 修改记录\n\n注意下面的 \",\" 不能写成 and\n![image.png](http://s3.airtlab.com/mysql/1601909474821-7725e949-a4f0-4b28-8057-c02c4f66f783.png)\n![image.png](http://s3.airtlab.com/mysql/1601909587175-31bbacf8-bf6f-4ee0-b87e-f90e250bb899.png)\n\n## 6. 删除记录\n\n![image.png](http://s3.airtlab.com/mysql/1601948470266-14b2c449-0976-46b0-b724-2d59f3402248.png)\n![image.png](http://s3.airtlab.com/mysql/1601950008844-b5078395-850a-4722-8efd-0fb98e35257d.png)\n\n## 7. 修改表结构\n![image.png](http://s3.airtlab.com/mysql/1601949016580-ebec25be-b18f-4f8d-8ed4-617e6346c1e8.png)","isLeaf":true}]},{"key":"/Mysql/02-查询语句","path":"/Mysql/02-查询语句","route":"/Mysql/02-查询语句","leaf":false,"title":"02-查询语句","depth":1,"content":"","isLeaf":false,"children":[{"key":"/Mysql/02-查询语句/01-简单查询.md","path":"/Mysql/02-查询语句/01-简单查询.md","route":"/Mysql/02-查询语句/01-简单查询.md","leaf":true,"title":"01-简单查询","depth":2,"content":"---\ntitle: 01-简单查询\n---\n\n## 1、查询字段\n\n- sql 语句以分号结尾\n- sql 语句不区分大小写 \n\n### 1. 查询一个字段\n\n```bash\nmysql> select id from student;\n+----+\n| id |\n+----+\n|  1 |\n|  2 |\n|  3 |\n|  4 |\n|  5 |\n|  7 |\n+----+\n6 rows in set (0.00 sec)\n```\n\n### 2. 查询多个字段\n\n```bash\nmysql> select id, student_name from student;\n+----+--------------+\n| id | student_name |\n+----+--------------+\n|  1 | ??           |\n|  2 | ??           |\n|  3 | ??           |\n|  4 | ??           |\n|  5 | ??           |\n|  7 | ??           |\n+----+--------------+\n6 rows in set (0.00 sec)\n```\n\n### 3. 查询全部字段\n\n    mysql> select * from student;\n    +----+--------------+----------+\n    | id | student_name | class_id |\n    +----+--------------+----------+\n    |  1 | ??           |        1 |\n    |  2 | ??           |        1 |\n    |  3 | ??           |        2 |\n    |  4 | ??           |        2 |\n    |  5 | ??           |        3 |\n    |  7 | ??           |       99 |\n    +----+--------------+----------+\n    6 rows in set (0.00 sec)\n\n### 4. 给字段起别名\n\n    mysql> select id, student_name as name  from student;\n    +----+------+\n    | id | name |\n    +----+------+\n    |  1 | ??   |\n    |  2 | ??   |\n    |  3 | ??   |\n    |  4 | ??   |\n    |  5 | ??   |\n    |  7 | ??   |\n    +----+------+\n    6 rows in set (0.00 sec)\n\n当别名为数字或者中文时，需要使用单引号。 \n\n## 2、**条件查询**\n\n### 1. mysql 运算符\n\n![](http://s3.airtlab.com/mysql/1661782051502-765ff27c-546e-401a-98ce-afd2091e8dc6.png)\n\n### 2. NULL 不是一个值\n\n![](http://s3.airtlab.com/mysql/1661782051499-ea7c845c-4741-424e-b165-078161c63c12.png)\n\n\n\n### 3. and 和 or 的优先级\n\n![](http://s3.airtlab.com/mysql/1661782051576-3a3d24d1-a612-47df-9136-c16d5955e10d.png)\n\n\n\n### 4. 模糊查询 like\n\n![](http://s3.airtlab.com/mysql/1661782051853-62ef74ec-1edd-441d-9ada-3b66192071f1.png)\n\n如果需要匹配 % \\_ 需要转译处理。 \n\n## 3、查询排序\n\n![image.png](http://s3.airtlab.com/mysql/1661782110452-70ee0ac9-65fe-4d6d-9daa-397af5165f79.png) \n\n### 1. 单一条件排序\n\n```sql\n-- 降序 DESC 默认升序\nSELECT * from student order by class_id DESC\n\n-- 升序 asc\nSELECT * from student order by class_id asc\n```\n\n### 2. 多条件排序\n\n```sql\n-- 先按照 class_id 降序，再按照 age 升序\nSELECT * from student order by class_id DESC, age asc\n```\n\n\n\n## 4、去重查询\n\n\n\n### 1. 单字段去重&#xA;![](http://s3.airtlab.com/mysql/1661782874994-1ec034bf-5235-4332-ba5b-615b48b68c06.png)\n\n\n### 2. 多字段去重&#xA;![](http://s3.airtlab.com/mysql/1661782875276-3dc5a245-3bb3-4d7c-8e41-9be303985513.png)\n\n### 3. 统计去重后的数量&#xA;![](http://s3.airtlab.com/mysql/1661782874984-10c9fb74-1353-4a01-9d32-1eb5650ddbd8.png)\n\n## 5、分页查询\n\n![image.png](http://s3.airtlab.com/mysql/1601888522322-9dc722db-434b-475d-992d-957b7d0ce754.png)\n![image.png](http://s3.airtlab.com/mysql/1601888545880-ee5ee7ce-9c1f-474f-b16e-f6152cd0d188.png)\n![image.png](http://s3.airtlab.com/mysql/1601888563228-bc40c2cb-b036-44b4-bc58-a4449d932b86.png)\n","isLeaf":true},{"key":"/Mysql/02-查询语句/02-聚合函数.md","path":"/Mysql/02-查询语句/02-聚合函数.md","route":"/Mysql/02-查询语句/02-聚合函数.md","leaf":true,"title":"02-聚合函数","depth":2,"content":"---\ntitle: 02-聚合函数\nurl: https://www.yuque.com/gaollard/utbbp1\n---\n\n\n\n### 1、5个聚合函数\n\n![](http://s3.airtlab.com/mysql/20220522232300.png)\n\n\n\n### 2、聚合函数使用限制\n\n分组函数不能直接使用在 where 子句中。\n\n\n\n### 3、count(*) 和 count(field) 区别\n\n![](http://s3.airtlab.com/mysql/20220522232337.png)\n\n\n\n### 4、处理单行数据\n\n![](http://s3.airtlab.com/mysql/20220522232356.png) \n\n### 5、ifnull()\n\n![image.png](http://s3.airtlab.com/mysql/1661782554406-24d19cc4-3dad-4ab0-ba4e-0e3957d8c210.png)\n","isLeaf":true},{"key":"/Mysql/02-查询语句/03-分组查询.md","path":"/Mysql/02-查询语句/03-分组查询.md","route":"/Mysql/02-查询语句/03-分组查询.md","leaf":true,"title":"03-分组查询","depth":2,"content":"---\ntitle: 03-分组查询\nurl: https://www.yuque.com/gaollard/utbbp1\n---\n\n\n\n### 1、group by\n\n\n\n#### 1. 简单用法\n\n![](http://s3.airtlab.com/mysql/20220522232517.png)\n\n\n\n#### 2. 分组时可以查询的字段？(聚和参数 & 分组字段)\n\n![](http://s3.airtlab.com/mysql/20220522232542.png)\n![](http://s3.airtlab.com/mysql/20220522232607.png)\n\n\n\n#### 3. 多字段联合分组\n\n![](http://s3.airtlab.com/mysql/20220522232637.png)\n![](http://s3.airtlab.com/mysql/20220522232702.png)\n\n\n\n### 2、having\n\n只有出现了 group by 才能使用 having。\n![](http://s3.airtlab.com/mysql/20220522232736.png)\n\n**上面这个用法效率低，可以优先考虑使用 where**\n![](http://s3.airtlab.com/mysql/20220522232807.png)\n\n**但是有时候 where 搞不定：**\n![](http://s3.airtlab.com/mysql/20220522232847.png)\n\n\n\n### 3. DQL 总结\n\n![](http://s3.airtlab.com/mysql/20220522232903.png)\n","isLeaf":true},{"key":"/Mysql/02-查询语句/04-连接查询.md","path":"/Mysql/02-查询语句/04-连接查询.md","route":"/Mysql/02-查询语句/04-连接查询.md","leaf":true,"title":"04-连接查询","depth":2,"content":"---\ntitle: 04-连接查询\nurl: https://www.yuque.com/gaollard/utbbp1\n---\n\n### 1. 什么是连接查询\n\n![](http://s3.airtlab.com/mysql/20220523223037.png)\n\n\n### 2. 连接查询的分类\n\n![](http://s3.airtlab.com/mysql/20220523223056.png)\n\n\n\n### 3. 笛卡尔乘积\n\n![](http://s3.airtlab.com/mysql/20220523223113.png)\n![](http://s3.airtlab.com/mysql/20220523223120.png)\n\n\n\n### 4. 内连接\n\n\n\n#### 1 等值连接\n\n![](http://s3.airtlab.com/mysql/20220523223151.png)\n\n这里省略了 inner。\n\n\n\n#### 2 非等值关系\n\n![](http://s3.airtlab.com/mysql/20220523223220.png)\n\n\n\n#### 3 自连接\n\n自连接最大的特点是一张表看成两张表使用。\n![](http://s3.airtlab.com/mysql/20220523223238.png)\n![](http://s3.airtlab.com/mysql/20220523223244.png)\n\n\n\n### 5. 外连接\n\n\n\n#### 1. 外连接和内连接区别\n\n![](http://s3.airtlab.com/mysql/20220523223315.png)\n\n\n\n### 6. 三张表及以上的查询\n\n**1）案例1**\n\n![](http://s3.airtlab.com/mysql/20220523223351.png)\n\n员工表\n![](http://s3.airtlab.com/mysql/20220523223410.png)\n\n部门表：\n![](http://s3.airtlab.com/mysql/20220523223427.png)\n\n工资等级表：\n![](http://s3.airtlab.com/mysql/20220523223439.png)\n\n![](http://s3.airtlab.com/mysql/20220523223452.png)\n\n**2） 案例2**\n![](http://s3.airtlab.com/mysql/20220523223537.png)\n","isLeaf":true},{"key":"/Mysql/02-查询语句/05-子查询.md","path":"/Mysql/02-查询语句/05-子查询.md","route":"/Mysql/02-查询语句/05-子查询.md","leaf":true,"title":"05-子查询","depth":2,"content":"---\ntitle: 05-子查询\nurl: https://www.yuque.com/gaollard/utbbp1\n---\n\n\n\n## 1. 什么是子查询\n\n![image.png](http://s3.airtlab.com/mysql/1601885338455-0e369f30-0ce3-4113-b5c2-e625306e9d14.png) \n\n## 2. where 子句中使用子查询\n\n![image.png](http://s3.airtlab.com/mysql/1601885473666-c6c1b7f5-2e87-49a5-9308-ad606a5b3ffe.png)\n![image.png](http://s3.airtlab.com/mysql/1601885488943-301bcb91-5d6a-4da4-a7ef-fa435b6cf442.png)\n![image.png](http://s3.airtlab.com/mysql/1601885510484-1e5c9275-71fc-41e1-a0b1-014616828b83.png) \n\n## 3. from 后面嵌套子查询\n\n（1）找出每个部门平均薪水的薪资等级\n![image.png](http://s3.airtlab.com/mysql/1601886221555-6c9c170b-b8db-4677-a1bb-5bf0b9af10fc.png)\n（2）找出每个部门平均的薪水等级\n![image.png](http://s3.airtlab.com/mysql/1601886458573-93559269-e915-4567-8a97-0105cc0857ee.png)\n![image.png](http://s3.airtlab.com/mysql/1601886801680-65fe3708-0a0c-49c4-a526-e56917dc5df3.png)\n![image.png](http://s3.airtlab.com/mysql/1601886912539-8bfefd1e-1368-45bb-9e43-ca4eb8d4b375.png)\n这里不需要临时表。 \n\n## 4. select 后面嵌套子查询\n\n![image.png](http://s3.airtlab.com/mysql/1601887387337-4c0fcacc-839d-4d04-af0d-553444199009.png)\n这里没必要这么写。\n","isLeaf":true},{"key":"/Mysql/02-查询语句/06-union用法.md","path":"/Mysql/02-查询语句/06-union用法.md","route":"/Mysql/02-查询语句/06-union用法.md","leaf":true,"title":"06-union用法","depth":2,"content":"---\ntitle: 06-union用法\nurl: https://www.yuque.com/gaollard/utbbp1\n---\n\nunion 可以将查询结果集相加:\n![image.png](http://s3.airtlab.com/mysql/1601888135416-33e41530-f96c-44e3-b84f-6eebad546da8.png)\n![image.png](http://s3.airtlab.com/mysql/1601888153407-fd2055a2-c3f6-4978-8af6-1b5ef75585db.png)\n\n***\n\n![image.png](http://s3.airtlab.com/mysql/1601888191141-4757336b-bd9a-4783-a799-acec39dd1330.png)\n使用 union 必须保证两个结果集列数一样，否则报错。\n","isLeaf":true},{"key":"/Mysql/02-查询语句/07-字段约束.md","path":"/Mysql/02-查询语句/07-字段约束.md","route":"/Mysql/02-查询语句/07-字段约束.md","leaf":true,"title":"07-字段约束","depth":2,"content":"---\ntitle: 07-字段约束\nurl: https://www.yuque.com/gaollard/utbbp1\n---\n\n\n\n## 1. 约束的介绍\n\n![image.png](http://s3.airtlab.com/mysql/1601949417466-64cc808a-93df-4dd5-bdea-cef7839eb762.png) \n\n## 2. 非空约束\n\n![image.png](http://s3.airtlab.com/mysql/1601949603518-89343fb9-5c39-48dd-8b87-da796e62c34d.png) \n\n## 3. 唯一性约束\n\n\n\n### 3.1 列约束\n\n![image.png](http://s3.airtlab.com/mysql/1601959085218-1e629fec-f253-4c81-8f76-1428414815ad.png) \n\n### 3.2 表约束\n\n![image.png](http://s3.airtlab.com/mysql/1601959135270-1497c7ba-6b57-4833-8bf0-03156fb5d627.png) \n\n## 4. 主键约束(重点)\n\n![image.png](http://s3.airtlab.com/mysql/1601959597383-50596c01-d603-4ed7-b63e-3929e0a91230.png)\n![image.png](http://s3.airtlab.com/mysql/1601961365296-2a6ea6df-851e-4923-8cd8-84608b1aeea3.png)\n\n![image.png](http://s3.airtlab.com/mysql/1601961407320-94a0444b-851a-4ab9-9814-eb1972023a70.png)\n![image.png](http://s3.airtlab.com/mysql/1601961557702-5bc98c0a-641b-4cf3-b09d-1ec6ec290df7.png)\n![image.png](http://s3.airtlab.com/mysql/1601961612224-e263a879-e80c-4734-a5b0-aaccd5d3a38f.png)\n![image.png](http://s3.airtlab.com/mysql/1601963951481-5123afa9-d96a-4b32-9395-445106781914.png) \n\n## 5. 外键约束\n\n![image.png](http://s3.airtlab.com/mysql/1601965067251-8da7d111-439d-45f2-a1d3-b46ed2b9116c.png)\n![image.png](http://s3.airtlab.com/mysql/1601965100981-6a58c685-f17d-4786-ac78-aabd9f12e9d4.png)\n![image.png](http://s3.airtlab.com/mysql/1601965149905-020fe47f-2bbc-4a2d-878f-98431e7d64d3.png)\n如果引用的外键不存在，那么插入数据将会抛出异常。\n![image.png](http://s3.airtlab.com/mysql/1601970143686-ebf491e0-8a0d-4ec3-9482-5c0a259101c5.png)\n","isLeaf":true},{"key":"/Mysql/02-查询语句/08-DQL 总结.md","path":"/Mysql/02-查询语句/08-DQL 总结.md","route":"/Mysql/02-查询语句/08-DQL 总结.md","leaf":true,"title":"08-DQL 总结","depth":2,"content":"---\ntitle: 08-DQL 总结\nurl: https://www.yuque.com/gaollard/utbbp1\n---\n\n![image.png](http://s3.airtlab.com/mysql/1656427575765-ec1185d3-a655-48d7-8f7d-62be88823e85.png)\n","isLeaf":true},{"key":"/Mysql/02-查询语句/09-使用索引.md","path":"/Mysql/02-查询语句/09-使用索引.md","route":"/Mysql/02-查询语句/09-使用索引.md","leaf":true,"title":"09-使用索引","depth":2,"content":"---\ntitle: 09-使用索引\nurl: https://www.yuque.com/gaollard/utbbp1\n---\n\n\n\n## 1. 什么是索引\n\n![image.png](http://s3.airtlab.com/mysql/1601993121317-cdef3d3a-e90f-4d50-b266-36946ebcc8d8.png) \n\n## 2. 如何创建索引\n\n![image.png](http://s3.airtlab.com/mysql/1601993627255-b5086be4-b2b2-465e-a537-dc783d98e3da.png)![image.png](http://s3.airtlab.com/mysql/1601993510011-78109ddf-923b-4473-932d-c274342743e6.png) \n\n## 3. 索引实现原理\n\n![image.png](http://s3.airtlab.com/mysql/1601993719963-00b36c58-7872-49b7-8a63-c610283df5e9.png)\n![image.png](http://s3.airtlab.com/mysql/1601995139699-5c50ec18-37a7-434f-b37e-b5919f4e9553.png) \n\n## 4. 索引的分类\n\n![image.png](http://s3.airtlab.com/mysql/1601995262424-50df09fc-ec0f-4310-a12f-08dff673e1c7.png) \n\n## 5. 索引失效问题\n\n![image.png](http://s3.airtlab.com/mysql/1601995400546-b3e8a8a7-03b2-4b8b-9f46-784e74d22e43.png)\n","isLeaf":true}]},{"key":"/Mysql/03-锁机制 ","path":"/Mysql/03-锁机制 ","route":"/Mysql/03-锁机制 ","leaf":false,"title":"03-锁机制 ","depth":1,"content":"","isLeaf":false,"children":[{"key":"/Mysql/03-锁机制 /01-参考资料.md","path":"/Mysql/03-锁机制 /01-参考资料.md","route":"/Mysql/03-锁机制 /01-参考资料.md","leaf":true,"title":"01-参考资料","depth":2,"content":"---\ntitle: 01-参考资料\nurl: https://www.yuque.com/gaollard/utbbp1\n---\n\n- [Mysql 锁机制之行锁、表锁、死锁的实现](https://www.jb51.net/article/240968.htm)\n- [MySQL 意向共享锁、意向排他锁、死锁](https://www.jb51.net/article/242634.htm)\n- <https://www.cnblogs.com/jojop/p/13982679.html>\n- 一张图彻底搞懂 MySQL 的锁机制 <https://learnku.com/articles/39212?order_by=vote_count&>\n- MySQL锁总结 <https://zhuanlan.zhihu.com/p/29150809>\n- 漫谈MySQL的锁机制 <https://zhuanlan.zhihu.com/p/75595737>\n\n![image.png](http://s3.airtlab.com/mysql/1661916530172-996af0e4-3fec-4032-8a01-7f16031f1881.png)\n","isLeaf":true},{"key":"/Mysql/03-锁机制 /02-锁测试.md","path":"/Mysql/03-锁机制 /02-锁测试.md","route":"/Mysql/03-锁机制 /02-锁测试.md","leaf":true,"title":"02-锁测试","depth":2,"content":"---\ntitle: 02-锁测试\n---\n\n### 1、行锁测试\n\n#### 1. 行锁分析\n\n```sql\nshow status like 'innodb_row_lock%';\n```\n\n![image.png](http://s3.airtlab.com/mysql/1661853567939-ef25e55f-c9d6-4fb1-93cb-5ad3b0c7d4b4.png)\n\n```sql\n1. innodb_row_lock_current_waits // 当前正在等待锁定的数量\n2. innodb_row_lock_time // 从系统启动到现在锁定总时间长度\n3. innodb_row_lock_time_avg // 每次等待所花平均时间\n4. innodb_row_lock_time_max // 从系统启动到现在等待最长的一次所花时间\n5. innodb_row_lock_waits // 系统启动后到现在总共等待的次数\n```\n\n\n\n#### 2.  读锁测试\n\n![image.png](http://s3.airtlab.com/mysql/1661917312810-80b15df5-0e01-4878-93c6-a134dcfbe215.png) \n\n#### 3. 写锁测试\n\n![image.png](http://s3.airtlab.com/mysql/1661917475949-8764df23-bd92-43b0-978e-64fb78723f13.png)\n\n\n\n### 2、表锁测试\n\n\n\n#### 1. 查询是否锁表\n\n```sql\nSHOW OPEN TABLES;\n\nshow OPEN TABLES where In_use > 0;\n```\n\n![image.png](http://s3.airtlab.com/mysql/1661853872258-24d64fb2-0cf8-4e1e-a40b-78cd94a90f49.png) \n\n#### 2. **锁表 & 解锁**\n\n```sql\n# 锁定数据表，避免在备份过程中，表被更新\n\nmysql>LOCK TABLES tbl_name READ;\n\n# 为表增加一个写锁定：\n\nmysql>LOCK TABLES tbl_name WRITE;\n\n# 解锁\nUNLOCK TABLES;\n```\n\n\n\n#### 3. 查询表锁争用情况\n\n```sql\nSHOW STATUS LIKE 'table%';\n```\n\n![image.png](http://s3.airtlab.com/mysql/1661853050613-eba3597b-5810-4fbd-9ce4-fcd5c4984ecb.png)\n\n- table\\_locks\\_immediate : 可以立即获取锁的次数\n- table\\_locks\\_waited : 不能立即获取锁，需要等待锁的次数 (每等待一次值加1） \n\n#### 4. 读锁测试\n\n![image.png](http://s3.airtlab.com/mysql/1661854262277-7d98c1c4-faed-43b2-8bad-506db28fa352.png) \n\n#### 5. 写锁测试\n\n场景：数据迁移，目标表加写锁，原表既可以读锁又可以写锁，但是读锁更好\n![image.png](http://s3.airtlab.com/mysql/1661854343954-c391dda8-f866-4c9e-b44a-46ac7cae5120.png)\n","isLeaf":true},{"key":"/Mysql/03-锁机制 /02-锁的分类.md","path":"/Mysql/03-锁机制 /02-锁的分类.md","route":"/Mysql/03-锁机制 /02-锁的分类.md","leaf":true,"title":"02-锁的分类","depth":2,"content":"---\ntitle: 02-锁的分类\n---\n\n<https://baijiahao.baidu.com/s?id=1719317428791454942&wfr=spider&for=pc> \n\n### 1、锁的分类\n\n- 从性能上分\n  - 乐观锁(用版本对比来实现)\n  - 悲观锁;\n- 从对数据库操作的类型分 (都属于悲观锁)\n  - 读锁（共享锁，S锁(Shared)）：针对同一份数据，多个读操作可以同时进行而不会互相影响\n  - 写锁（排它锁，X锁(eXclusive)）：当前写操作没有完成前，它会阻断其他写锁和读锁\n- 从对数据操作的粒度分\n  - 表锁\n  - 行锁 \n\n### 2、表锁与行锁\n\n\n\n#### 1. 表锁的介绍\n\n每次操作锁住整张表：\n\n- 开销小（不需要定位到某个元素，只需要定位到表）\n- 加锁快；\n- 不会出现死锁；\n- 锁定粒度大，发生锁冲突的概率最高，并发度最低；\n\n一般用在整表数据迁移的场景。\n\n\n\n#### 2. 表锁操作方式 (lock table...)\n\n- 手动增加表锁: `lock table 表名称 read(write),表名称2 read(write);`\n- 查看表上加过的锁: `show open tables;`\n- 删除表锁: `unlock tables;`\n\n\n\n#### 3. 行锁的介绍\n\n每次操作锁住一行数据。\n\n- 开销大，加锁慢；\n- 会出现死锁；\n- 锁定粒度最小，发生锁冲突的概率最低，并发度高。\n\nInnoDB 与MYISAM 的最大不同点：InnoDB 支持行级锁、支持事务\n\n- MyISAM 在执行查询语句 SELECT 前，会自动给涉及的所有表加读锁,在执行 update、insert、delete 操作会自动给涉及的表加写锁。\n- InnoDB 在执行查询语句 SELECT 时(非串行隔离级别)，不会加锁。但是 update、insert、delete 操作会加行锁。\n\n\n\n#### 4. 行锁操作方式 （...`for update`）\n\nsql 后增加 `for update` 来实现行锁。`for update` 在不走索引的时候会锁表！但是当要修改或者查询的数据不存在的时候，不会锁表，也不会锁定行！\n\n\n\n### 3、读锁与写锁\n\n读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞。\n\n\n\n### 4、并发场景下挑战\n\n多线程或者分布式程序中，并发的对 mysql 表记录进行修改时，由于网络原因，在逻辑上无法保证最后的修改者，无法保证数据的正确性。举例：\n\n\n\n#### 1. 乐观锁方案\n\n在表里增加个字段，版本号字段，每次更新前先从数据库里获取这个版本号的值，然后更新时要同步更新版本号+1，并且增加更新条件版本号=查询出来的值。\n\n因为更新时每次只可能有一个线程更新到数据，等到另外一个线程再去更新数据的时候版本号已经+1了，所以会更新失败，重新获取版本号再走更新流程，这样就解决了多线程并发更新被覆盖的问题。\n\n而且乐观锁机制避免了长事务中的数据库加锁开销（多个线程操作过程中，都没有对数据库数据加锁），大大提升了大并发量下的系统整体性能表现。\n","isLeaf":true},{"key":"/Mysql/03-锁机制 /03 乐观锁 & 悲观锁.md","path":"/Mysql/03-锁机制 /03 乐观锁 & 悲观锁.md","route":"/Mysql/03-锁机制 /03 乐观锁 & 悲观锁.md","leaf":true,"title":"03 乐观锁 & 悲观锁","depth":2,"content":"---\ntitle: 03 乐观锁 & 悲观锁\n---\n\n### 1、乐观锁\n\n乐观锁不是数据库自带的，需要我们自己去实现。乐观锁是指操作数据库时(更新操作)，想法很乐观，认为这次的操作不会导致冲突，在操作数据时，并不进行任何其他的特殊处理（也就是不加锁），而在进行更新后，再去判断是否有冲突了。\n\n```sql\n# 查询出商品信息\nselect (status,status,version) from t_goods where id=#{id}\n\n# 根据商品信息生成订单, 修改商品status为2\nupdate\n  t_goods \nset\n  status = 2,\n  version = version+1\nwhere id=#{id} and version=#{version};\n```\n\n\n\n### 2、[悲观锁](https://so.csdn.net/so/search?q=%E6%82%B2%E8%A7%82%E9%94%81\\&spm=1001.2101.3001.7020)\n\n悲观锁就是在操作数据时，认为此操作会出现数据冲突，所以在进行每次操作时都要通过获取锁才能进行对相同数据的操作。 \n\n#### 1. 共享锁  (读锁)\n\n共享锁(S锁)又称为读锁，若事务T对A加上S锁，则事务T只能读A；\n其他事务只能再对A加S锁，而不能加排他锁（X锁），直到T释放A上的S锁。这就保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。 \n\n#### 2. 排它锁 (X锁)\n\n排他锁（X锁）：如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据。\n","isLeaf":true},{"key":"/Mysql/03-锁机制 /04-InnoDB死锁.md","path":"/Mysql/03-锁机制 /04-InnoDB死锁.md","route":"/Mysql/03-锁机制 /04-InnoDB死锁.md","leaf":true,"title":"04-InnoDB死锁","depth":2,"content":"---\ntitle: 04-InnoDB死锁\nurl: https://www.yuque.com/gaollard/utbbp1\n---\n\n\n\n### 1、死锁定义\n\n当两个或以上的事务相互持有和请求锁，并形成一个循环的依赖关系，就会产生死锁。多个事务同时锁定同一个资源时，也会产生死锁。在一个事务系统中，死锁是确切存在并且是不能完全避免的。\n\n解决：InnoDB会自动检测事务死锁，立即回滚其中某个事务，并且返回一个错误。它根据某种机制来选择那个最简单（代价最小）的事务来进行回滚。\n\n\n\n### 2、死锁场景一之 select for update\n\n产生场景：两个 transaction 都有两个 select for update\n\n- transaction a 先锁记录1，再锁记录2\n- transaction b 先锁记录2，再锁记录1\n\n第一步更新会话一:\n\n```sql\nstart TRANSACTION;\nselect * from t_lock where id=1 for update;\n```\n\n第二步更新会话二:\n\n```sql\nstart TRANSACTION;\nselect * from t_lock where id=2 for update;\n```\n\n第三步更新会话一:\n\n```sql\nselect * from t_lock where id=2 for update;\n```\n\n![](http://s3.airtlab.com/mysql/20220603101538.png)\n\n第四步更新会话二:\n\n```sql\nselect * from t_lock where id=1 for update;\n```\n\n![](http://s3.airtlab.com/mysql/20220603101613.png)\n\n来看下执行的日志:\n\n```sql\nshow engine innodb status;\n```\n\n最后一个锁的时间，锁的表，引起锁的语句。其中session1被锁 14秒(ACTIVE 14)，session 2被锁了10秒(Active 10)\n\n\n\n### 3、死锁场景二之 两个update\n\n产生场景：两个transaction都有两个update:\n\n- transaction a先更新记录1，再更新记录2\n- transaction b先更新记录2，再更新记录1\n\n![](http://s3.airtlab.com/mysql/20220603101843.png)\n\n产生日志：\n\n![](http://s3.airtlab.com/mysql/20220603101903.png)\n\n\n\n### 4、innodb\\_deadlock\\_detect\n\n注意：仔细查看上面2个例子可以发现一个现象，当2条资源锁住后，再执行第三个会执行成功，但是第四个会提示死锁。\n\n在mysql5.7中，执行第三个的时候就会一直在Running状态了，本博文使用的是mysql8.0 ，其中 有这个参数 innodb\\_deadlock\\_detect 可以用于控制 InnoDB 是否执行死锁检测，当启用了死锁检测时（默认设置），InnoDB 自动执行事务的死锁检测，并且回滚一个或多个事务以解决死锁。InnoDB 尝试回滚更小的事务，事务的大小由它所插入、更新或者删除的数据行数决定。\n\n![](http://s3.airtlab.com/mysql/20220603102035.png)\n\n那么这个innodb\\_deadlock\\_detect参数，到底要不要启用呢？\n\n> 对于高并发的系统，当大量线程等待同一个锁时，死锁检测可能会导致性能的下降。此时，如果禁用死锁检测，而改为依靠参数 innodb\\_lock\\_wait\\_timeout 执行发生死锁时的事务回滚可能会更加高效。\n\n通常来说，应该启用死锁检测，并且在应用程序中尽量避免产生死锁，同时对死锁进行相应的处理，例如重新开始事务。\n\n只有在确认死锁检测影响了系统的性能，并且禁用死锁检测不会带来负面影响时，可以尝试关闭 innodb\\_deadlock\\_detect 选项。另外，如果禁用了 InnoDB 死锁检测，需要调整参数 innodb\\_lock\\_wait\\_timeout 的值，以满足实际的需求。\n\n\n\n### 5、程序开发过程中应该如何注意避免死锁\n\n锁的本质是资源相互竞争，相互等待，往往是两个(或以上)的Session加锁的顺序不一致。如何有效避免？\n\n（1）在程序中，操作多张表时，尽量以相同的顺序来访问（避免形成等待环路）\n\n（2）批量操作单张表数据的时候，先对数据进行排序（避免形成等待环路） A线程 id：1 ,10 ,20按顺序加锁     B线程id:20,10,1   这种的话就容易锁。\n\n（3）如果可以，大事务化成小事务，甚至不开启事务 select for update==>insert==>update = insert into update on duplicate key\n\n（4）尽量使用索引访问数据，避免没有 where 条件的操作，避免锁表 有走索引是记录行锁，没走索引是表锁\n\n（5）使用等值查询而不是范围查询查询数据，命中记录，避免间隙锁对并发的影响 1，10，20 等值where id in (1,10,20) 范围查询 id>1 and id<20\n\n（6）避免在同一时间点运行多个对同一表进行读写的脚本，特别注意加锁且操作数据量比较大的语句；我们经常会有一些定时脚本，避免它们在同一时间点运行\n","isLeaf":true}]},{"key":"/Mysql/04-事务机制","path":"/Mysql/04-事务机制","route":"/Mysql/04-事务机制","leaf":false,"title":"04-事务机制","depth":1,"content":"","isLeaf":false,"children":[{"key":"/Mysql/04-事务机制/01-两阶段提交.md","path":"/Mysql/04-事务机制/01-两阶段提交.md","route":"/Mysql/04-事务机制/01-两阶段提交.md","leaf":true,"title":"01-两阶段提交","depth":2,"content":"---\ntitle: 01-两阶段提交\nurl: https://www.yuque.com/gaollard/utbbp1/lkabcn\n---\n\n- <https://www.cnblogs.com/jelly12345/p/14446008.html>\n- <https://zhuanlan.zhihu.com/p/348828585>\n- <https://zhuanlan.zhihu.com/p/377412719>\n","isLeaf":true},{"key":"/Mysql/04-事务机制/02-事务处理.md","path":"/Mysql/04-事务机制/02-事务处理.md","route":"/Mysql/04-事务机制/02-事务处理.md","leaf":true,"title":"02-事务处理","depth":2,"content":"---\ntitle: 02-事务处理\nurl: https://www.yuque.com/gaollard/utbbp1\n---\n\n\n\n### 1. 什么是事务\n\n![image.png](http://s3.airtlab.com/mysql/1601975012141-d10ac3f8-2996-43ba-91b9-72e4bfb0276e.png) \n\n### 2. 事务的原理\n\n![image.png](http://s3.airtlab.com/mysql/1656428518318-f833e306-2639-4cea-bb81-2db85efa9efc.png)\n![image.png](http://s3.airtlab.com/mysql/1601975519551-f603e1a0-97b7-4a2e-91e3-a146594b2a50.png) \n\n### 3. 事务的特性\n\n![image.png](http://s3.airtlab.com/mysql/1601975727500-8343ebc1-5879-41ac-aeec-5a12ebc94f22.png)\n","isLeaf":true},{"key":"/Mysql/04-事务机制/03-事务隔离级别.md","path":"/Mysql/04-事务机制/03-事务隔离级别.md","route":"/Mysql/04-事务机制/03-事务隔离级别.md","leaf":true,"title":"03-事务隔离级别","depth":2,"content":"---\ntitle: 03-事务隔离级别\nurl: https://www.yuque.com/gaollard/utbbp1\n---\n\n\n\n### 1. 事务隔离级别\n\n![image.png](http://s3.airtlab.com/mysql/1601985719414-b9620436-1bda-44f5-9946-9007739cd3c9.png)举例说明：<https://blog.csdn.net/weixin_43790562/article/details/117195535> \n\n### 2. 事务的演示\n\n\n\n#### 2.1 mysql 事务支持自动提交\n\n![image.png](http://s3.airtlab.com/mysql/1601985910947-09e2873e-ce9f-4d0f-8dcc-81e0e56596ba.png)\n![image.png](http://s3.airtlab.com/mysql/1601985987596-7a163627-754b-4371-baae-02bd08f2f290.png) \n\n#### 2.2 事务隔离级别演示\n\n![image.png](http://s3.airtlab.com/mysql/1601988136160-1def1715-2236-4e43-9c0b-3cf227219454.png)\n","isLeaf":true},{"key":"/Mysql/04-事务机制/04-不可重复读和幻读的区别.md","path":"/Mysql/04-事务机制/04-不可重复读和幻读的区别.md","route":"/Mysql/04-事务机制/04-不可重复读和幻读的区别.md","leaf":true,"title":"04-不可重复读和幻读的区别","depth":2,"content":"---\ntitle: 04-不可重复读和幻读的区别\n---\n\n<https://www.csdn.net/tags/OtTaMg1sNzkyNTUtYmxvZwO0O0OO0O0O.html>\n","isLeaf":true}]},{"key":"/Mysql/05-数据同步","path":"/Mysql/05-数据同步","route":"/Mysql/05-数据同步","leaf":false,"title":"05-数据同步","depth":1,"content":"","isLeaf":false,"children":[{"key":"/Mysql/05-数据同步/01-迁移介绍.md","path":"/Mysql/05-数据同步/01-迁移介绍.md","route":"/Mysql/05-数据同步/01-迁移介绍.md","leaf":true,"title":"01-迁移介绍","depth":2,"content":"---\ntitle: 01-迁移介绍\nurl: https://www.yuque.com/gaollard/utbbp1/fbnwps\n---\n\n- 同构迁移\n- 异构迁移\n","isLeaf":true},{"key":"/Mysql/05-数据同步/02-表蠕虫复制.md","path":"/Mysql/05-数据同步/02-表蠕虫复制.md","route":"/Mysql/05-数据同步/02-表蠕虫复制.md","leaf":true,"title":"02-表蠕虫复制","depth":2,"content":"---\ntitle: 02-表蠕虫复制\nurl: https://www.yuque.com/gaollard/utbbp1/ehh73z\n---\n\n<https://juejin.cn/post/6999528489971875854>\n","isLeaf":true},{"key":"/Mysql/05-数据同步/03-实时同步到ES.md","path":"/Mysql/05-数据同步/03-实时同步到ES.md","route":"/Mysql/05-数据同步/03-实时同步到ES.md","leaf":true,"title":"03-实时同步到ES","depth":2,"content":"---\ntitle: 03-实时同步到ES\nurl: https://www.yuque.com/gaollard/utbbp1/dvc0ru\n---\n\n<https://blog.51cto.com/u_15050720/4245988>\n","isLeaf":true},{"key":"/Mysql/05-数据同步/04-canal 订阅 binlog.md","path":"/Mysql/05-数据同步/04-canal 订阅 binlog.md","route":"/Mysql/05-数据同步/04-canal 订阅 binlog.md","leaf":true,"title":"04-canal 订阅 binlog","depth":2,"content":"---\ntitle: 04-canal 订阅 binlog\nurl: https://www.yuque.com/gaollard/utbbp1/aohf9s\n---\n\n- <https://zhuanlan.zhihu.com/p/424550462>\n- <https://github.com/alibaba/canal/wiki>\n\n![image.png](https://s3.airtlab.com/mysql/1663925660698-e1fb4e47-c8d1-44f4-9c16-15e3bb8ade0e.png)\n\n### 工作原理\n\n- canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送 dump 协议\n- MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal )\n- canal 解析 binary log 对象 (原始为 byte 流) \n\n### 客户端\n\ncanal 特别设计了 client-server 模式，交互协议使用 protobuf 3.0 , client 端可采用不同语言实现不同的消费逻辑，欢迎大家提交 pull request\n\n- canal java 客户端: <https://github.com/alibaba/canal/wiki/ClientExample>\n- canal c# 客户端: <https://github.com/dotnetcore/CanalSharp>\n- canal go客户端: <https://github.com/CanalClient/canal-go>\n- canal php客户端: <https://github.com/xingwenge/canal-php>\n- canal Python客户端：<https://github.com/haozi3156666/canal-python>\n- canal Rust客户端：<https://github.com/laohanlinux/canal-rs>\n- canal Nodejs客户端：<https://github.com/marmot-z/canal-nodejs>\n","isLeaf":true}]},{"key":"/Mysql/08-高可用","path":"/Mysql/08-高可用","route":"/Mysql/08-高可用","leaf":false,"title":"08-高可用","depth":1,"content":"","isLeaf":false,"children":[{"key":"/Mysql/08-高可用/01-高可用架构.md","path":"/Mysql/08-高可用/01-高可用架构.md","route":"/Mysql/08-高可用/01-高可用架构.md","leaf":true,"title":"01-高可用架构","depth":2,"content":"---\ntitle: 01-高可用架构\nurl: https://www.yuque.com/gaollard/utbbp1/ci9s3a\n---\n\n<https://baijiahao.baidu.com/s?id=1712797974314216930&wfr=spider&for=pc>\n","isLeaf":true}]},{"key":"/Mysql/10-视图","path":"/Mysql/10-视图","route":"/Mysql/10-视图","leaf":false,"title":"10-视图","depth":1,"content":"","isLeaf":false,"children":[{"key":"/Mysql/10-视图/01-视图介绍.md","path":"/Mysql/10-视图/01-视图介绍.md","route":"/Mysql/10-视图/01-视图介绍.md","leaf":true,"title":"01-视图介绍","depth":2,"content":"---\ntitle: 01-视图介绍\nurl: https://www.yuque.com/gaollard/utbbp1\n---\n\n![image.png](http://s3.airtlab.com/mysql/1602034988109-949115e3-55b7-4f5a-ba0a-77db5e835d45.png)![image.png](http://s3.airtlab.com/mysql/1602035137382-c5faf76a-eac5-473b-8687-91f824b458ad.png)\n","isLeaf":true}]},{"key":"/Mysql/11-字段类型","path":"/Mysql/11-字段类型","route":"/Mysql/11-字段类型","leaf":false,"title":"11-字段类型","depth":1,"content":"","isLeaf":false,"children":[{"key":"/Mysql/11-字段类型/01-JSON 的使用.md","path":"/Mysql/11-字段类型/01-JSON 的使用.md","route":"/Mysql/11-字段类型/01-JSON 的使用.md","leaf":true,"title":"01-JSON 的使用","depth":2,"content":"---\ntitle: 01-JSON 的使用\nurl: https://www.yuque.com/gaollard/utbbp1/qvtgbs\n---\n\n要求：5.7 以上\n<https://www.cnblogs.com/zagwk/p/15739321.html>\n","isLeaf":true},{"key":"/Mysql/11-字段类型/02-日期存储格式.md","path":"/Mysql/11-字段类型/02-日期存储格式.md","route":"/Mysql/11-字段类型/02-日期存储格式.md","leaf":true,"title":"02-日期存储格式","depth":2,"content":"---\ntitle: 02-日期存储格式\nurl: https://www.yuque.com/gaollard/utbbp1/yat5am\n---\n\n","isLeaf":true}]},{"key":"/Mysql/12-触发器","path":"/Mysql/12-触发器","route":"/Mysql/12-触发器","leaf":false,"title":"12-触发器","depth":1,"content":"","isLeaf":false,"children":[{"key":"/Mysql/12-触发器/01-触发器介绍.md","path":"/Mysql/12-触发器/01-触发器介绍.md","route":"/Mysql/12-触发器/01-触发器介绍.md","leaf":true,"title":"01-触发器介绍","depth":2,"content":"---\ntitle: 01-触发器介绍\nurl: https://www.yuque.com/gaollard/utbbp1\n---\n\n参考 <https://blog.csdn.net/A496608119/article/details/123277898> \n\n### 1、什么时候会触发\n\n- insert\n- update\n- delete\n\n这些动作前或后触发 \n\n### 2、创建触发器演示1\n\n![image.png](http://s3.airtlab.com/mysql/1654785829474-f4a5f09c-b95b-4413-92df-0a71fe64df9a.png)\n\n```sql\ncreate trigger trigger_test1 before insert\non chufaqi_02 for each row\ninsert into chufaqi_01 values(2);\n```\n\n\n\n### 3、删除触发器\n\n```sql\ndrop trigger trigger_test1\n```\n\n\n\n### 4、触发器类型 NEW 和 OLD 的使用\n\n![image.png](http://s3.airtlab.com/mysql/1654786195937-54a81163-7c69-4981-bed4-ced5b95c9451.png)\n\n```sql\ncreate trigger trigger_test1 after update on user for each row\ninsert into user_logs values(\n  NULL,\n  now(),\n  concat('有用户信息修改,旧数据是：',OLD.uid,OLD.username,OLD.password)\n);\n```\n","isLeaf":true}]},{"key":"/Mysql/13-预备知识","path":"/Mysql/13-预备知识","route":"/Mysql/13-预备知识","leaf":false,"title":"13-预备知识","depth":1,"content":"","isLeaf":false,"children":[{"key":"/Mysql/13-预备知识/[工具] Sequel Ace 的使用.md","path":"/Mysql/13-预备知识/[工具] Sequel Ace 的使用.md","route":"/Mysql/13-预备知识/[工具] Sequel Ace 的使用.md","leaf":true,"title":"[工具] Sequel Ace 的使用","depth":2,"content":"---\ntitle: \"[工具] Sequel Ace 的使用\"\nurl: https://www.yuque.com/gaollard/utbbp1\n---\n\n\n\n### 导出数据\n\n![image.png](http://s3.airtlab.com/mysql/1654908184693-b07d0aa5-3e1c-42b8-a3f0-65ae9b506e23.png)\n","isLeaf":true},{"key":"/Mysql/13-预备知识/实体和实体关系.md","path":"/Mysql/13-预备知识/实体和实体关系.md","route":"/Mysql/13-预备知识/实体和实体关系.md","leaf":true,"title":"实体和实体关系","depth":2,"content":"---\ntitle: 实体和实体关系\nurl: https://www.yuque.com/gaollard/utbbp1\n---\n\n\n\n### 1、实体关系\n\n```latex\n1 对 1\n1 对 n (n 对 1)\nn 对 n\n```\n\n多对多往往需要有一个中间表:\n![](http://s3.airtlab.com/mysql/20220522220343.png) \n\n### 2、**设计范式**\n\n![image.png](http://s3.airtlab.com/mysql/1661781188760-2bc4a8a0-097b-4e98-b6bb-867de9877ecd.png)\n![image.png](http://s3.airtlab.com/mysql/1661781196331-9dd6d2ba-98c5-4d15-a6ba-eec334183c0c.png)\n![image.png](http://s3.airtlab.com/mysql/1661781203787-728b521f-77b6-462c-9941-e0785c0806ba.png) \n\n### 3、**数据类型**\n\n![image.png](http://s3.airtlab.com/mysql/1661781239264-10d1309e-56d5-4541-811f-865e4ba18425.png)\n![image.png](http://s3.airtlab.com/mysql/1661781255376-1e74efec-7206-48d7-9e47-89ed3604f03d.png)\n","isLeaf":true},{"key":"/Mysql/13-预备知识/并集&交集&差集.md","path":"/Mysql/13-预备知识/并集&交集&差集.md","route":"/Mysql/13-预备知识/并集&交集&差集.md","leaf":true,"title":"并集&交集&差集","depth":2,"content":"---\ntitle: 并集&交集&差集\nurl: https://www.yuque.com/gaollard/utbbp1\n---\n\n- <https://blog.csdn.net/sanzhongguren/article/details/76615464>\n- [https://blog.csdn.net/chaochao2113/article/details/127334873](https://blog.csdn.net/chaochao2113/article/details/127334873?spm=1001.2101.3001.6650.2\\&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EYuanLiJiHua%7EPosition-2-127334873-blog-76615464.pc_relevant_multi_platform_whitelistv3\\&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EYuanLiJiHua%7EPosition-2-127334873-blog-76615464.pc_relevant_multi_platform_whitelistv3\\&utm_relevant_index=5)\n\n![image.png](http://s3.airtlab.com/mysql/1668389702823-20cb6220-bbd8-4c4b-beae-04611a86339d.png)\n","isLeaf":true}]},{"key":"/Mysql/14 数据库运维","path":"/Mysql/14 数据库运维","route":"/Mysql/14 数据库运维","leaf":false,"title":"14 数据库运维","depth":1,"content":"","isLeaf":false,"children":[{"key":"/Mysql/14 数据库运维/mysql log.md","path":"/Mysql/14 数据库运维/mysql log.md","route":"/Mysql/14 数据库运维/mysql log.md","leaf":true,"title":"mysql log","depth":2,"content":"---\ntitle: mysql log\nurl: https://www.yuque.com/gaollard/utbbp1/bbn1g5\n---\n\n- bin log\n- slow query log\n","isLeaf":true},{"key":"/Mysql/14 数据库运维/mysql 两个 db 结构对比工具.md","path":"/Mysql/14 数据库运维/mysql 两个 db 结构对比工具.md","route":"/Mysql/14 数据库运维/mysql 两个 db 结构对比工具.md","leaf":true,"title":"mysql 两个 db 结构对比工具","depth":2,"content":"---\ntitle: mysql 两个 db 结构对比工具\nurl: https://www.yuque.com/gaollard/utbbp1/xrh4r1\n---","isLeaf":true},{"key":"/Mysql/14 数据库运维/mysql 权限.md","path":"/Mysql/14 数据库运维/mysql 权限.md","route":"/Mysql/14 数据库运维/mysql 权限.md","leaf":true,"title":"mysql 权限","depth":2,"content":"---\ntitle: mysql 权限\nurl: https://www.yuque.com/gaollard/utbbp1/hw7107\n---\n\n<http://c.biancheng.net/view/7490.html>\n\n```sql\n# gaollard VouFM2SEFk\nCREATE USER 'gaollard'@'%' IDENTIFIED BY PASSWORD '*8D03816E306DA2740387330539899035057E5B33';\n```\n\n```sql\n# canal 123456\nCREATE USER 'canal'@'%' IDENTIFIED BY PASSWORD '*6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9';\n```\n\n```sql\n# canal canal\nCREATE USER 'canal'@'%' IDENTIFIED BY PASSWORD '*E3619321C1A937C46A0D8BD1DAC39F93B27D4458';\n\n```\n\n```sql\nCREATE USER canal IDENTIFIED BY 'canal';  \nGRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'canal'@'%';\n-- GRANT ALL PRIVILEGES ON *.* TO 'canal'@'%' ;\nFLUSH PRIVILEGES;\n```\n","isLeaf":true},{"key":"/Mysql/14 数据库运维/sql beatutify.md","path":"/Mysql/14 数据库运维/sql beatutify.md","route":"/Mysql/14 数据库运维/sql beatutify.md","leaf":true,"title":"sql beatutify","depth":2,"content":"---\ntitle: sql beatutify\nurl: https://www.yuque.com/gaollard/utbbp1/nfu17b\n---\n\n[SQL Formatter & Beautifier Online](https://codebeautify.org/sqlformatter)\n","isLeaf":true}]},{"key":"/Mysql/15-运维工具","path":"/Mysql/15-运维工具","route":"/Mysql/15-运维工具","leaf":false,"title":"15-运维工具","depth":1,"content":"","isLeaf":false,"children":[]},{"key":"/Mysql/16 34道练习题","path":"/Mysql/16 34道练习题","route":"/Mysql/16 34道练习题","leaf":false,"title":"16 34道练习题","depth":1,"content":"","isLeaf":false,"children":[{"key":"/Mysql/16 34道练习题/34道练习题.md","path":"/Mysql/16 34道练习题/34道练习题.md","route":"/Mysql/16 34道练习题/34道练习题.md","leaf":true,"title":"34道练习题","depth":2,"content":"---\ntitle: 34道练习题\nurl: https://www.yuque.com/gaollard/utbbp1/rxggbv\n---\n\n参考文档：<https://www.cnblogs.com/d9e84208/p/10977986.html>\n","isLeaf":true},{"key":"/Mysql/16 34道练习题/mysql 34道练习题（1-10）.md","path":"/Mysql/16 34道练习题/mysql 34道练习题（1-10）.md","route":"/Mysql/16 34道练习题/mysql 34道练习题（1-10）.md","leaf":true,"title":"mysql 34道练习题（1-10）","depth":2,"content":"---\ntitle: mysql 34道练习题（1-10）\n---\n\n参考文档：<https://www.cnblogs.com/d9e84208/p/10977986.html>\n\n```sql\nDROP TABLE IF EXISTS EMP;\nDROP TABLE IF EXISTS DEPT;\nDROP TABLE IF EXISTS SALGRADE;\n\nCREATE TABLE DEPT\n\t(DEPTNO int(2) not null ,\n\tDNAME VARCHAR(14) ,\n\tLOC VARCHAR(13) ,\n\tprimary key (DEPTNO)\n\t);\nCREATE TABLE EMP\n\t(EMPNO int(4) not null ,\n\tENAME VARCHAR(10) ,\n\tJOB VARCHAR(9) ,\n\tMGR INT(4) ,\n\tHIREDATE DATE DEFAULT NULL ,\n\tSAL DOUBLE(7,2) ,\n\tCOMM DOUBLE(7,2) ,\n\tprimary key (EMPNO) ,\n\tDEPTNO INT(2)\n\t);\nCREATE TABLE SALGRADE\n\t(GRADE INT ,\n\tLOSAL INT ,\n\tHISAL INT \n\t);\n\t\nINSERT INTO DEPT ( DEPTNO, DNAME, LOC ) VALUES (\n10, 'ACCOUNTING', 'NEW YOURK');\nINSERT INTO DEPT ( DEPTNO, DNAME, LOC ) VALUES (\n20, 'RESEARCH', 'DALLAS');\nINSERT INTO DEPT ( DEPTNO, DNAME, LOC ) VALUES (\n30, 'SALES', 'CHICAGO');\nINSERT INTO DEPT( DEPTNO, DNAME, LOC ) VALUES (\n40, 'OPERATIONS', 'BOSTON');\ncommit;\n\nINSERT INTO EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES (\n7396, 'SMITH', 'CLERK', 7902, '1980-12-17', 800, NULL, 20);\nINSERT INTO EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES (\n7499, 'ALLEN', 'SALESMAN', 7698, '1981-02-20', 1600, 300,30);\nINSERT INTO EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES (\n7521, 'WARD', 'SALESMAN', 7698, '1981-02-22', 1250, 500, 30);\nINSERT INTO EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES (\n7566, 'JONES', 'MANAGER', 7839, '1981-04-02', 2975, NULL, 20);\nINSERT INTO EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES (\n7654, 'MARTIN', 'SALESMAN', 7698, '1981-09-28', 1250, 1400, 30);\nINSERT INTO EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES (\n7698, 'BLAKE', 'MANAGER', 7839, '1981-05-01', 2850, NULL, 30);\nINSERT INTO EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES (\n7782, 'CLARK', 'MANAGER', 7839, '1981-06-09', 2450, NULL, 20);\nINSERT INTO EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES (\n7788, 'SCOTT', 'ANALYST', 7566, '1987-04-19', 3000, NULL, 20);\nINSERT INTO EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES (\n7839, 'KING', 'PRESIDENT', NULL, '1981-11-17', 5000, NULL, 10);\nINSERT INTO EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES (\n7844, 'TURNER', 'SALESMAN', 7698, '1981-09-08', 1500, 0, 30);\nINSERT INTO EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES (\n7876, 'ADAMS', 'CLERK', 7788, '1987-05-23', 1100, NULL, 20);\nINSERT INTO EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES (\n7900, 'JAMES', 'CLERK', 7698, '1981-12-03', 950, NULL, 30);\nINSERT INTO EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES (\n7902, 'FORD', 'ANALYST', 7566, '1981-12-03', 3000, NULL, 20);\nINSERT INTO EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES (\n7934, 'MILLER', 'CLERK', 7782, '1982-01-23', 1300, NULL, 10);\ncommit;\n\nINSERT INTO SALGRADE (GRADE, LOSAL, HISAL) VALUES (\n1, 700, 1200);\nINSERT INTO SALGRADE (GRADE, LOSAL, HISAL) VALUES (\n2, 1201, 1400);\nINSERT INTO SALGRADE (GRADE, LOSAL, HISAL) VALUES (\n3, 1401, 2000);\nINSERT INTO SALGRADE (GRADE, LOSAL, HISAL) VALUES (\n4, 2001, 3000);\nINSERT INTO SALGRADE (GRADE, LOSAL, HISAL) VALUES (\n5, 3001, 9999);\ncommit;\n```\n\n### 1. **取得每个部门最高薪水的人员名称**\n\n注意可能存在某个部门有多个员工的工资相同，而且是最高的。\n\n(1) 先找出每个部门的最高薪资表 T\n\n```sql\n# 查询各部门最高薪水（临时表T1）\n# 按照部门编号分组找出每一组最大值\nselect e.deptno, max(SAL) as maxSal from EMP e group by deptno\n\n+--------+---------+\n| deptno | maxSal  |\n+--------+---------+\n|     10 | 5000.00 |\n|     20 | 3000.00 |\n|     30 | 2850.00 |\n+--------+---------+\n```\n\n（2）将员工表和T1表连接查询\n\n```sql\n\t\nselect\n        e.deptno,\n        e.ename,\n        t.maxsal,\n        e.sal\nfrom\n\t\tEMP e\njoin\n\t\t(select e.deptno,max(e.sal) as maxsal from EMP e group by e.deptno) t\non\n\t\te.deptno=t.deptno\nwhere\n    t.maxsal=e.sal\n\n+--------+-------+---------+---------+\n| deptno | ename | maxsal  | sal     |\n+--------+-------+---------+---------+\n|     30 | BLAKE | 2850.00 | 2850.00 |\n|     20 | SCOTT | 3000.00 | 3000.00 |\n|     10 | KING  | 5000.00 | 5000.00 |\n|     20 | FORD  | 3000.00 | 3000.00 |\n+--------+-------+---------+---------+\n4 rows in set (0.00 sec)\n```\n\n### 2.那些人的薪水在部门平均薪水之上\n\n（1）先求出部门的平均薪水\n\n```sql\nselect e.ename, deptno, avg(e.sal) as avgsale from EMP e group by e.`DEPTNO`\n\n+-------+--------+-------------+\n| ename | deptno | avgsale     |\n+-------+--------+-------------+\n| KING  |     10 | 3150.000000 |\n| SMITH |     20 | 2220.833333 |\n| ALLEN |     30 | 1566.666667 |\n+-------+--------+-------------+\n3 rows in set (0.00 sec)\n```\n\n（2）连接员工表筛选\n\n```sql\nselect\n\t\te.ename,\n\t\te.deptno,\n\t\te.sal\nfrom\n\t\tEMP e\njoin\n\t\t(select e.ename, deptno, avg(e.sal) as avgsale from EMP e group by e.`DEPTNO`) t\non\n\t\te.deptno = t.deptno\nand\n\t\te.sal > t.avgsale;\n```\n\n![20230718180900](http://s3.airtlab.com/blog/20230718180900.png)\n\n\n### 3. **取得部门所有人的平均薪水等级**\n\n```sql\n\nselect\n\t\te.deptno,\n\t\tavg(t.grade) as avggrade\nfrom\n\t\tEMP e\njoin\n\t\tSALGRADE t\non\n\t\te.sal between t.losal and t.hisal\ngroup by\n\te.deptno\n```\n\n![20230718180918](http://s3.airtlab.com/blog/20230718180918.png)\n\n\n### 4. **不准用聚合函数(max)，取得最高薪水(给出两种方法)**\n\n1. 使用max(否定)\n\n```sql\nselect max(t.sal) from EMP t\n```\n\n2. 排序取一个\n\n```sql\nselect t.sal from EMP t order by sal DESC limit 1\n```\n\n3. 两表连接把不是最大值的先找出来，然后用排除法找出最大值\n\n```sql\nSELECT\n\t\te.sal,\n\t\te.ename\nFROM\n\t\tEMP e\nWHERE\n\te.sal not in (SELECT distinct t.sal FROM EMP e JOIN EMP t WHERE e.sal > t.sal)\n```\n\n![20230718181000](http://s3.airtlab.com/blog/20230718181000.png)\n\n\n### 5. **取得平均薪水最高的部门的部门编号**\n\n先取出每个部门平均值，然后再取出最大值\n\n```sql\nselect \n\t\te.deptno,\n\t\tmax(e.avg_sal) as max_avg_sal\nfrom \n\t\t(select avg(e.sal) as avg_sal, e.deptno from EMP e group by e.deptno) e\n```\n\n![20230718181017](http://s3.airtlab.com/blog/20230718181017.png)\n\n### 6. **取得平均薪水最高的部门的部门名称**\n\n```sql\nselect\n\t\te.deptno,\n\t\td.dname,\n\t\tavg(e.sal)\nfrom\n\t\tEMP e\nJOIN\n\t\tDEPT d\non\n\td.deptno = e.deptno\ngroup by\n\t\te.deptno\nlimit \t1\n```\n\n![20230718181057](http://s3.airtlab.com/blog/20230718181057.png)\n\n**如果是求平均薪水最低的部门名称呢？**\n（1）思路整理\n\n```sql\n# 薪水表和部门表进行内连接，并且分组，找出：部门编号，部门名称，平均薪水\n# 对上表进行生序排序，并取出第一个值\n```\n\n（2）我的代码\n\n```sql\nselect\n\t\te.deptno,\n\t\td.dname,\n\t\tavg(e.sal) as avg_sal\nfrom\n\t\tEMP e\nJOIN\n\t\tDEPT d\non\n\td.deptno = e.deptno\ngroup by\n\t\te.deptno\norder by\n\t\tavg_sal ASC\nlimit 1\n```\n\n![20230718181124](http://s3.airtlab.com/blog/20230718181124.png)\n\n### 7. 求平均薪水等级最低的部门的部门名称&#xA;\n\n（1）我的方法1\n\n```sql\n# 求出部门的员工的薪水等级\n# 求出部门的员工平均薪水等级\n# 求出平均薪水等级最低的部门\n```\n\n方法：分组+子查询\n\n```sql\nselect\n\t\tt.DEPTNO,\n\t\tavg(t.sal_grade)\nfrom\n\t\t(\n\t\t\tSELECT\n\t\t\t\t\te.*,\n\t\t\t\t\ts.GRADE as sal_grade\n\t\t\tfrom\n\t\t\t\t\tEMP e\n\t\t\tJOIN\n\t\t\t\t\tSALGRADE s\n\t\t\ton\n\t\t\t\t\te.sal between s.LOSAL and s.HISAL\n\t\t) as t\ngroup by\n\t\tt.DEPTNO\norder by \n\t\tavg(t.sal_grade)\nlimit 1\n```\n\n![20230718181146](http://s3.airtlab.com/blog/20230718181146.png)\n\n当某个部门没有员工时，返回的数据没有包含改部门，是符合逻辑的。\n\n***\n\n\n### 8. **取得比普通员工(员工代码没有在mgr上出现)最高薪水还要高的经理人姓名**\n\n```sql\n-- 找出 mgr\nselect distinct mgr  from emp;\n\n\n-- mgr 员工\nselect\n\t*\nfrom\n\temp\nwhere\n\tempno\nin\n\t(select distinct mgr from emp where mgr is not null)\n\n\n-- 普通员工\nselect\n\t*\nfrom\n\temp\nwhere\n\tempno\nnot in\n\t(select distinct mgr from emp where mgr is not null)\n\n\n\n-- 找出普通员工的ID： \nselect\n\tempno, sal\nfrom\n\temp\nwhere\n\tempno\nnot in \n\t(select distinct mgr  from emp where mgr is not null); \n\n/* empno\tsal\n7396\t800.00\n7499\t1600.00\n7521\t1250.00\n7654\t1250.00\n7844\t1500.00\n7876\t1100.00\n7900\t950.00\n7934\t1300.00 */\n\n\n-- 3：取得普通员工的最高薪水\nselect\n\tmax(t.sal) as max_sal \nfrom\n\t(select empno,sal from emp where empno not in (select distinct mgr  from emp where mgr is not null)) t;\n  \n\n-- 4: 最终语句\nselect\n\tename,\n\tsal\nfrom\n-- \temp e\n\t(select * from emp where empno in (select distinct mgr from emp where mgr is not null)) e\nwhere\n\te.sal > (\n\t\tselect max(t.sal) as max_sal \n\t\tfrom  (select empno, sal from emp where empno not in (select distinct mgr from emp where mgr is not null)) t\n\t)\n```\n\n### 9. 取得薪水最高的前五名员工\n\n```sql\nselect ename, sal from emp e order by\te.sal limit\t0,5\n```\n\n### 10. 取得薪水最高的第六到第十名员工\n\n```sql\nselect ename, sal from emp e order by\te.sal limit\t6,10\n```\n\n### 11. 取得最后入职的五名员工\n","isLeaf":true},{"key":"/Mysql/16 34道练习题/mysql 34道练习题（11-20）.md","path":"/Mysql/16 34道练习题/mysql 34道练习题（11-20）.md","route":"/Mysql/16 34道练习题/mysql 34道练习题（11-20）.md","leaf":true,"title":"mysql 34道练习题（11-20）","depth":2,"content":"---\ntitle: mysql 34道练习题（11-20）\n---\n\n### 11. 取得最后入职的五名员工\n\n```sql\n# 按照入职时间来排序  入职晚 时间大\nselect * from emp order by HIREDATE DESC limit 0, 5\n```\n\n![image.png](http://s3.airtlab.com/mysql/1620804750369-0ac485e1-7303-455e-bf0c-d83035dacef9.png) \n\n### 12. 取得每个薪水等级有多少个员工\n\n```sql\n-- # 先查出每个员工的薪水等级\n\n/* select\n        e.ename,\n        e.sal,\n        s.grade\nfrom\n        emp  e\njoin\n\t\tsalgrade s\non\n\t\te.sal between s.losal and s.hisal */\n\t\t\n-- +--------+---------+-------+\n-- | ename  | sal     | grade |\n-- +--------+---------+-------+\n-- | SMITH  |  800.00 |     1 |\n-- | ALLEN  | 1600.00 |     3 |\n-- | WARD   | 1250.00 |     2 |\n-- | JONES  | 2975.00 |     4 |\n-- | MARTIN | 1250.00 |     2 |\n-- | BLAKE  | 2850.00 |     4 |\n-- | CLARK  | 2450.00 |     4 |\n-- | SCOTT  | 3000.00 |     4 |\n-- | KING   | 5000.00 |     5 |\n-- | TURNER | 1500.00 |     3 |\n-- | ADAMS  | 1100.00 |     1 |\n-- | JAMES  |  950.00 |     1 |\n-- | FORD   | 3000.00 |     4 |\n-- | MILLER | 1300.00 |     2 |\n\t\t\n-- # 再用聚合函数根据薪水等级分类即可\n\nselect\n\t\tt.grade,\n\t\tcount(t.grade) as grade_count\nfrom\n\t\t(\n\t\tselect\n\t\t        e.ename,\n        \t\te.sal,\n\t\t        s.grade\n\t\tfrom\n        \t\temp  e\n\t\tjoin\n\t\t\t\tsalgrade s\n\t\ton\n\t\t\t\te.sal between s.losal and s.hisal\n\t\t) t\n\t\t\ngroup by\n\t\tgrade\n\n-- +-------+-------------+\n-- | grade | grade_count |\n-- +-------+-------------+\n-- |     1 |           3 |\n-- |     2 |           3 |\n-- |     3 |           2 |\n-- |     4 |           5 |\n-- |     5 |           1 |\n-- +-------+-------------+\n```\n\n### 13. XXXXXXXX\n\n### 14. 列出所有员工及领导的名字\n\n```sql\nselect\n\t\tt1.ename,\n\t\tt2.ename as boss_name\nfrom\n\t\temp t1\njoin\n\t\temp t2\non\n\t\tt1.MGR = t2.EMPNO\n\t\t\n-- +--------+-------+\n-- | ename  | boss  |\n-- +--------+-------+\n-- | SMITH  | FORD  |\n-- | ALLEN  | BLAKE |\n-- | WARD   | BLAKE |\n-- | JONES  | KING  |\n-- | MARTIN | BLAKE |\n-- | BLAKE  | KING  |\n-- | CLARK  | KING  |\n-- | SCOTT  | JONES |\n-- | KING   | NULL  |\n-- | TURNER | BLAKE |\n-- | ADAMS  | SCOTT |\n-- | JAMES  | BLAKE |\n-- | FORD   | JONES |\n-- | MILLER | CLARK |\n-- +--------+-------+\n```\n\n### 15. 列出受雇日期早于其直接上级的所有员工 编号&姓名&部门名称\n\n```sql\nselect\n\t\tt1.empno,\n\t\tt1.ename,\n\t\td.dname,\n\t\tt2.ename as boss_name\nfrom\n\t\temp t1\njoin\n\t\temp t2\njoin\n\t\tdept d\non\n\t\tt1.deptno = d.deptno\nwhere\n\t\tt1.MGR = t2.EMPNO and t1.`HIREDATE` < t2.`HIREDATE`\n\t\t\n\t\t\n-- +--------+-------+\n-- | ename  | boss  |\n-- +--------+-------+\n-- | SMITH  | FORD  |\n-- | ALLEN  | BLAKE |\n-- | WARD   | BLAKE |\n-- | JONES  | KING  |\n-- | MARTIN | BLAKE |\n-- | BLAKE  | KING  |\n-- | CLARK  | KING  |\n-- | SCOTT  | JONES |\n-- | KING   | NULL  |\n-- | TURNER | BLAKE |\n-- | ADAMS  | SCOTT |\n-- | JAMES  | BLAKE |\n-- | FORD   | JONES |\n-- | MILLER | CLARK |\n-- +--------+-------+\n```\n\n### 16. 列出部门名称和这些部门的员工信息，同时列出那些没有员工的部门\n\n```sql\n# select d.dname, e.* from dept d join emp e on d.deptno = e.deptno\nselect d.dname, e.* from emp e join dept d on d.deptno = e.deptno\n```\n\n![image.png](http://s3.airtlab.com/mysql/1620806857777-0d3198fc-3863-4090-92f4-76cd884278d3.png)\n\n### 17. 列出至少有5个员工的所有部门\n\n```sql\nselect\n\t\te.deptno,\n\t\td.dname,\n\t\tcount(e.deptno) as em_count\nfrom\n\t\temp e\njoin\n\t\tdept d\non\n\t\td.deptno = e.deptno\ngroup by\n\t\te.deptno\nhaving\n\t\tem_count > 5\n```\n\n![image.png](http://s3.airtlab.com/mysql/1620807257224-06be3670-af5f-4fe5-a2e7-ee25307a8e60.png) \n\n### 18. 列出薪水比“SMITH”多的所有员工信息\n\n```sql\n(主要考察子查询)\nselect * from emp where sal>(select sal from emp where ename ='smith');\n```\n\n![image.png](http://s3.airtlab.com/mysql/1620807432665-e4f1b2a6-b535-40b8-b60a-98827df9eaf5.png) \n\n### 19. 列出所有“CLARK”（办事员）的姓名及其部门名 称，部门人数\n\n```sql\n-- 所有办事员(部门名称也找出)\n(select e.ENAME, e.DEPTNO, e.`empno`, d.`dname` from emp e join dept d on d.`DEPTNO` = e.`DEPTNO` where e.`JOB` = \"CLERK\");\n\n+--------+--------+-------+------------+\n| ENAME  | DEPTNO | empno | dname      |\n+--------+--------+-------+------------+\n| MILLER |     10 |  7934 | ACCOUNTING |\n| SMITH  |     20 |  7396 | RESEARCH   |\n| ADAMS  |     20 |  7876 | RESEARCH   |\n| JAMES  |     30 |  7900 | SALES      |\n+--------+--------+-------+------------+\n```\n\n```sql\n-- 通过 name 分组\nselect\n\t\tt.*,\n\t\tcount(e.`EMPNO`) as emp_count\nfrom\n\t\t(select e.ENAME as name, e.DEPTNO, e.`empno`, d.`dname` from emp e join dept d on d.`DEPTNO` = e.`DEPTNO` where e.`JOB` = \"CLERK\") t\njoin\n\t\temp e\non\n\t\te.`DEPTNO` = t.`DEPTNO`\ngroup by\n\t\tt.`name` \n\n+--------+--------+-------+------------+-----------+\n| name   | DEPTNO | empno | dname      | emp_count |\n+--------+--------+-------+------------+-----------+\n| ADAMS  |     20 |  7876 | RESEARCH   |         6 |\n| JAMES  |     30 |  7900 | SALES      |         6 |\n| MILLER |     10 |  7934 | ACCOUNTING |         2 |\n| SMITH  |     20 |  7396 | RESEARCH   |         6 |\n+--------+--------+-------+------------+-----------+\n```\n\n### 20. 列出最低薪水大于1500的各种工作及从事此工作的全部雇员人数\n\n```sql\n-- 查询员工表，根据工作分组，并且获取该工作的最低薪水 和 人数\nselect\n\t\te.job,\n    \tcount(e.empno) as emp_count,\n\t\tmin(e.sal) as minsal\nfrom \n\t\temp e\ngroup by\n\t\te.`job`\nhaving\n\t\tminsal > 1500\n\n+-----------+-----------+---------+\n| job       | emp_count | minsal  |\n+-----------+-----------+---------+\n| ANALYST   |         2 | 3000.00 |\n| MANAGER   |         3 | 2450.00 |\n| PRESIDENT |         1 | 5000.00 |\n+-----------+-----------+---------+\n```\n","isLeaf":true},{"key":"/Mysql/16 34道练习题/mysql 34道练习题（21-30）.md","path":"/Mysql/16 34道练习题/mysql 34道练习题（21-30）.md","route":"/Mysql/16 34道练习题/mysql 34道练习题（21-30）.md","leaf":true,"title":"mysql 34道练习题（21-30）","depth":2,"content":"---\ntitle: mysql 34道练习题（21-30）\n---\n\n### 21. 列出在部门“SALES”工作的员工的姓名，假定不知道销售部门的部门编号\n\n```sql\n-- 字查询\nselect ename from emp e where e.`DEPTNO` = (select deptno from dept d where d.dname = 'SALES');\n\n-- 连表查\nselect ename from emp e join dept d on e.deptno = d.deptno where d.dname = 'SALES';\n```\n\n![image.png](http://s3.airtlab.com/mysql/1620876916754-264db0f0-3d3d-41d0-8c89-88d0fb349ec1.png)\n\n### 22. 列出薪金高于公司水平薪资的员工，以及所在部门、上级领导、工资等级 \n\n```sql\n-- 找出公司平均薪资\nselect avg(sal) from `emp`;\n\n-- 找出薪资高于平均水平的员工\nselect * from `emp` e where e.sal > (select avg(sal) from `emp`)\n```\n\n![image.png](http://s3.airtlab.com/mysql/1620884283793-27cea758-4ac5-4b9f-9813-b66c35979710.png)\n\n```sql\n-- 最后组装\nselect\n\te.*,\n\td.dname,\n\ts.grade as salgrade,\n\te2.ename as boos\nfrom `emp` e \njoin dept d\non e.deptno = d.deptno\njoin salgrade s\non e.sal between s.losal and s.hisal\njoin emp e2\non e2.`EMPNO` = e.mgr\nwhere e.sal > (select avg(sal) from `emp`);\n```\n\n![image.png](http://s3.airtlab.com/mysql/1620879548185-bb0a8f6b-4c10-4bc9-8838-fe22d00341ec.png)\n这个代码有问题，遗漏了 KING，这里面自连接需要改为左连接：\n\n```sql\n-- 最后组装\nselect\n\te.*,\n\td.dname,\n\ts.grade as salgrade,\n\te2.ename as boos\nfrom\n\t`emp` e \njoin\n\tdept d\non\n\te.deptno = d.deptno\njoin\n\tsalgrade s\non\n\te.sal between s.losal and s.hisal\nleft join\n\temp e2\non\n\te2.`EMPNO` = e.mgr\nwhere\n\te.sal > (select avg(sal) from `emp`);\n```\n\n![image.png](http://s3.airtlab.com/mysql/1620884541416-07fa256d-de8b-4d5c-a477-9ba4e8cb2c2b.png) \n\n### 23. 列出与“SCOTT”从事相同工作的所有员工及部门名称\n\n```sql\nselect\n\te.job,\n\te.ename,\n\td.dname\nfrom emp e\nleft join dept d\non e.`DEPTNO` = d.`DEPTNO`\nwhere e.`JOB` = (select e.`JOB` from emp e where e.ename = \"SCOTT\")\n```\n\n![image.png](http://s3.airtlab.com/mysql/1620885157145-5bf1ee9b-7aa9-4533-b5b2-440114a275fd.png)\n\n### 24. ❌ 列出薪金等于部门(编号30)中员工的薪金的其它员工的姓名和薪金？？？\n\n### 25. 列出薪金高于在部门30工作的所有员工的薪金的员工姓名&薪金&部门名称\n\n```sql\n-- 找出在部门30工作的所有员工的薪金的最大值 v\n-- 找出薪资大于 v 的所有员工，以及部门编号\n```\n\n```sql\n (select max(e.sal) from emp e where e.`DEPTNO` = 30)\n```\n\n![image.png](http://s3.airtlab.com/mysql/1620885612410-3bc0e240-c804-4528-b5d9-fa78d0628c9f.png)\n\n```sql\nselect * from emp e where e.sal > (select max(e.sal) from emp e where e.`DEPTNO` = 30)\n```\n\n![image.png](http://s3.airtlab.com/mysql/1620885642367-6d502fd0-3cc9-4710-ac5d-34821c58d430.png)\n\n```sql\nselect e.*, d.dname from emp e left join dept d on e.`DEPTNO` = d.`DEPTNO` where e.sal > (select max(e.sal) from emp e where e.`DEPTNO` = 30)\n```\n\n![image.png](http://s3.airtlab.com/mysql/1620885793282-8ea2f728-1477-40b5-a9fe-93e8996a3828.png)\n\n### 26. 列出在每个部门工作的员工数量、平均工资和平均服务期限\n\n```sql\nselect\n\te.DEPTNO,\n\tcount(e.`EMPNO`) as emp_count,\n\tavg(e.`SAL`) as avg_sal,\n\tavg((to_days(now())-to_days(hiredate))/365) as avg_server_year \nfrom\n\temp e\ngroup by e.`DEPTNO`\n```\n\n![image.png](http://s3.airtlab.com/mysql/1620886160834-dd817860-d24c-4fbf-a11e-350118cb2c5b.png)\n\n### 27. 列出所有员工的姓名、部门名称、工资 \n\n```sql\nselect e.ename, e.sal, d.dname from emp e left join dept d on d.`DEPTNO` = e.`DEPTNO`\n```\n\n### 28. 列出所有部门的详细信息和人数\n\n```sql\nselect\n\td.*,\n\tcount(d.DEPTNO) as count_emp\nfrom \n\tdept d\njoin\n\temp e\non\n\te.`DEPTNO` = d.`DEPTNO`\ngroup by\n\td.`DEPTNO`\n```\n\n![image.png](http://s3.airtlab.com/mysql/1620889331650-29c68b81-5060-4c4d-bc01-1be1450bda1f.png)\n\n### 29. 列出各种工作的最低工资及从事此工作的雇员姓名\n\n```sql\n-- 列出各种工作的最低工资\nselect e.job, min(e.sal) as minsal from emp e group by e.job;\n```\n\n![image.png](http://s3.airtlab.com/mysql/1620888491489-0f0b2ca2-7fb3-48ff-a736-e98659928514.png)\n\n```sql\nselect\n\tt.*,\n\te.ename\nfrom \n\t(select e.job, min(e.sal) as minsal from emp e group by e.job) t\nleft join\n\temp e\non \n\te.`JOB` = t.`JOB` and e.sal = t.minsal;\n```\n\n![image.png](http://s3.airtlab.com/mysql/1620889071665-56613af7-500b-4d90-a272-eeec47ea719d.png)\n\n### 30 .列出各个部门 MANAGER 的最低薪金\n\n```sql\n-- 找出各个部门 MANAGER\n\nselect\n        e.deptno,min(e.sal) as minsal\nfrom\n        emp e\nwhere\n        e.job='manager'\ngroup by\n        e.deptno;\n```\n","isLeaf":true},{"key":"/Mysql/16 34道练习题/mysql 34道练习题（31-34）.md","path":"/Mysql/16 34道练习题/mysql 34道练习题（31-34）.md","route":"/Mysql/16 34道练习题/mysql 34道练习题（31-34）.md","leaf":true,"title":"mysql 34道练习题（31-34）","depth":2,"content":"---\ntitle: mysql 34道练习题（31-34）\n---\n\n### 31. 列出所有员工的年工资，按年薪从低到高排序\n\n```sql\nselect sal * 12 as year_sal from emp e order by year_sal DESC;\n\n+----------+\n| year_sal |\n+----------+\n| 60000.00 |\n| 36000.00 |\n| 36000.00 |\n| 35700.00 |\n| 34200.00 |\n| 29400.00 |\n| 19200.00 |\n| 18000.00 |\n| 15600.00 |\n| 15000.00 |\n| 15000.00 |\n| 13200.00 |\n| 11400.00 |\n|  9600.00 |\n+----------+\n```\n\n### 32. 求出员工领导的薪水超过3000的员工名称和领导名称\n\n```sql\nselect\n\te.`ename`,\n\ta.ename as boss,\n\ta.sal\n\t\nfrom emp e join emp a on e.`mgr` = a.`empno` where a.sal>3000;\n\n+-------+------+---------+\n| ename | boss | sal     |\n+-------+------+---------+\n| JONES | KING | 5000.00 |\n| BLAKE | KING | 5000.00 |\n| CLARK | KING | 5000.00 |\n+-------+------+---------+\n```\n\n### 33. 求部门名称中带“S”字符的部门员工的工资合计&部门人数\n\n```sql\n-- 部门名称中带“S”字符的部门A\n-- 求A中，每一个部门员工的工资合计 以及 部门人数\n\nselect\n\td.deptno,\n\td.dname,\n\tsum(e.`sal`) as sum_sal,\n\tcount(e.`empno`) as count_emp\nfrom\n\tdept d\njoin\n\temp e\non\n\te.`deptno` = d.`deptno`\nwhere\n\td.dname like '%s%'\ngroup by\n\td.dname;\n  \n+--------+----------+----------+-----------+\n| deptno | dname    | sum_sal  | count_emp |\n+--------+----------+----------+-----------+\n|     20 | RESEARCH | 13325.00 |         6 |\n|     30 | SALES    |  9400.00 |         6 |\n+--------+----------+----------+-----------+\n```\n\n### 34. 给任职日期超过30年的员工加薪10%\n\n```sql\n-- 找出职日期超过30年的员工\n\n-- # 先备份一下表\ncreate table emp_bak as select * from emp;\nupdate emp_bak set sal = sal *1.1 where (to_days(now())-to_days(hiredate))/365>30;\n-- +-------+--------+-----------+------+------------+---------+---------+--------+\n-- | EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |\n-- +-------+--------+-----------+------+------------+---------+---------+--------+\n-- |  7396 | SMITH  | CLERK     | 7902 | 1980-12-17 |  880.00 |    NULL |     20 |\n-- |  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1760.00 |  300.00 |     30 |\n-- |  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1375.00 |  500.00 |     30 |\n-- |  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 3272.50 |    NULL |     20 |\n-- |  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1375.00 | 1400.00 |     30 |\n-- |  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 3135.00 |    NULL |     30 |\n-- |  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2695.00 |    NULL |     20 |\n-- |  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3300.00 |    NULL |     20 |\n-- |  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5500.00 |    NULL |     10 |\n-- |  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1650.00 |    0.00 |     30 |\n-- |  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1210.00 |    NULL |     20 |\n-- |  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 | 1045.00 |    NULL |     30 |\n-- |  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3300.00 |    NULL |     20 |\n-- |  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1430.00 |    NULL |     10 |\n-- +-------+--------+-----------+------+------------+---------+---------+--------+\n```\n","isLeaf":true}]},{"key":"/Mysql/17 极客时间 45讲","path":"/Mysql/17 极客时间 45讲","route":"/Mysql/17 极客时间 45讲","leaf":false,"title":"17 极客时间 45讲","depth":1,"content":"","isLeaf":false,"children":[]},{"key":"/Mysql/18 一些疑问","path":"/Mysql/18 一些疑问","route":"/Mysql/18 一些疑问","leaf":false,"title":"18 一些疑问","depth":1,"content":"","isLeaf":false,"children":[{"key":"/Mysql/18 一些疑问/01-query-on-tcp.md","path":"/Mysql/18 一些疑问/01-query-on-tcp.md","route":"/Mysql/18 一些疑问/01-query-on-tcp.md","leaf":true,"title":"01-query-on-tcp","depth":2,"content":"---\ntags: Mysql\n---\n\n## 1、执行一次 mysql 查询，会进行几次 tcp 通讯\n\n执行一次MySQL查询大致会进行两次TCP通信：\n1. 建立连接：客户端与MySQL服务器通过TCP建立连接。\n\n2. 执行查询：完成建立连接后，客户端向MySQL服务器发送查询请求，MySQL服务器返回查询结果，此过程中也是使用TCP进行通讯。\n\n需要注意的是，在执行查询过程中，通信次数还会受到一些其他因素的影响，如查询的复杂程度、表的大小、网络状况等。但是，通常情况下，MySQL查询都会进行至少两次TCP通信。\n\n## 2、执行查询的详细过程\n\nMySQL查询的详细过程如下：\n1. 客户端向MySQL服务器发送查询请求，通过TCP套接字发送一个SQL命令字符串到MySQL服务器。\n\n2. MySQL服务器收到查询请求后，解析SQL命令，如SELECT、INSERT等，并对命令进行合法性验证，例如检查语法错误和访问权限。\n\n3. 如果SQL语句合法，则服务器会执行SQL查找数据或修改数据的操作。对于一个SELECT查询，服务器会将结果集拆分为多个数据包发送给客户端。对于INSERT、UPDATE和DELETE语句，服务器会返回命令执行的结果信息。\n\n4. 客户端接收到MySQL服务器返回的数据时，通过TCP套接字将结果集字节流传输到本地计算机内存中，然后将结果集数据转化为程序内部的数据结构，如二维数组、哈希表等。\n\n5. 客户端处理结果集数据，例如进行数据分析、统计和展示等操作。\n\n6. 客户端释放结果集内存并关闭TCP套接字连接。\n\n## 3、抓包分析\n\n![20230506165553](http://s3.airtlab.com/blog/20230506165553.png)\n\n![20230506165632](http://s3.airtlab.com/blog/20230506165632.png)\n\n![20230506165647](http://s3.airtlab.com/blog/20230506165647.png)\n\n## 4、mysql 通讯协议","isLeaf":true},{"key":"/Mysql/18 一些疑问/02-mysql-utilities.md","path":"/Mysql/18 一些疑问/02-mysql-utilities.md","route":"/Mysql/18 一些疑问/02-mysql-utilities.md","leaf":true,"title":"02-mysql-utilities","depth":2,"content":"---\ntags: Mysql\n---\n\n## 1、MySQL Utilities 介绍\n\nMySQL Utilities 提供一组命令行工具用于维护和管理 MySQL 服务器，包括：\n\n- 管理工具 (克隆、复制、比较、差异、导出、导入)\n- 复制工具 (安装、配置)\n- 一般工具 (磁盘使用情况、冗余索引、搜索元数据)\n\nMySQL Utilities 是一系列的命令行工具以 及​ ​Python​​库更容易完成管理的任务\n\n## 2、通过 pip 安装 【失败】\n\n您可以按照以下步骤在 macOS 上安装 mysql utilities：\n\n1. 使用 Homebrew 安装 MySQL：\n\n```\nbrew install mysql\n```\n\n2. 安装 Python pip 工具（如果您的系统尚未安装）：\n\n```\nsudo easy_install pip\n```\n\n这里安装可能会报错 (https://stackoverflow.com/questions/72270592/syntaxerror-when-pip-install-pip-def-readrel-path-str) \n\n![20230515145909](http://s3.airtlab.com/blog/20230515145909.png)\n\n3. 使用 pip 安装 mysql-utilities：\n\n```\nsudo pip install mysql-utilities\n```\n\n安装完成后，您可以在终端中运行 mysql utilities 命令。\n\n## 3、下载源码安装 【成功】\n\nhttps://github.com/mysql/mysql-utilities/releases/tag/release-1.6.5\n\n```shell\ncd mysql-utilities-release-1.6.5\npython setup.py install\n\ncd /Library/Frameworks/Python.framework/Versions/2.7/bin\n```\n\n![20230515160248](http://s3.airtlab.com/blog/20230515160248.png)\n\n## 4、测试 mysqldiff\n\n```shell\nmysqldiff --server1=root:123456@127.0.0.1:3306 --server2=root:123456@127.0.0.1:3306 --changes-for=server2 test:test2\n```\n\n提示缺少 MySQLConverter\n\n```shell\nTraceback (most recent call last):\n  File \"/Library/Frameworks/Python.framework/Versions/2.7/bin/mysqldiff\", line 30, in <module>\n    from mysql.utilities.command.diff import object_diff, database_diff\n  File \"/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/mysql/utilities/command/diff.py\", line 25, in <module>\n    from mysql.utilities.common.database import Database\n  File \"/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/mysql/utilities/common/database.py\", line 32, in <module>\n    from mysql.utilities.common.options import obj2sql\n  File \"/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/mysql/utilities/common/options.py\", line 36, in <module>\n    from mysql.connector.conversion import MySQLConverter\nImportError: No module named connector.conversion\n```\n\n安装\n```shell\npip install mysql-connector-python\n```\n\n又提示\n```text\nTraceback (most recent call last):\n  File \"/Library/Frameworks/Python.framework/Versions/2.7/bin/mysqldiff\", line 28, in <module>\n    from mysql.utilities.common.tools import check_python_version\nImportError: No module named utilities.common.tools\n```\n\n放弃了... 就很无语 😭😭😭","isLeaf":true},{"key":"/Mysql/18 一些疑问/03-mysql-workbench.md","path":"/Mysql/18 一些疑问/03-mysql-workbench.md","route":"/Mysql/18 一些疑问/03-mysql-workbench.md","leaf":true,"title":"03-mysql-workbench","depth":2,"content":"---\ntags: Mysql\n---\n\n## 1、MySQL Workbench 介绍\n\nMySQL Workbench 是一个可视化数据库设计和管理工具，旨在简化 MySQL 数据库的开发、部署和管理。\nMySQL Workbench 提供了以下功能：\n\n1. 数据库建模和设计：允许用户通过可视化工具进行数据库设计和建模。\n\n2. SQL 开发：允许用户创建、编辑和执行 SQL 查询、语句和脚本。\n\n3. 数据库管理：允许用户创建、修改、删除数据库、表、视图、存储过程等。\n\n4. 数据连接：MySQL Workbench 允许用户连接多个 MySQL 实例，包括在本地或远程服务器上运行的 MySQL 实例。\n\n5. 数据库备份和恢复：MySQL Workbench 允许用户对 MySQL 数据库进行备份和还原，以及管理备份文件。\n\n6. 数据库性能分析和优化：MySQL Workbench 允许用户查看和分析 MySQL 数据库的性能，并生成可视化图表。同时也提供了一些优化工具，如查询优化器等。\n\n总之，MySQL Workbench 可以帮助开发人员和 DBA 更高效地设计、开发和管理 MySQL 数据库，并提供全面的数据库管理和性能优化工具。","isLeaf":true},{"key":"/Mysql/18 一些疑问/04-get-db-used-size.md","path":"/Mysql/18 一些疑问/04-get-db-used-size.md","route":"/Mysql/18 一些疑问/04-get-db-used-size.md","leaf":true,"title":"04-get-db-used-size","depth":2,"content":"---\ntags: Mysql\n---\n\n## 1、某张表占用磁盘大小\n\n可以使用以下命令查询MySQL数据库中某张表占用的磁盘大小：\n\n```\nSELECT table_name AS \"Table\",\nROUND(((data_length + index_length) / 1024 / 1024), 2) AS \"Size (MB)\"\nFROM information_schema.TABLES\nWHERE table_schema = \"<your_database_name>\"\nAND table_name = \"<your_table_name>\";\n```\n\n请将 `<your_database_name>` 和 `<your_table_name>` 替换为您想查询的数据库名称和表名称。\n\n执行该命令后，您将看到表格名称和表占用的磁盘空间大小（以MB为单位）。\n\n## 2、数据库占用磁盘大小\n\n可以使用以下MySQL查询来检索整个数据库所占用的磁盘空间大小：\n\n```\nSELECT table_schema AS \"Database\",\nSUM(data_length + index_length) / 1024 / 1024 AS \"Size (MB)\"\nFROM information_schema.TABLES\nGROUP BY table_schema;\n```\n\n执行该命令后，您将看到每个数据库的名称和它所占用的磁盘空间大小（以MB为单位）。请注意，这将为所有表格的数据和索引空间总和提供一个估计值。","isLeaf":true},{"key":"/Mysql/18 一些疑问/SQL 语言介绍.md","path":"/Mysql/18 一些疑问/SQL 语言介绍.md","route":"/Mysql/18 一些疑问/SQL 语言介绍.md","leaf":true,"title":"SQL 语言介绍","depth":2,"content":"---\ntitle: SQL 语言介绍\nurl: https://www.yuque.com/gaollard/utbbp1\n---\n\n![image.png](http://s3.airtlab.com/mysql/1601645857104-cb7526b8-c5af-4677-ae19-83318c1c2b68.png)\n![image.png](http://s3.airtlab.com/mysql/1601645911349-030d10cd-beba-47a6-af6e-91e7667bd76d.png)\n![image.png](http://s3.airtlab.com/mysql/1601646004497-fbd4186f-0ae0-462f-a910-94dd7fa42632.png)\n","isLeaf":true},{"key":"/Mysql/18 一些疑问/mysql like 为什么很慢.md","path":"/Mysql/18 一些疑问/mysql like 为什么很慢.md","route":"/Mysql/18 一些疑问/mysql like 为什么很慢.md","leaf":true,"title":"mysql like 为什么很慢","depth":2,"content":"---\ntitle: mysql like 为什么很慢\nurl: https://www.yuque.com/gaollard/utbbp1/xhevle\n---\n\n模糊查询会导致索引失效\n","isLeaf":true},{"key":"/Mysql/18 一些疑问/mysql 使用 explain 解释语句.md","path":"/Mysql/18 一些疑问/mysql 使用 explain 解释语句.md","route":"/Mysql/18 一些疑问/mysql 使用 explain 解释语句.md","leaf":true,"title":"mysql 使用 explain 解释语句","depth":2,"content":"---\ntitle: mysql 使用 explain 解释语句\nurl: https://www.yuque.com/gaollard/utbbp1\n---\n\n```sql\nexplain select * from `book` t group by t.name\n```\n\n![image.png](http://s3.airtlab.com/mysql/1625556945713-0acc311a-f6c2-4a58-afcf-522c650366d8.png)\n","isLeaf":true},{"key":"/Mysql/18 一些疑问/mysql 分组.md","path":"/Mysql/18 一些疑问/mysql 分组.md","route":"/Mysql/18 一些疑问/mysql 分组.md","leaf":true,"title":"mysql 分组","depth":2,"content":"---\ntitle: mysql 分组\nurl: https://www.yuque.com/gaollard/utbbp1/is25v0\n---\n\n1、group 常用句式\n\n```sql\nselect ... from ... where ... group by ... having ... order by ...\n```\n\n```sql\nselect * from `book` t where t.id > 1 group by t.name having t.id > 1  order by t.id ASC \n```\n","isLeaf":true},{"key":"/Mysql/18 一些疑问/mysql 时间怎么存.md","path":"/Mysql/18 一些疑问/mysql 时间怎么存.md","route":"/Mysql/18 一些疑问/mysql 时间怎么存.md","leaf":true,"title":"mysql 时间怎么存","depth":2,"content":"---\ntitle: mysql 时间怎么存\nurl: https://www.yuque.com/gaollard/utbbp1/ttugko\n---\n\n- int\n- datetime\n- timestamp\n- varchar\n\n用哪一个好？\n\n- 仅仅用做展示\n- 大小对比\n","isLeaf":true},{"key":"/Mysql/18 一些疑问/union 与 union all.md","path":"/Mysql/18 一些疑问/union 与 union all.md","route":"/Mysql/18 一些疑问/union 与 union all.md","leaf":true,"title":"union 与 union all","depth":2,"content":"---\ntitle: union 与 union all\nurl: https://www.yuque.com/gaollard/utbbp1/esgoiz\n---\n\n","isLeaf":true},{"key":"/Mysql/18 一些疑问/全表分组的性能差.md","path":"/Mysql/18 一些疑问/全表分组的性能差.md","route":"/Mysql/18 一些疑问/全表分组的性能差.md","leaf":true,"title":"全表分组的性能差","depth":2,"content":"---\ntitle: 全表分组的性能差\nurl: https://www.yuque.com/gaollard/utbbp1/nb231s\n---\n\n","isLeaf":true},{"key":"/Mysql/18 一些疑问/如何正确使用 join 从句.md","path":"/Mysql/18 一些疑问/如何正确使用 join 从句.md","route":"/Mysql/18 一些疑问/如何正确使用 join 从句.md","leaf":true,"title":"如何正确使用 join 从句","depth":2,"content":"---\ntitle: 如何正确使用 join 从句\nurl: https://www.yuque.com/gaollard/utbbp1\n---\n\n### 1. 连接类型\n\n***\n\n![image.png](http://s3.airtlab.com/mysql/1601646120805-feb496bd-9874-4cc1-9592-ba9bb857f38f.png) \n\n### 2. 内连接\n\n***\n\n内连接也称为等值连接，返回两张表都满足条件的部分。\n![image.png](http://s3.airtlab.com/mysql/1601647451240-ff77e6c7-ec03-480b-95e1-0259916956a7.png)\n![image.png](http://s3.airtlab.com/mysql/1601647482334-67b8f9b2-421f-4f39-b762-7d6dd35a71e4.png)\n![image.png](http://s3.airtlab.com/mysql/1601647510549-e7f2e88e-0314-4052-8599-1ec44d42d435.png)\n\n```sql\n-- 只用 where ...\nselect s.`student_name`, c.`class_name`,  s.`class_id`, s.`id` as `student_id` from student s, class c where s.`class_id` = c.`id`\n\n-- join ... on ...\nselect s.`student_name`, c.`class_name`,  s.`class_id`, s.`id` as `student_id` from student s join class c on s.`class_id` = c.`id`\n\n-- inner join ... on ...\nselect s.`student_name`, c.`class_name`,  s.`class_id`, s.`id` as `student_id` from student s inner join class c on s.`class_id` = c.`id`\n```\n\n![image.png](http://s3.airtlab.com/mysql/1601647626566-9f555265-a068-4b26-a9ec-5efc95f6d129.png) \n\n### 3. 外连接\n\n***\n\n#### 3.1 左连接\n\n根据左表的记录，在被连接的右表中找出符合条件的记录与之匹配，如果找不到与左表匹配的，用 null 表示。注意和内连接的区别，内连接是识别出交集部分，而左连接是以左表为基准，右边的表按条件找出符合条件的显示，不符合则显示null。\n![image.png](http://s3.airtlab.com/mysql/1601648425851-5c144939-a985-4e86-96cb-eca5dbaab320.png)\n![image.png](http://s3.airtlab.com/mysql/1601648507489-6464a585-46ed-42a3-a3a0-c5df7c1982e9.png)\n![image.png](http://s3.airtlab.com/mysql/1601648520602-4211e3ce-5225-430b-aa41-f58687da1fdd.png)\n\n```sql\n-- letf join ... on ...\nselect s.`student_name`, c.`class_name`,  s.`class_id`, s.`id` as `student_id` from student s left join class c on s.`class_id` = c.`id`\n\n-- letf outer join ... on ...\nselect s.`student_name`, c.`class_name`,  s.`class_id`, s.`id` as `student_id` from student s left outer join class c on s.`class_id` = c.`id`\n```\n\n![image.png](http://s3.airtlab.com/mysql/1601651166059-a41028b2-f055-4737-9691-805a9879847e.png) \n\n#### 3.2 右连接\n\n![image.png](http://s3.airtlab.com/mysql/1601652160919-e8960bed-f0cb-48a3-9a9c-89d4999801bd.png)\n取右边的表的全部，左边的表按条件，符合的显示，不符合则显示null。用法完全与左连接完全一致，只是将 left join 改为 right join。\n![image.png](http://s3.airtlab.com/mysql/1601651529787-d0279b09-7a18-4697-8d0e-f51698e78523.png)\n![image.png](http://s3.airtlab.com/mysql/1601651539854-e8e698fd-9d12-4ff1-ab16-54ee6d1546eb.png)\n![image.png](http://s3.airtlab.com/mysql/1601651558941-62a0abe6-ab08-4d27-92a4-d5ef51bf14f9.png) \n\n#### 3.3 全连接\n\n返回符合条件的所有表的记录，没有与之匹配的，用 null 表示（结果是左连接和右连接的并集）\n![image.png](http://s3.airtlab.com/mysql/1601652137150-f67c5ce3-fd5d-4a1e-9943-e60e1bdc9e10.png)\n在 mysql 中使用 full join 会语法报错，需要换一种方式：\n![image.png](http://s3.airtlab.com/mysql/1601652679077-39e9ea35-e791-4e67-8ef7-2f4aa1e73d4f.png)\n\n```sql\nselect s.`student_name`, s.`id` as `student_id`, c.`class_name`, c.`id` as `class_id` from student s LEFT JOIN class c ON s.`class_id` = c.`id`\n\nUNION ALL\n\nselect s.`student_name`, s.`id` as `student_id`, c.`class_name`,  c.`id` as `class_id` from student s RIGHT JOIN class c ON s.`class_id` = c.`id`\n```\n\n这里需要注意 union 与 union all 的区别。\n![image.png](http://s3.airtlab.com/mysql/1601653439698-30e9d183-3451-4221-84d6-9f68530fe018.png) \n\n### 4. 交叉连接(笛卡尔集)\n\n![image.png](http://s3.airtlab.com/mysql/1601653634696-bfec6734-9973-4925-bb8d-ac45e725679b.png)\n\n```sql\n-- where \nselect * from student CROSS join class where student.`student_name`=\"小华\"\n\n-- on\nselect * from student CROSS join class on student.`student_name`=\"小华\"\n```\n\n![image.png](http://s3.airtlab.com/mysql/1601653913263-b786d0f0-b79c-400c-b7e0-58eb29bce77e.png) \n\n### 参考文档\n\n1. <https://www.cnblogs.com/buxingzhelyd/p/7853454.html>\n","isLeaf":true},{"key":"/Mysql/18 一些疑问/性能排查.md","path":"/Mysql/18 一些疑问/性能排查.md","route":"/Mysql/18 一些疑问/性能排查.md","leaf":true,"title":"性能排查","depth":2,"content":"---\ntitle: 性能排查\nurl: https://www.yuque.com/gaollard/utbbp1\n---\n\n参考资料 <https://www.bilibili.com/video/BV1zd4y127FJ/?spm_id_from=333.337.search-card.all.click&vd_source=0e3c815b57fd2e0fe8ae7e1813631816> \n\n### 1、慢查询\n\n\n\n#### 慢查询时间阈值\n\n```typescript\nshow variables like \"long_query_time%\";\n```\n\n![image.png](http://s3.airtlab.com/mysql/1667399532196-07dff47e-91dd-45fd-aca7-b29cec2df3a2.png) \n\n#### 查看慢查询日志\n\n```typescript\nshow variables like \"slow_query%\";\n```\n\n![image.png](http://s3.airtlab.com/mysql/1667399556378-8edd7f2d-94d4-4a4e-8071-f9c774b03ecc.png) \n\n### 2、当前线程的执行情况\n\n\n\n#### full processlist\n\n![image.png](http://s3.airtlab.com/mysql/1667399673892-8bcc29c3-326f-4830-8c12-7b5771c4a49f.png)\n可以使用 kill id 杀死一个线程\n![image.png](http://s3.airtlab.com/mysql/1667399767364-f4279202-1438-4ddb-9406-39c0c1d8867d.png) \n\n#### processlist + where\n\n```typescript\nselect * from information_schema.processlist where db = 'credit_admin_id_db';\n```\n\n\n\n### 3、借助 performance\\_schema\n\n![image.png](http://s3.airtlab.com/mysql/1667399855162-2b8b1cc5-24c1-4fa7-bde5-57a70bf20911.png)\n","isLeaf":true},{"key":"/Mysql/18 一些疑问/批量插入为什么快.md","path":"/Mysql/18 一些疑问/批量插入为什么快.md","route":"/Mysql/18 一些疑问/批量插入为什么快.md","leaf":true,"title":"批量插入为什么快","depth":2,"content":"---\ntitle: 批量插入为什么快\nurl: https://www.yuque.com/gaollard/utbbp1\n---\n\n结论：批量语句，只要有一个失败，就会全部失败。开发程序的时候要注意这点。\n![image.png](http://s3.airtlab.com/mysql/1667377725306-cb885614-4b64-4c46-b902-bd3250e8c351.png)\n","isLeaf":true},{"key":"/Mysql/18 一些疑问/查询最后一条数据一定是全表扫描吗.md","path":"/Mysql/18 一些疑问/查询最后一条数据一定是全表扫描吗.md","route":"/Mysql/18 一些疑问/查询最后一条数据一定是全表扫描吗.md","leaf":true,"title":"查询最后一条数据一定是全表扫描吗","depth":2,"content":"貌似性能还可以\n\n```typescript\nmysql:\n\nselect * from table order by id DESC limit 1\n\noracle:\n\nselect * from emp where id in (select max(id) from emp);\n```\n","isLeaf":true}]}]},{"key":"/NodeJS","path":"/NodeJS","route":"/NodeJS","leaf":false,"title":"NodeJS","depth":0,"content":"","isLeaf":false,"children":[{"key":"/NodeJS/01 基础知识","path":"/NodeJS/01 基础知识","route":"/NodeJS/01 基础知识","leaf":false,"title":"01 基础知识","depth":1,"content":"","isLeaf":false,"children":[{"key":"/NodeJS/01 基础知识/01-npm-usage.md","path":"/NodeJS/01 基础知识/01-npm-usage.md","route":"/NodeJS/01 基础知识/01-npm-usage.md","leaf":true,"title":"01-npm-usage","depth":2,"content":"---\ntitle: 01 npm 用法笔记\ntoc: true\ntags: NodeJS 基础\ncategories: NodeJS\n---\n\n## 1、设置镜像地址\n\n用户级别 `npm` 配置文件一般在 `~/.npmrc`，可以手动打开并修改：\n\n```text\n;;;;\n; npm userconfig file: /Users/xxx/.npmrc\n; this is a simple ini-formatted file\n; lines that start with semi-colons are comments\n; run `npm help 7 config` for documentation of the various options\n;\n; Configs like `@scope:registry` map a scope to a given registry url.\n;\n; Configs like `//<hostname>/:_authToken` are auth that is restricted\n; to the registry host specified.\n\nhome=https://www.npmjs.org\nregistry=https://npm.shopee.io/ # 设置仓库地址\n```\n\n或者通过 `npm config` 命令打开文件:\n\n```bash\nnpm config edit\n```\n\n或者直接使用 `npm config` 命令进行修改：\n\n```text\nUsage:\nnpm config set <key>=<value> [<key>=<value> ...]\nnpm config get [<key> [<key> ...]]\nnpm config delete <key> [<key> ...]\nnpm config list [--json]\nnpm config edit\n```\n\n当然你也可以在项目的根目录新建 `.npmrc` 文件进行局部覆盖：\n\n```text\nregistry=https://registry.npmjs.org/\n```\n\n## 2、安装本地 npm 包\n\n```bash\nnpm install [path]\n```\n\n比如安装下面的 sleep 包，可以通过 `npm install ~/Desktop/sleep` 进行安装，其目录地址为 `~/Desktop/sleep`。\n\n![20230404152959](http://s3.airtlab.com/blog/20230404152959.png)\n\n```js\nconst sleep = () => {\n  console.log(sleep);\n};\nmodule.exports = { sleep };\n```\n\n安装完成后，`dependencies` 中显示 `sleep` 是一个本地文件：\n\n```json\n{\n  \"dependencies\": {\n    \"sleep\": \"file:../sleep\"\n  }\n}\n```\n\n`package-lock.json` 也会标注本地依赖：\n\n```json\n{\n  \"packages\": {\n    \"../sleep\": {\n      \"version\": \"1.0.0\",\n      \"license\": \"ISC\"\n    },\n    \"node_modules/sleep\": {\n      \"resolved\": \"../sleep\",\n      \"link\": true\n    }\n  }\n}\n```\n\n## 3、查看 npm 全局包\n\n执行 `npm -h` 提示：\n\n```shell\nroot@host ~ %\nroot@host ~ %\nroot@host ~ %\nroot@host ~ %\nroot@host ~ %\nroot@host ~ % npm -h\nnpm <command>\n\nUsage:\n\nnpm install        install all the dependencies in your project\nnpm install <foo>  add the <foo> dependency to your project\nnpm test           run this project's tests\nnpm run <foo>      run the script named <foo>\nnpm <command> -h   quick help on <command>\nnpm -l             display usage info for all commands\nnpm help <term>    search for help on <term>\nnpm help npm       more involved overview\n\nAll commands:\n\n    access, adduser, audit, bin, bugs, cache, ci, completion,\n    config, dedupe, deprecate, diff, dist-tag, docs, doctor,\n    edit, exec, explain, explore, find-dupes, fund, get, help,\n    hook, init, install, install-ci-test, install-test, link,\n    ll, login, logout, ls, org, outdated, owner, pack, ping,\n    pkg, prefix, profile, prune, publish, query, rebuild, repo,\n    restart, root, run-script, search, set, set-script,\n    shrinkwrap, star, stars, start, stop, team, test, token,\n    uninstall, unpublish, unstar, update, version, view, whoami\n\nSpecify configs in the ini-formatted file:\n    /Users/xiong.gao/.npmrc\nor on the command line via: npm <command> --key=value\n\nMore configuration info: npm help config\nConfiguration fields: npm help 7 config\n\nnpm@8.19.3 /usr/local/lib/node_modules/npm\n```\n\n其中最底部 `/usr/local/lib/node_modules` 就是全局包的安装路径\n\n## 4、npm link 用法\n\n`npm link` 在开发 npm 包进行本地调试的时候会很有用，假设现在有两个项目，main 为主项目，sleep 为 npm 包项目。\n\n- 在 sleep 目录下执行 `npm link`，此操作会在全局包中创建一个软连接指向真实目录\n- 在 main 目录下执行 `npm link sleep`，创建软连接到 node_modules\n\n![20230404154920](http://s3.airtlab.com/blog/20230404154920.png)\n\n## 5、npx 用法\n\nnpx 想要解决的主要问题，就是调用项目内部安装的模块。比如，项目内部安装了 xxx，如果想在命令行下调用，必须像下面这样：\n\n```shell\n# 项目的根目录下执行\n$ node-modules/.bin/xxx --version\n```\n\n使用 npx 只要像下面这样调用就行了\n\n```shell\nnpx xxx --version\n```\n\n## 6、npm ci 和 npm install 区别\n\n- 必须已经存在 package-lock.json 或 npm-shrinkwrap.json，否则无法使用 npm ci\n- 如果 package-lock.json 中的依赖项与 package.json 中的依赖项不匹配，则 npm ci 将退出并显示错误，而不是更新 package-lock.json\n- npm ci 一次只能安装整个项目，无法添加单个依赖项\n- npm ci 开始安装之前自动删除 node_modules 文件夹\n- npm ci 不会更改 package.json 和 package-lock.json\n\n## 7、npm prune 的作用\n\n在开发过程中，可能使用了某些模块，而后来的某个环节可能又不再使用。但是 npm install 一次，都会在 node_modules 中存留文件，node_modules 目录就会变的臃肿起来，npm prune 此命令的功能是根据 package.json 里的依赖项，删除不需要的模块文件。如果 --production 指定了标志或将 NODE_ENV 环境变量设置为 production，则此命令将删除您的包中指定的软件包 devDependencies\n\n```shell\nnpm prune --production\n```\n\n## 8、peerDependencies 作用\n\n当一个包被依赖时，如果它在其peer dependency中声明了另一个依赖包，那么这个依赖包的版本和安装方式将被忽略，而是使用当前项目中或父级包中已经安装的相同版本的依赖包。\n\n默认在安装依赖时 peerDependency 版本不一致会报错，可以设置忽略。\n\n## 9、npm devDependencies\n\n我的项目依赖了 npm 包 b， 当执行 npm install b 时，b 里面的 devDependencies 会被自动安装吗？\n\n在默认情况下，当您运行 `npm install b` 时，npm 将仅安装依赖项列表中列出的生产环境依赖项，而不会自动安装 `b` 包中 `devDependencies` 中列出的开发环境依赖项。\n如果你需要同时安装开发环境依赖项，你需要在安装时加上 `--dev` 或 `-D` 参数来安装所有生产和开发环境依赖项。\n\n例如，您可以运行以下命令来同时安装生产和开发环境依赖项：\n\n```\nnpm install b --save-dev\n```\n\n或者也可以简写为：\n\n```\nnpm install b -D\n```\n\n这将安装 `b` 依赖项和 `b` 的所有 `devDependencies` 依赖项。\n","isLeaf":true},{"key":"/NodeJS/01 基础知识/02-nodejs-version.md","path":"/NodeJS/01 基础知识/02-nodejs-version.md","route":"/NodeJS/01 基础知识/02-nodejs-version.md","leaf":true,"title":"02-nodejs-version","depth":2,"content":"---\ntitle: 02 nodejs 版本管理\ntoc: true\ntags: NodeJS 基础\ncategories: NodeJS\n---\n\n推荐在 windows 上使用 nvm，在 mac 上则使用 n。\n二者主要区别如下：\n- n 会将 nodejs 安装为全局版本，因此有可能在切换 node 版本后，发生全局模块执行出错的问题；\n- nvm 则会将全局模块存在于各自版本的沙箱中，切换版本后需要重新安装，不同版本间也不存在任何冲突；\n\n对于 `node` 可执行文件的位置:\n- n 存放到 `/usr/local/bin`，所以不需要配置环境变量就能访问\n- nvm 则需要手动指定路径。\n\n## 1. nvm\nnvm 全名 Node.js Version Management，在 macOS、Linux（包括适用于 Linux 的 Windows 子系统）和各种其他类 Unix 系统上均受支持。\n由于 Windows 支持程度不佳，社区孵化了 nvm-windows 供 Windows 使用，它们隶属于不同的项目，相互分开的支持和维护。\n\n- Linux、Mac OS：https://github.com/nvm-sh/nvm\n- Windows：https://github.com/coreybutler/nvm-windows\n\n### 1.1 安装\n#### Mac\n```shell\n# 方式1 浏览器打开下面链接下载\nhttps://github.com/nvm-sh/nvm/blob/v0.39.1/install.sh\n# 下载完成后，通过命令安装\nsh install.sh\n\n# 方式2 推荐\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash\n\n# 方式3\nwget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash\n```\n\n#### windows\n参考 https://www.freecodecamp.org/chinese/news/node-version-manager-nvm-install-guide/\n\n注意，如果在安装 nvm 之前已经装了 nodejs，建议先卸载掉。\n\n**nvm-setup 安装**\n请记住安装位置，后续配置环境变量时方便检查\n![vnm安装路径](http://s3.airtlab.com/blog/20230224224924.png)\n\n![链接路径](http://s3.airtlab.com/blog/20230224224943.png)\n\n**查看安装路径**\nC:\\Users\\Administrator\\AppData\\Roaming\\nvm\n![20230224225211](http://s3.airtlab.com/blog/20230224225211.png)\n\n**修改 setting 配置镜像**\n![20230224225244](http://s3.airtlab.com/blog/20230224225244.png)\n\n### 1.2 使用\n```shell\nnvm ls                # 查看版本安装所有版本\nnvm ls-remote         # 查看远程所有的 Node.js 版本\nnvm install 17.0.0    # 安装指定的 Node.js 版本\nnvm use 17.0.0        # 使用指定的 Node.js 版本\nnvm alias default 17.0.0  # 设置默认 Node.js 版本\nnvm alias dev 17.0.0  # 设置指定版本的别名，如将 17.0.0 版本别名设置为 dev\n```\n\n## 2. n\nn 是一款交互式的 Node.js 版本管理工具，没有子脚本，没有配置文件，也没有复杂的 API，使用起来非常简单。\nn 只适用于 macOS 和 Linux ，不适用于 Windows。\n### 2.1 安装\n\n```shell\nnpm install n -g\n```\n\n### 2.2 使用\n```shell\nn          # 显示所有已下载版本\nn 10.16.0  # 下载指定版本\nn lts      # 查看远程所有 LTS Node.js 版本\nn run 10.16.0 # 运行指定的 Node.js 版本\n```","isLeaf":true},{"key":"/NodeJS/01 基础知识/03-nodejs-debug.md","path":"/NodeJS/01 基础知识/03-nodejs-debug.md","route":"/NodeJS/01 基础知识/03-nodejs-debug.md","leaf":true,"title":"03-nodejs-debug","depth":2,"content":"---\ntitle: 03 nodejs 代码调试\ntoc: true\ntags: NodeJS 基础\ncategories: NodeJS\n---\n\n目标：掌握程序的调试技巧\n\n## 1、开启调试模式\n\n在调试之前我们先初始化一个工程：\n```shell\n$ npm init -y\n$ npm install --save koa koa-route\n```\n\n```js\n// app.js\nconst Koa = require('koa');\nconst router = require('koa-route');\n\nconst app = new Koa();\n\nconst main = ctx => {\n  debugger\n  ctx.response.body = 'Hello World';\n};\n\nconst welcome = (ctx, name) => {\n  ctx.response.body = 'Hello ' + name;\n};\n\napp.use(router.get('/', main));\napp.use(router.get('/:name', welcome));\n\napp.listen(3000);\nconsole.log('listening on port 3000');\n```\n\n### 1) 9229\n\n端口 9229 是默认的 NodeJS 调试端口。它允许您将诸如Chrome 的 Inspector或 WebStorm 的远程调试之类的调试工具附加到使用特殊标志运行的 Node 进程\n\n### 2) --inspect\n\n在运行 nodejs 程序时，可以通过 `--inspect` 开始调试模式：\n```shell\nnode --inspect app.js\n```\n\n然后就可以通过 `浏览器` 和 `vscode` 以及 `webstorm` 等UI界面调试了。 \n\n启动后提示：\n```shell\n# 这里提示调试通道的地址为 ws://127.0.0.1:9229/91a04b5e-67bd-4b1a-93c5-9260a75403d2\nDebugger listening on ws://127.0.0.1:9229/91a04b5e-67bd-4b1a-93c5-9260a75403d2\nFor help, see: https://nodejs.org/en/docs/inspector\nlistening on port 3000\n```\n\n### 3) inspect-brk\n\n`--inspect-brk` 指定在第一行就设置断点。也就是说，一开始运行，就是暂停的状态。这对在 chrome 中调试非服务脚本会非常有用。否则在你设置断点之前程序就结束了。\n\n## 2、使用浏览器调试\n\n一共有两种打开调试工具的方法，第一种是在 Chrome 浏览器的地址栏，键入 `chrome://inspect` 或者 `about:inspect`，回车后就可以看到下面的界面：\n\n![20230225085601](http://s3.airtlab.com/blog/20230225085601.png)\n\n点击 inspect 链接，就能进入调试工具了。\n\n第二种方法，是在 http://127.0.0.1:3000 的窗口打开\"开发者工具\"，顶部左上角有一个 Node 的绿色标志，点击就可以进入。\n\n![20230225085741](http://s3.airtlab.com/blog/20230225085741.png)\n\n点击后进入：\n![20230225085820](http://s3.airtlab.com/blog/20230225085820.png)\n\n当我们访问 `http://localhost:3000`，就会进入暂停在断点处：\n![20230225090028](http://s3.airtlab.com/blog/20230225090028.png)\n\n### 1) url 调试地址\n\n假若 ws 地址为：ws://127.0.0.1:9229/8e951b59-b730-41dc-a4c0-15da52b71fd3，有两个很重要的页面地址：\n\n- **js_app.html**: `devtools://devtools/bundled/js_app.html?experiments=true&v8only=true&ws=127.0.0.1:9229/8e951b59-b730-41dc-a4c0-15da52b71fd3`\n\n- **inspector.html**: `devtools://devtools/bundled/inspector.html?experiments=true&v8only=true&ws=127.0.0.1:9229/8e951b59-b730-41dc-a4c0-15da52b71fd3` 访问该 url 即可进入调试页面\n\n## 3、使用 vscode 调试\n\n创建 `launch.json ` 文件, 格式如下：\n\n```json\n{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    // 配置1\n    {},\n    // 配置2\n    {}\n  ]\n}\n```\n\n### 1) 调试 Node.js 程序\n```json\n{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"type\": \"pwa-node\",\n      \"request\": \"launch\",\n      \"name\": \"Launch Javascript Program\",\n      \"skipFiles\": [\"<node_internals>/**\"],\n      \"program\": \"${workspaceFolder}/node_modules/@vue/cli-service/lib/Service.js\"\n    }\n  ]\n}\n```\n\n- type: 必填项，调试类型，当前为 node，如果是 PHP 调试，则在安装 PHP 调试插件后写 php；\n- request: 必填项，有两种类型，分别是 launch 和 attach，前者的意思就是 VSCode 会打开这个程序然后进入调试，后者的意思是你已经打开了程序，然后接通 Node.js 的内部调试协议进行调试，如果你看过“Node.js 的调试原理”一文，应该可以大致理解；\n- program: 程序的启动入口；\n\n还可以使用另外的配置方式，打开 launch.json 找到 name 为 调试 Node.js 程序 - args 的文件：\n```json\n{\n  \"name\": \"调试 Node.js 程序 - args\",\n  \"type\": \"node\",\n  \"request\": \"launch\",\n  \"runtimeExecutable\": \"node\",\n  \"args\": [\n    \"${workspaceFolder}/src/index.js\"\n  ]\n}\n```\n\n这里并没有采用 program 来描述程序入口，而是通过 runtimeExecutable 和 args 组合的方式来启动程序:\n\n- runtimeExecutable: 使用什么命令启动\n- args: 启动时的参数\n\n相当于：\n```shell\nnode ${workspaceFolder}/src/index.js\n```\n\n### 2) 通过npm脚本启动\n\n```json\n{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"type\": \"pwa-node\",\n      \"request\": \"launch\",\n      \"name\": \"Npm Command\",\n      \"skipFiles\": [\"<node_internals>/**\"],\n      \"runtimeExecutable\": \"npm\",\n      \"runtimeArgs\": [\"run-script\", \"build\"]\n    }\n  ]\n}\n```\n\nruntimeArgs 是为 runtimeExecutable 环境提供的配置，而 args 是为程序提供的配置。这个 JSON 的意思是：\n```shell\nnpm run build\n```\n\n### 3) 调试一个 TS Node 程序\n\n```json\n{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"type\": \"node\",\n      \"request\": \"launch\",\n      \"name\": \"Launch Typescript Program\",\n      \"runtimeArgs\": [\"-r\", \"ts-node/register\"],\n      \"args\": [\"${workspaceFolder}/main.ts\"]\n    }\n  ]\n}\n```\n\n等同于:\n```shell\nnode --inspect-brk=DEBUG_PORT -r ts-node/register $workspaceFolder/main.ts\n```\n\n### 4) 调试已启动的程序\n\n```json\n{\n  \"type\": \"pwa-node\",\n  \"request\": \"attach\",\n  \"name\": \"Attach\",\n  \"port\": 9229\n}\n```\n上面写死了 9229，你可以换种写法：\n\n```json\n{\n  \"type\": \"pwa-node\",\n  \"request\": \"attach\",\n  \"name\": \"Attach\",\n  \"processId\": \"${command:PickProcess}\"\n}\n```\n\n`${command:PickProcess}` 作为 processId 的值，VSCode 会遍历所有的 Node PID 列出来让你选择，如下图所示：\n![20230225094847](http://s3.airtlab.com/blog/20230225094847.png)\n\n\n### 5) 调试网页的 JS 代码\n大家应该十分熟悉在 Chrome 中调试 JS 代码，不过 VSCode 允许你在安装了 Debugger for Chrome 插件后，直接在 VSCode 调试 JS 代码，让你的代码和调试融为一体，提升开发体验：\n\n![20230225095030](http://s3.airtlab.com/blog/20230225095030.png)\n\n可以通过如下简单的配置进行调试：\n```json\n{\n  \"name\": \"调试网页的 JS 文件\",\n  \"request\": \"launch\",\n  \"type\": \"chrome\",\n  \"file\": \"${workspaceFolder}/index.html\"\n}\n```\n\n注意，这里的 type 是 chrome，默认会启动一个 Chrome 浏览器（新用户）加载 file 字段对应的文件地址（通过 file:// 协议加载），文件中用到的 JS 都可以断点调试。当然你也可以起一个 Web Server 来调试 http:// 协议的文件，这里就需要设置 webRoot 和 url 参数了，可自行 Google。\n\n\n## 3、参考文档\n- [nodejs debugger](https://code.visualstudio.com/docs/nodejs/nodejs-debugging)\n- [VSCode 调试中 launch.json 配置不完全指南](https://www.barretlee.com/blog/2019/03/18/debugging-in-vscode-tutorial/)\n- [Node 调试工具入门教程](https://www.ruanyifeng.com/blog/2018/03/node-debugger.html)\n- [让你 nodejs 水平暴增的 debugger 技巧](https://zhuanlan.zhihu.com/p/387270007?utm_source=wechat_session&utm_medium=social&utm_oi=635912988696121344)\n- [如何在vscode里面调试js和node.js](https://www.cnblogs.com/both-eyes/p/10152142.html)\n","isLeaf":true},{"key":"/NodeJS/01 基础知识/04-nodejs-debug-why.md","path":"/NodeJS/01 基础知识/04-nodejs-debug-why.md","route":"/NodeJS/01 基础知识/04-nodejs-debug-why.md","leaf":true,"title":"04-nodejs-debug-why","depth":2,"content":"---\ntitle: 04 nodejs 调试原理\ntoc: true\ntags: NodeJS 基础\ncategories: NodeJS\n---\n\n> 原文 神光《JavaScript Debugger 原理揭秘》 https://zhuanlan.zhihu.com/p/372135871\n\n> 这篇文章首先对我是有帮助的，了解一些概念，但是作者在介绍 “解释型语言的 debugger” 原理时明显是有纰漏的，没有讲到解释器是如何支持中断的。比如我可以简单理解为死循环？这明显是错误的。其中可以参考雪碧大佬的回答：\n\n> doodlewind: 这个有点跑偏了吧……感觉这方面内容主要应该涉及 step over、step in 的时候会发生的事？（或者说引擎是如何支持调试协议的。）至于类似 INT3 中断的机制，这对解释器来说确实是必要的（比如引擎跑进死循环 JS 代码的时候，也可以响应 ctrl-c 的信号跳出 main loop），但我不太觉得这个概念就是调试器的「底层原理」……[捂脸]\n\n## 1、CPU 中断\n\ncpu 只会不断地执行下一条指令，但程序运行过程中难免要处理一些外部的消息，比如 io、网络、异常等等，所以设计了中断的机制，cpu 每执行完一条指令，就会去看下中断标记，是否需要中断了。就像 event loop 每次 loop 完都要检查下是否需要渲染一样。\n\n## 2、INT 指令\n\ncpu 支持 INT 指令来触发中断，中断有编号，不同的编号有不同的处理程序，记录编号和中断处理程序的表叫做中断向量表。其中 INT 3 (3 号中断)可以触发 debugger，这是一种约定。\n\n那么可执行文件是怎么利用这个 3 号中断来 debugger 的呢?其实就是运行时替换执行的内容，debugger 程序会在需要设置断点的位置把指令内容换成 INT 3，也就是 0xCC，这就断住了。就可以获取这时候的环境数据来做调试。\n\n![20230226204200](http://s3.airtlab.com/blog/20230226204200.png)\n\n通过机器码替换成 0xcc (INT 3)是把程序断住了，可是怎么恢复执行呢?其实也比较简单，把当时替换的机器码记录下来，需要释放断点的时候再换回去就行了。\n\n这就是可执行文件的 debugger 的原理了，最终还是靠 cpu 支持的中断机制来实现的。\n\n## 3、中断寄存器\n\n上面说的 debugger 实现方式是修改内存中的机器码的方式，但有的时候修改不了代码，比如 ROM，这种情况就要通过 cpu 提供的 4 个中断寄存器(DR0 - DR3)来做了。这种叫做硬中断。\n\n总之，INT 3 的软中断，还有中断寄存器的硬中断，是可执行文件实现 debugger 的两种方式。\n\n## 4、解释型语言的 debugger\n\n编译型语言因为直接在操作系统之上执行，所以要利用 cpu 和操作系统的中断机制和系统调用来实现 debugger。但是解释型语言是自己实现代码的解释执行的，所以不需要那一套，但是实现思路还是一样的，就是插入一段代码来断住，支持环境数据的查看和代码的执行，当释放断点的时候就继续往下执行。\n\n比如 javascript 中支持 debugger 语句，当解释器执行到这一条语句的时候就会断住。\n\n解释型语言的 debugger 相对简单一些，不需要了解 cpu 的 INT 3 中断。\n\n> 这个有点跑偏了吧……感觉这方面内容主要应该涉及 step over、step in 的时候会发生的事？（或者说引擎是如何支持调试协议的。）至于类似 INT3 中断的机制，这对解释器来说确实是必要的（比如引擎跑进死循环 JS 代码的时候，也可以响应 ctrl-c 的信号跳出 main loop），但我不太觉得这个概念就是调试器的「底层原理」……[捂脸]\n\n## 5、debugger 客户端\n\n上面我们了解了直接执行和解释执行的代码的 debugger 分别是怎么实现的。我们知道了代码是怎么断住的，那么断住之后呢?怎么把环境数据暴露出去，怎么执行外部代码?\n\n这就需要 debugger 客户端了。比如 v8 引擎会把设置断点、获取环境信息、执行脚本的能力通过 socket 暴露出去，socket 传递的信息格式就是 v8 debug protocol 。\n\n设置断点：\n\n```json\n{\n  \"seq\": 117,\n  \"type\": \"request\",\n  \"command\": \"setbreakpoint\",\n  \"arguments\": {\n    \"type\": \"function\",\n    \"target\": \"f\"\n  }\n}\n```\n\n去掉断点：\n\n```json\n{\n  \"seq\": 117,\n  \"type\": \"request\",\n  \"command\": \"clearbreakpoint\",\n  \"arguments\": {\n    \"type\": \"function\",\n    \"breakpoint\": 1\n  }\n}\n```\n\n继续：\n\n```json\n{\n  \"seq\": 117,\n  \"type\": \"request\",\n  \"command\": \"continue\"\n}\n```\n\n执行代码：\n\n```json\n{\n  \"seq\": 117,\n  \"type\": \"request\",\n  \"command\": \"evaluate\",\n  \"arguments\": { \"expression\": \"1+2\" }\n}\n```\n感兴趣的同学可以去 v8 debug protocol 的文档中去查看全部的协议。\n\n基于这些协议就可以控制 v8 的 debugger 了，所有的能够实现 debugger 的都是对接了这个协议，比如 chrome devtools、vscode debugger 还有其他各种 ide 的 debugger。\n\n## 6、nodejs 代码的调试\n\nnodejs 可以通过添加 --inspect 的 option 来做调试(也可以是 --inspect-brk，这个会在首行就断住)。\n\n它会起一个 debugger 的 websocket 服务端，我们可以用 vscode 来调试 nodejs 代码，也可以用 chrome devtools 来调试(见 nodejs debugger 文档)。\n\n```bash\nnode --inspect test.js\nDebugger listening on ws://127.0.0.1:9229/db309268-623a-4abe-b19a-c4407ed8998d\nFor help see https://nodejs.org/en/docs/inspector\n```\n\n原理就是实现了 v8 debug protocol。\n我们如果自己做调试工具、做 ide，那就要对接这个协议。\n\n## 7、debugger adaptor protocol\n上面介绍的 v8 debug protocol 可以实现 js 代码的调试，那么 python、c# 等肯定也有自己的调试协议，如果要实现 ide，都要对接一遍太过麻烦。所以后来出现了一个中间层协议，DAP(debugger adaptor protocol)。\n\ndebugger adaptor protocol， 顾名思义，就是适配的，一端适配各种 debugger 协议，一端提供给客户端统一的协议。这是适配器模式的一个很好的应用。\n\n![20230226205040](http://s3.airtlab.com/blog/20230226205040.png)\n\n## 8、总结\n\n本文我们学习了 debugger 的实现原理和暴露出的调试协议。\n\n首先我们了解了代码两种运行方式：直接执行和解释执行，然后分析了下为什么需要 debugger。\n\n之后探索了直接执行的代码通过 INT 3 的中断的方式来实现 debugger 和解释型语言自己实现的 debugger。\n\n然后 debugger 的能力会通过 socket 暴露给客户端，提供调试协议，比如 v8 debug protocol，各种客户端包括 chrome devtools、ide 等都实现了这个协议。\n\n但是每种语言都要实现一次的话太过麻烦，所以后来出现了一个适配层协议，屏蔽了不同协议的区别，提供统一的协议接口给客户端用。\n\n希望这篇文章能够让你理解 debugger 的原理，如果要实现调试工具也知道怎么该怎么去对接协议。能够知道 chrome devtools、vscode 为啥都可以调试 nodejs 代码。\n\n## 9、文章纠错\n其中涉及一些错误参考原文评论 -> https://zhuanlan.zhihu.com/p/372135871·","isLeaf":true},{"key":"/NodeJS/01 基础知识/05-Character-Encoding.md","path":"/NodeJS/01 基础知识/05-Character-Encoding.md","route":"/NodeJS/01 基础知识/05-Character-Encoding.md","leaf":true,"title":"05-Character-Encoding","depth":2,"content":"---\ntitle: 05 理解字符编码\ntoc: true\ntags: NodeJS 基础\ncategories: NodeJS\n---\n\n> - ASCII编码转换 https://www.qqxiuzi.cn/bianma/ascii.htm\n> - Unicode(UTF-8, UTF-16)令人混淆的概念 https://www.cnblogs.com/kingcat/archive/2012/10/16/2726334.html\n\n### 1、ASCII\nASCII编码范围 0x00-0x7F，即十进制的0-127，定义了128个单字节字符，其中包含95个可打印字符（数字、字母、符号），以及33个控制字符（下表中文描述的字符）。国标码GB18030、国际码Unicode均兼容ASCII编码。\n\n### 2、Unicode\n统一码（Unicode），也叫万国码、Unicode的最初目标，是用1个16位的编码来为超过65000字符提供映射。但这还不够，它不能覆盖全部历史上的文字，也不能解决传输的问题 (implantation head-ache's)，尤其在那些基于网络的应用中。已有的软件必须做大量的工作来程序16位的数据。 \n\n因此，Unicode用一些基本的保留字符制定了三套编码方式。它们分别是`UTF-8`, `UTF-16` 和 `UTF-32`。\n\n在UTF－8中，字符 是以8位序列来编码的，用一个或几个字节来表示一个字符。这种方式的最大好处，是UTF－8保留了ASCII字符的编码做为它的一部分，例如，在 UTF－8和ASCII中，“A”的编码都是0x41。\n\nUTF－16和UTF－32分别是Unicode的16位和32位编码方式。考虑到最初的目的，通常说的Unicode就是指UTF-16。在讨论Unicode时，搞清楚哪种编码方式非常重要。Unicdoe相关的技术介绍参见http://www.unicode.org/unicode/standard/principles.html.\n\n### 3、UTF8\n参考 https://www.zhihu.com/question/23374078\n![20230226215929](http://s3.airtlab.com/blog/20230226215929.png)\n\n> UTF-8的编码方式中，当计算机读到1110XXXX，就知道目前的这个字符占了3个字节，应该继续往后读取。\n\n### 4、UTF-8/UTF-16/UTF-32\n（1）UTF-8是变长编码，每个Unicode代码点按照不同范围，可以有1-3字节的不同长度。\n\n（2）UTF-16长度相对固定，只要不处理大于\\U200000范围的字符，每个Unicode代码点使用16位即2字节表示，超出部分使用两个UTF-16即4字节表示。按照高低位字节顺序，又分为UTF-16BE/UTF-16LE。\n\n（3）UTF-32长度始终固定，每个Unicode代码点使用32位即4字节表示。按照高低位字节顺序，又分为UTF-32BE/UTF-32LE。\n\n**举个例子**\n假如中文字\"汉\"对应的 unicode 是6C49(这是用十六进制表示，用十进制表示是 27721 为啥不用十进制表示呢？很明显用十六进制表示要短点。其实都是等价的没啥不一样，就跟你说60分钟和1小时一样)。你可能会问当用程序打开一个文件时我们怎么知道那是用的UTF-8还是UTF-16啊.自然会有点啥标志,在文件的开头几个字节就是标志:\n```\nEF BB BF 表示UTF-8\nFE FF 表示UTF-16.\n```\n\n### 5、base64\nBase64是网络上最常见的用于传输8Bit字节码的编码方式之一，Base64就是一种`基于64个可打印字符来表示二进制数据的方法`。可查看RFC2045～RFC2049，上面有MIME的详细规范。base64 编码是可逆的。\n","isLeaf":true},{"key":"/NodeJS/01 基础知识/06-hexadecimal.md","path":"/NodeJS/01 基础知识/06-hexadecimal.md","route":"/NodeJS/01 基础知识/06-hexadecimal.md","leaf":true,"title":"06-hexadecimal","depth":2,"content":"---\ntitle: 06 进制表示\ntoc: true\ntags: NodeJS 基础\ncategories: NodeJS\n---\n\n> 在线进制转换 https://www.sojson.com/hexconvert.html\n\n## 1. 二进制\n\n二进制数（binaries）是逢2进位的进位制，0、1 是基本算符。\n\n**特性**: 如果一个二进制数（整型）数的第零位的值是1，那么这个数就是奇数；而如果该位是0，那么这个数就是偶数。\n\n## 2. N 进制\n\n- 十进制：有10个基数：0、1、2、3、4、5、6、7、8、9，逢十进一\n- 二进制：有2 个基数：0、1，逢二进一\n- 八进制：有8个基数：0、1、2、3、4、5、6、7，逢八进一\n- 十六进制：有16个基数：0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、F，逢十六进一\n\n## 3. 进制转换\n\n![20230227091616](http://s3.airtlab.com/blog/20230227091616.png)\nhttps://zhuanlan.zhihu.com/p/459817484 \n\n## 4. 负数的表示\n- 求出原码\n- 求出反码\n- 求出补码\n\n演示 -5 的二进制计算过程：\n- 5的原码： 101 => 0000 0101\n- 求出反码：    => 1111 1010\n- 求出补码：    => 1111 1011\n\n如果要表示16位的-5，在左边添上8个1即\n1111 1111 1111 1011\n\n**逆运算**\n比如知道一个补码: 1111 1011\n- 根据补码得到反码: 1111 1010\n- 根据反码得到原码：0000  0101 => 5\n\n### 4.1 最高位上的1和0是表示正负，还是不表示正负？\n\n二进制是表示计数的一种方法，用二进制计数时，用最高位上的1和0来代表这个数的正与负，这样的数就称为“有符号数”，同时也存在着“无符号数”。\n\n那若给出一个用二进制表示出来的数，如何分辨最高位上的1和0是表示正负，还是不表示正负？\n\n比如 11010110:\n- 无符号数表示：214\n- 有符号数表示：-42\n  - 根据补码得到反码：11010110 - 1 = 11010101\n  - 根据反码得到原码：00101010 => 42\n\n这个是人为定义的，假如 int 占用1个字节，那么:\n```c\n// 定义有符号 -128 ——— 0 ———- 127\nint a\n\n// 定义无符号 0 —————– 255\nunsigned int b\n```\n\n## 5. 浮点数的表示\n\n![20230227232435](http://s3.airtlab.com/blog/20230227232435.png)\n\n很多人都遇到过这个问题 “0.1 + 0.2 == 0.3?” 答案是不一定：\n> 这主要是因为有的小数无法可以用「完整」的二进制来表示，所以计算机里只能采用近似数的方式来保存，那两个近似数相加，得到的必然也是一个近似数。https://xiaolincoding.com/os/1_hardware/float.html\n\n- double 的有效数字是 15~16 位\n- float 的有效数字是 7~8 位\n\n这些有效位是包含整数部分和小数部分；","isLeaf":true},{"key":"/NodeJS/01 基础知识/07-buffer.md","path":"/NodeJS/01 基础知识/07-buffer.md","route":"/NodeJS/01 基础知识/07-buffer.md","leaf":true,"title":"07-buffer","depth":2,"content":"---\ntitle: 07 buffer操作二进制数\ntoc: true\ntags: NodeJS 基础\ncategories: NodeJS\n---\n\n> 部分内容参考 《针对 Node 的 Buffer 模块中难理解的 API 做一次彻底的讲解》https://www.bilibili.com/read/cv4881167?spm_id_from=333.999.0.0\n\nBuffer 对象用于表示固定长度的字节序列，许多 Node.js API 都支持 Buffer。\n\n## 1. 预备知识\n\n### 1.1 什么是缓冲区 Buffer\n\n在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理 I/O 操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。\n\n### 1.2 Buffer 与字符编码\n\nBuffer 实例一般用于表示编码字符的序列，比如 UTF-8 、 UCS2 、 Base64 、或十六进制编码的数据。 通过使用显式的字符编码，就可以在 Buffer 实例与普通的 JavaScript 字符串之间进行相互转换。\n\n```javascript\nconst buf = Buffer.from(\"r\", \"ascii\");\nconsole.log(buf); // <Buffer 72>\n// 这里的 72 在 ascii 编码中对应的十六进制值为72 => 其二进制值为 0111 0010\n```\n\n```javascript\nconst buf = Buffer.from(\"runoob\", \"ascii\");\n\n// 输出 72756e6f6f62\nconsole.log(buf.toString(\"hex\"));\n\n// 输出 cnVub29i\nconsole.log(buf.toString(\"base64\"));\n```\n\nNode.js 目前支持的字符编码包括：\n\n- ascii - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。\n- utf8 - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。\n- utf16le - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。\n- ucs2 - utf16le  的别名。\n- base64 - Base64 编码。\n- latin1 - 一种把  Buffer  编码成一字节编码的字符串的方式。\n- binary - latin1  的别名。\n- hex - 将每个字节编码为两个十六进制字符。\n\n### 1.3 Buffer 与 Stream 的关系\n\n在应用中，因为在后端与前端、后端的 IO 中，每当需要在 Node.js 中处理 I/O 操作中移动的数据时，就有可能使用 Buffer 库，很多时候会出现数据过大，不能一次性读取的问题。会导致程序的等待时间过长，因此，流操作（stream）便营运而生。\n\n在 readable 和 writable 的 Stream 之间筑起沟通，如果仅仅使用事件方法来进行的话，代码会显得很冗杂，因此需要出现 pipe（管道）方法来进行。\n\n```javascript\nreadable.pipe(writable);\n```\n\nStream 就像司机，它的作用就是将装着数据的 Buffer 开向终点，在 NodeJS 中，许多接口都集成 Stream。假如你不懂 Stream 也没有关系，先这样了解就可以了。\n\n## 2.  创建 Buffer 类\n\nBuffer 提供两类 API 来创建 buffer\n\n### 2.1 从字符串创建\n\n`Buffer.from(string[, encoding])`\n\n```javascript\nconst buf = Buffer.from(\"知\", \"utf-8\");\nconsole.log(buf); // <Buffer e7 9f a5>\n```\n\n### 2.2 指定字节序列创建\n\n指定字节序列创建 Buffer(使用 0 – 255 范围内的字节 array 分配)，该范围之外的数组条目将被截断以符合它。\n\n`Buffer.from(array)`\n\n```javascript\n// 创建包含字符串 'buffer' 的 UTF-8 字节的新缓冲区。\nconst buf = Buffer.from([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]);\nconsole.log(buf);\n```\n\n### 2.3 buffer 拷贝创建\n\n`Buffer.from(buffer)`\n\n```javascript\nconst buf1 = Buffer.from(\"buffer\");\nconst buf2 = Buffer.from(buf1);\n\nbuf1[0] = 0x61; // a\n\nconsole.log(buf1.toString());\n// 打印: auffer\nconsole.log(buf2.toString());\n// 打印: buffer\n```\n\n```javascript\nconst buf1 = Buffer.from(\"知\");\nconst buf2 = Buffer.from(buf1);\n\n// 根据 utf-8 编码规则, 后面两个字节显然无效喽\n// 因为它属于 0~U+007F\nbuf1[0] = 0x61;\n\nconsole.log(buf1.toString());\n// 打印: a��\nconsole.log(buf2.toString());\n// 打印: 知\n```\n\n### 2.4 Buffer.alloc\n\n```javascript\nconst buf = Buffer.alloc(26);\nfor (var i = 0; i < 26; i++) {\n  buf[i] = i + 97;\n}\n\nconsole.log(buf.toString(\"ascii\")); // 输出: abcdefghijklmnopqrstuvwxyz\nconsole.log(buf.toString(\"ascii\", 0, 5)); // 输出: abcde\nconsole.log(buf.toString(\"utf8\", 0, 5)); // 输出: abcde\nconsole.log(buf.toString(undefined, 0, 5)); // 使用 'utf8' 编码, 并输出: abcde\n```\n\n#### Buffer.alloc(size[, fill[, encoding]])\n\n- size 代表 Buffer 的长度\n- fill 初始化填充的内容\n- encoding 代表编码\n\n![20230228202308](http://s3.airtlab.com/blog/20230228202308.png)\n\n可以看出 fil l 和 encoding 之间的关系，fill 先按照 encoding 编码成二进制，然后一个字节一个字节的向此方法生成的 Buffer 中填充，根据长度 size，依次循环。\n\n### 2.5 Buffer.from 对比\n\n(1) Buffer.from(array)  返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖）。\n(2) Buffer.from(arrayBuffer[, byteOffset[, length]])  返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。\n(3) Buffer.from(buffer)  复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例。\n(4) Buffer.from(string[, encoding])： 返回一个被 string 的值初始化的新的 Buffer 实例。\n\n```javascript\n// 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。\nconst buf4 = Buffer.from([1, 2, 3]);\n\n// 创建一个包含 UTF-8 字节 [0x74, 0xc3, 0xa9, 0x73, 0x74] 的 Buffer。\nconst buf5 = Buffer.from(\"tést\");\n\n// 创建一个包含 Latin-1 字节 [0x74, 0xe9, 0x73, 0x74] 的 Buffer。\nconst buf6 = Buffer.from(\"tést\", \"latin1\");\n```\n\n#### Buffer.from(arrayBuffer[, byteOffset[, length]])\n\n![20230228202419](http://s3.airtlab.com/blog/20230228202419.png)\n\n将一个二进制数组`[5000, 4000]` 放入 Buffer 中生成了 `<88 a0>`，因为 Buffer 实例是 Uint8Array 的实例，此时相当于把 arr 放入 Uint8Array 中，元素一一对应，而 Uint8Array 每个元素都是 8 位，最大值是 256，所以发生了溢出，根据溢出的算法最终变为了<88 a0>。\n\n如果不想发生溢出，可以使用二进制数组的 buffer 属性（此时会共享内存）：\n\n![20230228202649](http://s3.airtlab.com/blog/20230228202649.png)\n\n可选的 byteOffset 和 length 参数指定 arrayBuffer 中与 Buffer 共享的内存范围，如果不使用 buffer 属性，这两个参数并不会生效。\n\n![20230228202659](http://s3.airtlab.com/blog/20230228202659.png)\n\n可选的 byteOffset 和 length 参数指定 arrayBuffer 中与 Buffer 共享的内存范围，如果不使用 buffer 属性，这两个参数并不会生效：\n![20230228202715](http://s3.airtlab.com/blog/20230228202715.png)\n\n## 3、读字节流\n\n### 3.1 readUInt8/readInt8\n\n读取一个字节的有/无符号的整数\n\n![20230228202626](http://s3.airtlab.com/blog/20230228202626.png)\n\n- readUInt8 直接读取一个字节的二进制\n- readInt8 读取 8 位有符号的二进制，所以有可能会发生溢出，溢出的算法之前已经提到了\n\n### 3.2 读取 16 位\n\n- readInt16BE\n- readInt16LE\n- readUInt16BE\n- readUInt16LE\n\n读取`两个字节`的有/无符号的整数\n\n- BE 代表大端字节序，高位在前，网络就是这种字节序\n- LE 代表小端字节序，低位在前\n\n![20230228202551](http://s3.airtlab.com/blog/20230228202551.png)\n\n```javascript\nconst buf = Buffer.from([0xff, 0x01, 0x08, 0x05]);\nconsole.log(buf);\n\nconsole.log(buf.readUInt16BE(0)); // 65281 = 15 * 16 * 16 * 16 + 15 * 16 * 16 + 1\n\n// 按照大端顺序读取（有符号）\n// => 1111 1111 0000 0001\n// => 1111 1110\n// => 1111 1111\nconsole.log(buf.readInt16BE(0)); // -255\n```\n\n```javascript\n{\n  const buf = Buffer.from([0x9f, 0xaf, 0x08, 0x05]);\n  console.log(buf);\n\n  // 9 * 16 * 16 * 16 + 15 * 16 * 16 + 10 * 16 + 15 = 40879\n  // 而16位有符号范围 -32768～32767\n  // 1001 1111 1010 1111 原码\n  // 0110 0000 0101 0000 反码\n  // 0110 0000 0110 0001 补码\n  // 6051 => 24657\n  console.log(buf.readInt16BE(0)); // -24657  这个数是怎么来的呢\n}\n```\n\n## 4.  写入缓冲区\n\n```javascript\nbuf.write(string[, offset[, length]][, encoding])\n// @param string - 写入缓冲区的字符串。\n// @param offset - 缓冲区开始写入的索引值，默认为 0 。\n// @param length - 写入的字节数，默认为 buffer.length\n// @param encoding - 使用的编码。默认为 'utf8' 。\n// @result 返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。\n```\n\n```javascript\nconst buf = Buffer.alloc(256);\nconst len = buf.write(\"www.runoob.com\");\nconsole.log(\"写入字节数 : \" + len);\nconsole.log(buf.toString(\"ascii\"));\n```\n\n## 5.  从缓冲区读取数据\n\n```javascript\nbuf.toString([encoding[, start[, end]]])\n// @param encoding - 使用的编码。默认为 'utf8' 。\n// @param start - 指定开始读取的索引位置，默认为 0。\n// @param end - 结束位置，默认为缓冲区的末尾。\n// @result 解码缓冲区数据并使用指定的编码返回字符串\n```\n\n```javascript\nbuf = Buffer.alloc(26);\nfor (var i = 0; i < 26; i++) {\n  buf[i] = i + 97;\n}\n\nconsole.log(buf.toString(\"ascii\")); // 输出: abcdefghijklmnopqrstuvwxyz\nconsole.log(buf.toString(\"ascii\", 0, 5)); // 输出: abcde\nconsole.log(buf.toString(\"utf8\", 0, 5)); // 输出: abcde\nconsole.log(buf.toString(undefined, 0, 5)); // 使用 'utf8' 编码, 并输出: abcde\n```\n\n## 6.  缓冲区合并\n\n```javascript\nvar buffer1 = Buffer.from(\"菜鸟教程\");\nvar buffer2 = Buffer.from(\"www.runoob.com\");\n\nvar buffer3 = Buffer.concat([buffer1, buffer2]);\nconsole.log(\"buffer3 内容: \" + buffer3.toString());\n```\n\n## 7. **TypedArray**\n\n> 一个 **_TypedArray_** 对象描述了底层[二进制数据缓冲区](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)的类数组视图，是所有 TypedArray 子类的通用父类。将 %TypedArray% 作为一个“抽象类”，\n\n```javascript\n// Create a TypedArray with a size in bytes\nconst typedArray1 = new Int8Array(8);\ntypedArray1[0] = 32;\n\nconst typedArray2 = new Int8Array(typedArray1);\ntypedArray2[1] = 42;\n\nconsole.log(typedArray1);\n// Expected output: Int8Array [32, 0, 0, 0, 0, 0, 0, 0]\n\nconsole.log(typedArray2);\n// Expected output: Int8Array [32, 42, 0, 0, 0, 0, 0, 0]\n```\n\n### TypeArray 列表\n\n| 类型                                                                                                                    | 值范围                                       | 字节大小 | 描述                                                      | Web IDL 类型        | 等价的 C 类型                 |\n| ----------------------------------------------------------------------------------------------------------------------- | -------------------------------------------- | -------- | --------------------------------------------------------- | ------------------- | ----------------------------- |\n| [Int8Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Int8Array)                 | -128 到 127                                  | 1        | 8 位有符号整型（补码）                                    | byte                | int8_t                        |\n| [Uint8Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array)               | 0 到 255                                     | 1        | 8 位无符号整型                                            | octet               | uint8_t                       |\n| [Uint8ClampedArray](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray) | 0 到 255                                     | 1        | 8 位无符号整型（一定在 0 到 255 之间）                    | octet               | uint8_t                       |\n| [Int16Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Int16Array)               | -32768 到 32767                              | 2        | 16 位有符号整型（补码）                                   | short               | int16_t                       |\n| [Uint16Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array)             | 0 到 65535                                   | 2        | 16 位无符号整型                                           | unsigned short      | uint16_t                      |\n| [Int32Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Int32Array)               | -2147483648 到 2147483647                    | 4        | 32 位有符号整型（补码）                                   | long                | int32_t                       |\n| [Uint32Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array)             | 0 到 4294967295                              | 4        | 32 位无符号整型                                           | unsigned long       | uint32_t                      |\n| [Float32Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Float32Array)           | -3.4E38 到 3.4E38 并且 1.2E-38 是最小的正数  | 4        | 32 位 IEEE 浮点数（7 位有效数字，例如 1.234567）          | unrestricted float  | float                         |\n| [Float64Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Float64Array)           | -1.8E308 到 1.8E308 并且 5E-324 是最小的正数 | 8        | 64 位 IEEE 浮点数（16 位有效数字，例如 1.23456789012345） | unrestricted double | double                        |\n| [BigInt64Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt64Array)         | -263 到 263 - 1                              | 8        | 64 位有符号整型（补码）                                   | bigint              | int64_t (signed long long)    |\n| [BigUint64Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigUint64Array)       | 0 到 264 - 1                                 | 8        | 64 位无符号整型                                           | bigint              | uint64_t (unsigned long long) |\n\n### 溢出规则\n\n```javascript\n{\n  // -128 到 127\n  const typedArray1 = new Int8Array(8);\n  typedArray1[0] = 128;\n\n  console.log(typedArray1); // ? 为什么是 -128\n  // Int8Array(8) [\n  //     -128, 0, 0, 0,\n  //        0, 0, 0, 0\n  //   ]\n}\n\n{\n  // -128 到 127\n  const typedArray1 = new Int8Array(8);\n  typedArray1[0] = 300;\n\n  console.log(typedArray1); // ? 为什么是44\n  // Int8Array(8) [\n  //     44, 0, 0, 0,\n  //        0, 0, 0, 0\n  //   ]\n}\n```\n","isLeaf":true},{"key":"/NodeJS/01 基础知识/08-buffer-array.md","path":"/NodeJS/01 基础知识/08-buffer-array.md","route":"/NodeJS/01 基础知识/08-buffer-array.md","leaf":true,"title":"08-buffer-array","depth":2,"content":"---\ntitle: 08 Buffer 数组\ntoc: true\ntags: NodeJS 基础\ncategories: NodeJS\n---\n\n目前笔者很少有使用到相关API，仅做了解。\n\n## 1. 二进制数组的由来\n为了满足 JavaScript 与显卡之间大量的、实时的数据交换，它们之间的数据通信必须是二进制的，而不能是传统的文本格式。文本格式传递一个32位整数，两端的 JavaScript 脚本与显卡都要进行格式转化，将非常耗时。这时要是存在一种机制，可以像 C 语言那样，直接操作字节，将4个字节的32位整数，以二进制形式原封不动地送入显卡，脚本的性能就会大幅提升。\n\n比如 WebGL 相关接口的调用。\n\n二进制数组主要有三个对象：\n- ArrayBuffer\n- TypedArray\n- DataView\n\n参考文章：\n- [JS操作内存？二进制数组了解一下](https://www.bilibili.com/read/cv4386302/)\n- [ArrayBuffer 介绍](https://wizardforcel.gitbooks.io/es6-tutorial-3e/content/docs/arraybuffer.html)","isLeaf":true},{"key":"/NodeJS/01 基础知识/09-nodejs-tracing.md","path":"/NodeJS/01 基础知识/09-nodejs-tracing.md","route":"/NodeJS/01 基础知识/09-nodejs-tracing.md","leaf":true,"title":"09-nodejs-tracing","depth":2,"content":"---\ntitle: 09 nodejs 链路追踪\ntoc: true\ntags: NodeJS 基础\ncategories: NodeJS\n---\n\n## 1、研究背景\n链路追踪是后台服务开发的一个很重要工具，它可以将所有的调用串联起来，形成一个有先后顺序的链路图。本文研究如何在 nodejs 中实现链路追踪。\n\n## 2、链路信息获取\n对于多线程语言如 Java 、 Python 来说，做全链路信息获取有线程上下文如 ThreadLocal 这种利器相助。而对于 Node.js 来说，由于单线程和基于IO回调的方式来完成异步操作，所以在全链路信息获取上存在天然获取难度大的问题。那么如何解决这个问题呢？\n\n## 3、业界方案\n由于 Node.js 单线程，非阻塞 IO 的设计思想。在全链路信息获取上，到目前为止，主要有以下 2 种方案：\n\n- 显式传递：手动传递、中间件挂载；\n- Async Hooks：node api；\n\n方案1显式传递过于繁琐和具有侵入性。<br />效果最好的方案就是第2种方案，这种方案有如下优点：\n\n- nodejs 原生支持的模块，具有可靠性性保证\n- 隐式的链路跟踪，入侵小，目前隐式跟踪的最优解；\n- 提供了 API 来追踪 node 中异步资源的生命周期；\n- 借助 async_hook 实现上下文的关联关系；\n\n## 4、Async Hooks\n### 4.1  Async Hooks 概念\nAsync Hooks 是 Node.js v8.x 版本新增加的一个核心模块，它提供了 API 用来追踪 Node.js 中异步资源的生命周期，可帮助我们正确追踪异步调用的处理逻辑及关系。\n\n### 4.2 Async Hooks 核心\n![image__1](http://s3.airtlab.com/blog/image__1.png)\n```typescript\nimport async_hooks from 'node:async_hooks';\n\n// Return the ID of the current execution context.\n// 返回当前异步资源的执行上下文 id\nconst eid = async_hooks.executionAsyncId();\n\n// Return the ID of the handle responsible for triggering the callback of the\n// current execution scope to call.\n// 返回当前异步资源执 execution scope 的 trigger ID\nconst tid = async_hooks.triggerAsyncId();\n\n// Create a new AsyncHook instance. All of these callbacks are optional.\n// 创建实例\nconst asyncHook =\n    async_hooks.createHook({ init, before, after, destroy, promiseResolve });\n\n// Allow callbacks of this AsyncHook instance to call. This is not an implicit\n// action after running the constructor, and must be explicitly run to begin\n// executing callbacks.\n// 启用\nasyncHook.enable();\n\n// Disable listening for new asynchronous events.\n// 禁用\nasyncHook.disable();\n\n//\n// The following are the callbacks that can be passed to createHook().\n//\n\n// init() is called during object construction. The resource may not have\n// completed construction when this callback runs. Therefore, all fields of the\n// resource referenced by \"asyncId\" may not have been populated.\n// 初始化(不一定完成)\nfunction init(asyncId, type, triggerAsyncId, resource) { }\n\n// before() is called just before the resource's callback is called. It can be\n// called 0-N times for handles (such as TCPWrap), and will be called exactly 1\n// time for requests (such as FSReqCallback).\nfunction before(asyncId) { }\n\n// after() is called just after the resource's callback has finished.\nfunction after(asyncId) { }\n\n// destroy() is called when the resource is destroyed.\nfunction destroy(asyncId) { }\n\n// promiseResolve() is called only for promise resources, when the\n// resolve() function passed to the Promise constructor is invoked\n// (either directly or through other means of resolving a promise).\nfunction promiseResolve(asyncId) { }\n```\n通过 async_hooks 钩子，我们可以探测异步资源执行的全生命周期，从 创建 -> 执行前 -> 执行后 -> 销毁。\n```javascript\nconst asyncHooks = require('async_hooks');\nconst fs = require('fs');\n\nconst hooks = asyncHooks.createHook({\n  init(asyncId, type, triggerAsyncId, resource) {\n    fs.writeFileSync(2, `init asyncId: ${asyncId}, type: ${type}, triggerAsyncId: ${triggerAsyncId}\\n`)\n  },\n  destroy (asyncId) {\n    fs.writeFileSync(2, `destroy: ${asyncId}\\n`)\n  },\n  before (asyncId) {\n    fs.writeFileSync(2, `before: ${asyncId}\\n`)\n  },\n  after (asyncId) {\n    fs.writeFileSync(2, `after: ${asyncId}\\n`)\n  }\n});\nhooks.enable();\n\nsetTimeout(() => {\n  setTimeout(() => {\n  })\n})\n```\n打印顺序如下：\n```javascript\ninit asyncId: 2, type: Timeout, triggerAsyncId: 1\nbefore: 2\ninit asyncId: 3, type: Timeout, triggerAsyncId: 2\nafter: 2\ndestroy: 2\nbefore: 3\nafter: 3\ndestroy: 3\n```\n\n### 4.3 AsyncResource 异步资源\nAsyncResource 用于创建异步资源 context，可以让很多个异步资源共享上下文。\n```typescript\nconst asyncHook = require(\"async_hooks\");\nconst fs = require(\"fs\");\nconst list = []\n\nasyncHook\n  .createHook({\n    init(asyncId, type, triggerAsyncId) {\n      const content = `asyncId: ${asyncId}, type: ${type}, triggerAsyncId: ${triggerAsyncId}`\n      fs.writeSync(1, content);\n      fs.writeSync(1, \"\\n\");\n    },\n  })\n  .enable();\n\nconst asyncResource = new asyncHook.AsyncResource(\"ZeroContext\");\nfs.writeSync(1, asyncResource.asyncId().toString());\nfs.writeSync(1, \"\\n\");\n\n// 在此异步资源的执行上下文中调用的函数\nasyncResource.runInAsyncScope(() => {\n  setTimeout(() => {})\n});\n\n// asyncId: 2, type: ZeroContext, triggerAsyncId: 1\n// 2\n// asyncId: 3, type: Timeout, triggerAsyncId: 2\n```\n```javascript\nconst http = require('http');\nconst { AsyncLocalStorage } = require('async_hooks');\n\nconst asyncLocalStorage = new AsyncLocalStorage();\n\nfunction logWithId(msg) {\n  const id = asyncLocalStorage.getStore();\n  console.log(`${id !== undefined ? id : '-'}:`, msg);\n}\n\nlet idSeq = 0;\n\nhttp.createServer((req, res) => {\n  // 每一个请求都有一个唯一的id\n  // 每一个请求的处理逻辑都放到 asyncLocalStorage.run 中，并且传入 id\n\n  asyncLocalStorage.run(idSeq++, () => {\n    logWithId('start');\n    setImmediate(() => {\n      logWithId('processing...');\n      setTimeout(() => {\n        logWithId('finish');\n        res.end(\"hello\");\n      }, 2000)\n    });\n  });\n}).listen(8080);\n```\n\n## 5、http-context 的实现\nhttp context 是指请求上下文，对于 server 来说，每一个请求都有独立的请求上下文。\n### 5.1 通过 hooks 实现\n简化后的代码，ns 对象有3个关键的属性: \n\n- active 当前的 context\n- _contexts context 和 asyncId 的映射\n- _set context 栈\n```javascript\nfunction Context() {\n  this._map = {};\n}\n\nContext.prototype.set = function (key, val) {\n  this._map[key] = val;\n};\n\nContext.prototype.get = function (key, val) {\n  return this._map[key];\n};\n\nconst ns = new Namespace();\nlet currentUid = -1;\n\nfunction createNamespace(name) {\n  let namespace = new Namespace(name);\n  namespace.id = currentUid;\n}\n\nconst hooks = asyncHooks.createHook({\n  // 当 int 被触发时说明，正在创建一个异步资源，\n  // 我们需要将该异步资源和当前的 context 关联起来\n  init(asyncId, type, triggerAsyncId, resource) {\n    currentUid = async_hooks.executionAsyncId();\n    if (namespace.active) {\n      namespace._contexts.set(asyncId, namespace.active);\n    } else if (currentUid === 0) {\n      const triggerId = async_hooks.triggerAsyncId();\n      const triggerIdContext = namespace._contexts.get(triggerId);\n      if (triggerIdContext) {\n        namespace._contexts.set(asyncId, triggerIdContext);\n      }\n    }\n  },\n  // 当 before 被调用时，说明马上要执行该异步资源的回调\n  // 我们需要更新该 active 为 _map[asyncId]\n  // 而且 push 到 context stack 中\n  before(asyncId) {\n    const context = this._map[asyncId];\n    ns.enter(context);\n  },\n  // 当 after 被调用时，说明马上要执行该异步资源的回调已经执行完毕\n  // 我们需要更新该 active 为 stack 中的倒数第二个\n  after(asyncId) {\n    const context = this._map[asyncId];\n    ns.exit(context);\n  },\n  // 异步资源销毁，释放资源\n  destroy(asyncId) {\n    ns._contexts[asyncId] = null;\n  },\n});\n\nhooks.enabled();\n\nfunction Namespace() {\n  this.active = null;\n  this._set = [];\n  this._contexts = new Map();\n}\n\nNamespace.prototype.run = function (fn) {\n  const context = new createContext();\n  this.enter(context);\n  fn(context);\n};\n\nNamespace.prototype.runPromise = function (fn) {\n  const context = new createContext();\n  const promise = this.enter(context);\n\n  return promise\n    .then((result) => {\n      this.exit(context);\n      return result;\n    })\n    .catch((err) => {\n      this.exit(context);\n      throw err;\n    });\n};\n\nNamespace.prototype.enter = function (context) {\n  this.active = context;\n  this.stack.push(this.active);\n};\n\nNamespace.prototype.exit = function (context) {\n  if (this.active === context) {\n    this.active = this._set.pop();\n    return;\n  }\n};\n\n// 提供 express middleware\nfunction contextMiddleware(req, res, next) {\n  ns.run(() => next());\n}\n```\n### 5.2 cls-hookd\n[npm cls]([https://www.npmjs.com/package/cls](https://www.npmjs.com/package/cls)) 的工作方式类似于 tls。[cls-hooked]([https://www.npmjs.com/package/cls-hooked](https://www.npmjs.com/package/cls-hooked)) 这个包从 cls fork 而来，cls-hooked 采用新的 api [async_hooks](https://link.juejin.cn/?target=https%3A%2F%2Fnodejs.org%2Fapi%2Fasync_hooks.html) 对核心逻辑进行了重写。\n### 5.3 express-http-context\n基于 cls-hookd 封装为 express 中间件的形式\n## 6、参考资料\n\n- VIVO 技术团队《 Node.js 应用全链路追踪技术》—— [全链路信息获取](https://mp.weixin.qq.com/s/SpC50ZqbKnKjlGBTSPMd9w?scene=25#wechat_redirect)","isLeaf":true},{"key":"/NodeJS/01 基础知识/10-how-to-crash-node.md","path":"/NodeJS/01 基础知识/10-how-to-crash-node.md","route":"/NodeJS/01 基础知识/10-how-to-crash-node.md","leaf":true,"title":"10-how-to-crash-node","depth":2,"content":"---\ntitle: 10 如何让 nodejs 程序 crash\ntoc: true\ntags: NodeJS 基础\ncategories: NodeJS\n---\n\n- 异常未被捕获\n- 内存溢出\n- 发送中断信号（CTRL + C）或停止进程来停止Node.js程序\n- 在代码中引入不存在的模块或文件","isLeaf":true},{"key":"/NodeJS/01 基础知识/11-amazing-stream.md","path":"/NodeJS/01 基础知识/11-amazing-stream.md","route":"/NodeJS/01 基础知识/11-amazing-stream.md","leaf":true,"title":"11-amazing-stream","depth":2,"content":"---\ntitle: 11 stream 的使用\ntoc: true\ntags: NodeJS 基础\ncategories: NodeJS\n---\n\n## 1、stream 介绍\n\nStream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对 http 服务器发起请求的 request 对象就是一个 Stream，还有 stdout（标准输出）。\n\n**Node.js Stream 有四种流类型**:\n- Readable - 可读操作。\n- Writable - 可写操作。\n- Duplex - 可读可写操作.\n- Transform - 操作被写入数据，然后读出结果。\n\n所有的 Stream 对象都是 EventEmitter 的实例。\n\n**常用的事件有**：\n- data - 当有数据可读时触发。\n- end - 没有更多的数据可读时触发。\n- error - 在接收和写入过程中发生错误时触发。\n- finish - 所有数据已被写入到底层系统时触发。\n\n## 2、stream 优势\n\n相对于使用其他的数据处理方法，流基本上提供了两个主要优点：\n- 内存效率: 无需加载大量的数据到内存中即可进行处理。\n- 时间效率: 当获得数据之后即可立即开始处理数据，这样所需的时间更少，而不必等到整个数据有效负载可用才开始\n\n## 3、内存占用测试\n\n```js\nconst fs = require(\"fs\");\nconst v8 = require(\"v8\");\n\nconst getData = (start) => {\n  const list = [];\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      const a = {};\n      a;\n      for (let i = 0; i < 50; i++) {\n        const index = start + i;\n        list.push({\n          name: \"姓名\" + index,\n          age: `${index}`,\n          content: `这是一个掩演示，哈哈哈 ${index}`,\n          name2: \"姓名\" + index,\n          age2: `${index}`,\n          content2: `这是一个掩演示，哈哈哈 ${index}`,\n          id: `大冰哥 ${index}`,\n          address: `深圳市 ${index}`,\n        });\n      }\n      resolve(list);\n    });\n  });\n};\n\nasync function testNormal() {\n  const list = [];\n  let i = 0;\n\n  // setInterval(() => {\n  //   console.log(v8.getHeapStatistics().used_heap_size);\n  // }, 2000);\n\n  while (i < 100 * 10000) {\n    const data = await getData(i);\n    list.push(...data);\n    i += 50;\n  }\n\n  console.log(\"case normal\", v8.getHeapStatistics().used_heap_size);\n\n  setTimeout(() => {\n    fs.writeFileSync(\"out.json\", JSON.stringify(list));\n  });\n}\n\nfunction write(stream, chunk) {\n  return new Promise((resolve) => {\n    stream.write(chunk, (err) => {\n      if (!err) {\n        resolve();\n      }\n    });\n  });\n}\n\nasync function testStream() {\n  const stream = fs.createWriteStream(\"stream.json\");\n\n  stream.on('drain', () => {\n    console.log(`drain`)\n  })\n\n  let i = 0;\n\n  setInterval(() => {\n    console.log(v8.getHeapStatistics().used_heap_size);\n  }, 2000);\n\n  while (i < 100 * 10000) {\n    const data = await getData(i);\n    await write(stream, JSON.stringify(data));\n    i += 50;\n  }\n\n  console.log(`case stream`);\n  console.log(v8.getHeapStatistics().used_heap_size);\n\n  setTimeout(() => {\n    stream.close();\n  });\n}\n\nasync function start() {\n  console.log(process.pid);\n  await testStream()\n  // setTimeout(() => {\n  //   testNormal();\n  // }, 1000)\n}\n\nstart()\n```\n\n通过对比发现，使用 stream 方式进行写文件时，内存占用比较稳定，而令另一种方式，内存会持续上升，直到文件写入完成。\n\n## 5、常见问题\n\n### 5.1 什么是 stream\n\nstream 是基于事件EventEmitter的数据管理模式．由各种不同的抽象接口组成，主要包括可写，可读，可读写，可转换等几种类型．\n\n### 5.2 stream 好处\n\n非阻塞式数据处理提升效率，片断处理节省内存，管道处理方便可扩展等.\n\n### 5.3 stream 典型应用\n\n文件，网络，数据转换，音频视频等.\n\n### 5.4 怎么捕获 stream 错误\n\n监听 error 事件，方法同 EventEmitter.\n\n### 5.5 有哪些常用 stream\n- Readable 为可被读流，在作为输入数据源时使用；\n- Writable 为可被写流,在作为输出源时使用；\n- Duplex 为可读写流,它作为输出源接受被写入，同时又作为输入源被后面的流读出．\n- Transform 机制和 Duplex 一样，都是双向流，区别是 Transform 只需要实现一个函数 `_transfrom(chunk, encoding, callback)` 而 Duplex 需要分别实现`_read(size)` 函数和 `_write(chunk, encoding, callback)` 函数。\n\n### 5.6 实现一个 writable stream\n\n三步走:\n- 1) 构造函数 call Writable \n- 2) 继承 Writable\n- 3) 实现 `_write(chunk, encoding, callback)` 函数\n\n```js\nvar Writable = require('stream').Writable;\nvar util = require('util');\n\nfunction MyWritable(options) {\n\tWritable.call(this, options);\n}\n\nutil.inherits(MyWritable, Writable); // 继承自Writable\n\nMyWritable.prototype._write = function(chunk, encoding, callback) {\n\tconsole.log(\"被写入的数据是:\", chunk.toString()); // 此处可对写入的数据进行处理\n\tcallback();\n};\n\nprocess.stdin.pipe(new MyWritable()); // stdin作为输入源，MyWritable作为输出源   \n```\n\n## 6、参考文档\n\n- [深入理解 Node Stream 内部机制](https://www.barretlee.com/blog/2017/06/06/dive-to-nodejs-at-stream-module/)\n- [想学Node.js，stream先有必要搞清楚](https://juejin.cn/post/6844903891083984910)\n- [可写流 - nodejs stream总结](https://www.cnblogs.com/walkermag/p/13579990.html)","isLeaf":true},{"key":"/NodeJS/01 基础知识/12-event-loop.md","path":"/NodeJS/01 基础知识/12-event-loop.md","route":"/NodeJS/01 基础知识/12-event-loop.md","leaf":true,"title":"12-event-loop","depth":2,"content":"---\ntitle: 12 事件循环\ntoc: true\ntags: NodeJS 基础\ncategories: NodeJS\n---\n\n- 大循环宏任务\n- 小循环微任务","isLeaf":true},{"key":"/NodeJS/01 基础知识/13-settimeout.md","path":"/NodeJS/01 基础知识/13-settimeout.md","route":"/NodeJS/01 基础知识/13-settimeout.md","leaf":true,"title":"13-settimeout","depth":2,"content":"---\ntitle: 13 setTimeout 实现原理\ntoc: true\ntags: NodeJS 基础\ncategories: NodeJS\n---\n\n不同的 Runtime 实现机制不一样，`setTimeout` 并不是 ECMA 的 API，而是 Web API，所以 V8 这类 JavaScript 引擎是不会帮你实现的，需要在 Runtime 中自行实现。 \n\n- [`死月` 和 `王译锋` 回答](https://www.zhihu.com/question/463446982/answer/1927497540)\n- [深入Linux C/C++ Timer定时器的实现核心原理](https://cloud.tencent.com/developer/article/1763594)","isLeaf":true},{"key":"/NodeJS/01 基础知识/14-max-old-space-size.md","path":"/NodeJS/01 基础知识/14-max-old-space-size.md","route":"/NodeJS/01 基础知识/14-max-old-space-size.md","leaf":true,"title":"14-max-old-space-size","depth":2,"content":"---\ntitle: 14 设置 max-old-space-size\ntoc: true\ntags: NodeJS 基础\ncategories: NodeJS\n---\n\n设置 V8 旧生代内存部分的最大内存大小。 随着内存消耗接近极限，V8 会花更多的时间在垃圾回收上，以释放未使用的内存。\n\ntest.js\n```js\nconst v8 = require('v8');\nconsole.log(v8.getHeapStatistics())\n```\n\n当前的测试宿主机为 MacPro 2019 16G 内存。\n\n当执行 `node test.js`\n```json\n{\n  total_heap_size: 4984832,\n  total_heap_size_executable: 524288,\n  total_physical_size: 3947728,\n  total_available_size: 4342033176,\n  used_heap_size: 4170336,\n  heap_size_limit: 4345298944,\n  malloced_memory: 254120,\n  peak_malloced_memory: 90624,\n  does_zap_garbage: 0,\n  number_of_native_contexts: 1,\n  number_of_detached_contexts: 0,\n  total_global_handles_size: 8192,\n  used_global_handles_size: 3200,\n  external_memory: 321551\n}\n```\n\n当执行 `NODE_OPTIONS=--max-old-space-size=6144 node ./test.js`\n```json\n{\n  total_heap_size: 4984832,\n  total_heap_size_executable: 524288,\n  total_physical_size: 3913440,\n  total_available_size: 6489516800,\n  used_heap_size: 4170368,\n  heap_size_limit: 6492782592,\n  malloced_memory: 254120,\n  peak_malloced_memory: 221520,\n  does_zap_garbage: 0,\n  number_of_native_contexts: 1,\n  number_of_detached_contexts: 0,\n  total_global_handles_size: 8192,\n  used_global_handles_size: 3200,\n  external_memory: 321551\n}\n```\n\n其中 total_available_size 已经被修改。","isLeaf":true},{"key":"/NodeJS/01 基础知识/15-heapsnapshot.md","path":"/NodeJS/01 基础知识/15-heapsnapshot.md","route":"/NodeJS/01 基础知识/15-heapsnapshot.md","leaf":true,"title":"15-heapsnapshot","depth":2,"content":"---\ntitle: 15 v8 内存快照文件分析\ntoc: true\ntags: NodeJS 基础\ncategories: NodeJS\n---\n\n- https://segmentfault.com/a/1190000039650874?sort=newest\n- https://zhengrenzhe.com/posts/v8-snapshot/","isLeaf":true},{"key":"/NodeJS/01 基础知识/16-node-monitor.md","path":"/NodeJS/01 基础知识/16-node-monitor.md","route":"/NodeJS/01 基础知识/16-node-monitor.md","leaf":true,"title":"16-node-monitor","depth":2,"content":"---\ntitle: 16 nodejs 应用监控\ntoc: true\ntags: NodeJS 基础\ncategories: NodeJS\n---\n\n- [alinode](https://www.aliyun.com/product/nodejs)","isLeaf":true},{"key":"/NodeJS/01 基础知识/17-watch-file-change.md","path":"/NodeJS/01 基础知识/17-watch-file-change.md","route":"/NodeJS/01 基础知识/17-watch-file-change.md","leaf":true,"title":"17-watch-file-change","depth":2,"content":"---\ntitle: 17 监听文件变化\ntoc: true\ntags: NodeJS 基础\ncategories: NodeJS\n---\n\n- [node.js监听文件变化](https://juejin.cn/post/6844903824738500622)\n- chokidar 的使用\n- nodemon 原理等\n- watchdog 的使用\n","isLeaf":true},{"key":"/NodeJS/01 基础知识/18-restart-node-app.md","path":"/NodeJS/01 基础知识/18-restart-node-app.md","route":"/NodeJS/01 基础知识/18-restart-node-app.md","leaf":true,"title":"18-restart-node-app","depth":2,"content":"---\ntitle: 18 如何重启服务\ntoc: true\ntags: NodeJS 基础\ncategories: NodeJS\n---\n\n当 node 进程挂了，如何自动重启？supervisor nodemon 等重启原理。。\n\n在 Node.js 应用运行时，可以通过一些第三方的 Node.js 模块或者工具来实现应用挂了之后自动重。\n\n## 1. PM2\nPM2（process manager 2）是一个开源的 Node.js 进程管理器，它可以启动、停止、重启和监视 Node.js 应用。PM2 可以自动监控应用程序的运行状态，并且在应用程序退出或奔溃时自动重启。使用 PM2 启动应用程序后，可以使用一些基本的命令来管理应用程序，例如：\n\n```\npm2 start /path/to/app.js       // 启动应用程序\npm2 stop app                    // 停止应用程序\npm2 restart app                 // 重启应用程序\npm2 list                        // 列出当前运行的所有应用程序\n```\n\n## 2. Forever\nForever 是一个简单的命令行工具，它可以启动和管理 Node.js 应用程序，类似于 PM2。使用 Forever 启动应用程序后，Forever 会监视应用程序的运行状态，当应用程序奔溃时会自动重启应用程序。Forever 的命令行使用方式如下：\n\n```\nforever start /path/to/app.js   // 启动应用程序\nforever stop app                // 停止应用程序\nforever restart app             // 重启应用程序\nforever list                    // 列出当前运行的所有应用程序\n```\n\n总之，使用这些工具，可以方便地实现应用挂了之后自动重启的功能，减少应用程序奔溃对业务造成的影响。\n\n如果您不想使用第三方库，也可以编写一些代码来实现自动重启的功能。下面介绍两种方法。\n\n## 3. 增加监控程序\n1. 使用 child_process 模块启动子进程，并监听其 exit 事件。如果子进程退出，就重新启动新的子进程。示例代码如下：\n\n```\nconst { spawn } = require('child_process');\n\nfunction startApp() {\n  const app = spawn('node', ['/path/to/app.js']);\n\n  app.stdout.on('data', (data) => {\n    console.log(`stdout: ${data}`);\n  });\n\n  app.stderr.on('data', (data) => {\n    console.error(`stderr: ${data}`);\n  });\n\n  app.on('exit', (code) => {\n    console.log(`child process exited with code ${code}`);\n    setTimeout(startApp, 5000); // 重新启动子进程\n  });\n}\n\nstartApp();\n```\n\n2. 使用 try-catch 装饰器来捕获应用程序中的异常，并进行重启操作。示例代码如下：\n\n```\nfunction restartOnCrash(target) {\n  const originalMethod = target.prototype.run;\n\n  target.prototype.run = function() {\n    try {\n      originalMethod.apply(this, arguments);\n    } catch (err) {\n      console.error(`application crashed: ${err}`);\n      setTimeout(() => {\n        console.log(`restarting application...`);\n        this.run();\n      }, 5000);\n    }\n  };\n}\n\nclass MyApp {\n  run() {\n    // your application code goes here\n  }\n}\n\nrestartOnCrash(MyApp);\nconst app = new MyApp();\napp.run();\n```\n\n这里使用了装饰器 `restartOnCrash` 对 `MyApp` 类中的 `run` 方法进行装饰，当 `run` 方法中抛出异常时，会在 5 秒钟后重新调用 `run` 方法。\n","isLeaf":true},{"key":"/NodeJS/01 基础知识/19-cross-spawn.md","path":"/NodeJS/01 基础知识/19-cross-spawn.md","route":"/NodeJS/01 基础知识/19-cross-spawn.md","leaf":true,"title":"19-cross-spawn","depth":2,"content":"---\ntitle: 19 cross-spawn 跨平台进程\ntoc: true\ntags: NodeJS 基础\ncategories: NodeJS\n---\n\nnpm cross-spawn 是一个 Node.js 模块，主要用于在跨平台环境中，安全地运行 shell 命令和子进程。\n在 Windows 和 Linux 等操作系统上，shell 命令和子进程的实现方式可能存在差异，例如 Windows 下的子进程可能需要使用 cmd.exe 来执行，而 Linux 下的子进程则需要使用 sh。\n\n这就会导致在跨平台开发中，使用 child_process 模块执行 shell 命令和子进程时，可能会出现一些兼容性问题。\n\n而 npm cross-spawn 利用了 Node.js 的 child_process 模块，提供了一个跨平台的解决方案，可以在不同的平台上安全地执行 shell 命令和子进程，并且能够自动识别当前所处的操作系统环境，从而选择正确的实现方式。这样可以有效避免因不同平台实现方式差异而导致的问题，提高跨平台开发的效率和可靠性。\n\n\n```js\nconst args = process.argv.slice(2);\n\nconst scriptIndex = args.findIndex(\n  (x) => x === \"build\" || x === \"eject\" || x === \"start\" || x === \"test\"\n);\nconst script = scriptIndex === -1 ? args[0] : args[scriptIndex];\nconst nodeArgs = scriptIndex > 0 ? args.slice(0, scriptIndex) : [];\n\nconst result = spawn.sync(\n    process.execPath, // node path\n    nodeArgs\n      .concat(require.resolve(\"../lib/\" + script))\n      .concat(args.slice(scriptIndex + 1)),\n    { stdio: \"inherit\" }\n  );\nconsole.log(result)\n```\n\n```js\n// work\nprocess.exit(10)\n```\n\n\n```json\n{\n  status: 10,\n  signal: null,\n  output: [ null, null, null ],\n  pid: 43229,\n  stdout: null,\n  stderr: null,\n  error: null\n}\n```\n","isLeaf":true},{"key":"/NodeJS/01 基础知识/20-linux-signal.md","path":"/NodeJS/01 基础知识/20-linux-signal.md","route":"/NodeJS/01 基础知识/20-linux-signal.md","leaf":true,"title":"20-linux-signal","depth":2,"content":"---\ntitle: 20 linux 进程信号\ntoc: true\ntags: NodeJS 基础\ncategories: NodeJS\n---\n\n- 参考 http://gityuan.com/2015/12/20/signal/\n- https://blog.csdn.net/xiaobai_hellow/article/details/124673131\n\n\n## 1、linux 信号\n```bash\n[root@localhost test6]# kill -l\n```\n\n```text\n\n 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL\n\n 5) SIGTRAP      6) SIGABRT      7) SIGBUS       8) SIGFPE\n\n 9) SIGKILL     10) SIGUSR1     11) SIGSEGV     12) SIGUSR2\n\n13) SIGPIPE     14) SIGALRM     15) SIGTERM     16) SIGSTKFLT\n\n17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP\n\n21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU\n\n25) SIGXFSZ     26) SIGVTALRM   27) SIGPROF     28) SIGWINCH\n\n29) SIGIO       30) SIGPWR      31) SIGSYS      34) SIGRTMIN\n\n35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3  38) SIGRTMIN+4\n\n39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8\n\n43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12\n\n47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14\n\n51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10\n\n55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7  58) SIGRTMAX-6\n\n59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2\n\n63) SIGRTMAX-1  64) SIGRTMAX\n```\n\n只有第9种信号 (SIGKILL) 才可以无条件终止进程，其他信号进程都有权利忽略。下面是常用的信号：\n\n```text\nHUP　　1    终端断线\n\nINT　　2    中断（同 Ctrl+C）\n\nQUIT　 3    退出（同 Ctrl+\\）\n\nTERM   15   终止\n\nKILL   9    强制终止\n\nCONT   18   继续（与STOP相反， fg/bg命令）\n\nSTOP   19   暂停（同 Ctrl+Z）\n```\n\n## 2、演示给 node 进程发送信号\n\n```js\nconst http = require(\"http\");\nconsole.log(process.pid)\n\nconst server = http.createServer((req, res) => {\n  res.end('hello')\n});\n\nserver.listen(3002, () => {\n  console.log(\"服务启动成功\");\n});\n\nprocess.on('exit', function (code) {\n  // TODO 这里可以主动释放其他资源 如zookeeper连接等\n  console.log(`exit-------------------------`);\n\n  if (code === 1000) {\n    console.error('process:uncaughtException');\n  } else if (code === 1001) {\n    console.error('process:SIGINT');\n  } else if (code === 1002) {\n    console.error('process:SIGTERM');\n  } else {\n    console.error('process:unknown');\n  }\n});\n\nprocess.on('uncaughtException', function (e) {\n  console.log(`uncaughtException`, e);\n  // 异常可以选择不退出\n  process.exit(1000);\n});\n\nprocess.on('SIGINT', function () {\n  console.log(`SIGINT`);\n  process.exit(1001);\n});\n\nprocess.on('SIGTERM', function () {\n  console.log(`SIGTERM`);\n  process.exit(1002);\n});\n\nprocess.on('SIGHUP', () => {\n  console.log(`SIGHUP`);\n  console.log('接收到退出指令');\n});\n```\n\n假设进程 id 为 44525，执行：\n\n```shell\nkill -s SIGINTS 44525\n```\n\n会打印\n\n```text\nSIGINT\nexit-------------------------\nprocess:SIGINT\n```\n\n## 3、Node.js 捕获 Ctrl+C\nNode 支持信号事件，要捕获 Ctrl+C ，只要注册SIGINT信号事件就可以捕获 Ctrl+C。需要注意的是SIGINT信号事件被注册后，在终端按下 Ctrl+C 就没法终止程序了，所以在事件回调函数内必须调用process.exit() 函数终止程序。\n\n```js\nprocess.on('SIGINT', function () {\n    console.log('Exit now!');\n    process.exit();\n});\n```\n\n如果在退出之前需要做一些后续的处理，那么可以将 process.exit() 放在其它回调函数内调用。\n\n```js\nprocess.on('SIGINT', function () {\n    console.log('Exit now!');\n    port.write('ddd', function (){\n        process.exit();\n    });\n});\n```\n\n## 4、关于 kill 命令\nhttps://www.cnblogs.com/heracles-lau/articles/3392029.html\n","isLeaf":true},{"key":"/NodeJS/01 基础知识/21-nodejs-module.md","path":"/NodeJS/01 基础知识/21-nodejs-module.md","route":"/NodeJS/01 基础知识/21-nodejs-module.md","leaf":true,"title":"21-nodejs-module","depth":2,"content":"---\ntitle: 21 nodejs 模块机制\ntoc: true\ntags: NodeJS 基础\ncategories: NodeJS\n---\n\n- nodejs 模块机制 https://juejin.cn/post/6844903951742025736\n","isLeaf":true},{"key":"/NodeJS/01 基础知识/22-crypto.md","path":"/NodeJS/01 基础知识/22-crypto.md","route":"/NodeJS/01 基础知识/22-crypto.md","leaf":true,"title":"22-crypto","depth":2,"content":"---\ntitle: 22 加密相关\ntoc: true\ntags: NodeJS 基础\ncategories: NodeJS\n---\n\n## aes 演示\n\nNode.js内置了加密模块，该模块提供了各种加密和解密算法，如AES（高级加密标准）和DES（数据加密标准）等。\n下面是一些常用的加密和解密方法：\n\n- crypto.createHash(algorithm): 创建一个散列对象，该对象可用于生成一个加密的哈希值，其中的“algorithm”参数是散列算法的名称，如“sha256”，“sha512”等。\n\n- crypto.createCipheriv(algorithm, key, iv): 创建一个加密算法的对象，其中的“algorithm”参数是加密算法的名称，如“AES-128-CBC”或“DES-EDE3-CBC”，“key”参数是加密密钥，iv参数是初始化向量。\n\n- cipher.update(data, input_encoding, output_encoding): 使用输入编码（如果给出）和输出编码（如果给出）更新加密。\n\n- cipher.final(output_encoding): 返回加密的结果，并且关闭加密器。\n\n\n例如，AES加密可以使用以下代码：\n\n```javascript\nconst crypto = require('crypto');\n\nconst algorithm = 'aes-256-cbc';\nconst key = 'mysecretkey';\nconst iv = crypto.randomBytes(16);\nconst message = 'secret message';\n\nconst cipher = crypto.createCipheriv(algorithm, key, iv);\nlet encrypted = cipher.update(message, 'utf8', 'hex');\nencrypted += cipher.final('hex');\n\nconsole.log('Encrypted message:', encrypted);\n```\n\n在上面的示例代码中，我们使用AES-256-CBC加密算法，将密钥设置为“mysecretkey”，使用随机生成的16字节IV，并且我们将明文消息设置为“secret message”。通过 `crypto.createCipheriv()` 方法创建加密算法对象，然后使用 `cipher.update()` 来加密消息，并使用 `cipher.final()`来对消息进行最终加密。\n\n## md5 演示\n\n在Node.js中，也可以使用`crypto`模块来计算MD5散列值。下面是使用Node.js的代码示例，演示如何使用`crypto`模块计算字符串的MD5散列值：\n```javascript\nconst crypto = require('crypto');\n\nconst message = '需要加密的字符串';\nconst hash = crypto.createHash('md5').update(message).digest('hex');\n\nconsole.log('MD5加密后的字符串为：', hash);\n```\n\n在这个示例中，我们首先将要加密的字符串存储在变量`message`中。然后，我们使用`createHash()`方法创建一个MD5 hash对象，并使用`update()`方法将输入字符串添加到对象中。最后，我们使用`digest()`方法获得计算出的16进制字符串，它表示了输入字符串的MD5散列值。最后，使用`console.log()`语句输出计算后的散列值。\n\n需要注意的是，MD5虽然是一种常见的散列函数，但其安全性已经被攻击，因此建议使用更安全的散列函数，例如SHA-2系列的函数。\n","isLeaf":true},{"key":"/NodeJS/01 基础知识/23-V8-GC.md","path":"/NodeJS/01 基础知识/23-V8-GC.md","route":"/NodeJS/01 基础知识/23-V8-GC.md","leaf":true,"title":"23-V8-GC","depth":2,"content":"---\ntitle: 23 V8 垃圾回收\ntoc: true\ntags: NodeJS 基础\ncategories: NodeJS\n---\n","isLeaf":true},{"key":"/NodeJS/01 基础知识/24-libuv.md","path":"/NodeJS/01 基础知识/24-libuv.md","route":"/NodeJS/01 基础知识/24-libuv.md","leaf":true,"title":"24-libuv","depth":2,"content":"---\ntitle: 24 libuv\ntoc: true\ntags: NodeJS 基础\ncategories: NodeJS\n---\n\n- https://musicfe.com/libuv/\n- https://zhuanlan.zhihu.com/p/50497450\n\n## libuv 的核心\n\nlibuv为什么可以这么高效呢？实际他使用了操作系统提供的高并发异步模型：\n- linux: epoll\n- freebsd: kqueue\n- windows: iocp\n\n每个我们常见的操作系统都为我们封装了类似的高并发异步模型，那libuv其实就是对各个操作系统进行封装，最后暴露出统一的api供开发者调用，开发者不需要关系底层是什么操作系统，什么API了。 我们来看一下同步模型和异步模型的区别\n\n\n![image](https://user-images.githubusercontent.com/34447750/230695916-e4c2dcef-62ce-432d-9fa0-d3ed667eabbd.png)\n","isLeaf":true},{"key":"/NodeJS/01 基础知识/25-mvc.md","path":"/NodeJS/01 基础知识/25-mvc.md","route":"/NodeJS/01 基础知识/25-mvc.md","leaf":true,"title":"25-mvc","depth":2,"content":"---\ntitle: 25 nodejs mvc 实现\ntoc: true\ntags: NodeJS 基础\ncategories: NodeJS\n---\n\n## 1、mvc 介绍\n\nMVC是一种软件设计架构，它将应用程序按照模型（Model）、视图（View）和控制器（Controller）的角色分成三个部分。\nMVC框架可以帮助开发人员更轻松地构建和维护Web应用程序，并提高应用程序的可扩展性和可重用性。下面是MVC框架的一些关键特征：\n- 模型（Model）处理数据和数据操作，包括数据的获取、存储和验证等。\n- 视图（View）显示数据，通常是HTML页面或者是其他UI组件。\n- 控制器（Controller）处理业务逻辑和用户输入，例如响应用户的请求并将请求转发给合适的模型和视图。\n\nMVC框架将应用程序分为三个独立的模块，使开发更加模块化和易于组织。MVC还可以提高代码的复用程度，因为模型和视图通常可以在多个控制器之间共享。因此，MVC是Web应用程序开发中广泛使用的一种架构。常见的MVC框架包括Spring MVC、ASP.NET MVC、Ruby on Rails等。\n\n## 2、mvc 不是完整的框架\n\nMVC是一种常见的软件架构模式，但是它不是一个完整的应用程序设计或框架，而只是一种在应用程序中组织代码的方法。MVC中的架构模式是模型（Model）、视图（View）和控制器（Controller）的缩写，其中视图和控制器都是属于应用程序的界面和交互层。\n在MVC的设计中，通常不需要服务层来处理具体的业务逻辑，而应该将业务逻辑放在控制器中处理。控制器作为连接模型和视图的中介，可以处理用户的请求并根据需要从模型中获取数据，再把数据传递给视图进行呈现。如果需要对数据进行一些逻辑操作，可以直接在控制器层面进行处理，而不需要引入额外的服务层。\n\n当然，在某些MVC实现中，服务层或业务层可能会被用来处理更复杂的业务逻辑，特别是当控制器和模型非常庞大时。但是，这并不是MVC的强制性要求，而是一种设计选择。\n\n相比之下，NestJS 是一个后端开发框架，它在MVC设计之上为开发者提供了便捷的模块化和服务化。在 NestJS的设计中，服务层是用来处理业务逻辑的，控制器层只负责处理HTTP请求并将请求传递给服务层处理并返回请求的响应。因此，NestJS的设计需要引入服务层来分离业务逻辑和控制器，实现业务逻辑的可重用性并使代码更加清晰易懂。\n\n## 3、nodejs mvc\n\n使用Node.js和Express框架的简单MVC框架。下面是主要的代码和文件：\n首先，我们需要在项目中安装 Express：\n\n```\nnpm install express\n```\n\n然后，创建一个server.js文件，用来启动服务器并设置路由：\n\n```javascript\nconst express = require('express');\nconst app = express();\n\n// 设置路由\napp.get('/', function(req, res){\n  res.send('Hello World!');\n});\n\napp.listen(3000, function(){\n  console.log('Server started on port 3000...');\n});\n```\n\n这段代码启动一个服务器，并在根URL上返回 \"Hello World!\" 字符串。\n\n接下来，创建一个目录结构，用来容纳我们的MVC框架：\n\n```\n- app/\n  - controllers/\n    - homeController.js\n  - models/\n    - homeModel.js\n  - views/\n    - homeView.ejs\n  - routes.js\n- server.js\n```\n\n在MVC框架中，代码被分成三层：模型、视图和控制器。\n\n- 模型层负责处理数据和数据操作（CRUD）。\n- 视图层负责显示数据。\n- 控制器层负责接收和处理用户请求，并将请求转发给适当的模型和视图。\n\n接下来，我们来实现这三个层的代码：\n\n### 模型层\n\n打开homeModel.js文件，加入以下代码：\n\n```javascript\nclass HomeModel {\n  constructor() {\n    this.data = {\n      name: \"John\",\n      age: 30,\n      email: \"john@example.com\"\n    };\n  }\n\n  getData() {\n    return this.data;\n  }\n}\n\nmodule.exports = HomeModel;\n```\n\n这是一个简单的模型类，它只是返回一些硬编码的数据。\n\n### 视图层\n\n我们使用EJS（Embedded JavaScript）模板引擎来实现我们的视图。\n\n打开homeView.ejs文件，并加入以下代码：\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <title>Home Page</title>\n</head>\n<body>\n  <h1>Welcome <%= name %>!</h1>\n  <p>You are <%= age %> years old.</p>\n  <p>Your email address is <%= email %>.</p>\n</body>\n</html>\n```\n\n这个模板使用了EJS的嵌入式Javascript语法，它将在渲染视图时被动态替换为数据。\n\n### 控制器层\n\n打开homeController.js文件，并加入以下代码：\n\n```javascript\nconst HomeModel = require('../models/homeModel');\n\nclass HomeController {\n  constructor() {\n    this.homeModel = new HomeModel();\n  }\n\n  index(req, res) {\n    let data = this.homeModel.getData();\n    res.render('homeView', data);\n  }\n}\n\nmodule.exports = HomeController;\n```\n\n这个控制器将接收请求并调用模型对象，然后将模型数据传递给视图进行呈现。\n\n### service\n增加 service 文件夹，增加：\n- home.service.js\n- user.service.js\n\n简化 Controller 代码，抽离到 Service 中 \n\n### 路由\n\n打开routes.js文件，并加入以下代码：\n\n```javascript\nconst express = require('express');\nconst router = express.Router();\nconst HomeController = require('./controllers/homeController');\n\nconst homeController = new HomeController();\n\nrouter.get('/', homeController.index.bind(homeController));\n\nmodule.exports = router;\n```\n\n这个路由文件建立路由，并将请求传递到HomeController的index方法。\n\n### 启动服务器\n\n最后，在server.js文件中加入以下代码：\n\n```javascript\nconst express = require('express');\nconst app = express();\nconst router = require('./app/routes');\n\n// 设置路由\napp.use('/', router);\n\napp.set('view engine', 'ejs');\napp.set('views', __dirname + '/app/views');\n\napp.listen(3000, function(){\n  console.log('Server started on port 3000...');\n});\n```\n\n这个文件启动服务器并设置路由，同时指定视图渲染引擎为EJS。\n\n现在，运行下面的命令启动服务器：\n\n```\nnode server.js\n```\n\n现在，在浏览器中访问 http://localhost:3000/，你应该可以看到一个简单的欢迎页面。恭喜，你已经写了一个使用 Node.js 和 Express 的简单的 MVC 框架！\n\n### 约定式自动加载\n按照约定\n- service 目录下每个文件导出一个 Service\n- controller 目录下每个文件导出一个 Controller\n- model 目录下每个文件导出一个 Model\n\n假设程序入口为 main.js，在 main.js 中，使用 fs 遍历文件夹，再 require 每个文件，挂载到对应的 `ctx.controller` `ctx.service`  `ctx.model`，使用时不需要再导入，可以直接引用 ctx。 \n\n## 4、软件架构的层级划分\n- 粗划分\n  - Model\n  - View\n  - Controller\n- 细划分\n  - Model\n  - View\n  - Controller\n  - Service\n  - Validation","isLeaf":true},{"key":"/NodeJS/01 基础知识/26-ejs.md","path":"/NodeJS/01 基础知识/26-ejs.md","route":"/NodeJS/01 基础知识/26-ejs.md","leaf":true,"title":"26-ejs","depth":2,"content":"---\ntitle: 26 ejs 模板引擎\ntags: NodeJS 基础\ncategories: NodeJS\n---\n\n- 官方文档 https://ejs.co/#install\n\n## 1、ejs 模板函数\n\n可以在 EJS 模板中编写 JavaScript 函数。 在 EJS 中，可以像在 JavaScript 代码中一样定义并执行函数。 可以在 EJS 模板的代码块中定义函数，然后在模板中使用它们。\n以下是使用 EJS 编写函数的示例：\n\n```html\n<% function greet(name) {\n    return \"Hello \" + name;\n} %>\n\n<p><%= greet(\"John\") %></p>\n```\n\n在上面的示例中，我们定义了一个名为“greet”的函数，它接受一个参数“name”并返回“Hello”加上给定名称的字符串。 然后，我们在模板中使用了 greet 函数，并传递“John”作为参数。 我们使用<%= %>标记来呈现函数返回的值。\n\n请注意，函数应该在对它们进行调用之前定义，以便 EJS 能够正确解析它们。\n\n## 2、模板引用\n\n```\n- views\n  - header.ejs\n  - footer.ejs\n- main.js\n```\n\n```js\nlet ejs = require(\"ejs\");\nlet path = require(\"path\");\n\nconst tpl = `\n<%- include(\"/views/header\"); %>\n\n<%- include(\"/views/footer\"); %>\n`;\n\nvar html = ejs.render(tpl, null, {\n  root: path.resolve(__dirname),\n});\n\nconsole.log(html);\n\n```\n\n## 3、ejs 递归渲染\n\n### 实现方式 1\n\n`./user/item`\n\n```html\n<li class=\"item\">\n  <div class=\"title\"><%= user.title %></div>\n  <% if (user.children && user.children.length) { %> <%- include('/user/list',\n  {users: user.children}); %> <% } %>\n</li>\n```\n\n`./user/list`\n\n```html\n<ul class=\"list\">\n  <% users.forEach(function(user){ %> <%- include('/user/item', {user: user});\n  %> <% }); %>\n</ul>\n```\n\n`./entry.js`\n\n```js\nlet ejs = require(\"ejs\");\nlet path = require(\"path\");\nlet fs = require(\"fs\");\n\nvar html = ejs.render(\n  fs.readFileSync(\"./user/list.ejs\", \"utf8\"),\n  {\n    users: [\n      {\n        title: \"B\",\n        children: [\n          {\n            title: \"B1\",\n          },\n          {\n            title: \"B2\",\n          },\n        ],\n      },\n      {\n        title: \"CC\",\n      },\n    ],\n  },\n  {\n    root: path.resolve(__dirname),\n  }\n);\n\nfs.writeFileSync(\"out/03.html\", html);\n```\n\n### 实现方式 2\n\n```js\nlet ejs = require(\"ejs\");\nlet path = require(\"path\");\nlet fs = require(\"fs\");\n\nconst tpl = `\n<% function renderTree(node) {\n  %>\n  <ul>\n      <li><%= node.name %></li>\n      <% if(node.children && node.children.length) {\n          node.children.forEach(child => {\n              %> \n              <li><%= renderTree(child) %></li>\n              <%})\n          }\n      %>\n  </ul>\n  <%\n} %>\n\n<%= renderTree(rootNode) %>\n`;\n\nvar html = ejs.render(\n  tpl,\n  {\n    rootNode: {\n      name: \"AA\",\n      children: [\n        {\n          name: \"BB\",\n        },\n        {\n          name: \"CC\",\n        },\n      ],\n    },\n  },\n  {\n    root: path.resolve(__dirname),\n  }\n);\n\nfs.writeFileSync(\"out/04.html\", html);\n```\n","isLeaf":true}]},{"key":"/NodeJS/02 expressjs","path":"/NodeJS/02 expressjs","route":"/NodeJS/02 expressjs","leaf":false,"title":"02 expressjs","depth":1,"content":"","isLeaf":false,"children":[{"key":"/NodeJS/02 expressjs/01-design.md","path":"/NodeJS/02 expressjs/01-design.md","route":"/NodeJS/02 expressjs/01-design.md","leaf":true,"title":"01-design","depth":2,"content":"---\ntitle: 01 整体介绍\ntoc: true\ntags: ExpressJS\ncategories: NodeJS\n---\n\n## 1、初识 express\n[express.js](https://link.juejin.cn/?target=https%3A%2F%2Fwww.expressjs.com.cn%2F) 是一款基于 Node.js 平台，极简的 Web 开发框架。本文将基于 4.18.2 版本，详细讲解 Express 核心原理的实现，包括主体架构 以及 核心的中间件架构模型讲解。\n\nExpress 在使用上非常较简单：\n\n- （1）初始化一个应用\n- （2）注册中间件调用\n- （3）最后监听端口启动服务\n\n```typescript\nconst express = require('express')\n\n// 初始化一个应用\nconst app = express()\nconst port = 3000\n\n// 注册中间件调用\napp.get('/', (req, res) => {\n  res.send('Hello World!')\n})\n\n// 监听端口启动服务\napp.listen(port, () => {\n  console.log(`Example app listening on port ${port}`)\n})\n```\n \n这个例子很简单，在更进一步之前，我们需要理解 express.js 的中间件模型，它可以帮助我们理解源码。\n\n## 2、中间件模型\nexpress.js 本质上是一个中间件模型，比如对于如下代码：\n```cpp\nconst express = require('express')\nconst app = express()\nconst port = 3000\n\n// 注册中间件: 响应请求，打印1，并且调用 next() 进入下一个中间件\napp.get('/', (req, res, next) => {\n  console.log(1)\n  res.send('Hello World!')\n  next()\n})\n\n// 注册中间件: 打印2，并且调用 next() 进入下一个中间件\napp.get('/', (req, res, next) => {\n  console.log(2)\n  next()\n})\n\n// 注册中间: 打印3\napp.get('/', (req, res, next) => {\n  console.log(3)\n  next()\n})\n\n// 注册中间件: 打印4\napp.get('/hello', (req, res) => {\n  console.log(4)\n})\n\napp.listen(port, () => {\n  console.log(`Example app listening on port ${port}`)\n})\n```\n在这里我们注册了4个中间件，当访问 [http://localhost:3000/](http://localhost:3000/) 会命中前3个中间件，从而打印 1 2 3，其命中规则主要依靠 HTTP 请求方法 和 请求路径来判断。\n\n![图1](http://s3.airtlab.com/blog/20230228221626.png)\n\n在 express.js 内部，当监听到一个请求时，会遍历所有中间件，如果某个中间件命中，则会进入该中间件，否则跳过，直到所有中间件遍历结束。 \n\n## 3、核心概念介绍\n以下的内容，只需要大体清楚留个印象即可，在后面的章节中，我们会详细的介绍。\n\n### 3.1 application 对象\n该对象由 express() 创建，app 本质是一个函数(也是中间件)，用于接受请求并下发，同时挂载了很多方法。\n```typescript\nvar app = function(req, res, nest) {}\n\n/**\n * Initialize the server.\n *\n *   - setup default configuration\n *   - setup default middleware\n *   - setup route reflection methods\n *\n * @private\n */\n// 入口\napp.init = function init() {}\n\n/**\n * Initialize application configuration.\n * @private\n */\n// 初始化配置\napp.defaultConfiguration = function defaultConfiguration() {}\n\n// 创建 router\napp.lazyrouter = function lazyrouter() {}\n```\n### 3.2 middleware 中间件\nmiddleware 本质上是一个 Function，存在3种定义：\n```cpp\n// 正常中间件：你对数据进行处理，然后调用 next 调用下一个中间件\nfn1(req, res, next) {}\n\n// 异常中间件: 你出错口才调用它，而且必须是四个参数，不能多也不能少\nfn2(err, req, res, next) {}\n\n// 终止中间件：没有 next 说明数据到里结束\nfn3(req, res) {}\n```\n中间件可以绑定路由，也可以不用绑定路由：\n```cpp\n// 全局, 不绑定路由\napp.use(function(req, res, next){});\n\n// 路由中间件, 绑定路由 get 方法\napp.get(\"/ping\", function(req, res, next){})\n\n// 路由中间件, 绑定路由 所有方法\napp.all(\"/ping\", function(req, res, next){})\n```\n中间件的更多演示 [Middleware callback function examples]([https://expressjs.com/en/4x/api.html#app.use](https://expressjs.com/en/4x/api.html#app.use))\n\n### 3.3 Router 对象\n每一个 application 中都只有一个 router 路由对像，这个对像管理这个 application 下面有所有的 subApplication, middleware 和 route。\n\n### 3.4 Route 对象\n```cpp\nfunction Route(path) {\n  this.path = path;\n  this.stack = [];\n\n  debug('new %o', path)\n\n  // route handlers for various http methods\n  this.methods = {};\n}\n```\n用于管理路由对象，比如：\n```cpp\napp.get(\"/ping\", function fn1(req, res, next){})\n```\n这时，就会创建一个 Route 实例:\n```cpp\n{\n\t\"path\": \"/ping\", // 请求路径\n    \"stack\": [fn1],  // 回掉函数\n    \"methods\": {     // 该 route 绑定了的请求方法\n        \"get\": true\n    }\n}\n```\n\n### 3.5 Layer 对象\nLayer 是一个连接器，用于串联 router route 以及 middleware，也是 express.js 中间件的核心\n\n### 3.6 sub application 子应用\napplication 指一个 express 实例，这个实例可以有自己环境变量等，而 subApplication 是指的 application 下面又会嵌套 一个 express 实例对像。\n```cpp\n// An Express app is valid middleware.\nvar subApp = express()\nsubApp.get('/', function (req, res, next) {\n  next()\n})\napp.use(subApp)\n```","isLeaf":true},{"key":"/NodeJS/02 expressjs/02-create-app.md","path":"/NodeJS/02 expressjs/02-create-app.md","route":"/NodeJS/02 expressjs/02-create-app.md","leaf":true,"title":"02-create-app","depth":2,"content":"---\ntitle: 02 创建 application\ntoc: true\ntags: ExpressJS\ncategories: NodeJS\n---\n\nexpress.js 第一步是创建 application 实例\n\n```js\nconst express = require('express')\n\n// 创建 application 实例\nconst app = express()\nconst port = 3000\n\napp.get('/', (req, res) => {\n  res.send('Hello World!')\n})\n\napp.listen(port, () => {\n  console.log(`Example app listening on port ${port}`)\n})\n```\n\n我们来看看 调用 express 函数后，背后的逻辑是什么。\n\n## 1. createApplication()\n\n源码：lib/express.js<br />express 函数就是 createApplication:\n\n```js\n/**\n* Create an express application.\n*\n* @return {Function}\n* @api public\n*/\n\nfunction createApplication() {\n  // app 仅仅是一个函数\n  // app 为什么这么定义，后续会讲到\n  var app = function (req, res, next) {\n    app.handle(req, res, next);\n  };\n\n  // 给 app 扩展 发布订阅\n  mixin(app, EventEmitter.prototype, false);\n\n  // 给 app 扩展 application 里面所定义对象\n  // 比如 app.init 就在 proto 中定义的\n  mixin(app, proto, false);\n\n  // 将 request 挂载到 app.request\n  // 并且 app 挂载到   request.app\n  // expose the prototype that will get set on requests\n  app.request = Object.create(req, {\n    app: { configurable: true, enumerable: true, writable: true, value: app },\n\t});\n\n  // 将 response 挂载到  app.response\n  // 并且 app 挂载到 response.app\n  // expose the prototype that will get set on responses\n  app.response = Object.create(res, {\n    app: { configurable: true, enumerable: true, writable: true, value: app },\n  });\n\n  // 初始化\n  app.init();\n\n  return app;\n}\n```\n\n## 2. app.init()\n\n源码：lib/application.js\n\n```js\n/**\n* Initialize the server.\n*\n*   - setup default configuration\n*   - setup default middleware\n*   - setup route reflection methods\n*\n* @private\n*/\n\napp.init = function init() {\n  this.cache = {};\n  this.engines = {};\n  this.settings = {};\n\n  // 初始化 setting\n  // setting 用于存储一些配置项\n  this.defaultConfiguration();\n};\n```\n\n## 3. app.defaultConfiguration()\n\n源码：lib/application.js\n\n```js\n/**\n* Initialize application configuration.\n* @private\n*/\n\napp.defaultConfiguration = function defaultConfiguration() {\n  var env = process.env.NODE_ENV || 'development';\n\n  // default settings\n  // this.set(key, value) 设置 settings\n  this.enable('x-powered-by');\n  this.set('etag', 'weak');\n  this.set('env', env);\n  this.set('query parser', 'extended');\n  this.set('subdomain offset', 2);\n  this.set('trust proxy', false);\n\n  // trust proxy inherit back-compat\n  Object.defineProperty(this.settings, trustProxyDefaultSymbol, {\n    configurable: true,\n    value: true\n    });\n\n  debug('booting in %s mode', env);\n\n  // MARK TODO mount 事件什么时候 emit\n  this.on('mount', function onmount(parent) {\n    // inherit trust proxy\n    if (this.settings[trustProxyDefaultSymbol] === true\n    && typeof parent.settings['trust proxy fn'] === 'function') {\n    delete this.settings['trust proxy'];\n    delete this.settings['trust proxy fn'];\n  }\n\n  // inherit protos\n  setPrototypeOf(this.request, parent.request)\n    setPrototypeOf(this.response, parent.response)\n    setPrototypeOf(this.engines, parent.engines)\n    setPrototypeOf(this.settings, parent.settings)\n  });\n\n  // setup locals\n  this.locals = Object.create(null);\n\n  // top-most app is mounted at /\n  this.mountpath = '/';\n\n  // default locals\n  this.locals.settings = this.settings;\n\n  // default configuration\n  this.set('view', View);\n  this.set('views', resolve('views'));\n  this.set('jsonp callback name', 'callback');\n\n  if (env === 'production') {\n    this.enable('view cache');\n  }\n\n  Object.defineProperty(this, 'router', {\n    get: function() {\n      throw new Error('\\'app.router\\' is deprecated!\\nPlease see the 3.x to 4.x migration guide for details on how to update your app.');\n    }\n  });\n};\n```\n\n## 4. 监听 mount 事件\n\n当 express 实例是一个子应用时，该子应用注册成功后，就会收到 mount 事件\n\n```js\n  app.on('mount', function onmount(parent) {\n    // inherit trust proxy\n    if (this.settings[trustProxyDefaultSymbol] === true\n      && typeof parent.settings['trust proxy fn'] === 'function') {\n      delete this.settings['trust proxy'];\n      delete this.settings['trust proxy fn'];\n    }\n\n    // inherit protos\n    setPrototypeOf(this.request, parent.request)\n    setPrototypeOf(this.response, parent.response)\n    setPrototypeOf(this.engines, parent.engines)\n    setPrototypeOf(this.settings, parent.settings)\n  });\n```\n\n```js\n// An Express app is valid middleware.\nvar subApp = express()\nsubApp.get('/', function (req, res, next) {\n  next()\n})\napp.use(subApp)\n```\n\napp.use 源码\n\n```js\napp.use = function use(fn) {\n  var offset = 0;\n  var path = '/';\n\n  // default path to '/'\n  // disambiguate app.use([fn])\n  if (typeof fn !== 'function') {\n    var arg = fn;\n\n    while (Array.isArray(arg) && arg.length !== 0) {\n      arg = arg[0];\n    }\n\n    // first arg is the path\n    if (typeof arg !== 'function') {\n      offset = 1;\n      path = fn;\n    }\n  }\n\n  var fns = flatten(slice.call(arguments, offset));\n\n  if (fns.length === 0) {\n    throw new TypeError('app.use() requires a middleware function')\n  }\n\n  // setup router\n  this.lazyrouter();\n  var router = this._router;\n\n  fns.forEach(function (fn) {\n    // non-express app\n    if (!fn || !fn.handle || !fn.set) {\n      return router.use(path, fn);\n    }\n\n    debug('.use app under %s', path);\n    fn.mountpath = path;\n    fn.parent = this;\n\n    // restore .app property on req and res\n    router.use(path, function mounted_app(req, res, next) {\n      var orig = req.app;\n      fn.handle(req, res, function (err) {\n        setPrototypeOf(req, orig.request)\n        setPrototypeOf(res, orig.response)\n        next(err);\n      });\n    });\n\n    // mounted an app\n    fn.emit('mount', this);\n  }, this);\n\n  return this;\n};\n```\n","isLeaf":true},{"key":"/NodeJS/02 expressjs/03-app-receive-request.md","path":"/NodeJS/02 expressjs/03-app-receive-request.md","route":"/NodeJS/02 expressjs/03-app-receive-request.md","leaf":true,"title":"03-app-receive-request","depth":2,"content":"---\ntitle: 03 app 接收请求\ntoc: true\ntags: ExpressJS\ncategories: NodeJS\n---\n\n```js\nconst express = require('express')\n\n// 初始化一个应用\nconst app = express()\nconst port = 3000\n\n// 注册中间件调用\napp.get('/', (req, res) => {\n  res.send('Hello World!')\n})\n\n// 监听端口启动服务\napp.listen(port, () => {\n  console.log(`Example app listening on port ${port}`)\n})\n```\n然后 app.listen 内部封装 http.createServer，所以先看看 app.listen\n\n## 1. app.listen()\n```js\n// lib/application.js\napp.listen = function listen() {\n  // this 就是\n  // var app = function (req, res, next) {\n  //   next 为 undefined  \n  //   app.handle(req, res, next);\n  // };\n\n  var server = http.createServer(this);\n\n  return server.listen.apply(server, arguments);\n};\n```\n所以当监听到请求时会进入 app.handle\n\n## 2. app.handle()\n```cpp\n// lib/application.js\n\n// Dispatch a req, res pair into the application. Starts pipeline processing.\n// If no callback is provided, then default error handlers will respond\n// in the event of an error bubbling through the stack.\napp.handle = function handle(req, res, callback) {\n  var router = this._router;\n\n  // final handler\n  var done = callback || finalhandler(req, res, {\n    env: this.get('env'),\n    onerror: logerror.bind(this)\n  });\n\n  // no routes\n  if (!router) {\n    debug('no routes defined on app');\n    done();\n    // 如果没有注册任何的中间件，则 done()\n    return;\n  }\n\n  router.handle(req, res, done);\n};\n```\n app.handle  用于下发请求到 router 进行处理，首先定义了 done Function，这个函数会在所有中间件都执行完了后执行。调用 router.handle 后，会进人流水线处理流程，我们先看看 finalhandler 的定义\n```cpp\nfunction finalhandler (req, res, options) {\n  var opts = options || {}\n\n  // get environment\n  var env = opts.env || process.env.NODE_ENV || 'development'\n\n  // get error callback\n  var onerror = opts.onerror\n\n  // 如果执行流水线执行完成，或者中途出现了错误\n  // 则会调用这个函数，并且传入错误信息\n  return function (err) {\n    var headers\n    var msg\n    var status\n\n    // ignore 404 on in-flight response\n    // 如果没错误，但是已经响应请求了，则请求处理完成\n    if (!err && headersSent(res)) {\n      debug('cannot 404 after headers sent')\n      return\n    }\n\n    // unhandled error\n    if (err) {\n      // respect status code from error\n      status = getErrorStatusCode(err)\n\n      if (status === undefined) {\n        // fallback to status code on response\n        status = getResponseStatusCode(res)\n      } else {\n        // respect headers from error\n        headers = getErrorHeaders(err)\n      }\n\n      // get error message\n      msg = getErrorMessage(err, status, env)\n    } else {\n      // not found\n      status = 404\n      msg = 'Cannot ' + req.method + ' ' + encodeUrl(getResourceName(req))\n    }\n\n    debug('default %s', status)\n\n    // schedule onerror callback\n    if (err && onerror) {\n      defer(onerror, err, req, res)\n    }\n\n    // cannot actually respond\n    if (headersSent(res)) {\n      debug('cannot %d after headers sent', status)\n      req.socket.destroy()\n      return\n    }\n\n    // send response\n    send(req, res, status, headers, msg)\n  }\n}\n```\n接下来，我们看看 router.handle 的逻辑\n\n## 3. router.handle()\nrouter.handle 是中间件执行调度的核心，我们后续会用单独的章节详细介绍，这里只做大概的阐述。<br />实际上，所有注册的中间件都会被 router 对象所管理，在 router.handle 内部封装了关键的 next 方法 以及 关键指针 idx，next 方法 + idx 指针来串联所有的中间件：\n\n- 从 idx = 0 开始，进入 next 方法，取一个 matched 的中间件\n- 当第一个中间件执行完成后，并且 next 被调用\n- 则取下一个 matched，这样直到所有 middleware 都被处理\n- 最后执行 done() \n\n下面是极简的代码（仅仅提供帮助理解，后续会详细介绍）\n```js\nproto.handle = function handle(req, res, out) {\n  var self = this;\n\n  var idx = 0;\n\n  // middleware and routes\n  var stack = self.stack;\n\n  var done = restore(out, req, 'baseUrl', 'next', 'params');\n\n  // setup basic req values\n  req.baseUrl = parentUrl;\n  req.originalUrl = req.originalUrl || req.url;\n\n  next();\n\n  function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // max sync stack\n    if (++sync > 100) {\n      return setImmediate(next, err)\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    // while 循环负责获取一个 matched 的中间件\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer);\n      if (match !== true) {\n        continue;\n      }\n    }\n\n    // 执行该中间件\n\thandle_request(req, res, next)\n  }\n};\n```\n然后整个请求就处理完成了\n","isLeaf":true},{"key":"/NodeJS/02 expressjs/04-middleware-register.md","path":"/NodeJS/02 expressjs/04-middleware-register.md","route":"/NodeJS/02 expressjs/04-middleware-register.md","leaf":true,"title":"04-middleware-register","depth":2,"content":"---\ntitle: 04 中间件注册流程\ntoc: true\ntags: ExpressJS\ncategories: NodeJS\n---\n\n创建 app 以及 app 接收请求 我们已经阐述过了，并且在《app 接收请求》这一小节中，我们介绍了 router.handle 中间件宏观的执行流程。现在我们需要详细的理解 中间件的注册流程 以及 中间件的执行流程。\n\n这一小节先介绍注册流程（如果你希望快速了解 middleware 的模型，请看文章末尾的 layer 模型图）\n\n## 1. 从 `app[method]()` 开始\n`app[method](path, fn)` 注册中间件:\n```js\n// 注册中间件: 响应请求，打印1，并且调用 next() 进入下一个中间件\napp.get('/', (req, res, next) => {\n  console.log(1)\n  res.send('Hello World!')\n  next()\n})\n```\n\n我们需要知道 `app.get` 是如何定义的：\n```js\n// lib/application.js\n// 遍历所有 http method\nmethods.forEach(function(method){\n  app[method] = function(path){\n    if (method === 'get' && arguments.length === 1) {\n      // app.get(setting)\n      return this.set(path);\n    }\n\n    // 创建 router, 内部有判断，只会全局创建一个 router\n    this.lazyrouter();\n      \n    // 创建 Route 实例\n    var route = this._router.route(path);\n\n    // 这个调用了 route.method 方法\n    // 本质上给该 route 创建了一个 layer\n    // route 绑定了 handle\n    route[method].apply(route, slice.call(arguments, 1));\n\n    return this;\n  };\n});\n```\n处理逻辑包括：\n\n- 创建 Router 实例 (内部有判断，只会全局创建一个 router)\n- 创建 Route 实例，每次调用 app[method] 都会创建一个 Route\n  - 创建 route\n  - 创建 router layer\n- 执行 route[method] 方法，参数为 handle\n  - 创建 route layer\n\n下面分别详细介绍。\n\n## 2. new Router\n### app.lazyrouter [创建 router]\n```js\napp.lazyrouter = function lazyrouter() {\n  if (!this._router) {\n    this._router = new Router({\n      caseSensitive: this.enabled('case sensitive routing'),\n      strict: this.enabled('strict routing')\n    });\n\n    // query parser: 解析 url 参数\n    this._router.use(query(this.get('query parser fn')));\n\n    // 完成 req 和 res 互相引用，以及按照国际惯例增加 \"X-Powered-By\" 😁\n    this._router.use(middleware.init(this));\n  }\n};\n```\nlazyrouter 内部决定是否执行 new Router，只会创建一个实例，这里可以理解为两步：\n\n- 创建 Router 实例\n- 注册两个内置的 middleware\n\n### Router 的定义\nlib/router/index.js\n```js\nvar proto = module.exports = function(options) {\n  var opts = options || {};\n\n  // 有趣的是 router 本身也是一个充当 middlewaren handle 的函数\n  // 这个会很有用, 比如路由分组  \n  function router(req, res, next) {\n    router.handle(req, res, next);\n  }\n\n  // mixin Router class functions\n  setPrototypeOf(router, proto)\n\n  router.params = {};\n  router._params = [];\n  router.caseSensitive = opts.caseSensitive;\n  router.mergeParams = opts.mergeParams;\n  router.strict = opts.strict;\n\n  // 用于保存所有的 middleware\n  router.stack = [];\n\n  return router;\n};\n```\n\n## 3. new Route\n### router.route() [创建 Route & router layer]\n注册中间件时:\n\n- (1) 创建一个 route\n- (2) 创建一个 layer\n- (3) layer.route = route\n- (4) 将 layer 添加到 router.stack 中\n\n```js\n/**\n * Create a new Route for the given path.\n *\n * Each route contains a separate middleware stack and VERB handlers.\n *\n * See the Route api documentation for details on adding handlers\n * and middleware to routes.\n *\n * @param {String} path\n * @return {Route}\n * @public\n */\nproto.route = function route(path) {\n  var route = new Route(path);\n\n  // layer 的 handle 为 route.dispatch 这个很重要\n  var layer = new Layer(path, {\n    sensitive: this.caseSensitive,\n    strict: this.strict,\n    end: true\n  }, route.dispatch.bind(route));\n\n  layer.route = route;\n\n  this.stack.push(layer);\n  return route;\n};\n```\n\n### route[method] [创建 route layer]\nlib/router/route.js\n```js\nmethods.forEach(function(method){\n  Route.prototype[method] = function(){\n      // handles 就是 app.method(path, fn1, fn2) 中的 [fn1, fn2]\n    var handles = flatten(slice.call(arguments));\n\n    for (var i = 0; i < handles.length; i++) {\n      var handle = handles[i];\n\n      if (typeof handle !== 'function') {\n        var type = toString.call(handle);\n        var msg = 'Route.' + method + '() requires a callback function but got a ' + type\n        throw new Error(msg);\n      }\n\n      debug('%s %o', method, this.path)\n\n      // 创建 Layer\n      // 将 layer 添加到 layer.stack 中\n      var layer = Layer('/', {}, handle);\n      layer.method = method;\n\n      this.methods[method] = true;\n      this.stack.push(layer);\n    }\n\n    return this;\n  };\n});\n\n```\n\n## 4. new Layer\nLayer 是对 middleware 的封装，先看 Layer 的定义。\n\n### Layer 的定义\n```js\n\nvar pathRegexp = require('path-to-regexp');\nvar debug = require('debug')('express:router:layer');\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nmodule.exports = Layer;\n\nfunction Layer(path, options, fn) {\n  if (!(this instanceof Layer)) {\n    return new Layer(path, options, fn);\n  }\n\n  debug('new %o', path)\n  var opts = options || {};\n\n  // 关键属性\n  this.handle = fn;\n\n  this.name = fn.name || '<anonymous>';\n  this.params = undefined;\n  this.path = undefined;\n  this.regexp = pathRegexp(path, this.keys = [], opts);\n\n  // set fast path flags\n  this.regexp.fast_star = path === '*'\n  this.regexp.fast_slash = path === '/' && opts.end === false\n}\n\n/**\n * Handle the error for the layer.\n *\n * @param {Error} error\n * @param {Request} req\n * @param {Response} res\n * @param {function} next\n * @api private\n */\nLayer.prototype.handle_error = function handle_error(error, req, res, next) {\n  var fn = this.handle;\n\n  if (fn.length !== 4) {\n    // not a standard error handler\n    return next(error);\n  }\n\n  try {\n    fn(error, req, res, next);\n  } catch (err) {\n    next(err);\n  }\n};\n\n/**\n * Handle the request for the layer.\n *\n * @param {Request} req\n * @param {Response} res\n * @param {function} next\n * @api private\n */\nLayer.prototype.handle_request = function handle(req, res, next) {\n  var fn = this.handle;\n\n    // 如果 handle 参数只有2个时\n    // 内部会帮助 next() 避免 pipe 中断\n  if (fn.length > 3) {\n    // not a standard request handler\n    return next();\n  }\n\n  try {\n    fn(req, res, next);\n  } catch (err) {\n    next(err);\n  }\n};\n\n/**\n * Check if this route matches `path`, if so\n * populate `.params`.\n *\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\nLayer.prototype.match = function match(path) {\n  var match\n\n  if (path != null) {\n    // fast path non-ending match for / (any path matches)\n    if (this.regexp.fast_slash) {\n      this.params = {}\n      this.path = ''\n      return true\n    }\n\n    // fast path for * (everything matched in a param)\n    if (this.regexp.fast_star) {\n      this.params = {'0': decode_param(path)}\n      this.path = path\n      return true\n    }\n\n    // match the path\n    match = this.regexp.exec(path)\n  }\n\n  if (!match) {\n    this.params = undefined;\n    this.path = undefined;\n    return false;\n  }\n\n  // store values\n  this.params = {};\n  this.path = match[0]\n\n  var keys = this.keys;\n  var params = this.params;\n\n  for (var i = 1; i < match.length; i++) {\n    var key = keys[i - 1];\n    var prop = key.name;\n    var val = decode_param(match[i])\n\n    if (val !== undefined || !(hasOwnProperty.call(params, prop))) {\n      params[prop] = val;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Decode param value.\n *\n * @param {string} val\n * @return {string}\n * @private\n */\n\nfunction decode_param(val) {\n  if (typeof val !== 'string' || val.length === 0) {\n    return val;\n  }\n\n  try {\n    return decodeURIComponent(val);\n  } catch (err) {\n    if (err instanceof URIError) {\n      err.message = 'Failed to decode param \\'' + val + '\\'';\n      err.status = err.statusCode = 400;\n    }\n\n    throw err;\n  }\n}\n\n```\n\n从 2 和 3 中可以看到, route 和 router 实例都有 stack 属性，都用于保存 Layer 实例，它们之间有什么区别呢？主要 handle function 的差异。\n\n### route layer 和 route layer\n前面我们已经讲过，router layer 是在调用 router.route 方法时创建的：\n```js\nrouter.route = function route(path) {\n  var route = new Route(path);\n\n  var layer = new Layer(path, {\n    sensitive: this.caseSensitive,\n    strict: this.strict,\n    end: true\n  }, route.dispatch.bind(route));\n\n  layer.route = route;\n\n  this.stack.push(layer);\n  return route;\n};\n```\n注意 router layer 的 handle 实际上是  route.dispatch，而 route layer 是在调用 route[method]() 创建的:\n```js\nmethods.forEach(function(method){\n  Route.prototype[method] = function(){\n    var handles = flatten(slice.call(arguments));\n\n    for (var i = 0; i < handles.length; i++) {\n      var handle = handles[i];\n\n      if (typeof handle !== 'function') {\n        var type = toString.call(handle);\n        var msg = 'Route.' + method + '() requires a callback function but got a ' + type\n        throw new Error(msg);\n      }\n\n      debug('%s %o', method, this.path)\n\n      var layer = Layer('/', {}, handle);\n      layer.method = method;\n      // route layer 必须绑定 method, 因为一个 route 既可以绑定 post 也可以绑定 get...\n      // post 对应 post layer, get 对应 get layer\n\n      this.methods[method] = true;\n      this.stack.push(layer);\n    }\n\n    return this;\n  };\n});\n```\n对比差异：\n```js\n// router layer\nnew Layer(path, {\n    sensitive: this.caseSensitive,\n    strict: this.strict,\n    end: true\n  }, route.dispatch.bind(route));\nlayer.route = route;\n\n// route layer\nvar layer = Layer('/', {}, handle);\nlayer.method = method;\n```\n\n### user handle 和 dispatch handle\n概念区分，体现差异\n\n### layer 测试\n```js\nconst express = require('express')\nconst app = express()\nconst port = 3000\n\n// 注册中间件\n// 功能包含：响应请求，打印1，并且调用 next() 进入下一个中间件\napp.get('/', (req, res, next) => {\n  console.log(1)\n  res.send('Hello World!')\n  next()\n})\n\n// 注册中间件\n// 功能包含：打印2，并且调用 next() 进入下一个中间件\napp.get('/', (req, res, next) => {\n  console.log(2)\n  next()\n})\n\napp.listen(port, () => {\n  console.log(`Example app listening on port ${port}`)\n})\ndebugger\n```\n针对上面代码，当执行到 debugger 时, app._router.stack 长度为 4:\n\n![20230228234147](http://s3.airtlab.com/blog/20230228234147.png)\n\n前两个是内置中间件，后面2个是自定义注册的。我们看看第三个 layer:\n\n![20230228234130](http://s3.airtlab.com/blog/20230228234130.png)\n\n该 layer 的 handle 是 route.dispatch 方法，而且该 layer 有一个 route 属性。route 也有 一个 layer, 其 handle 就是我们注册的 callback function。route.stack 是一个数组，这表示一个route可以拥有多layer，比如：\n```js\n// route.all 或者 route.get 支持链式写法\n// 给一个 route 注册了两个layer\nrouter.route('/users/:user_id')\n  .all(function (req, res, next) {\n    // runs for all HTTP verbs first\n    // think of it as route specific middleware!\n    next()\n  })\n  .get(function (req, res, next) {\n    res.json(req.user)\n  })\n```\n\n### layer 模型图\n到此为止我们画出 Layer 的模型图:\n\n![20230228234105](http://s3.airtlab.com/blog/20230228234105.png)\n\n### route 多 layer\n```js\napp.route('/user') \n.get((req, res, next) => { \n    res.send('GET request called'); \n}) \n.post((req, res, next) => { \n\tres.send('POST request called'); \n}) \n.all((req, res, next) => { \n\tres.send('Other requests called'); \n}) \n  \n```","isLeaf":true},{"key":"/NodeJS/02 expressjs/05-middleware-runtime.md","path":"/NodeJS/02 expressjs/05-middleware-runtime.md","route":"/NodeJS/02 expressjs/05-middleware-runtime.md","leaf":true,"title":"05-middleware-runtime","depth":2,"content":"---\ntitle: 05 中间件执行流程\ntoc: true\ntags: ExpressJS\ncategories: NodeJS\n---\n\n使用以下代码进行调试:\n```cpp\nconst express = require('express')\nconst app = express()\nconst port = 3000\n\n// 注册中间件\n// 功能包含：响应请求，打印1，并且调用 next() 进入下一个中间件\napp.get('/', (req, res, next) => {\n  console.log(1)\n  res.send('Hello World!')\n  next()\n})\n\n// 注册中间件\n// 功能包含：打印2，并且调用 next() 进入下一个中间件\napp.get('/', (req, res, next) => {\n  console.log(2)\n  next()\n})\n\napp.listen(port, () => {\n  debugger\n  console.log(`Example app listening on port ${port}`)\n})\n```\n\n### 1. layer 执行流程\n先了解 express.js 中 layer 的执行流程，再看代码会变得非常简单。<br />\n![image](http://s3.airtlab.com/blog/image.png)\n\n- 理解 router layer 递归\n- 理解 route layer 递归\n\n### 2. router.handle 接管请求\n```cpp\n/**\n * Dispatch a req, res into the router.\n * @private\n */\nrouter.handle = function handle(req, res, out) {\n  var self = this;\n\n  debug('dispatching %s %s', req.method, req.url);\n\n  var idx = 0;\n  var protohost = getProtohost(req.url) || ''\n  var removed = '';\n  var slashAdded = false;\n  var sync = 0\n  var paramcalled = {};\n\n  // store options for OPTIONS request\n  // only used if OPTIONS request\n  var options = [];\n\n  // middleware and routes\n  var stack = self.stack;\n\n  // manage inter-router variables\n  var parentParams = req.params;\n  var parentUrl = req.baseUrl || '';\n  var done = restore(out, req, 'baseUrl', 'next', 'params');\n\n  // setup next layer\n  req.next = next;\n\n  // for options requests, respond with a default if nothing else responds\n  if (req.method === 'OPTIONS') {\n    done = wrap(done, function(old, err) {\n      if (err || options.length === 0) return old(err);\n      sendOptionsResponse(res, options, old);\n    });\n  }\n\n  // setup basic req values\n  req.baseUrl = parentUrl;\n  req.originalUrl = req.originalUrl || req.url;\n\n  next();\n\n  function next(err) {}\n}\n```\n#### next() 递归函数\n我们只看 next 的核心逻辑，就是递归的匹配 layer 并执行 handle，其他的可以先忽略。\n```cpp\n  function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.slice(1)\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.slice(protohost.length)\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // max sync stack\n    if (++sync > 100) {\n      return setImmediate(next, err)\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n\n    // layerPath 和 path 的区别\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        next(layerError || err)\n      } else if (route) {\n          // 如果是一个 route layer, 则执行 layer.handle, 也就是 route.dispatch\n        layer.handle_request(req, res, next)\n      } else {\n          // 如果不是 route layer, 则要 trim_prefix\n          // 后续在讲 trim_prefix 是干什么\n        trim_prefix(layer, layerError, layerPath, path)\n      }\n\n      sync = 0\n    });\n  }\n\n```\n```cpp\nLayer.prototype.handle_request = function handle(req, res, next) {\n  var fn = this.handle;\n\n  if (fn.length > 3) {\n    // not a standard request handler\n    return next();\n  }\n\n  try {\n    fn(req, res, next);\n  } catch (err) {\n    next(err);\n  }\n};\n\n// app.get('/', (req, res, next) => {\n//   console.log(2)\n//   next() => router next()\n// })\n```\n#### trim_prefix 函数\n```cpp\n  function trim_prefix(layer, layerError, layerPath, path) {\n    if (layerPath.length !== 0) {\n      // Validate path is a prefix match\n      if (layerPath !== path.slice(0, layerPath.length)) {\n        next(layerError)\n        return\n      }\n\n      // Validate path breaks on a path separator\n      var c = path[layerPath.length]\n      if (c && c !== '/' && c !== '.') return next(layerError)\n\n      // Trim off the part of the url that matches the route\n      // middleware (.use stuff) needs to have the path stripped\n      debug('trim prefix (%s) from url %s', layerPath, req.url);\n      removed = layerPath;\n      req.url = protohost + req.url.slice(protohost.length + removed.length)\n\n      // Ensure leading slash\n      if (!protohost && req.url[0] !== '/') {\n        req.url = '/' + req.url;\n        slashAdded = true;\n      }\n\n      // Setup base URL (no trailing slash)\n      req.baseUrl = parentUrl + (removed[removed.length - 1] === '/'\n        ? removed.substring(0, removed.length - 1)\n        : removed);\n    }\n\n    debug('%s %s : %s', layer.name, layerPath, req.originalUrl);\n\n    if (layerError) {\n      layer.handle_error(layerError, req, res, next);\n    } else {\n      layer.handle_request(req, res, next);\n    }\n  }\n```\n#### layerPath 和 path 的区别\n#### req.baseUrl & req.url 维护\n`req.baseUrl` 表示当前 router instance 所挂载的路径\n```cpp\nconst app = express()\nconst port = 3000\n\n// 演示1\napp.get('/test', function (req, res) {\n  console.log(req.baseUrl) // ''\n  console.log(req.path) // /test\n\n  res.send('Konichiwa!')\n})\n\n\n// 演示2\nvar greet = express.Router()\n\ngreet.get('/jp', function (req, res) {\n  console.log(req.baseUrl) // /greet\n  console.log(req.path) // jp\n  res.send('Konichiwa!')\n})\n\napp.use('/greet', greet) // load the router on '/greet'\n\n// 演示3\ngreet.get('/:id', function (req, res) {\n  console.log(req.baseUrl) // /greet\n  console.log(req.path) // 12\n  res.send('Konichiwa!')\n})\n\napp.use('/greet', greet) // load the router on '/greet'\n// visit /greet/12\n```\n### 3. route.dispatch\n```cpp\n// 当 route 里面的 layer 执行完成之后，会执行 done\n// 这个 done 实际就是 router layer next\nRoute.prototype.dispatch = function dispatch(req, res, done) {}\n```\n```cpp\nRoute.prototype.dispatch = function dispatch(req, res, done) {\n  var idx = 0;\n  var stack = this.stack;\n  var sync = 0\n\n  if (stack.length === 0) {\n    return done();\n  }\n\n  var method = req.method.toLowerCase();\n  if (method === 'head' && !this.methods['head']) {\n    method = 'get';\n  }\n\n  req.route = this;\n\n  next();\n\n  function next(err) {\n    // signal to exit route\n    if (err && err === 'route') {\n      return done();\n    }\n\n    // signal to exit router\n    if (err && err === 'router') {\n      return done(err)\n    }\n\n    // max sync stack\n    if (++sync > 100) {\n      return setImmediate(next, err)\n    }\n\n    var layer = stack[idx++]\n\n    // end of layers\n    if (!layer) {\n      return done(err)\n    }\n\n    // layer 也绑定了 method  \n    if (layer.method && layer.method !== method) {\n      next(err)\n    } else if (err) {\n      layer.handle_error(err, req, res, next);\n    } else {\n      layer.handle_request(req, res, next);\n    }\n\n    sync = 0\n  }\n};\n```","isLeaf":true},{"key":"/NodeJS/02 expressjs/06-router-group.md","path":"/NodeJS/02 expressjs/06-router-group.md","route":"/NodeJS/02 expressjs/06-router-group.md","leaf":true,"title":"06-router-group","depth":2,"content":"---\ntitle: 06 路由分组原理\ntoc: true\ntags: ExpressJS\ncategories: NodeJS\n---\n\n`app[http method]` 用于挂载一个路由到默认的 router，而 `app.use` 可以挂载子 router, 因为 router instance 本身也是一个中间件。<br />调试代码：\n\n```js\nconst express = require('express')\nconst app = express()\nconst port = 3000\n\nvar greet = express.Router()\ngreet.get('/jp', function (req, res) {\n  res.send('Konichiwa!')\n})\n\napp.use('/greet', greet) // load the router on '/greet'\n\ndebugger\napp.listen(port, () => {\n  console.log(`Example app listening on port ${port}`)\n})\n\n```\n\n![image](http://s3.airtlab.com/blog/image.png)\n\n### 1. app.use()\n\n```cpp\napp.use = function use(fn) {\n  var offset = 0;\n  var path = '/';\n\n  // default path to '/'\n  // disambiguate app.use([fn])\n  if (typeof fn !== 'function') {\n    var arg = fn;\n\n    while (Array.isArray(arg) && arg.length !== 0) {\n      arg = arg[0];\n    }\n\n    // first arg is the path\n    if (typeof arg !== 'function') {\n      offset = 1;\n      path = fn;\n    }\n  }\n\n  var fns = flatten(slice.call(arguments, offset));\n\n  if (fns.length === 0) {\n    throw new TypeError('app.use() requires a middleware function')\n  }\n\n  // setup router\n  this.lazyrouter();\n  var router = this._router;\n\n  fns.forEach(function (fn) {\n    // non-express app\n    if (!fn || !fn.handle || !fn.set) {\n        // entered\n      return router.use(path, fn);\n    }\n\n    debug('.use app under %s', path);\n    fn.mountpath = path;\n    fn.parent = this;\n\n    // restore .app property on req and res\n    router.use(path, function mounted_app(req, res, next) {\n      var orig = req.app;\n      fn.handle(req, res, function (err) {\n        setPrototypeOf(req, orig.request)\n        setPrototypeOf(res, orig.response)\n        next(err);\n      });\n    });\n\n    // mounted an app\n    fn.emit('mount', this);\n  }, this);\n\n  return this;\n};\n\n```\n![image_1](http://s3.airtlab.com/blog/image_1.png)\n\n### 2. router.use()\n\n在 router 中注册中间件有两种方式，第一种是 router[method](), 另一种是 router.use(), 后者注册的方式和 HTTP Method 无关，只有 path 有关：\n\n```cpp\n// all requests to this router will first hit this middleware\nrouter.use(function (req, res, next) {\n  console.log('%s %s %s', req.method, req.url, req.path)\n  next()\n})\n\n// this will only be invoked if the path starts with /bar from the mount point\nrouter.use('/bar', function (req, res, next) {\n  // ... maybe some additional /bar logging ...\n  next()\n})\n```\n\n源码：\n\n```cpp\nrouter.use = function use(fn) {\n  var offset = 0;\n  var path = '/';\n\n  // default path to '/'\n  // disambiguate router.use([fn])\n  if (typeof fn !== 'function') {\n    var arg = fn;\n\n    while (Array.isArray(arg) && arg.length !== 0) {\n      arg = arg[0];\n    }\n\n    // first arg is the path\n    if (typeof arg !== 'function') {\n      offset = 1;\n      path = fn;\n    }\n  }\n\n  var callbacks = flatten(slice.call(arguments, offset));\n\n  if (callbacks.length === 0) {\n    throw new TypeError('Router.use() requires a middleware function')\n  }\n\n  for (var i = 0; i < callbacks.length; i++) {\n    var fn = callbacks[i];\n\n    if (typeof fn !== 'function') {\n      throw new TypeError('Router.use() requires a middleware function but got a ' + gettype(fn))\n    }\n\n    // add the middleware\n    debug('use %o %s', path, fn.name || '<anonymous>')\n\n    var layer = new Layer(path, {\n      sensitive: this.caseSensitive,\n      strict: false,\n      end: false\n    }, fn);\n\n    // 通过\n    layer.route = undefined;\n\n    this.stack.push(layer);\n  }\n\n  return this;\n};\n```\n\n### 3. trim_prefix() 剥掉分组前缀\n当执行到 greet 中间件时:\n![image_](http://s3.airtlab.com/blog/image_.png)\n\n```cpp\nfunction trim_prefix(layer, layerError, layerPath, path) {\n    if (layerPath.length !== 0) {\n      // Validate path is a prefix match\n      // 校验前缀是否相等\n      if (layerPath !== path.slice(0, layerPath.length)) {\n        next(layerError)\n        return\n      }\n\n      // Validate path breaks on a path separator\n      // 校验分割符\n      var c = path[layerPath.length]\n      if (c && c !== '/' && c !== '.') return next(layerError)\n\n      // Trim off the part of the url that matches the route\n      // middleware (.use stuff) needs to have the path stripped\n      debug('trim prefix (%s) from url %s', layerPath, req.url);\n      removed = layerPath;\n\n      // /greeting/test => /test\n      req.url = protohost + req.url.slice(protohost.length + removed.length)\n\n      // Ensure leading slash\n      // 保证 / 开头\n      if (!protohost && req.url[0] !== '/') {\n        req.url = '/' + req.url;\n        slashAdded = true;\n      }\n\n      // Setup base URL (no trailing slash)\n      req.baseUrl = parentUrl + (removed[removed.length - 1] === '/'\n        ? removed.substring(0, removed.length - 1)\n        : removed);\n    }\n\n    debug('%s %s : %s', layer.name, layerPath, req.originalUrl);\n\n    if (layerError) {\n      layer.handle_error(layerError, req, res, next);\n    } else {\n      layer.handle_request(req, res, next);\n    }\n  }\n```\n","isLeaf":true},{"key":"/NodeJS/02 expressjs/07-express-session.md","path":"/NodeJS/02 expressjs/07-express-session.md","route":"/NodeJS/02 expressjs/07-express-session.md","leaf":true,"title":"07-express-session","depth":2,"content":"---\ntitle: 07 express-session ⭕\ntoc: true\ntags: ExpressJS\ncategories: NodeJS\n---","isLeaf":true},{"key":"/NodeJS/02 expressjs/08-express-http-context.md","path":"/NodeJS/02 expressjs/08-express-http-context.md","route":"/NodeJS/02 expressjs/08-express-http-context.md","leaf":true,"title":"08-express-http-context","depth":2,"content":"---\ntitle: 08 express-http-context ⭕\ntoc: true\ntags: ExpressJS\ncategories: NodeJS\n---\n\nTODO","isLeaf":true}]},{"key":"/NodeJS/03 koa","path":"/NodeJS/03 koa","route":"/NodeJS/03 koa","leaf":false,"title":"03 koa","depth":1,"content":"","isLeaf":false,"children":[{"key":"/NodeJS/03 koa/01-design.md","path":"/NodeJS/03 koa/01-design.md","route":"/NodeJS/03 koa/01-design.md","leaf":true,"title":"01-design","depth":2,"content":"---\ntitle: 01 架构设计\ntags: KoaJS\ncategories: NodeJS\n---\n\nTODO","isLeaf":true}]},{"key":"/NodeJS/04 nestjs","path":"/NodeJS/04 nestjs","route":"/NodeJS/04 nestjs","leaf":false,"title":"04 nestjs","depth":1,"content":"","isLeaf":false,"children":[{"key":"/NodeJS/04 nestjs/00-introduce.md","path":"/NodeJS/04 nestjs/00-introduce.md","route":"/NodeJS/04 nestjs/00-introduce.md","leaf":true,"title":"00-introduce","depth":2,"content":"---\ntags: nodejs-nestjs\ncategories: NodeJS\n---\n\n![20230606151927](http://s3.airtlab.com/blog/20230606151927.png)\n\n![20230606151934](http://s3.airtlab.com/blog/20230606151934.png)\n\n## 介绍\nNest是构建高效，可扩展的 Node.js Web 应用程序的框架。 它使用现代的 JavaScript 或 TypeScript（保留与纯 JavaScript 的兼容性），并结合 OOP（面向对象编程），FP（函数式编程）和FRP（函数响应式编程）的元素。。\n\n## 设计哲学\n近几年，由于 Node.js，JavaScript 已经成为 Web 前端和后端应用程序的“通用语言”，并且有了 Angular，React 和 Vue 等令人耳目一新的项目，提高了开发人员的生产力，使得可以快速构建可测试的且可扩展的前端应用程序。 然而，在服务器端，虽然有很多优秀的库、helper 和 Node 工具，但是它们都没有有效地解决主要问题 - 架构。\n\nNest 旨在提供一个开箱即用的应用程序体系结构，允许轻松创建高度可测试，可扩展，松散耦合且易于维护的应用程序。\n\n## 学习资料\n\n- nestJS 中文文档 [https://docs.nestjs.cn/7/controllers?id=headers](https://docs.nestjs.cn/7/controllers?id=headers)\n- nestJS 官方文档 [https://docs.nestjs.com/first-steps](https://docs.nestjs.com/first-steps) \n- [https://gitee.com/gaollard/zhufeng-nestjs](https://gitee.com/gaollard/zhufeng-nestjs)  珠峰 nestjs 教程\n\n- 《nestjs搭建通用业务框架》\n  - [Coding World](https://www.toimc.com/categories/nestjs%E6%90%AD%E5%BB%BA%E9%80%9A%E7%94%A8%E4%B8%9A%E5%8A%A1%E6%A1%86%E6%9E%B6/)\n\n- 《nestjs-mysql-api企业级权限系统》\n  - [https://github.com/kuangshp/nestjs-mysql-api](https://github.com/kuangshp/nestjs-mysql-api)\n  - [https://juejin.cn/post/6877421936356360200](https://juejin.cn/post/6877421936356360200)","isLeaf":true},{"key":"/NodeJS/04 nestjs/01-basic.md","path":"/NodeJS/04 nestjs/01-basic.md","route":"/NodeJS/04 nestjs/01-basic.md","leaf":true,"title":"01-basic","depth":2,"content":"---\ntags: nodejs-nestjs\ncategories: NodeJS\n---\n\n参考文档：[https://docs.nestjs.cn/7/controllers?id=request](https://docs.nestjs.cn/7/controllers?id=request)\n\n- 路由：常用是指 uri\n- 控制器：用于处理特定路由\n- \n\n## 1、请求方法\n\n### @GET\n```typescript\nimport { Controller, Get } from '@nestjs/common';\nimport { AppService } from './app.service';\n\n@Controller()\nexport class AppController {\n  constructor(private readonly appService: AppService) {}\n\n  @Get()\n  getHello(): string {\n    return this.appService.getHello();\n  }\n\n  @Get('/home')\n  getHome(): string {\n    return 'hello home';\n  }\n}\n\n```\n\n### @Post\n\n```typescript\nimport { Controller, Get, Query, Request, Response, Post } from '@nestjs/common';\nimport { AppService } from './app.service';\n\n@Controller()\nexport class AppController {\n  constructor(private readonly appService: AppService) {}\n\n  @Post('test')\n  getTest(@Request() req): string {\n    console.log(req.body)\n    return 'test'\n  }\n}\n```\n\n## 2、请求参数\n\n### @Query 获取 query 参数\n\n```typescript\nimport { Controller, Get, Query } from '@nestjs/common';\nimport { AppService } from './app.service';\n\n@Controller()\nexport class AppController {\n  constructor(private readonly appService: AppService) {}\n\n  @Get()\n  getHello(): string {\n    return this.appService.getHello();\n  }\n\n  @Get('/home')\n  getHome(@Query() query): string {\n    console.log(query)\n    return 'hello home';\n  }\n}\n```\n```typescript\nimport { Controller, Get, Query } from '@nestjs/common';\nimport { AppService } from './app.service';\n\n@Controller()\nexport class AppController {\n  constructor(private readonly appService: AppService) {}\n\n  @Get('/home')\n  getHome(@Query('name') query): string {\n    console.log(query)\n    return 'hello home';\n  }\n}\n\n```\n\n### @Params 获取 path 参数\n\n```typescript\nimport { Controller, Header, Headers, Get, Query, Request, Response, Post, Body, Param } from '@nestjs/common';\nimport { AppService } from './app.service';\n\n@Controller()\nexport class AppController {\n  constructor(private readonly appService: AppService) {}\n\n  @Get(':id')\n  getTest(@Headers() headers, @Param() params): string {\n    console.log(params)\n    return 'test'\n  }\n}\n```\n\n### @Body 获取 body 参数\n\n```typescript\nimport { Controller, Get, Query, Request, Response, Post, Body } from '@nestjs/common';\nimport { AppService } from './app.service';\n\n@Controller()\nexport class AppController {\n  constructor(private readonly appService: AppService) {}\n\n  @Post('test')\n  getTest(@Body() body): string {\n    console.log(body)\n    return 'test'\n  }\n}\n```\n\n## 3、请求对象&响应对象\n\n### @Request 请求对象\n\n```typescript\nimport { Controller, Get, Query, Request } from '@nestjs/common';\nimport { AppService } from './app.service';\n\n@Controller()\nexport class AppController {\n  constructor(private readonly appService: AppService) {}\n\n  @Get('test')\n  getTest(@Request() req): string {\n    console.log(req.query)\n    return 'test'\n  }\n}\n```\n\n### @Response 响应对象\n\n## 4、请求头获取和设置\n\n### @Headers 获取请求头\n```typescript\nimport { Controller, Header, Headers, Get, Query, Request, Response, Post, Body } from '@nestjs/common';\nimport { AppService } from './app.service';\n\n@Controller()\nexport class AppController {\n  constructor(private readonly appService: AppService) {}\n\n  @Post('test')\n  getTest(@Headers() headers): string {\n    console.log(headers)\n    return 'test'\n  }\n}\n```\n\n### @Header 设置头\n```typescript\nimport { Controller, Header, Headers, Get, Query, Request, Response, Post, Body } from '@nestjs/common';\nimport { AppService } from './app.service';\n\n@Controller()\nexport class AppController {\n  constructor(private readonly appService: AppService) {}\n\n  @Post('test')\n  @Header('x-s', 'ddd')\n  getTest(@Headers() headers): string {\n    console.log(headers)\n    return 'test'\n  }\n}\n```\n\n## 5、路由分组\n```typescript\nimport { Module } from '@nestjs/common';\nimport { RouterModule, Routes } from 'nest-router';\nimport { AppController } from './app.controller';\nimport { AppService } from './app.service';\nimport { UserModule } from './user.module';\n\nconst routes: Routes = [\n  {\n    path: '/v1',\n    module: UserModule,\n  },\n];\n\n@Module({\n  imports: [\n    UserModule,\n    RouterModule.forRoutes(routes),\n  ],\n  controllers: [AppController],\n  providers: [AppService],\n})\nexport class AppModule {}\n\n```\n## 6、路由重定向\n```typescript\nimport { Controller, Get, Res } from '@nestjs/common';\nimport { Response } from 'supertest';\nimport { PingService } from './ping.service';\n\n@Controller('ping')\nexport class PingController {\n  constructor(private service: PingService) {}\n\n  @Get('test')\n  test(): string {\n    return this.service.getHello();\n  }\n\n  @Get()\n  getHello(): string {\n    return this.service.getHello();\n  }\n\n  @Get('redirect')\n  redirect(\n    @Res() res: Response & { redirect: (uri: string, status?: number) => void },\n  ) {\n    // (1) 重定向到 http 协议的站点\n    // res.redirect('https://nestjs.com', 301)\n    // (2) 重定向到站点\n    // (property) request.Response.redirect: boolean\n    // redirect 居然是个 boolean 类型，好奇怪\n    res.redirect('/ping/test', 302)\n  }\n}\n\n```\n","isLeaf":true},{"key":"/NodeJS/04 nestjs/02-view.md","path":"/NodeJS/04 nestjs/02-view.md","route":"/NodeJS/04 nestjs/02-view.md","leaf":true,"title":"02-view","depth":2,"content":"---\ntags: nodejs-nestjs\ncategories: NodeJS\n---\n\n## 1、使用模版引擎\n\n```typescript\nimport { NestFactory } from '@nestjs/core';\nimport { NestExpressApplication } from '@nestjs/platform-express';\nimport { AppModule } from './app.module';\n\nimport { join } from 'path';\n\nasync function bootstrap() {\n  const app = await NestFactory.create<NestExpressApplication>(AppModule);\n  \n  // 配置模板引擎(安装ejs: yarn add ejs)\n  app.setBaseViewsDir('views');\n  app.setViewEngine('ejs');\n\n  await app.listen(7000);\n}\n\nbootstrap();\n```\n\n```typescript\nimport { Controller, Header, Headers, Get, Render, Param } from '@nestjs/common';\nimport { AppService } from './app.service';\n\n@Controller()\nexport class AppController {\n  constructor(private readonly appService: AppService) {}\n\n  @Get(':id')\n  @Render('home')\n  getTest(@Headers() headers, @Param() params) {\n    console.log(headers)\n    return {\n      name: \"XManba\",\n      headers: headers\n    }\n  }\n}\n```\n\n![20230606150205](http://s3.airtlab.com/blog/20230606150205.png)\n\n## 2、静态资源服务设置\n```typescript\nimport { NestFactory } from '@nestjs/core';\nimport { NestExpressApplication } from '@nestjs/platform-express';\nimport { AppModule } from './app.module';\n\nimport { join } from 'path';\n\nasync function bootstrap() {\n  const app = await NestFactory.create<NestExpressApplication>(AppModule);\n\n  // 配置静态资源(设置虚拟目录是更好的做法)\n  // app.useStaticAssets(join(__dirname, '..', 'public'));\n  app.useStaticAssets(join(__dirname, '..', 'public'), {\n    prefix: '/static/', // 设置虚拟路径\n  });\n\n  await app.listen(7000);\n}\n\nbootstrap();\n```","isLeaf":true},{"key":"/NodeJS/04 nestjs/03-cookie-session.md","path":"/NodeJS/04 nestjs/03-cookie-session.md","route":"/NodeJS/04 nestjs/03-cookie-session.md","leaf":true,"title":"03-cookie-session","depth":2,"content":"---\ntags: nodejs-nestjs\ncategories: NodeJS\n---\n\n## 1、使用 cookie\n\n### cookie-parser(express平台)\n\n```typescript\nimport { NestFactory } from '@nestjs/core';\nimport { NestExpressApplication } from '@nestjs/platform-express';\nimport { AppModule } from './app.module';\nimport * as cookieParser from 'cookie-parser';\n\nimport { join } from 'path';\n\nasync function bootstrap() {\n  const app = await NestFactory.create<NestExpressApplication>(AppModule);\n\n  app.use(cookieParser());\n\n  await app.listen(7000);\n}\n\n\nbootstrap();\n```\n\n**设置cookie**\n\n```typescript\nimport {Controller, Get, Response } from '@nestjs/common';\nimport { NewsService } from './news.service';\n\n@Controller('news')\nexport class NewsController {\n  constructor(private newsService: NewsService) {}\n\n  @Get()\n  getNewsList(@Response() res) {\n    res.cookie('username', 'XManba', {\n      maxAge: 24 * 60 * 60\n    })\n    // 这里只能用 res.send\n    res.send(this.newsService.findAll())\n    // return this.newsService.findAll()\n  }\n}\n```\n\n**获取cookie**\n\n```typescript\nimport { Controller, Get, Request, Response } from '@nestjs/common';\nimport { AppService } from './app.service';\n\n@Controller()\nexport class AppController {\n  constructor(private readonly appService: AppService) {}\n\n  @Get()\n  getTest(@Request() req) {\n    return req.cookies;\n  }\n}\n```\n\n### cookie 配置参数\n\n![20230606150407](http://s3.airtlab.com/blog/20230606150407.png)\n\n\n### cookie 加密\n\n![20230606150419](http://s3.airtlab.com/blog/20230606150419.png)\n\n**设置**\n```typescript\nimport {Controller, Get, Response } from '@nestjs/common';\nimport { NewsService } from './news.service';\n\n@Controller('news')\nexport class NewsController {\n  constructor(private newsService: NewsService) {}\n\n  @Get()\n  getNewsList(@Response() res) {\n    res.cookie('username', '1XManba', {\n      maxAge: 24 * 60 * 60 * 1000,\n      httpOnly: false,\n      signed: true\n    })\n    // 这里只能用 res.send\n    res.send(this.newsService.findAll())\n    // return this.newsService.findAll()\n  }\n}\n```\n\n**获取**\n\n```typescript\nimport { Controller, Get, Request, Response } from '@nestjs/common';\nimport { AppService } from './app.service';\n\n@Controller()\nexport class AppController {\n  constructor(private readonly appService: AppService) {}\n\n  @Get()\n  getTest(@Request() req) {\n    return {\n      ...req.signedCookies,\n      ...req.cookies\n    }\n  }\n}\n```\n\n## 2、使用 session\n\n![20230606150519](http://s3.airtlab.com/blog/20230606150519.png)\n\n![20230606150532](http://s3.airtlab.com/blog/20230606150532.png)\n\n**配置**\n```typescript\nimport { NestFactory } from '@nestjs/core';\nimport { NestExpressApplication } from '@nestjs/platform-express';\nimport { AppModule } from './app.module';\n\nimport * as cookieParser from 'cookie-parser';\nimport * as session from 'express-session';\n\nimport { join } from 'path';\n\nasync function bootstrap() {\n  const app = await NestFactory.create<NestExpressApplication>(AppModule);\n\n  // cookie\n  app.use(cookieParser('user123.'));\n\n  // session\n  app.use(session({\n    secret: 'user123.',\n    cookie: {\n      maxAge: 1000 * 10\n    }\n  }))\n\n  await app.listen(7000);\n}\n\n\nbootstrap();\n```\n\n**使用**\n```typescript\nimport { Controller, Get, Response, Request } from '@nestjs/common';\n\n@Controller('session')\nexport class SessionController {\n  @Get('set')\n  getSession(@Request() req) {\n    console.log(req.session)\n    req.session.token = \"zxczxcxzc\"\n    return req.session.token\n  }\n\n  @Get('get')\n  setSession(@Request() req) {\n    return req.session.token ? req.session.token : 'none';\n  }\n}\n```\n\n### 常用参数\n\n![20230606150628](http://s3.airtlab.com/blog/20230606150628.png)\n\n![20230606150635](http://s3.airtlab.com/blog/20230606150635.png)\t\t\t\t\t\n\n### 常用方法\n\n![20230606150646](http://s3.airtlab.com/blog/20230606150646.png)","isLeaf":true},{"key":"/NodeJS/04 nestjs/04-file-upload.md","path":"/NodeJS/04 nestjs/04-file-upload.md","route":"/NodeJS/04 nestjs/04-file-upload.md","leaf":true,"title":"04-file-upload","depth":2,"content":"---\ntags: nodejs-nestjs\ncategories: NodeJS\n---\n\n---\ntitle: 04 文件上传\n---\n\n## 1、基本用法\n\n```typescript\nimport { Controller, Post, UseInterceptors, UploadedFile, Body, Get, Render, UploadedFiles } from '@nestjs/common';\nimport { FileInterceptor, FilesInterceptor, FileFieldsInterceptor } from '@nestjs/platform-express';\n\nimport { join } from 'path';\nimport { createWriteStream } from 'fs';\n\n@Controller('upload')\nexport class UploadController {\n  // 上传单个文件\n  @Post('single')\n  @UseInterceptors(FileInterceptor('avatar'))\n  uploadFile(@UploadedFile() file, @Body() body) {\n    console.log(file)\n    console.log(body)\n    const rstream = createWriteStream(\n      join(__dirname, '../../public/upload', `${Date.now()}-${file.originalname}`)\n    )\n    rstream.write(file.buffer)\n    return file.size\n  }\n\n  // 上传一个文件\n  @Post('array')\n  @UseInterceptors(FilesInterceptor('avatars'))\n  uploadFileList(@UploadedFiles() files, @Body() body) {\n    console.log(files)\n    return files.map(elment => elment.originalname)\n  }\n\n  // 上传多个文件\n  @Post('many')\n  @UseInterceptors(FileFieldsInterceptor([\n    { name: 'avatar', maxCount: 2 },\n    { name: 'background', maxCount: 1 },\n  ]))\n  uploadFiles(@UploadedFiles() files) {\n    console.log(files.avatar)\n    console.log(files.background)\n    return files.size\n  }\n}\n```\n\n## 2、配置路径 & 参数\n\n```typescript\nimport { Module } from '@nestjs/common';\nimport { MulterModule } from '@nestjs/platform-express';\nimport { UploadController } from './upload.controller';\nimport { UploadService } from './upload.service';\n\n@Module({\n  imports: [\n    MulterModule.register({\n      dest: './upload',\n    }),\n  ],\n  providers: [UploadService],\n  controllers: [UploadController],\n})\nexport class UploadModule {}\n\n```\n```typescript\nimport {\n  Controller,\n  Post,\n  UploadedFile,\n  UseInterceptors,\n} from '@nestjs/common';\nimport { FileInterceptor } from '@nestjs/platform-express';\nimport { diskStorage } from 'multer';\nimport { UploadService } from './upload.service';\n\n// export const imageFileFilter = (req, file, callback) => {\n//   if (!file.originalname.match(/\\.(jpg|jpeg|png|gif)$/)) {\n//     return callback(new Error('Only image files are allowed!'), false);\n//   }\n//   callback(null, true);\n// };\n\n// export const editFileName = (req, file, callback) => {\n//   const name = file.originalname.split('.')[0];\n//   const fileExtName = extname(file.originalname);\n//   const randomName = Array(4)\n//     .fill(null)\n//     .map(() => Math.round(Math.random() * 16).toString(16))\n//     .join('');\n//   callback(null, `${name}-${randomName}${fileExtName}`);\n// };\n\n@Controller('upload')\nexport class UploadController {\n  constructor(\n    private uploadService: UploadService\n  ) {}\n\n  @Post()\n  @UseInterceptors(\n    FileInterceptor('file', {\n      storage: diskStorage({\n        destination: './upload',\n      }),\n    }),\n  )\n  async upload(@UploadedFile() file: Express.Multer.File) {\n    return this.uploadService.upload(file.path, file.originalname)\n  }\n}\n\n```","isLeaf":true},{"key":"/NodeJS/04 nestjs/05-decorator.md","path":"/NodeJS/04 nestjs/05-decorator.md","route":"/NodeJS/04 nestjs/05-decorator.md","leaf":true,"title":"05-decorator","depth":2,"content":"---\ntags: nodejs-nestjs\ncategories: NodeJS\n---\n\n---\ntitle: 05 自定义装饰器\n---\n\n## 1、内置参数装饰器\nNest 提供了一组有用的 **参数装饰器**，您可以将它们与 HTTP 路由处理程序一起使用。下面是提供的装饰器和它们代表的普通 Express（或 Fastify）对象的列表\n\n| @Request(), @Req() | req |\n| --- | --- |\n| @Response(), @Res() | res |\n| @Next() | next |\n| @Session() | req.session |\n| @Param(param?: string) | req.params/req.params[param] |\n| @Body(param?: string) | req.body/req.body[param] |\n| @Query(param?: string) | req.query/req.query[param] |\n| @Headers(param?: string) | req.headers/req.headers[param] |\n| @Ip() | req.ip |\n| @HostParam() | req.hosts |\n\n## 2、自定义参数装饰器\n\n在 node.js 世界中，将属性附加到 **请求** 对象是常见的做法。然后在每个路由处理程序中手动提取它们，使用如下代码：\n\n```typescript\nconst user = req.user;\n```\n\n为了使您的代码更具可读性和透明性，您可以创建一个@User()装饰器并在所有控制器中重用它。\n\n```typescript\nimport { createParamDecorator, ExecutionContext } from '@nestjs/common';\n\nexport const User = createParamDecorator(\n  (data: unknown, ctx: ExecutionContext) => {\n    const request = ctx.switchToHttp().getRequest();\n    return request.user;\n  },\n);\n```\n\n然后，您可以在适合您要求的任何地方简单地使用它\n\n```typescript\n@Get()\nasync findOne(@User() user: UserEntity) {\n  console.log(user);\n}\n```\n\n### 返回值可以是 Promise\n\n```typescript\nimport { createParamDecorator, ExecutionContext } from '@nestjs/common';\n\nexport const User = createParamDecorator(\n  (data: unknown, ctx: ExecutionContext) => {\n    const request = ctx.switchToHttp().getRequest();\n    return new Promise((resolve) => {\n      resolve(1);\n    });\n  },\n);\n```\n\n## 3、装饰器的参数\n\n```typescript\nimport { createParamDecorator, ExecutionContext } from '@nestjs/common';\n\nexport const User = createParamDecorator(\n  (data: string, ctx: ExecutionContext) => {\n    const request = ctx.switchToHttp().getRequest();\n    return new Promise((resolve) => {\n      resolve(`${data}_1`);\n    });\n  },\n);\n```\n\n## 4、使用管道\n\n在 @Query 和 @Body 等装饰器中，我们是可以使用 ValidationPipe 功能的，如何让你的装饰器具有同样的功能呢？\n\n```typescript\n@Get()\nasync findOne(\n  @User(new ValidationPipe({ validateCustomDecorators: true }))\n  user: UserEntity,\n) {\n  console.log(user);\n}\n```\n\n> 请注意，validateCustomDecorators 选项必须设置为 true。ValidationPipe 默认情况下，不验证使用自定义装饰器注释的参数。\n\n## 5、装饰器组合\nNest 提供了一个辅助方法来组合多个装饰器。例如，假设您想将所有与身份验证相关的装饰器组合成一个装饰器。这可以通过以下结构来完成：\n\n```typescript\nimport { applyDecorators } from '@nestjs/common';\n\nexport function Auth(...roles: Role[]) {\n  return applyDecorators(\n    SetMetadata('roles', roles),\n    UseGuards(AuthGuard, RolesGuard),\n    ApiBearerAuth(),\n    ApiUnauthorizedResponse({ description: 'Unauthorized' }),\n  );\n}\n```\n\n然后，您可以@Auth()按如下方式使用此自定义装饰器：\n\n```typescript\nclass MyController {\n  @Get('users')\n  @Auth('admin')\n  findAllUsers() {}\n}\n```","isLeaf":true},{"key":"/NodeJS/04 nestjs/06-param-validate.md","path":"/NodeJS/04 nestjs/06-param-validate.md","route":"/NodeJS/04 nestjs/06-param-validate.md","leaf":true,"title":"06-param-validate","depth":2,"content":"---\ntags: nodejs-nestjs\ncategories: NodeJS\n---\n\n---\ntitle: 06 参数验证\n---\n\n参数验证主要是结合 NestJS pipe 来做\n\n**安装**\n```shell\nyarn add class-transformer class-validator\n```\n\n**配置全局验证 pipe**\n\n```typescript\nimport { appLogger } from '@libs/logger';\nimport { ValidationPipe, BadRequestException } from '@nestjs/common';\n\nconst app = await NestFactory.create<NestExpressApplication>(AppModule);\n\nconst exceptionFactory: ValidationPipe['exceptionFactory'] = (errors) => {\n  appLogger.error(`validator error`, errors);\n  const error = errors[0];\n  return new BadRequestException(\n    error.constraints[Object.keys(error.constraints)[0]],\n  );\n};\n\nexport const ParamsValidationPipe = new ValidationPipe({\n  // transform: true,\n  // whitelist: true, 开启 whitelist 会将不需要的字段都丢去\n  // skipMissingProperties: true,\n  exceptionFactory,\n  // transformOptions: {\n  //   excludeExtraneousValues: false,\n  // },\n});\n\napp.useGlobalPipes(ParamsValidationPipe);\t\n```\n\n**使用**\n```typescript\nimport { ApiProperty } from '@nestjs/swagger';\nimport { IsOptional, IsString } from 'class-validator';\nimport { UserEntity } from '../entity/user.entity';\nimport { CodeTypeEnum } from '../enums/CodeTypeEnum';\nimport { LoginTypeEnum } from '../enums/LoginTypeEnum';\n\nexport class RegisterDto {\n  @ApiProperty({ description: '账号'  })\n  @IsOptional()\n  @IsString()\n  account?: string;\n\n  @ApiProperty({ description: '密码', required: false })\n  @IsOptional()\n  @IsString()\n  password?: string;\n\n  @ApiProperty({ description: '验证码', required: false })\n  @IsOptional()\n  @IsString()\n  code?: string;\n\n  @ApiProperty({ description: '账号类型', enum:  RegisterType })\n  @IsString()\n  registerType: RegisterType;\n}\n```\n\n```typescript\n@ApiTags('账户')\n@Controller('account')\nexport class AccountController {\n  constructor(\n    private authService: AuthService,\n    private accountService: AccountService,\n  ) {}\n\n  // 注册\n  @Post('register')\n  register(@Body() body: RegisterDto) {\n    return this.accountService.register(body);\n  }\n}\n```\n","isLeaf":true},{"key":"/NodeJS/04 nestjs/07-response-pip.md","path":"/NodeJS/04 nestjs/07-response-pip.md","route":"/NodeJS/04 nestjs/07-response-pip.md","leaf":true,"title":"07-response-pip","depth":2,"content":"---\ntags: nodejs-nestjs\ncategories: NodeJS\n---\n\n```typescript\n@Controller('file')\nexport class FileController {\n  @Get()\n  getFile(@Res() res: Response) {\n    const file = createReadStream(join(process.cwd(), 'package.json'));\n    file.pipe(res);\n  }\n}\n```","isLeaf":true},{"key":"/NodeJS/04 nestjs/08-typeorm-auto-load-entity.md","path":"/NodeJS/04 nestjs/08-typeorm-auto-load-entity.md","route":"/NodeJS/04 nestjs/08-typeorm-auto-load-entity.md","leaf":true,"title":"08-typeorm-auto-load-entity","depth":2,"content":"---\ntags: nodejs-nestjs\ncategories: NodeJS\n---\n\n## 1、自动加载实体\n\n指定该选项后，通过该 forFeature() 方法注册的每个实体都将自动添加到 entities 配置对象的数组中。\n\n```typescript\nimport { Module } from '@nestjs/common';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { User } from './user.entity';\n\n@Module({\n  imports: [TypeOrmModule.forFeature([User])],\n  exports: [TypeOrmModule]\n})\nexport class UsersModule {}\n```\n\n```typescript\nimport { Module } from '@nestjs/common';\nimport { TypeOrmModule } from '@nestjs/typeorm';\n\n@Module({\n  imports: [\n    TypeOrmModule.forRoot({\n      ...\n      autoLoadEntities: true,\n    }),\n  ],\n})\nexport class AppModule {}\n```","isLeaf":true},{"key":"/NodeJS/04 nestjs/09-SetMetadata.md","path":"/NodeJS/04 nestjs/09-SetMetadata.md","route":"/NodeJS/04 nestjs/09-SetMetadata.md","leaf":true,"title":"09-SetMetadata","depth":2,"content":"---\ntags: nodejs-nestjs\ncategories: NodeJS\n---\n\n**设置元数据**\n\n```typescript\nimport { Controller, Get, SetMetadata, UseGuards } from '@nestjs/common';\nimport { RolesGuard } from './auth.guard';\nimport { CatsService } from './cats.service';\n\n@SetMetadata('roles', ['admin'])\n@Controller()\nexport class AppController {\n  constructor(\n    private catService: CatsService\n  ) {}\n\n  @UseGuards(RolesGuard)\n  @Get()\n  async findOne() {\n    this.catService.test()\n  }\n}\n```\n\n**获取元数据**\n\n```typescript\nimport { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';\nimport { Reflector } from '@nestjs/core';\n\n@Injectable()\nexport class RolesGuard implements CanActivate {\n  constructor(private reflector: Reflector) {}\n\n  canActivate(context: ExecutionContext): boolean {\n    const request = context.switchToHttp().getRequest();\n    const roles = this.reflector.get<string[]>('roles', context.getHandler());\n    console.log(roles)\n    return true;\n  }\n}\n```\n\n**元数据合并策略**\n\n- getAllAndOverride\n```typescript\nconst roles = this.reflector.getAllAndOverride<string[]>('roles', [\n  context.getHandler(),\n  context.getClass(),\n]);\n```\n\n- getAllAndMerge\n```typescript\nconst roles = this.reflector.getAllAndMerge<string[]>('roles', [\n  context.getHandler(),\n  context.getClass(),\n]);\n```\n","isLeaf":true},{"key":"/NodeJS/04 nestjs/10-core-module.md","path":"/NodeJS/04 nestjs/10-core-module.md","route":"/NodeJS/04 nestjs/10-core-module.md","leaf":true,"title":"10-core-module","depth":2,"content":"---\ntags: nodejs-nestjs\ncategories: NodeJS\n---\n\n---\ntitle: 10 模块 Module\n---\n\n模块是具有 `@Module()` 装饰器的类。 `@Module()` 装饰器提供了元数据，Nest 用它来组织应用程序结构。\n\n![20230606152347](http://s3.airtlab.com/blog/20230606152347.png)\n\n每个 Nest 应用程序至少有一个模块，即根模块。根模块是 Nest 开始安排应用程序树的地方。事实上，根模块可能是应用程序中唯一的模块，特别是当应用程序很小时，但是对于大型程序来说这是没有意义的。在大多数情况下，您将拥有多个模块，每个模块都有一组紧密相关的功能。\n\n`@module()` 装饰器接受一个描述模块属性的对象：\n\n| 字段 | 介绍 |\n| --- | --- |\n| providers | 由 Nest 注入器实例化的提供者，并且可以至少在整个模块中共享 |\n| controllers | 必须创建的一组控制器 |\n| imports | 导入模块的列表，这些模块导出了此模块中所需提供者 |\n| exports | 由本模块提供并应在其他模块中可用的提供者的子集。 |\n\n> 默认情况下，该模块封装提供程序。这意味着无法注入既不是当前模块的直接组成部分，也不是从导入的模块导出的提供程序。因此，您可以将从模块导出的提供程序视为模块的公共接口或API。\n\n## 1、按功能组织模块\n\n一个功能模块仅仅是将具有相同功能的 Service、Controller 已经其他信息封装在一个模块中，比如：\n\n```typescript\nimport { Module } from '@nestjs/common';\nimport { CatsModule } from './cats/cats.module';\n\n@Module({\n  imports: [CatsModule],\n})\nexport class AppModule {}\n```\n\n## 2、模块是单例的\n在 Nest 中，模块默认是单例的，因此您可以轻松地在多个模块之间共享任何提供程序的相同实例。\n\n![20230606152549](http://s3.airtlab.com/blog/20230606152549.png)\n\n每个模块一旦创建，它就可以被任何模块重用。假设我们想 CatsService 在其他几个模块之间共享一个实例。为此，我们首先需要通过将提供程序添加到模块的数组中来导出提供程序，如下所示：CatsService exports\n\n```typescript\nimport { Module } from '@nestjs/common';\nimport { CatsController } from './cats.controller';\nimport { CatsService } from './cats.service';\n\n@Module({\n  controllers: [CatsController],\n  providers: [CatsService],\n  exports: [CatsService]\n})\nexport class CatsModule {}\n```\n\n现在任何导入 的模块 CatsModule 都可以访问 CatsService 并且将与导入它的所有其他模块共享相同的实例。\n\n## 3、模块重新导出\n\n如上所示，模块可以导出其内部提供者。此外，他们可以重新导出他们导入的模块。在下面的示例中，CommonModule 既可以导入也可以从 导出 CoreModule，使其可用于导入该模块的其他模块。\n\n```typescript\n@Module({\n  imports: [CommonModule],\n  exports: [CommonModule],\n})\nexport class CoreModule {}\n```\n\n## 4、模块类也可以注入提供者\n\n```typescript\nimport { Module } from '@nestjs/common';\nimport { CatsController } from './cats.controller';\nimport { CatsService } from './cats.service';\n\n@Module({\n  controllers: [CatsController],\n  providers: [CatsService],\n})\nexport class CatsModule {\n  constructor(private catsService: CatsService) {}\n}\n```\n\n[但是，由于循环依赖](https://docs.nestjs.com/fundamentals/circular-dependency)，模块类本身不能作为提供者注入。\n\n## 5、全局模块\n\n如果您必须在任何地方导入相同的模块集，这可能会变得乏味。与 Nest 不同，[Angular](https://angular.io/) providers 是在全局范围内注册的。一旦定义，它们在任何地方都可用。然而，Nest 将提供程序封装在模块范围内。如果不首先导入封装模块，您将无法在其他地方使用模块的提供程序。\n当您想提供一组开箱即用的提供程序时（例如，帮助程序、数据库连接等），请使用装饰器使模块成为全局的，即 `@Global()`\n\n```typescript\nimport { Module, Global } from '@nestjs/common';\nimport { CatsController } from './cats.controller';\nimport { CatsService } from './cats.service';\n\n@Global()\n@Module({\n  controllers: [CatsController],\n  providers: [CatsService],\n  exports: [CatsService],\n})\nexport class CatsModule {}\n```\n\n@Global() 装饰器使模块具有全局范围。全局模块应该只注册 **一次**，通常由根模块或核心模块注册。在上面的示例中，CatsService 提供者将无处不在，希望注入服务的模块不需要 CatsModule 在其导入数组中导入。\n\n让一切都全球化并不是一个好的设计决策。`全局模块可用于减少必要的样板数量`。imports数组通常是使模块的 API 可供消费者使用的首选方式 。\n\n## 6、动态模块\n\nNest 模块系统包括一个称为 **动态模块** 的强大功能。此功能使您能够轻松创建可动态注册和配置提供程序的可定制模块。[动态模块在这里](https://docs.nestjs.com/fundamentals/dynamic-modules) 得到了广泛的介绍。在本章中，我们将简要概述以完成对模块的介绍。\n\n以下是 a 的动态模块定义示例 DatabaseModule：\n\n```typescript\nimport { Module, DynamicModule } from '@nestjs/common';\nimport { createDatabaseProviders } from './database.providers';\nimport { Connection } from './connection.provider';\n\n@Module({\n  providers: [Connection],\n})\nexport class DatabaseModule {\n  static forRoot(entities = [], options?): DynamicModule {\n    const providers = createDatabaseProviders(options, entities);\n    return {\n      module: DatabaseModule,\n      providers: providers,\n      exports: providers,\n    };\n  }\n}\n```\n\n```typescript\nimport { Module } from '@nestjs/common';\nimport { DatabaseModule } from './database/database.module';\nimport { User } from './users/entities/user.entity';\n\n@Module({\n  imports: [DatabaseModule.forRoot([User])],\n})\nexport class AppModule {}\n```\n\n### 动态模块的意义\n主要用于提供可定制功能\n\n### forRoot() 方法可以是异步\nforRoot 返回动态模块，即一个 Promise。\n\n### 全局范围内注册动态模块\n如果要在全局范围内注册动态模块，请将 global 属性设置为 true\n```typescript\n{\n  global: true,\n  module: DatabaseModule,\n  providers: providers,\n  exports: providers,\n}\n```","isLeaf":true},{"key":"/NodeJS/04 nestjs/11-core-provider.md","path":"/NodeJS/04 nestjs/11-core-provider.md","route":"/NodeJS/04 nestjs/11-core-provider.md","leaf":true,"title":"11-core-provider","depth":2,"content":"---\ntitle: 11 提供者 Provider\ntags: nodejs-nestjs\ncategories: NodeJS\n---\n\n## 1、@Injectable() 标记\n\n依赖注入是一种 [控制反转 (IoC)](https://en.wikipedia.org/wiki/Inversion_of_control) 技术，您可以将依赖项的实例化委托给 IoC 容器（在我们的例子中是 NestJS 运行时系统），而不是在您自己的代码中强制执行。`@Injectable() 装饰器将类标记为 Provider`\n\n```typescript\nimport { Injectable } from '@nestjs/common';\nimport { Cat } from './interfaces/cat.interface';\n\n@Injectable()\nexport class CatsService {\n  private readonly cats: Cat[] = [];\n\n  findAll(): Cat[] {\n    return this.cats;\n  }\n}\n```\n\n```typescript\nimport { Controller, Get } from '@nestjs/common';\nimport { CatsService } from './cats.service';\nimport { Cat } from './interfaces/cat.interface';\n\n@Controller('cats')\nexport class CatsController {\n  constructor(private catsService: CatsService) {}\n\n  @Get()\n  async findAll(): Promise<Cat[]> {\n    return this.catsService.findAll();\n  }\n}\n```\n\n```typescript\nimport { Module } from '@nestjs/common';\nimport { CatsController } from './cats/cats.controller';\nimport { CatsService } from './cats/cats.service';\n\n@Module({\n  controllers: [CatsController],\n  providers: [CatsService],\n})\nexport class AppModule {}\n```\n\n## 2、简写模式 (useClass)\n\n```typescript\n@Module({\n  controllers: [CatsController],\n  providers: [CatsService],\n})\nclass MyModule {}\n```\n\n该 providers 属性需要一个数组 providers，他是更完整语法的简写：\n```typescript\n@Module({\n  controllers: [CatsController],\n  providers: [\n    {\n      provide: CatsService,\n      useClass: CatsService,\n    },\n  ],\n})\nclass MyModule {}\n```\n\n简写符号只是为了简化最常见的用例，其中令牌用于请求具有相同名称的类的实例。\n\n## 3、理解 useValue\n该 useValue 语法对于注入常量值、将外部库放入 Nest 容器或用模拟对象替换真实实现很有用。假设您想强制 Nest 使用模拟 CatsService 来进行测试\n\n```typescript\nimport { CatsService } from './cats.service';\n\nconst mockCatsService = {\n  /* mock implementation\n  ...\n  */\n};\n\n@Module({\n  imports: [CatsModule],\n  providers: [\n    {\n      provide: CatsService,\n      useValue: mockCatsService,\n    },\n  ],\n})\nexport class AppModule {}\n```\n\n在此示例中，CatsService 令牌将解析为 mockCatsService 模拟对象。需要一个值 - 在这种情况下，一个文字对象与它正在替换 useValue 的类具有相同的接口。CatsService 由于 TypeScript 的[结构类型](https://www.typescriptlang.org/docs/handbook/type-compatibility.html)，您可以使用任何具有兼容接口的对象，包括文字对象或用 实例化的类实例 new。\n\n## 4、非基于类的提供者令牌\n到目前为止，我们使用类名作为我们的提供者标记（数组provide中列出的提供者中的属性值）。[这与基于构造函数的注入](https://docs.nestjs.com/providers#dependency-injection)providers 使用的标准模式相匹配，其中标记也是类名。\n\n```typescript\nimport { connection } from './connection';\n\n@Module({\n  providers: [\n    {\n      provide: 'CONNECTION',\n      useValue: connection,\n    },\n  ],\n})\nexport class AppModule {}\n```\n\n```typescript\n@Injectable()\nexport class CatsRepository {\n  constructor(@Inject('CONNECTION') connection: Connection) {}\n}\n```\n\n在此示例中，我们将字符串值标记 ( ) 与我们从外部文件导入'CONNECTION'的预先存在的对象相关联。connection。除了使用字符串作为标记值之外，您还可以使用 JavaScript [符号](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol) 或 TypeScript[枚举](https://www.typescriptlang.org/docs/handbook/enums.html)。\n\n## 5、class provider: useClass\n假设我们有一个抽象的 ConfigService 类。根据当前环境，我们希望 Nest 提供不同的配置服务实现。下面的代码实现了这样的策略。\n\n```typescript\nconst configServiceProvider = {\n  provide: ConfigService,\n  useClass:\n    process.env.NODE_ENV === 'development'\n      ? DevelopmentConfigService\n      : ProductionConfigService,\n};\n\n@Module({\n  providers: [configServiceProvider],\n})\nexport class AppModule {}\n```\n\n## 6、factory provider: useFactory\n该语法允许**动态**创建提供程序。实际的提供者将由工厂函数返回的值提供，工厂本身可以注入其他提供程序。对于后一种情况，工厂提供者语法有一对相关的机制：\n\n1. 工厂函数可以接受（可选）参数。\n2. inject 属性接受一组提供者，Nest 将在实例化过程中解析并作为参数传递给工厂函数。此外，这些提供程序可以标记为可选。这两个列表应该是相关的：Nest 会将inject列表中的实例作为参数以相同的顺序传递给工厂函数。下面的示例演示了这一点。\n```typescript\nconst connectionFactory = {\n  provide: 'CONNECTION',\n  useFactory: (optionsProvider: OptionsProvider, optionalProvider?: string) => {\n    const options = optionsProvider.get();\n    return new DatabaseConnection(options);\n  },\n  inject: [OptionsProvider, { token: 'SomeOptionalProvider', optional: true }],\n  //       \\_____________/            \\__________________/\n  //        This provider              The provider with this\n  //        is mandatory.              token can resolves to `undefined`.\n};\n\n@Module({\n  providers: [\n    connectionFactory,\n    OptionsProvider,\n    // { provide: 'SomeOptionalProvider', useValue: 'anything' },\n  ],\n})\nexport class AppModule {}\n```\n\n## 7、alias provider：useExisting\n该useExisting语法允许您为现有提供程序创建别名。这创建了两种访问同一提供程序的方法。在下面的示例中，（基于字符串的）标记'AliasedLoggerService'是（基于类的）标记的别名LoggerService。假设我们有两个不同的依赖项，一个 for'AliasedLoggerService'和一个 for LoggerService。如果两个依赖项都指定了SINGLETON范围，它们都将解析为同一个实例。\n\n```typescript\n@Injectable()\nclass LoggerService {\n  /* implementation details */\n}\n\nconst loggerAliasProvider = {\n  provide: 'AliasedLoggerService',\n  useExisting: LoggerService,\n};\n\n@Module({\n  providers: [LoggerService, loggerAliasProvider],\n})\nexport class AppModule {}\n```\n\n## 8、非服务提供商\n虽然供应商经常提供服务，但他们并不局限于这种用途。提供者可以提供**任何**价值。例如，提供者可能会根据当前环境提供一组配置对象，如下所示：\n\n```typescript\nconst configFactory = {\n  provide: 'CONFIG',\n  useFactory: () => {\n    return process.env.NODE_ENV === 'development' ? devConfig : prodConfig;\n  },\n};\n\n@Module({\n  providers: [configFactory],\n})\nexport class AppModule {}\n```\n\n## 9、导出自定义提供程序\n与任何提供者一样，自定义提供者的范围仅限于其声明模块。要使其对其他模块可见，必须将其导出。要导出自定义提供者，我们可以使用其令牌或完整的提供者对象。以下示例显示使用令牌导出：\n```typescript\nconst connectionFactory = {\n  provide: 'CONNECTION',\n  useFactory: (optionsProvider: OptionsProvider) => {\n    const options = optionsProvider.get();\n    return new DatabaseConnection(options);\n  },\n  inject: [OptionsProvider],\n};\n\n@Module({\n  providers: [connectionFactory],\n  exports: ['CONNECTION'],\n})\nexport class AppModule {}\n```\n\n或者，使用完整的提供者对象导出：\n```typescript\nconst connectionFactory = {\n  provide: 'CONNECTION',\n  useFactory: (optionsProvider: OptionsProvider) => {\n    const options = optionsProvider.get();\n    return new DatabaseConnection(options);\n  },\n  inject: [OptionsProvider],\n};\n\n@Module({\n  providers: [connectionFactory],\n  exports: [connectionFactory],\n})\nexport class AppModule {}\n```\n\n## 10、异步提供者\n有时，应延迟应用程序启动，直到完成一个或多个**异步任务**。例如，您可能不想在与数据库的连接建立之前开始接受请求。您可以使用异步提供程序来实现这一点。\n```typescript\n{\n  provide: 'ASYNC_CONNECTION',\n  useFactory: async () => {\n    const connection = await createConnection(options);\n    return connection;\n  },\n}\n```\n","isLeaf":true},{"key":"/NodeJS/04 nestjs/12-core-middleware.md","path":"/NodeJS/04 nestjs/12-core-middleware.md","route":"/NodeJS/04 nestjs/12-core-middleware.md","leaf":true,"title":"12-core-middleware","depth":2,"content":"---\ntags: nodejs-nestjs\ncategories: NodeJS\ntitle: 12 中间件 Middleware\n---\n\n中间件是在路由处理程序 **之前** 调用的函数。 中间件函数可以访问请求和响应对象，以及应用程序请求响应周期中的 `next()` 中间件函数。 `next()` 中间件函数通常由名为 `next` 的变量表示。\n\n![20230606154242](http://s3.airtlab.com/blog/20230606154242.png)\n\nNest 中间件实际上等价于 [express](http://expressjs.com/en/guide/using-middleware.html) 中间件。 下面是Express官方文档中所述的中间件功能：\n中间件函数可以执行以下任务:\n\n- 执行任何代码。\n- 对请求和响应对象进行更改。\n- 结束请求-响应周期。\n- 调用堆栈中的下一个中间件函数。\n- 如果当前的中间件函数没有结束请求-响应周期, 它必须调用 `next()` 将控制传递给下一个中间件函数。否则, 请求将被挂起。\n\n## 类中间件\n\n```typescript\nimport { Module, NestModule, MiddlewareConsumer } from '@nestjs/common';\nimport { AppController } from './app.controller';\nimport { AppService } from './app.service';\nimport { ProductController } from './product/product.controller';\nimport { NewsController } from './news/news.controller';\nimport { NewsService } from './news/news.service';\nimport { SessionController } from './session/session.controller';\nimport { UploadController } from './upload/upload.controller';\n\nimport { LoggerMiddleware } from './middleware/logger.middleware';\nimport { UserMiddleware } from './middleware/user.middleware';\n\n@Module({\n  imports: [],\n  controllers: [AppController, ProductController, NewsController, SessionController, UploadController],\n  providers: [AppService, NewsService],\n})\nexport class AppModule implements NestModule {\n  configure(consumer: MiddlewareConsumer) {\n    consumer\n      .apply(LoggerMiddleware)\n      .forRoutes('*')\n      .apply(UserMiddleware)\n      .forRoutes('product')\n  }\n}\n```\n\n**中间件代码**\n\n```typescript\nimport { Injectable, NestMiddleware } from '@nestjs/common';\nimport { Request, Response } from 'express';\n\n@Injectable()\nexport class LoggerMiddleware implements NestMiddleware {\n  async use(req: Request, res: Response, next: Function) {\n    console.log('logger start ' + Date.now());\n    await next();\n    console.log('logger end ' + Date.now());\n  }\n}\n```\n\n## 函数式中间件\n```typescript\nexport function logger(req, res, next) {\n  console.log(`Request...`);\n  next();\n};\n```\n\n## 全局中间件 (只能是函数中间件)\n全局中间件只能是函数中间件，不能是类中间件。如果我们想一次性将中间件绑定到每个注册路由，我们可以使用由`INestApplication`实例提供的 `use()`方法：\n\n```typescript\nconst app = await NestFactory.create(AppModule);\napp.use(logger);\nawait app.listen(3000);\n```\n","isLeaf":true},{"key":"/NodeJS/04 nestjs/13-ExceptionFilters.md","path":"/NodeJS/04 nestjs/13-ExceptionFilters.md","route":"/NodeJS/04 nestjs/13-ExceptionFilters.md","leaf":true,"title":"13-ExceptionFilters","depth":2,"content":"---\ntitle: 13 异常过滤器 ExceptionFilter\ntags: nodejs-nestjs\ncategories: NodeJS\n---\n\n内置的异常层负责处理整个应用程序中的所有抛出的异常。当捕获到未处理的异常时，最终用户将收到友好的响应。\n```typescript\nlogger1-middleware before...\nlogger2-middleware before...\nAuthGuard\nlogger2-middleware after...\nlogger1-middleware after...\n\nLoggingInterceptor Before...\nValidationPipe\nAllExceptionsFilter\n\n# LoggingInterceptor After... 未执行\n```\n\n## 1、默认异常过滤器 \n开箱即用，此操作由内置的全局异常过滤器执行，该过滤器处理类型 HttpException（及其子类）的异常。每个发生的异常都由全局异常过滤器处理, 当这个异常无法被识别时 (既不是 HttpException 也不是继承的类 HttpException ) , 用户将收到以下 JSON 响应:\n```typescript\n{\n    \"statusCode\": 500,\n    \"message\": \"Internal server error\"\n}\n```\n\n## 2、内置HTTP异常\n为了减少样板代码，Nest 提供了一系列继承自核心异常 HttpException 的可用异常。所有这些都可以在 @nestjs/common包中找到：\n\n- BadRequestException\n- UnauthorizedException\n- NotFoundException\n- ForbiddenException\n- NotAcceptableException\n- RequestTimeoutException\n- ConflictException\n- GoneException\n- PayloadTooLargeException\n- UnsupportedMediaTypeException\n- UnprocessableException\n- InternalServerErrorException\n- NotImplementedException\n- BadGatewayException\n- ServiceUnavailableException\n- GatewayTimeoutException\n  \n## 3、自定义异常过滤器\n虽然基本（内置）异常过滤器可以为您自动处理许多情况，但有时您可能希望对异常层拥有**完全控制权**，例如，您可能要添加日志记录或基于一些动态因素使用其他 JSON模式。 **异常过滤器**正是为此目的而设计的。 它们使您可以控制精确的控制流以及将响应的内容发送回客户端。\n\n让我们创建一个异常过滤器，它负责捕获作为HttpException类实例的异常，并为它们设置自定义响应逻辑。为此，我们需要访问底层平台 Request和 Response。我们将访问Request对象，以便提取原始 url并将其包含在日志信息中。我们将使用 Response.json()方法，使用 Response对象直接控制发送的响应。\n\n```typescript\nimport { ExceptionFilter, Catch, ArgumentsHost, HttpException } from '@nestjs/common';\nimport { Request, Response } from 'express';\n\n@Catch(HttpException)\nexport class HttpExceptionFilter implements ExceptionFilter {\n  catch(exception: HttpException, host: ArgumentsHost) {\n    const ctx = host.switchToHttp();\n    const response = ctx.getResponse<Response>();\n    const request = ctx.getRequest<Request>();\n    const status = exception.getStatus();\n\n    response\n      .status(status)\n      .json({\n        statusCode: status,\n        timestamp: new Date().toISOString(),\n        path: request.url,\n      });\n  }\n}\n```\n@Catch() 装饰器绑定所需的元数据到异常过滤器上。它告诉 Nest这个特定的过滤器正在寻找 HttpException 而不是其他的。在实践中，@Catch() 可以传递多个参数，所以你可以通过逗号分隔来为多个类型的异常设置过滤器。\n\n## 4、捕获任意异常\n```typescript\nimport {\n  ExceptionFilter,\n  Catch,\n  ArgumentsHost,\n  HttpException,\n  HttpStatus,\n} from '@nestjs/common';\n\n@Catch()\nexport class AllExceptionsFilter implements ExceptionFilter {\n  catch(exception: unknown, host: ArgumentsHost) {\n    const ctx = host.switchToHttp();\n    const response = ctx.getResponse();\n    const request = ctx.getRequest();\n\n    const status =\n      exception instanceof HttpException\n        ? exception.getStatus()\n        : HttpStatus.INTERNAL_SERVER_ERROR;\n\n    response.status(status).json({\n      statusCode: status,\n      timestamp: new Date().toISOString(),\n      path: request.url,\n    });\n  }\n}\n```\n","isLeaf":true},{"key":"/NodeJS/04 nestjs/14-NestInterceptor.md","path":"/NodeJS/04 nestjs/14-NestInterceptor.md","route":"/NodeJS/04 nestjs/14-NestInterceptor.md","leaf":true,"title":"14-NestInterceptor","depth":2,"content":"---\ntitle: 14 拦截器 (NestInterceptor)\ntags: nodejs-nestjs\ncategories: NodeJS\n---\n\n拦截器是一个用 @Injectable() 装饰器注解并实现 NestInterceptor 接口的类。\n\n![20230606154845](http://s3.airtlab.com/blog/20230606154845.png)\n\n```typescript\nlogger1-middleware before...\nlogger2-middleware before...\nAuthGuard\nlogger2-middleware after...\nlogger1-middleware after...\n\nLoggingInterceptor Before...\nValidationPipe\nLoggingInterceptor After... 1ms\n```\n\n[拦截器具有一组受面向方面编程](https://en.wikipedia.org/wiki/Aspect-oriented_programming)(AOP) 技术启发的有用功能。它们可以：\n\n- 在方法执行之前/之后绑定额外的逻辑\n- 转换从函数返回的结果\n- 转换函数抛出的异常\n- 扩展基本功能行为\n- 根据特定条件完全覆盖函数（例如，出于缓存目的）\n\n## 1、拦截器三部分\n### intercept 方法\n每个拦截器都实现该intercept()方法，该方法接受两个参数。第一个是实例（与[guards](https://docs.nestjs.com/guards)ExecutionContext完全相同的对象）。继承自. 我们之前在异常过滤器章节中看到过。在那里，我们看到它是传递给原始处理程序的参数的包装器，并且包含基于应用程序类型的不同参数数组。您可以参考[异常过滤器](https://docs.nestjs.com/exception-filters#arguments-host)以获取有关此主题的更多信息。ExecutionContextArgumentsHostArgumentsHost\n\n### 执行上下文\n通过扩展ArgumentsHost，ExecutionContext还添加了几个新的辅助方法，这些方法提供了有关当前执行过程的更多详细信息。这些细节有助于构建更通用的拦截器，这些拦截器可以跨广泛的控制器、方法和执行上下文工作。ExecutionContext[在此处](https://docs.nestjs.com/fundamentals/execution-context)了解更多信息。\n\n### 调用处理程序\n第二个参数是一个CallHandler。该CallHandler接口实现了该handle()方法，您可以使用该方法在拦截器中的某个位置调用路由处理程序方法。handle()如果您在方法的实现中不调用该方法intercept()，则根本不会执行路由处理程序方法。\n```typescript\nimport { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';\nimport { Observable } from 'rxjs';\nimport { tap } from 'rxjs/operators';\n\n@Injectable()\nexport class LoggingInterceptor implements NestInterceptor {\n  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {\n    console.log('Before...');\n\n    const now = Date.now();\n    return next\n      .handle()\n      .pipe(\n        tap(() => console.log(`After... ${Date.now() - now}ms`)),\n      );\n  }\n}\n```\n\n### 绑定拦截器\n为了设置拦截器，我们使用从包中@UseInterceptors()导入的装饰器。@nestjs/common像[管道](https://docs.nestjs.com/pipes)和[守卫](https://docs.nestjs.com/guards)一样，拦截器可以是控制器范围的、方法范围的或全局范围的。\n\n```typescript\n@UseInterceptors(LoggingInterceptor)\nexport class CatsController {}\n```\n\n```typescript\nconst app = await NestFactory.create(AppModule);\napp.useGlobalInterceptors(new LoggingInterceptor());\n```\n\n## 2、使用场景\n### Response mapping\n```typescript\nimport { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';\nimport { Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nexport interface Response<T> {\n  data: T;\n}\n\n@Injectable()\nexport class TransformInterceptor<T> implements NestInterceptor<T, Response<T>> {\n  intercept(context: ExecutionContext, next: CallHandler): Observable<Response<T>> {\n    return next.handle().pipe(map(data => ({ data })));\n  }\n}\n```\n### Exception mapping\n```typescript\nimport {\n  Injectable,\n  NestInterceptor,\n  ExecutionContext,\n  BadGatewayException,\n  CallHandler,\n} from '@nestjs/common';\nimport { Observable, throwError } from 'rxjs';\nimport { catchError } from 'rxjs/operators';\n\n@Injectable()\nexport class ErrorsInterceptor implements NestInterceptor {\n  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {\n    return next\n      .handle()\n      .pipe(\n        catchError(err => throwError(() => new BadGatewayException())),\n      );\n  }\n}\n```\n\n### More operators\n```typescript\nimport { Injectable, NestInterceptor, ExecutionContext, CallHandler, RequestTimeoutException } from '@nestjs/common';\nimport { Observable, throwError, TimeoutError } from 'rxjs';\nimport { catchError, timeout } from 'rxjs/operators';\n\n@Injectable()\nexport class TimeoutInterceptor implements NestInterceptor {\n  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {\n    return next.handle().pipe(\n      timeout(5000),\n      catchError(err => {\n        if (err instanceof TimeoutError) {\n          return throwError(() => new RequestTimeoutException());\n        }\n        return throwError(() => err);\n      }),\n    );\n  };\n};\n```\n","isLeaf":true},{"key":"/NodeJS/04 nestjs/15-Guard.md","path":"/NodeJS/04 nestjs/15-Guard.md","route":"/NodeJS/04 nestjs/15-Guard.md","leaf":true,"title":"15-Guard","depth":2,"content":"---\ntitle: 15 守卫 Guard\ntags: nodejs-nestjs\ncategories: NodeJS\n---\n\n守卫是一个使用 `@Injectable()` 装饰器的类。 守卫应该实现 `CanActivate` 接口。\n\n![20230606155201](http://s3.airtlab.com/blog/20230606155201.png)\n\n守卫有一个单独的责任。它们根据运行时出现的某些条件（例如权限，角色，访问控制列表等）来确定给定的请求是否由路由处理程序处理。 这通常称为授权。在传统的 `Express` 应用程序中，通常由中间件处理授权。中间件是身份验证的良好选择。到目前为止，访问限制逻辑大多在中间件内。这样很好，因为诸如 `token` 验证或将 `request` 对象附加属性与特定路由没有强关联。\n\n中间件不知道调用 `next()` 函数后会执行哪个处理程序。另一方面，警卫可以访问 `ExecutionContext` 实例，因此确切地知道接下来要执行什么。它们的设计与异常过滤器、管道和拦截器非常相似，目的是让您在请求/响应周期的正确位置插入处理逻辑，并以声明的方式进行插入。这有助于保持代码的简洁和声明性。\n\n## 1、执行时机\n守卫在所有中间件之后执行，但在任何拦截器或管道之前。\n```\nlogger1-middleware before...\nlogger2-middleware before...\nAuthGuard\nlogger2-middleware after...\nlogger1-middleware after...\nValidationPipe \n```\n\n## 2、执行上下文\n该canActivate()函数接受一个参数，即ExecutionContext实例。ExecutionContext继承自ArgumentsHost. ArgumentsHost我们之前在异常过滤器章节中看到过。在上面的示例中，我们只是使用ArgumentsHost之前定义的相同帮助方法来获取对Request对象的引用。有关此主题的更多信息，您可以参考[异常过滤器一章的](https://docs.nestjs.com/exception-filters#arguments-host)参数主机部分。\n\n通过扩展ArgumentsHost，ExecutionContext还添加了几个新的辅助方法，这些方法提供了有关当前执行过程的更多详细信息。这些细节有助于构建更通用的防护，这些防护可以在广泛的控制器、方法和执行上下文中工作。ExecutionContext[在此处](https://docs.nestjs.com/fundamentals/execution-context)了解更多信息。\n\n## 3、绑定守卫\n像管道和异常过滤器一样，守卫可以是**控制器范围的**、方法范围的或全局范围的。\n\n## 4、基于角色的身份验证\n```typescript\nimport { SetMetadata } from '@nestjs/common';\nexport const Roles = (...roles: string[]) => SetMetadata('roles', roles);\n```\n\n```typescript\n@Post()\n@Roles('admin')\nasync create(@Body() createCatDto: CreateCatDto) {\n  this.catsService.create(createCatDto);\n}\n```\n\n```typescript\nimport { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';\nimport { Reflector } from '@nestjs/core';\n\n@Injectable()\nexport class RolesGuard implements CanActivate {\n  constructor(private reflector: Reflector) {}\n\n  canActivate(context: ExecutionContext): boolean {\n    const roles = this.reflector.get<string[]>('roles', context.getHandler());\n    if (!roles) {\n      return true;\n    }\n    const request = context.switchToHttp().getRequest();\n    const user = request.user;\n    return matchRoles(roles, user.roles);\n  }\n}\n```\n","isLeaf":true},{"key":"/NodeJS/04 nestjs/16-PipeTransform.md","path":"/NodeJS/04 nestjs/16-PipeTransform.md","route":"/NodeJS/04 nestjs/16-PipeTransform.md","leaf":true,"title":"16-PipeTransform","depth":2,"content":"---\ntitle: 16 数据转换管道 PipeTransform\ntags: nodejs-nestjs\ncategories: NodeJS\n---\n\n管道是具有 `@Injectable()` 装饰器的类。管道应实现 `PipeTransform` 接口，管道有两个类型:\n\n- 转换：管道将输入数据转换为所需的数据输出\n- 验证：对输入数据进行验证，如果验证成功继续传递; 验证失败则抛出异常;\n\n在这两种情况下, 管道 `参数(arguments)` 会由 [控制器(controllers)的路由处理程序](https://docs.nestjs.cn/7/controllers?id=%e8%b7%af%e7%94%b1%e5%8f%82%e6%95%b0) 进行处理. Nest 会在调用这个方法之前插入一个管道，管道会先拦截方法的调用参数，进行转换或是验证处理，然后用转换好或是验证好的参数调用原方法。\n\n> 管道在异常区域内运行。这意味着当抛出异常时，它们由核心异常处理程序和应用于当前上下文的 [异常过滤器](https://docs.nestjs.cn/7/exceptionfilters) 处理。当在 Pipe 中发生异常，controller 不会继续执行任何方法。\n\n```typescript\nimport { Type } from '../type.interface';\nimport { Paramtype } from './paramtype.interface';\nexport declare type Transform<T = any> = (value: T, metadata: ArgumentMetadata) => any;\n/**\n * Interface describing a pipe implementation's `transform()` method metadata argument.\n *\n * @see [Pipes](https://docs.nestjs.com/pipes)\n *\n * @publicApi\n */\nexport interface ArgumentMetadata {\n    /**\n     * Indicates whether argument is a body, query, param, or custom parameter\n     */\n    readonly type: Paramtype;\n    /**\n     * Underlying base type (e.g., `String`) of the parameter, based on the type\n     * definition in the route handler.\n     */\n    readonly metatype?: Type<any> | undefined;\n    /**\n     * String passed as an argument to the decorator.\n     * Example: `@Body('userId')` would yield `userId`\n     */\n    readonly data?: string | undefined;\n}\n\n/**\n * Interface describing implementation of a pipe.\n *\n * @see [Pipes](https://docs.nestjs.com/pipes)\n *\n * @publicApi\n */\nexport interface PipeTransform<T = any, R = any> {\n  /**\n   * Method to implement a custom pipe.  Called with two parameters\n   *\n   * @param value argument before it is received by route handler method\n   * @param metadata contains metadata about the value\n   */\n  transform(value: T, metadata: ArgumentMetadata): R;\n}\n```\n\n## 1、内置管道\nNest 有九个开箱即用的管道：\n- ValidationPipe\n- ParseIntPipe\n- ParseFloatPipe\n- ParseBoolPipe\n- ParseArrayPipe\n- ParseUUIDPipe\n- ParseEnumPipe\n- DefaultValuePipe\n- ParseFilePipe\n\n它们是从@nestjs/common包中导出的。让我们快速浏览一下使用 ParseIntPipe. 这是转换用例的示例，其中管道确保将方法处理程序参数转换为 JavaScript 整数（或在转换失败时引发异常）。\n\n## 2、绑定管道\n要使用管道，我们需要将管道类的实例绑定到适当的上下文。在我们的 ParseIntPipe 示例中，我们希望将管道与特定的路由处理程序方法相关联，并确保它在调用该方法之前运行。\n\n### 2.1 方法参数级别绑定管道\n```typescript\n@Get()\nasync findOne(@Query('id', ParseIntPipe) id: number) {\n  return this.catsService.findOne(id);\n}\n```\n\n### 2.2 方法调用级别绑定管道\n这样会校验每个参数\n```typescript\n@Get()\n@UsePipes(ParseIntPipe)\nasync findOne(@Query('id') id: number, @Query('age') age: number) {\n  return this.catsService.findOne(id);\n}\n```\n\n## 3、同步和异步管道\nNest 同时支持同步和异步管道，提升程序的灵活性。\n\n## 4、自定义管道\n```typescript\nimport { PipeTransform, Injectable, ArgumentMetadata } from '@nestjs/common';\n\n@Injectable()\nexport class ValidationPipe implements PipeTransform {\n  transform(value: any, metadata: ArgumentMetadata) {\n    console.log(222)\n    return value;\n  }\n}\n```\n\n```typescript\n@Get(':id')\nasync findOne(@Param('id', ValidationPipe) id: number) {\n  console.log(id)\n}\n```\n\n## 5、模式验证\n```typescript\nimport { PipeTransform, Injectable, ArgumentMetadata, BadRequestException } from '@nestjs/common';\nimport { ObjectSchema } from 'joi';\n\n@Injectable()\nexport class JoiValidationPipe implements PipeTransform {\n  constructor(private schema: ObjectSchema) {}\n\n  transform(value: any, metadata: ArgumentMetadata) {\n    const { error } = this.schema.validate(value);\n    if (error) {\n      throw new BadRequestException('Validation failed');\n    }\n    return value;\n  }\n}\n```\n\n```typescript\n@Get('user')\n@UsePipes(new JoiValidationPipe(createCatSchema))\nasync queryUser(@Query() query: any) {\n  console.log(query)\n}\n```\n\n## 6、class-validator\n```typescript\nimport { PipeTransform, Injectable, ArgumentMetadata, BadRequestException } from '@nestjs/common';\nimport { validate } from 'class-validator';\nimport { plainToInstance } from 'class-transformer';\n\n@Injectable()\nexport class ValidationPipe implements PipeTransform<any> {\n  async transform(value: any, { metatype }: ArgumentMetadata) {\n    console.log(value, metatype)\n    if (!metatype || !this.toValidate(metatype)) {\n      return value;\n    }\n    const object = plainToInstance(metatype, value);\n    console.log(object)\n    const errors = await validate(object);\n    if (errors.length > 0) {\n      throw new BadRequestException('Validation failed');\n    }\n    return value;\n  }\n\n  private toValidate(metatype: Function): boolean {\n    const types: Function[] = [String, Boolean, Number, Array, Object];\n    return !types.includes(metatype);\n  }\n}\n```\n\n```typescript\nimport {\n  Controller,\n  Get,\n  Query,\n} from '@nestjs/common';\nimport { AppService } from './app.service';\nimport { ValidationPipe } from './ValidationPipe';\nimport { IsString, IsInt } from 'class-validator';\n\nclass CreateCatDto {\n  @IsString()\n  name: string;\n\n  @IsInt()\n  age: number;\n}\n\n@Controller()\nexport class AppController {\n  constructor(private readonly appService: AppService) {}\n\n  @Get()\n  async create(@Query(new ValidationPipe()) createCatDto: CreateCatDto) {\n    console.log(createCatDto)\n  }\n}\n```\n\n## 7、全局范围的管道\n由于 ValidationPipe 创建的尽可能通用，我们可以通过将其设置为 **全局范围的** 管道来实现它的完整实用程序，以便将其应用于整个应用程序中的每个路由处理程序。\n```typescript\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n  app.useGlobalPipes(new ValidationPipe());\n  await app.listen(3000);\n}\n\nbootstrap();\n```\n\n## 8、内置的 ValidationPipe\n提醒一下，您不必自己构建通用验证管道，因为它 ValidationPipe 是由 Nest 开箱即用提供的。内置 ValidationPipe 提供了比我们在本章中构建的示例更多的选项，为了说明定制管道的机制，我们一直保持基本。[您可以在此处](https://docs.nestjs.com/techniques/validation)找到完整的详细信息以及大量示例。","isLeaf":true},{"key":"/NodeJS/04 nestjs/17-Circular-dependency.md","path":"/NodeJS/04 nestjs/17-Circular-dependency.md","route":"/NodeJS/04 nestjs/17-Circular-dependency.md","leaf":true,"title":"17-Circular-dependency","depth":2,"content":"---\ntags: nodejs-nestjs\ncategories: NodeJS\n---\n\nforwardRef\n\n```typescript\n@Injectable()\nexport class CatsService {\n  constructor(\n    @Inject(forwardRef(() => CommonService))\n    private commonService: CommonService,\n  ) {}\n}\n```\n\n```typescript\n@Injectable()\nexport class CommonService {\n  constructor(\n    @Inject(forwardRef(() => CatsService))\n    private catsService: CatsService,\n  ) {}\n}\n```\n","isLeaf":true},{"key":"/NodeJS/04 nestjs/18-ModuleRef.md","path":"/NodeJS/04 nestjs/18-ModuleRef.md","route":"/NodeJS/04 nestjs/18-ModuleRef.md","leaf":true,"title":"18-ModuleRef","depth":2,"content":"---\ntags: nodejs-nestjs\ncategories: NodeJS\n---\n\n通过 ModuleRef 来查找 provider 而不需要在构造函数中依赖注入\n\n```typescript\nimport { forwardRef, Inject, Injectable } from \"@nestjs/common\";\nimport { ModuleRef } from \"@nestjs/core\";\nimport { CommonService } from \"./common.service\";\n\n@Injectable()\nexport class CatsService {\n  constructor(\n    // @Inject(forwardRef(() => CommonService))\n    // private commonService: CommonService,\n\n    private moduleRef: ModuleRef,\n  ) {\n    \n  }\n\n  test () {\n    const s = this.moduleRef.get(CommonService)\n    s.test()\n  }\n}\n```\n\n```typescript\nimport { forwardRef, Inject, Injectable } from \"@nestjs/common\";\nimport { CatsService } from \"./cats.service\";\n\n@Injectable()\nexport class CommonService {\n  constructor(\n    @Inject(forwardRef(() => CatsService))\n    private catsService: CatsService,\n  ) {}\n\n  test () {\n    console.log('common')\n  }\n}\n```\n","isLeaf":true},{"key":"/NodeJS/04 nestjs/19-Context.md","path":"/NodeJS/04 nestjs/19-Context.md","route":"/NodeJS/04 nestjs/19-Context.md","leaf":true,"title":"19-Context","depth":2,"content":"---\ntags: nodejs-nestjs\ncategories: NodeJS\n---\n\n## 1、ArgumentsHost\n```typescript\nexport interface ArgumentsHost {\n  /**\n   * Returns the array of arguments being passed to the handler.\n   */\n  getArgs<T extends Array<any> = any[]>(): T;\n  /**\n   * Returns a particular argument by index.\n   * @param index index of argument to retrieve\n   */\n  getArgByIndex<T = any>(index: number): T;\n  /**\n   * Switch context to RPC.\n   * @returns interface with methods to retrieve RPC arguments\n   */\n  switchToRpc(): RpcArgumentsHost;\n  /**\n   * Switch context to HTTP.\n   * @returns interface with methods to retrieve HTTP arguments\n   */\n  switchToHttp(): HttpArgumentsHost;\n  /**\n   * Switch context to WebSockets.\n   * @returns interface with methods to retrieve WebSockets arguments\n   */\n  switchToWs(): WsArgumentsHost;\n  /**\n   * Returns the current execution context type (string)\n   */\n  getType<TContext extends string = ContextType>(): TContext;\n}\n```\n\n```typescript\nexport interface RpcArgumentsHost {\n  /**\n   * Returns the data object.\n   */\n  getData<T = any>(): T;\n  /**\n   * Returns the context object.\n   */\n  getContext<T = any>(): T;\n}\n```\n\n```typescript\nexport interface HttpArgumentsHost {\n  /**\n   * Returns the in-flight `request` object.\n   */\n  getRequest<T = any>(): T;\n  /**\n   * Returns the in-flight `response` object.\n   */\n  getResponse<T = any>(): T;\n  getNext<T = any>(): T;\n}\n```\n\n```typescript\nexport interface WsArgumentsHost {\n    /**\n     * Returns the data object.\n     */\n    getData<T = any>(): T;\n    /**\n     * Returns the client object.\n     */\n    getClient<T = any>(): T;\n}\n```\n\n## 2、ExecutionContext\n```typescript\nconst ctx = host.switchToHttp();\nconst request = ctx.getRequest<Request>();\nconst response = ctx.getResponse<Response>();\n```\n\n### 获取当前 controller\n```typescript\nexport interface ExecutionContext extends ArgumentsHost {\n  /**\n   * Returns the *type* of the controller class which the current handler belongs to.\n   */\n  getClass<T = any>(): Type<T>;\n  /**\n   * Returns a reference to the handler (method) that will be invoked next in the\n   * request pipeline.\n   */\n  getHandler(): Function;\n}\n```\n\n### 获取当前 getHandler\n```typescript\nexport interface ExecutionContext extends ArgumentsHost {\n  /**\n   * Returns the *type* of the controller class which the current handler belongs to.\n   */\n  getClass<T = any>(): Type<T>;\n  /**\n   * Returns a reference to the handler (method) that will be invoked next in the\n   * request pipeline.\n   */\n  getHandler(): Function;\n}\n```\n","isLeaf":true},{"key":"/NodeJS/04 nestjs/20-bootstrap.md","path":"/NodeJS/04 nestjs/20-bootstrap.md","route":"/NodeJS/04 nestjs/20-bootstrap.md","leaf":true,"title":"20-bootstrap","depth":2,"content":"---\ntags: nodejs-nestjs\ncategories: NodeJS\n---\n\n## 1、执行顺序\n下图描述了关键应用程序生命周期事件的顺序，从应用程序启动到节点进程退出。我们可以将整个生命周期分为三个阶段：初始化、运行和终止。使用此生命周期，您可以计划模块和服务的适当初始化，管理活动连接，并在收到终止信号时正常关闭应用程序。\n\n![20230606160440](http://s3.airtlab.com/blog/20230606160440.png)\n\n## 2、钩子函数\n\n在下表中 onModuleDestroy，beforeApplicationShutdown 和 onApplicationShutdown 仅在您显式调用app.close() 或 进程接收到特殊系统信号（例如 SIGTERM）并且您 enableShutdownHooks 在应用程序引导时正确调用时才会触发\n\n| 生命周期钩子方法 | 触发钩子方法调用的生命周期事件 |\n| --- | --- |\n| onModuleInit() | 解析主机模块的依赖关系后调用。 |\n| onApplicationBootstrap() | 一旦所有模块都被初始化，但在监听连接之前调用。 |\n| onModuleDestroy()* | 在接收到终止信号（例如 ）后调用SIGTERM。 |\n| beforeApplicationShutdown()* | onModuleDestroy()在所有处理程序完成后调用（承诺已解决或被拒绝）；\n一旦完成（承诺解决或拒绝），所有现有连接将被关闭（app.close()调用）。 |\n| onApplicationShutdown()* | 在连接关闭（app.close()解析）后调用。 |\n\n### 使用钩子\n```typescript\nimport { Injectable, OnModuleInit } from '@nestjs/common';\n\n@Injectable()\nexport class UsersService implements OnModuleInit {\n  onModuleInit() {\n    console.log(`The module has been initialized.`);\n  }\n}\n```\n\n### 异步逻辑\nOnModuleInit和钩子都OnApplicationBootstrap允许您延迟应用程序初始化过程（在方法主体中返回Promise或标记方法async和await异步方法完成）。\n\n```typescript\nasync onModuleInit(): Promise<void> {\n  await this.fetch();\n}\n```","isLeaf":true},{"key":"/NodeJS/04 nestjs/21-浅谈NestJS设计思想.md","path":"/NodeJS/04 nestjs/21-浅谈NestJS设计思想.md","route":"/NodeJS/04 nestjs/21-浅谈NestJS设计思想.md","leaf":true,"title":"21-浅谈NestJS设计思想","depth":2,"content":"https://justin3go.com/%E5%8D%9A%E5%AE%A2/2023/01/25%E6%B5%85%E8%B0%88NestJS%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3.html","isLeaf":true}]},{"key":"/NodeJS/05 prisma","path":"/NodeJS/05 prisma","route":"/NodeJS/05 prisma","leaf":false,"title":"05 prisma","depth":1,"content":"","isLeaf":false,"children":[{"key":"/NodeJS/05 prisma/01-prisma-usage.md","path":"/NodeJS/05 prisma/01-prisma-usage.md","route":"/NodeJS/05 prisma/01-prisma-usage.md","leaf":true,"title":"01-prisma-usage","depth":2,"content":"## 1、prisma 用法\n\n- quick-start https://www.prisma.io/docs/getting-started/quickstart\n- https://dev.to/inezabonte/setting-up-a-mysql-database-using-prisma-2869\n- 《面向 Node.js 和 TypeScript 的下一代 ORM 工具 Prisma》 https://www.justsoso.tech/default/prisma-without-foreignKey.html\n\n## 2、prisma 工程初始化\n\n假设已经存在一个目录，确保安装了 `typescript ts-node @types/node prisma`\n\n**初始化**\n\n```\nnpx prisma init --datasource-provider mysql\n```\n\n## 3、prisma schema\n\n```prisma\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\ndatasource db {\n  provider = \"mysql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel user {\n  id   Int     @id @default(autoincrement()) @db.UnsignedInt\n  name String? @default(\"\") @db.VarChar(255)\n}\n\nmodel post {\n  id        Int     @id @default(autoincrement())\n  title     String\n  content   String?\n  published Boolean @default(false)\n  uid       Int\n}\n```\n\n## 4、增删改查\n\n### 1) create\n\n```ts\nimport { PrismaClient } from \"@prisma/client\";\n\nconst prisma = new PrismaClient();\n\nasync function main() {\n  const user = await prisma.user.create({\n    data: {\n      name: \"Alice\",\n    },\n  });\n  console.log(user);\n}\n\nmain()\n  .then(async () => {\n    await prisma.$disconnect();\n  })\n  .catch(async (e) => {\n    console.error(e);\n    await prisma.$disconnect();\n    process.exit(1);\n  });\n```\n\n### 2) findMany\n```ts\nimport { PrismaClient } from '@prisma/client';\n\nconst prisma = new PrismaClient();\n\n// query\nasync function main() {\n  const users = await prisma.user.findMany({})\n  console.log(users)\n}\n\nmain()\n  .then(async () => {\n    await prisma.$disconnect();\n  })\n  .catch(async (e) => {\n    console.error(e);\n    await prisma.$disconnect();\n    process.exit(1);\n  });\n\n```\n\n### 3) create  with relation\n\n```ts\nimport { PrismaClient } from '@prisma/client';\n\nconst prisma = new PrismaClient();\n\nasync function main() {\n  const user = await prisma.user.create({\n    data: {\n      name: 'Bob',\n      post: {\n        create: {\n          title: 'Hello World',\n        },\n      },\n    },\n  });\n  console.log(user);\n}\n\nmain()\n  .then(async () => {\n    await prisma.$disconnect();\n  })\n  .catch(async (e) => {\n    console.error(e);\n    await prisma.$disconnect();\n    process.exit(1);\n  });\n\n```\n\n### 4) query with relation\n```ts\nimport { PrismaClient } from '@prisma/client';\n\nconst prisma = new PrismaClient();\n\n// query\nasync function main() {\n  const users = await prisma.user.findMany({\n    take: 10,\n    skip: 1,\n    include: {\n      post: true\n    },\n  })\n  console.dir(users, { depth: null })\n}\n\nmain()\n  .then(async () => {\n    await prisma.$disconnect();\n  })\n  .catch(async (e) => {\n    console.error(e);\n    await prisma.$disconnect();\n    process.exit(1);\n  });\n```\n\n### 5) logger\n\n```ts\nimport { Prisma, PrismaClient } from '@prisma/client';\n\nconst prisma = new PrismaClient({\n  log: ['query', 'error', 'info', 'warn']\n});\n\n\n// query\nasync function main() {\n  const res = await prisma.$queryRaw(Prisma.sql`select * from user`);\n  console.log(res)\n\n  const users = await prisma.user.findMany({\n    take: 10,\n    skip: 1,\n    include: {\n      post: true\n    },\n  })\n  console.dir(users, { depth: null })\n}\n\nmain()\n  .then(async () => {\n    await prisma.$disconnect();\n  })\n  .catch(async (e) => {\n    console.error(e);\n    await prisma.$disconnect();\n    process.exit(1);\n  });\n\n```\n\n### 6) $queryRaw\n\n```ts\nimport { Prisma, PrismaClient } from '@prisma/client';\n\nconst prisma = new PrismaClient({\n  log: ['query', 'error', 'info', 'warn']\n});\n\n// query\nasync function main() {\n  const res = await prisma.$queryRaw(Prisma.sql`select * from user`);\n  console.log(res)\n}\n\nmain()\n  .then(async () => {\n    await prisma.$disconnect();\n  })\n  .catch(async (e) => {\n    console.error(e);\n    await prisma.$disconnect();\n    process.exit(1);\n  });\n```\n\n## 5、prisma 命令\n\n**创建 diff 并且同步到远程 db**\n\n```\nnpx prisma migrate dev\n```\n\n**将远程 db 的结构同步到本地，这可能会导致本地一些 relation 丢失**\n\n```\nnpx prisma db pull\n```\n\n**ddl diff**\n\n```\nnpx prisma migrate diff \\\n  --from-url \"mysql://root:123456@localhost:3306/test\"  \\\n  --to-url \"mysql://root:123456@localhost:3306/test_2\" \\\n  --script\n```","isLeaf":true}]},{"key":"/NodeJS/06 some code","path":"/NodeJS/06 some code","route":"/NodeJS/06 some code","leaf":false,"title":"06 some code","depth":1,"content":"","isLeaf":false,"children":[{"key":"/NodeJS/06 some code/01-gen-dic-tree.md","path":"/NodeJS/06 some code/01-gen-dic-tree.md","route":"/NodeJS/06 some code/01-gen-dic-tree.md","leaf":true,"title":"01-gen-dic-tree","depth":2,"content":"---\ntitle: 01 目录树转 JSON\ntoc: true\ntags: nodejs-scripts\ncategories: NodeJS\n---\n\n```js\nconst fs = require(\"fs\");\nconst path = require(\"path\");\n\nconst rootPath = path.resolve(\"/Users/user/Desktop/gaollard-blog/docs/pages\");\nconst rootNode = new Node(rootPath, rootPath, false);\n\nfunction Node(path, route, title, depth, leaf) {\n  this.path = path;\n  this.route = route;\n  this.leaf = leaf;\n  this.title = title;\n  this.depth = depth;\n  if (!this.leaf) {\n    this.children = [];\n  }\n}\n\nfunction read(sPath, parent, depth) {\n  const files = fs.readdirSync(sPath);\n  files.forEach((file) => {\n    const cPath = sPath + \"/\" + file;\n    const stats = fs.statSync(cPath);\n    const { name, ext } = path.parse(file);\n\n    if (stats.isDirectory()) {\n      const node = new Node(\n        cPath,\n        cPath.replace(rootPath, \"\"),\n        name,\n        depth,\n        false\n      );\n      parent.children.push(node);\n      read(cPath, node, depth + 1);\n    } else {\n      if (ext == '.md') {\n        const node = new Node(\n          cPath,\n          cPath.replace(rootPath, \"\"),\n          name,\n          depth,\n          true\n        );\n        parent.children.push(node);\n      }\n    }\n  });\n}\n\nread(rootPath, rootNode, 0);\n\nfs.writeFileSync(\"src/routes.json\", JSON.stringify(rootNode.children));\n\nconsole.dir(rootNode, { depth: 6 });\n```\n\n```json\n[\n   {\n    \"path\": \"docs/pages/android\",\n    \"route\": \"/android\",\n    \"leaf\": false,\n    \"title\": \"android\",\n    \"depth\": 0,\n    \"children\": [\n      {\n        \"path\": \"docs/pages/android/01-use-javascriptcore.md\",\n        \"route\": \"/android/01-use-javascriptcore.md\",\n        \"leaf\": true,\n        \"title\": \"01-use-javascriptcore\",\n        \"depth\": 1\n      },\n      {\n        \"path\": \"docs/pages/android/02-react-native.md\",\n        \"route\": \"/android/02-react-native.md\",\n        \"leaf\": true,\n        \"title\": \"02-react-native\",\n        \"depth\": 1\n      },\n      {\n        \"path\": \"docs/pages/android/03-use-quickjs.md\",\n        \"route\": \"/android/03-use-quickjs.md\",\n        \"leaf\": true,\n        \"title\": \"03-use-quickjs\",\n        \"depth\": 1\n      }\n    ]\n  },\n  {\n    \"path\": \"docs/pages/backend\",\n    \"route\": \"/backend\",\n    \"leaf\": false,\n    \"title\": \"backend\",\n    \"depth\": 0,\n    \"children\": [\n      {\n        \"path\": \"docs/pages/backend/01-mysql\",\n        \"route\": \"/backend/01-mysql\",\n        \"leaf\": false,\n        \"title\": \"01-mysql\",\n        \"depth\": 1,\n        \"children\": [\n          {\n            \"path\": \"docs/pages/backend/01-mysql/01-query-on-tcp.md\",\n            \"route\": \"/backend/01-mysql/01-query-on-tcp.md\",\n            \"leaf\": true,\n            \"title\": \"01-query-on-tcp\",\n            \"depth\": 2\n          },\n          {\n            \"path\": \"docs/pages/backend/01-mysql/02-mysql-utilities.md\",\n            \"route\": \"/backend/01-mysql/02-mysql-utilities.md\",\n            \"leaf\": true,\n            \"title\": \"02-mysql-utilities\",\n            \"depth\": 2\n          },\n          {\n            \"path\": \"docs/pages/backend/01-mysql/03-mysql-workbench.md\",\n            \"route\": \"/backend/01-mysql/03-mysql-workbench.md\",\n            \"leaf\": true,\n            \"title\": \"03-mysql-workbench\",\n            \"depth\": 2\n          },\n          {\n            \"path\": \"docs/pages/backend/01-mysql/04-get-db-used-size.md\",\n            \"route\": \"/backend/01-mysql/04-get-db-used-size.md\",\n            \"leaf\": true,\n            \"title\": \"04-get-db-used-size\",\n            \"depth\": 2\n          },\n          {\n            \"path\": \"docs/pages/backend/01-mysql/是多大.md\",\n            \"route\": \"/backend/01-mysql/是多大.md\",\n            \"leaf\": true,\n            \"title\": \"是多大\",\n            \"depth\": 2\n          }\n        ]\n      },\n      {\n        \"path\": \"docs/pages/backend/02-redis\",\n        \"route\": \"/backend/02-redis\",\n        \"leaf\": false,\n        \"title\": \"02-redis\",\n        \"depth\": 1,\n        \"children\": [\n          {\n            \"path\": \"docs/pages/backend/02-redis/01-Failed-to-refresh-slots-cache.md\",\n            \"route\": \"/backend/02-redis/01-Failed-to-refresh-slots-cache.md\",\n            \"leaf\": true,\n            \"title\": \"01-Failed-to-refresh-slots-cache\",\n            \"depth\": 2\n          }\n        ]\n      }\n    ]\n  },\n]\n```","isLeaf":true},{"key":"/NodeJS/06 some code/02-gen-dict-recursive.md","path":"/NodeJS/06 some code/02-gen-dict-recursive.md","route":"/NodeJS/06 some code/02-gen-dict-recursive.md","leaf":true,"title":"02-gen-dict-recursive","depth":2,"content":"---\ntitle: 02 创建多层目录\ntoc: true\ntags: nodejs-scripts\ncategories: NodeJS\n---\n\n```js\nconst fs = require(\"fs\");\n\nvar dir = \"/Users/user/Desktop/gaollard-blog/t1/t2/t3.md\";\n\nfunction createDir(dir, prev) {\n  const list = dir.split(\"/\").filter((el) => el);\n  const [first, ...arg] = list;\n  const _dir = `${prev || \"\"}/${first}`;\n\n  try {\n    const stat = fs.statSync(_dir);\n  } catch (e) {\n    fs.mkdirSync(_dir);\n  }\n\n  if (arg.length) {\n    createDir(arg.join(\"/\"), _dir);\n  }\n}\n\ncreateDir(dir);\n```","isLeaf":true},{"key":"/NodeJS/06 some code/03-check-dic-exist.md","path":"/NodeJS/06 some code/03-check-dic-exist.md","route":"/NodeJS/06 some code/03-check-dic-exist.md","leaf":true,"title":"03-check-dic-exist","depth":2,"content":"---\ntitle: 03 检测目录是否存在\ntoc: true\ntags: nodejs-scripts\ncategories: NodeJS\n---\n\n```js\nconst fs = require('fs')\nconst path = require('path')\nconst os = require('os')\n\ntry {\n  const rootPath = path.resolve(os.homedir(), 'yunqu1/docs')\n  const stat1 = fs.statSync(rootPath)\n  console.log(stat1)\n} catch (e) {\n  // 不存在会报错\n  console.log(e)\n}\n```\n\n或者 \n\n```javascript\nconst fs = require('fs');\nconst path = './my-directory';\n\nif (fs.existsSync(path)) {\n  console.log('目录存在');\n} else {\n  console.log('目录不存在');\n}\n```","isLeaf":true}]},{"key":"/NodeJS/07 pm2","path":"/NodeJS/07 pm2","route":"/NodeJS/07 pm2","leaf":false,"title":"07 pm2","depth":1,"content":"","isLeaf":false,"children":[{"key":"/NodeJS/07 pm2/pm2.md","path":"/NodeJS/07 pm2/pm2.md","route":"/NodeJS/07 pm2/pm2.md","leaf":true,"title":"pm2","depth":2,"content":"","isLeaf":true}]},{"key":"/NodeJS/08 graphql","path":"/NodeJS/08 graphql","route":"/NodeJS/08 graphql","leaf":false,"title":"08 graphql","depth":1,"content":"","isLeaf":false,"children":[{"key":"/NodeJS/08 graphql/index.md","path":"/NodeJS/08 graphql/index.md","route":"/NodeJS/08 graphql/index.md","leaf":true,"title":"index","depth":2,"content":"## 学习资料\n《 拉钩教育  GraphQL 教程》https://www.bilibili.com/video/BV1fb4y117ya","isLeaf":true}]},{"key":"/NodeJS/09 grpc","path":"/NodeJS/09 grpc","route":"/NodeJS/09 grpc","leaf":false,"title":"09 grpc","depth":1,"content":"","isLeaf":false,"children":[{"key":"/NodeJS/09 grpc/index.md","path":"/NodeJS/09 grpc/index.md","route":"/NodeJS/09 grpc/index.md","leaf":true,"title":"index","depth":2,"content":"## 学习资料\nhttps://grpc.io/docs/languages/node/quickstart/","isLeaf":true}]},{"key":"/NodeJS/10 middleware","path":"/NodeJS/10 middleware","route":"/NodeJS/10 middleware","leaf":false,"title":"10 middleware","depth":1,"content":"","isLeaf":false,"children":[{"key":"/NodeJS/10 middleware/01-body-parser.md","path":"/NodeJS/10 middleware/01-body-parser.md","route":"/NodeJS/10 middleware/01-body-parser.md","leaf":true,"title":"01-body-parser","depth":2,"content":"- 预备知识：熟悉 express 的中间件逻辑\n- 阅读时间：30min\n\n## 1. body-parser 解决什么问题\n在 node http 模块中，您只能通过 data 事件，以 buffer 的形式来获取请求体内容，node 没有提供如何解析请求 body 的API，[body-parser](https://www.npmjs.com/package/body-parser) 提供了这个功能。\n\nbody-parser 本质是一个处理请求 body 的中间件函数，他负责按照您给的规则解析请求body，并且将结果赋值到 req.body 属性上。\n\n## 2. 简单的使用 body-parser\n```javascript\nvar express = require('express')\nvar bodyParser = require('body-parser')\n \nvar app = express()\n \n// parse application/x-www-form-urlencoded\napp.use(bodyParser.urlencoded({ extended: false }))\n \n// parse application/json\napp.use(bodyParser.json())\n \napp.use(function (req, res) {\n  res.setHeader('Content-Type', 'text/plain')\n  res.write('you posted:\\n')\n  \n  // 您可以通过req.body 来访问请求体内容\n  res.end(JSON.stringify(req.body, null, 2))\n})\n```\n\n通过这个例子您可以了解到如何简单的使用 body-parser。\n\n## 3. 源码分析\n\n首先 bodyParser 的源码结构如下：\n\n![20230605002602](http://s3.airtlab.com/blog/20230605002602.png)\n\n- index.js：入口文件\n- lib：核心方法\n   - types：该文件下的4个文件，分别用于解析对应的4个类型\n      - json.js：将body解析为JSON对象\n      - raw.js\n      - text.js：将body解析为字符串\n      - urlencoded.js：将表单数据(urlencoded编码)解析为JSON对象\n   - read.js：读取 body 内容\n\n### 1. bodyParser的导出形式\n\nbodyParser 的定义在 index.js，这里的逻辑非常清晰：\n\n- 创建一个用于解析 json 和 urlencoded 格式的中间件：bodyParser 并导出\n- 给 bodyParser 添加 json/text/raw/urlencoded 方法\n```javascript\n'use strict'\n\nvar deprecate = require('depd')('body-parser')\n\n// 缓存 parser \nvar parsers = Object.create(null)\n\n// 导出一个Function\nexports = module.exports = deprecate.function(bodyParser,\n  'bodyParser: use individual json/urlencoded middlewares')\n\n// JSON parser.\nObject.defineProperty(exports, 'json', {\n  configurable: true,\n  enumerable: true,\n  get: createParserGetter('json')\n})\n\n// Raw parser.\nObject.defineProperty(exports, 'raw', {\n  configurable: true,\n  enumerable: true,\n  get: createParserGetter('raw')\n})\n\n// Text parser.\nObject.defineProperty(exports, 'text', {\n  configurable: true,\n  enumerable: true,\n  get: createParserGetter('text')\n})\n\n// URL-encoded parser.\nObject.defineProperty(exports, 'urlencoded', {\n  configurable: true,\n  enumerable: true,\n  get: createParserGetter('urlencoded')\n})\n\n// 创建一个用于解析 json 和 urlencoded 格式的中间件\nfunction bodyParser (options) {\n  var opts = {}\n\n  // exclude type option\n  if (options) {\n    for (var prop in options) {\n      if (prop !== 'type') {\n        opts[prop] = options[prop]\n      }\n    }\n  }\n\n  var _urlencoded = exports.urlencoded(opts)\n  var _json = exports.json(opts)\n\n  return function bodyParser (req, res, next) {\n    _json(req, res, function (err) {\n      if (err) return next(err)\n      _urlencoded(req, res, next)\n    })\n  }\n}\n\n// Create a getter for loading a parser.\nfunction createParserGetter (name) {\n  return function get () {\n    return loadParser(name)\n  }\n}\n\n// Load a parser module.\nfunction loadParser (parserName) {\n  var parser = parsers[parserName]\n\n  if (parser !== undefined) {\n    return parser\n  }\n\n  // this uses a switch for static require analysis\n  switch (parserName) {\n    case 'json':\n      parser = require('./lib/types/json')\n      break\n    case 'raw':\n      parser = require('./lib/types/raw')\n      break\n    case 'text':\n      parser = require('./lib/types/text')\n      break\n    case 'urlencoded':\n      parser = require('./lib/types/urlencoded')\n      break\n  }\n\n  // store to prevent invoking require()\n  return (parsers[parserName] = parser)\n}\n\n```\n### 2. text 解析流程\n\n将 body 解析非常简单，这只需要将 buffer 转换为 string 即可。 所以从最简单 text parser 开始，其他解析大体也是类似的，主要区别在于将字符串解析到特定格式的方法。比如将表单数据(urlencoded form) 解析为JSON对象。\n\n现在您希望将 text/plain 的请求体解析为一个字符串，源码是这样的：\n\n```javascript\n// 默认将 type 为 text/plain 解析为字符串\nvar express = require('express')\nvar bodyParser = require('body-parser')\n \nvar app = express()\nvar port = 3000;\n \napp.use(bodyParser.text())\n\napp.post('/text', (req, res) => res.send(req.body))\n\napp.listen(port, () => console.log(`\\nExample app listening on port ${port}!`))\n```\n\n当我们 curl 进行如下访操作：\n\n```bash\n$ curl -d \"hello\" http://localhost:3000/text\nhello\n```\n\n这背后的流程是怎样的呢？\n\n#### 1. bodyParser.text() 中间件\n\n由于我们使用 bodyParser.text() 中间件，所以当进行上述访问时，会访问到 lib/types/text，源码如下：\n```javascript\n'use strict'\n\nvar bytes = require('bytes')\nvar contentType = require('content-type')\nvar debug = require('debug')('body-parser:text')\nvar read = require('../read')\nvar typeis = require('type-is')\n\n// 导出 text 中间件\nmodule.exports = text\n\n// text 中间件 定义\nfunction text (options) {\n  // option 是使用该中间件传入的选项\n  var opts = options || {}\n\n\t// 获取字符集\n  var defaultCharset = opts.defaultCharset || 'utf-8'\n \n  // 是否处理压缩的body, true时body会被解压，false时body不会被处理\n  var inflate = opts.inflate !== false\n  \n  // body大小限制\n  var limit = typeof opts.limit !== 'number'\n    ? bytes.parse(opts.limit || '100kb')\n    : opts.limit\n  \n  // 需要处理的 content-type 类型\n  var type = opts.type || 'text/plain'\n  \n  // 用户自定义的校验函数，若提供则会被调用verify(req, res, buf, encoding)\n  var verify = opts.verify || false\n\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function')\n  }\n\n  // create the appropriate type checking function\n  var shouldParse = typeof type !== 'function'\n    ? typeChecker(type)\n    : type\n\t\n  // 这里是核心, 不同的解析器有不同的处理方式\n  // text parse 很简单是因为它啥也不需要干\n  function parse (buf) {\n    return buf\n  }\n\n  return function textParser (req, res, next) {\n    // 当我们进行 POST 请求时 textParser 中间件会被调用\n    // 这里先判断 body 是否已经解析过了，下游会设置为 true\n    if (req._body) {\n      debug('body already parsed')\n      next()\n      return\n    }\n\n    req.body = req.body || {}\n\t\t\n    // 没有请求体时不处理\n    // skip requests without bodies\n    if (!typeis.hasBody(req)) {\n      debug('skip empty body')\n      next()\n      return\n    }\n\n    debug('content-type %j', req.headers['content-type'])\n\n    // determine if request should be parsed\n    if (!shouldParse(req)) {\n      debug('skip parsing')\n      next()\n      return\n    }\n\n    // get charset\n    var charset = getCharset(req) || defaultCharset\n\n    // read\n    read(req, res, next, parse, debug, {\n      encoding: charset,\n      inflate: inflate,\n      limit: limit,\n      verify: verify\n    })\n  }\n}\n\n// 获取请求字符集\nfunction getCharset (req) {\n  try {\n    return (contentType.parse(req).parameters.charset || '').toLowerCase()\n  } catch (e) {\n    return undefined\n  }\n}\n\n// content-type 检测\nfunction typeChecker (type) {\n  return function checkType (req) {\n    return Boolean(typeis(req, type))\n  }\n}\n\n// 判断是否包含请求体(这个函数是从type-is包复制出来的)\nfunction hasbody (req) {\n  return req.headers['transfer-encoding'] !== undefined ||\n    !isNaN(req.headers['content-length'])\n}\n```\n大概流程如下：\n\n- 使用 app.use 使用中间件\n- 客户端发起 POST 请求\n- 进入 textParser 中间件\n   - 判断是否已经解析过(req._body = true)\n   - 判断请求是否包含请求体\n   - 判断请求体类型是否需要处理\n   - 读取请求体，解析并设置 req.body &&  req._body = true\n- 进入 read 中间件(读取请求体，解析并设置 req.body &&  req._body = true)\n\n#### 2. read() 中间件(lib/read.js)\n\nlib/types 下的4个文件，最终都会访问 lib/read.js，形式如下：\n\n```javascript\nread(req, res, next, parse, debug, {\n  encoding: charset,\n  inflate: inflate,\n  limit: limit,\n  verify: verify\n})\n```\n\n现在我们来看下 lib/read.js 源码：\n\n```javascript\n'use strict'\n\nvar createError = require('http-errors')\nvar getBody = require('raw-body')\nvar iconv = require('iconv-lite')\nvar onFinished = require('on-finished')\nvar zlib = require('zlib')\n\nmodule.exports = read\n\nfunction read (req, res, next, parse, debug, options) {\n  var length\n  var opts = options\n  var stream\n\n  // parsed flag, 上游服务有做判断\n  req._body = true\n\n  // read options\n  var encoding = opts.encoding !== null\n    ? opts.encoding\n    : null\n  var verify = opts.verify\n\n  try {\n    // get the content stream\n    stream = contentstream(req, debug, opts.inflate)\n    length = stream.length\n    stream.length = undefined\n  } catch (err) {\n    return next(err)\n  }\n\n  // set raw-body options\n  opts.length = length\n  opts.encoding = verify\n    ? null\n    : encoding\n\n  // assert charset is supported\n  if (opts.encoding === null && encoding !== null && !iconv.encodingExists(encoding)) {\n    return next(createError(415, 'unsupported charset \"' + encoding.toUpperCase() + '\"', {\n      charset: encoding.toLowerCase(),\n      type: 'charset.unsupported'\n    }))\n  }\n\n  // read body\n  debug('read body')\n  // getBody 函数用于从 stream 中读取内容\n  getBody(stream, opts, function (error, body) {\n    if (error) {\n      // 异常处理\n      var _error\n      if (error.type === 'encoding.unsupported') {\n        // echo back charset\n        _error = createError(415, 'unsupported charset \"' + encoding.toUpperCase() + '\"', {\n          charset: encoding.toLowerCase(),\n          type: 'charset.unsupported'\n        })\n      } else {\n        // set status code on error\n        _error = createError(400, error)\n      }\n\n      // read off entire request\n      stream.resume()\n      onFinished(req, function onfinished () {\n        next(createError(400, _error))\n      })\n      return\n    }\n\n    // 用户自定义校验函数 verify\n    if (verify) {\n      try {\n        debug('verify body')\n        verify(req, res, body, encoding)\n      } catch (err) {\n        next(createError(403, err, {\n          body: body,\n          type: err.type || 'entity.verify.failed'\n        }))\n        return\n      }\n    }\n\n    var str = body\n    try {\n      debug('parse body')\n      // 如果body不是字符类型而且设置了encoding，那么需要重新解码 \n      str = typeof body !== 'string' && encoding !== null\n        ? iconv.decode(body, encoding)\n        : body\n     \t\n      // 这里不同解析器，会传入不同 parse\n      req.body = parse(str)\n    } catch (err) {\n      next(createError(400, err, {\n        body: str,\n        type: err.type || 'entity.parse.failed'\n      }))\n      return\n    }\n\n    next()\n  })\n}\n\n// 获取请求体 stream\n// 1. 获取压缩编码格式，如果有压缩需要先解压\n// 2. 返回 stream\nfunction contentstream (req, debug, inflate) {\n  var encoding = (req.headers['content-encoding'] || 'identity').toLowerCase()\n  var length = req.headers['content-length']\n  var stream\n\n  debug('content-encoding \"%s\"', encoding)\n\n  if (inflate === false && encoding !== 'identity') {\n    throw createError(415, 'content encoding unsupported', {\n      encoding: encoding,\n      type: 'encoding.unsupported'\n    })\n  }\n\n  switch (encoding) {\n    case 'deflate':\n      stream = zlib.createInflate()\n      debug('inflate body')\n      req.pipe(stream)\n      break\n    case 'gzip':\n      stream = zlib.createGunzip()\n      debug('gunzip body')\n      req.pipe(stream)\n      break\n    case 'identity':\n      stream = req\n      stream.length = length\n      break\n    default:\n      throw createError(415, 'unsupported content encoding \"' + encoding + '\"', {\n        encoding: encoding,\n        type: 'encoding.unsupported'\n      })\n  }\n\n  return stream\n}\n```\n\n## 4. 一些疑问\n\n### 1. 为什么要对 charset 进行处理\n其实本质上来说，charset前端一般都是固定为utf-8的， 甚至在JQuery的AJAX请求中，前端请求charset甚至是不可更改，只能是charset，但是在使用fetch等API的时候，的确是可以更改charset的，这个工作尝试满足一些比较偏僻的更改charset需求。\n\n### 2. 为什么要对 content-encoding 做处理\n一般情况下我们认为，考虑到前端发的AJAX之类的请求的数据量，是不需要做Gzip压缩的。但是向服务器发起请求的不一定只有前端，还可能是Node的客户端。这些Node客户端可能会向Node服务端传送压缩过后的数据流。 例如下面的代码所示:\n\n```javascript\nconst zlib = require('zlib');\nconst request = require('request');\nconst data = zlib.gzipSync(Buffer.from(\"我是一个被Gzip压缩后的数据\"));\nrequest({\n    method: 'POST',\n    url: 'http://127.0.0.1:3000/post',\n    headers: {//设置请求头\n        \"Content-Type\": \"text/plain\",\n        \"Content-Encoding\": \"gzip\"\n    },\n    body: data\n})\n```\n\n## 5. 参考以及延伸\n\n- npm bodyParser [https://www.npmjs.com/package/body-parser#bodyparsertextoptions](https://www.npmjs.com/package/body-parser#bodyparsertextoptions)\n- npm iconv-lite 纯JS编码转换器\n- npm raw-body 以buffer或者string的方式获取一个可读流的全部内容，并且可校验长度\n- bodyparser 实现原理解析(这篇文章回答了我上述2个疑问) [https://zhuanlan.zhihu.com/p/78482006](https://zhuanlan.zhihu.com/p/78482006)\n","isLeaf":true}]},{"key":"/NodeJS/11 coverage","path":"/NodeJS/11 coverage","route":"/NodeJS/11 coverage","leaf":false,"title":"11 coverage","depth":1,"content":"","isLeaf":false,"children":[{"key":"/NodeJS/11 coverage/01-coverage-intro.md","path":"/NodeJS/11 coverage/01-coverage-intro.md","route":"/NodeJS/11 coverage/01-coverage-intro.md","leaf":true,"title":"01-coverage-intro","depth":2,"content":"---\ntags: nodejs-coverage\n---\n\n## 1、覆盖率介绍\n\n代码覆盖率测试是一种软件测试技术，用于测量在执行测试用例集合期间程序的源代码的百分比。\n\n它评估了测试用例对代码库的覆盖率，即它测量了编写的测试用例中有多少行、分支或语句被执行过。\n\n测试的目标就是尽可能多的执行代码，这样就可以排除潜在的错误和漏洞。\n\n通过代码覆盖率测试可以确定代码库的质量，并帮助开发人员在测试完成后进行代码调整或优化。代码覆盖率测试还可以确保每行代码都至少被执行了一次，这可以降低软件错误和缺陷的风险，提高代码的可靠性。\n\n## 2、覆盖率指标\n\n以下是几个覆盖率指标：\n\n- 函数覆盖率（Function coverage）：调用到程式中的每一个Function吗？\n- 行覆盖率（Line coverage)：执行到程序中的每一行了吗？\n- 语句覆盖率（Statement coverage）：若用控制流图表示程序，执行到控制流图中的每一个节点了吗？\n- 分支覆盖率（Branches coverage）：若用控制流图表示程式，执行到控制流图中的每一条边吗？例如控制结构中所有IF指令都有执行到逻辑运算式成立及不成立的情形吗？\n- 条件覆盖率（Condition coverage）：也称为谓词覆盖（predicate coverage），每一个逻辑运算式中的每一个条件（无法再分解的逻辑运算式）是否都有执行到成立及不成立的情形吗？\n  \n对指标的偏好可说是见仁见智，比如大名鼎鼎的 coveralls.io 就以行覆盖率 (Line coverage) 作为给项目颁发badge的首选指标。\n\n我们需要的，是一个能根据测试用例得出覆盖率指标的工具。\n\n## 3、代码覆盖率数据收集\n\n在程序执行到某个执行单元时，收集其代码的信息，比如所在文件、行、列，上报到数据中心。\n\n## 4、数据收集实现原理\n\n不同语言的覆盖率收集，在实现机制甚至语法规范层面都大同小异。先将特定的标记按照一定规则插入到代码行中，这一步我们称为“代码插桩“，然后在执行 case 的过程中收集这些标记的执行情况，最终计算输出覆盖率然后格式化输出结果。大体流程如图所示：\n\n![20230615100458](http://s3.airtlab.com/blog/20230615100458.png)\n\n### 1. 代码插桩\n\n代码插桩是覆盖率收集的前提，这一步主要是对现有代码进行语法层面的分析，并在行内指定的位置加入预设标记。咱们通过一段代码看下处理前后的对比：\n\n**源文件**\n![20230615100657](http://s3.airtlab.com/blog/20230615100657.png)\n\n**插桩后文件**\n![20230615100719](http://s3.airtlab.com/blog/20230615100719.png)\n\n## 5、nodejs 方案调研\n\n### 5.1 istanbuljs\n\nistanbuljs（也称为Istanbul）是JavaScript测试覆盖率工具，用于测量在运行测试时被测JavaScript代码的代码覆盖率。istanbul可用于各种用例，包括前端和后端JavaScript代码库，例如Node.js等。\n \n使用istanbuljs，可以了解每个function、branch和line的代码覆盖率率情况。istanbuljs 支持使用命令行、配置文件或API设置和运行测试覆盖率。此外，istanbul还提供了用于生成测试覆盖率报告的选项和插件，可以生成各种格式的报告，如HTML、文本等，以方便开发人员阅读和分析测试结果。\n\n使用 istanbul 有助于提高代码库的质量，确保代码库的每个部分都得到覆盖，从而减少潜在的漏洞和错误。\n\n`istanbuljs` 包含一些核心包，以 monorepo 的方式进行代码组织：\n\n![20230615102955](http://s3.airtlab.com/blog/20230615102955.png)\n\n支持多种方式的使用：\n- cli 比如 `istanbul cover simple.js`\n- babel 借助 [babel-plugin-istanbul](https://github.com/istanbuljs/babel-plugin-istanbul)\n\n### 5.2 Coveralls\nCoveralls 是一个在线的测试覆盖率报告服务，它能够将你项目中的测试覆盖率报告进行图形化展示，为你提供求助和决策的重要数据。\nCoveralls 支持多种不同的编程语言和测试框架，包括JavaScript、Python、Java、Ruby等等，并与 GitHub、GitLab、Bitbucket 和 Travis CI 等常用的在线仓库和自动化构建平台进行无缝集成，使得测试结果和代码覆盖率报告可以自动发布到 Coveralls 平台上。这样开发人员就可以轻松地对代码库的测试质量进行监控和管理。\n\nCoveralls 比较流行的一个原因是，它提供的覆盖率报告非常直观，易于理解和分析。开发人员可以通过图形化界面，详细了解测试用例和代码库的覆盖情况，从而有针对性地进行代码调整和优化。\n\n总之，Coveralls.io是一个非常有用的测试覆盖率的检测和展示工具。\n\n## 6、参考文档\n- [infoq Qunar 酒店 NodeJS 覆盖率收集实践](https://www.infoq.cn/article/l3mqhbbeadqtlrdmpojz)\n- [[Node.js] Express的测试覆盖率](https://www.cnblogs.com/moye/p/express_coverage.html)\n- [代码覆盖率工具 Istanbul 入门教程](https://www.ruanyifeng.com/blog/2015/06/istanbul.html)\n- JS代码覆盖率工具instanbuljs及其思路介绍 https://shenlvmeng.github.io/blog/2020/04/16/istanbuljs/","isLeaf":true},{"key":"/NodeJS/11 coverage/02-coverage-collection.md","path":"/NodeJS/11 coverage/02-coverage-collection.md","route":"/NodeJS/11 coverage/02-coverage-collection.md","leaf":true,"title":"02-coverage-collection","depth":2,"content":"```ts\nimport * as fs from 'fs';\nimport * as types from '@babel/types';\nimport * as babel from '@babel/core';\nimport generate from '@babel/generator';\n\nconst code = fs.readFileSync('code.ts', 'utf-8');\n\nconst ast = babel.parse(code, {\n  presets: ['@babel/preset-typescript'],\n  filename: 'code.ts',\n});\n\nvar fnCount = 0;\nvar statementCount = 0;\nvar branchCount = 0;\n\nfunction uni() {\n  return {\n    execStatement(index: number) {\n      \n    }\n  }\n}\n\nvar callbackName = 'context';\nvar callback = uni();\n\nvar stateMap: any = {\n  \n}\n\nbabel.traverse(ast!, {\n  // Program (path) {\n  //   path.scope.push({\n  //     id: types.identifier('myScope')\n  //   })\n  // },\n  FunctionDeclaration(path) {\n    fnCount++;\n  },\n  ArrowFunctionExpression() {\n    fnCount++;\n  },\n  Expression(t) {},\n\n  CallExpression(path) {\n    statementCount++;\n    debugger\n\n    stateMap[statementCount] = {\n      loc: {\n        start: path.node.loc!.start,\n        end: path.node.loc!.end,\n      }\n    }\n\n    const i = types.sequenceExpression([\n      types.callExpression(\n        types.memberExpression(\n          types.identifier(callbackName),\n          types.identifier('execStatement'),\n        ),\n        [types.numericLiteral(statementCount)],\n      ),\n      path.node,\n    ]);\n    path.skip();\n    path.replaceWith(i);\n  },\n\n  BinaryExpression(path) {\n    statementCount++;\n\n    stateMap[statementCount] = {\n      loc: {\n        start: path.node.loc!.start,\n        end: path.node.loc!.end,\n      }\n    }\n  \n    const i = types.sequenceExpression([\n      types.callExpression(\n        types.memberExpression(\n          types.identifier(callbackName),\n          types.identifier('execStatement'),\n        ),\n        [types.numericLiteral(statementCount)],\n      ),\n      path.node,\n    ]);\n    path.skip();\n    path.replaceWith(i);\n  },\n});\n\nconst output = generate(\n  ast!,\n  {\n    /* options */\n  },\n  code,\n);\n\nconsole.log(output.code);\nconsole.log(JSON.stringify(stateMap))\n```","isLeaf":true},{"key":"/NodeJS/11 coverage/03-istanbuljs.md","path":"/NodeJS/11 coverage/03-istanbuljs.md","route":"/NodeJS/11 coverage/03-istanbuljs.md","leaf":true,"title":"03-istanbuljs","depth":2,"content":"## 1、配置\n\n- @istanbuljs/nyc-config-typescript\n- source-map-support\n\n**package.json**\n\n```json\n  \"nyc\": {\n    \"extends\": \"./nyc-config.js\",\n    \"all\": true,\n    \"require\": [\n      \"ts-node/register/transpile-only\",\n      \"source-map-support/register\"\n    ]\n  },\n```\n\n**nyc-config.js**\n\n```js\nconst { parserPlugins } = require('@istanbuljs/schema').defaults.nyc;\n\nmodule.exports = {\n  cache: false,\n  parserPlugins: parserPlugins.concat('typescript', 'jsx', 'decorators-legacy'),\n};\n```\n\n## 2、插桩\n\n```ts\nimport { Controller, Get } from '@nestjs/common';\nimport { AppService } from './app.service';\n\nconst bool = false;\n\n@Controller()\nexport class AppController {\n  constructor(private readonly appService: AppService) {}\n\n  @Get()\n  getHello(): string {\n    if (bool) {\n      return this.appService.getHello();\n    } else {\n      return 'hello';\n    }\n  }\n\n  @Get('coverage')\n  coverageData() {\n    return global.__coverage__;\n  }\n}\n```\n\n```js\nfunction cov_s0t1xtp2e() {\n  var path = 'app.controller.ts';\n  var hash = 'd1ab3cf10fe95bb683cc2f63d090695750c72e09';\n  var global = new Function('return this')();\n  var gcv = '__coverage__';\n  var coverageData = {\n    path: 'app.controller.ts',\n    statementMap: {\n      0: { start: { line: 4, column: 13 }, end: { line: 4, column: 18 } },\n      1: { start: { line: 12, column: 4 }, end: { line: 16, column: 5 } },\n      2: { start: { line: 13, column: 6 }, end: { line: 13, column: 40 } },\n      3: { start: { line: 15, column: 6 }, end: { line: 15, column: 20 } },\n      4: { start: { line: 21, column: 4 }, end: { line: 21, column: 31 } },\n    },\n    fnMap: {\n      0: {\n        name: '(anonymous_0)',\n        decl: { start: { line: 8, column: 2 }, end: { line: 8, column: 3 } },\n        loc: { start: { line: 8, column: 55 }, end: { line: 8, column: 57 } },\n        line: 8,\n      },\n      1: {\n        name: '(anonymous_1)',\n        decl: { start: { line: 10, column: 2 }, end: { line: 10, column: 3 } },\n        loc: { start: { line: 11, column: 21 }, end: { line: 17, column: 3 } },\n        line: 11,\n      },\n      2: {\n        name: '(anonymous_2)',\n        decl: { start: { line: 19, column: 2 }, end: { line: 19, column: 3 } },\n        loc: { start: { line: 20, column: 17 }, end: { line: 22, column: 3 } },\n        line: 20,\n      },\n    },\n    branchMap: {\n      0: {\n        loc: { start: { line: 12, column: 4 }, end: { line: 16, column: 5 } },\n        type: 'if',\n        locations: [\n          { start: { line: 12, column: 4 }, end: { line: 16, column: 5 } },\n          { start: { line: 12, column: 4 }, end: { line: 16, column: 5 } },\n        ],\n        line: 12,\n      },\n    },\n    s: { 0: 0, 1: 0, 2: 0, 3: 0, 4: 0 },\n    f: { 0: 0, 1: 0, 2: 0 },\n    b: { 0: [0, 0] },\n    _coverageSchema: '1a1c01bbd47fc00a2c39e90264f33305004495a9',\n    hash: 'd1ab3cf10fe95bb683cc2f63d090695750c72e09',\n  };\n  var coverage = global[gcv] || (global[gcv] = {});\n  if (!coverage[path] || coverage[path].hash !== hash) {\n    coverage[path] = coverageData;\n  }\n  var actualCoverage = coverage[path];\n  {\n    cov_s0t1xtp2e = function () {\n      return actualCoverage;\n    };\n  }\n  return actualCoverage;\n}\ncov_s0t1xtp2e();\nconst bool = (cov_s0t1xtp2e().s[0]++, false);\nlet AppController = class AppController {\n  constructor(appService) {\n    this.appService = appService;\n    cov_s0t1xtp2e().f[0]++;\n  }\n  getHello() {\n    cov_s0t1xtp2e().f[1]++;\n    cov_s0t1xtp2e().s[1]++;\n    if (bool) {\n      cov_s0t1xtp2e().b[0][0]++;\n      cov_s0t1xtp2e().s[2]++;\n      return this.appService.getHello();\n    } else {\n      cov_s0t1xtp2e().b[0][1]++;\n      cov_s0t1xtp2e().s[3]++;\n      return 'hello';\n    }\n  }\n  coverageData() {\n    cov_s0t1xtp2e().f[2]++;\n    cov_s0t1xtp2e().s[4]++;\n    return global.__coverage__;\n  }\n};\n```\n\n## 2、数据结构\n\n```json\n{\n  \"path\": \"app.controller.ts\",\n  \"statementMap\": {\n    \"0\": {\n      \"start\": { \"line\": 10, \"column\": 4 },\n      \"end\": { \"line\": 10, \"column\": 38 }\n    },\n    \"1\": {\n      \"start\": { \"line\": 15, \"column\": 4 },\n      \"end\": { \"line\": 15, \"column\": 31 }\n    }\n  },\n  \"fnMap\": {\n    \"0\": {\n      \"name\": \"(anonymous_0)\",\n      \"decl\": {\n        \"start\": { \"line\": 6, \"column\": 2 },\n        \"end\": { \"line\": 6, \"column\": 3 }\n      },\n      \"loc\": {\n        \"start\": { \"line\": 6, \"column\": 55 },\n        \"end\": { \"line\": 6, \"column\": 57 }\n      },\n      \"line\": 6\n    },\n    \"1\": {\n      \"name\": \"(anonymous_1)\",\n      \"decl\": {\n        \"start\": { \"line\": 8, \"column\": 2 },\n        \"end\": { \"line\": 8, \"column\": 3 }\n      },\n      \"loc\": {\n        \"start\": { \"line\": 9, \"column\": 21 },\n        \"end\": { \"line\": 11, \"column\": 3 }\n      },\n      \"line\": 9\n    },\n    \"2\": {\n      \"name\": \"(anonymous_2)\",\n      \"decl\": {\n        \"start\": { \"line\": 13, \"column\": 2 },\n        \"end\": { \"line\": 13, \"column\": 3 }\n      },\n      \"loc\": {\n        \"start\": { \"line\": 14, \"column\": 17 },\n        \"end\": { \"line\": 16, \"column\": 3 }\n      },\n      \"line\": 14\n    }\n  },\n  \"branchMap\": {},\n  \"s\": { \"0\": 3, \"1\": 11 },\n  \"f\": { \"0\": 1, \"1\": 3, \"2\": 11 },\n  \"b\": {},\n  \"_coverageSchema\": \"1a1c01bbd47fc00a2c39e90264f33305004495a9\",\n  \"hash\": \"4ca2bfe3281e37824b063daa0c37f084ca573ddf\"\n}\n```\n\n- fnMap 对象用于维护函数信息，key 为函数索引(从 0 开始)，loc 表示函数体的位置\n- branchMap 对象用于维护分支信息，key 为分支索引(从 0 开始)，loc 表示函数体的位置\n- s 对象用于维护 statement 执行信息，key 为 statement 索引(从 0 开始)，value 为执行次数\n- f 对象用于维护 function 执行信息，key 为 function 索引(从 0 开始)，value 为执行次数\n\n### function\n\n### statement\n\n### branch\n\n### 可视化\n\n![20230706115628](http://s3.airtlab.com/blog/20230706115628.png)\n\n## 核心部件\n- istanbul-lib-coverage 分析覆盖率元数据 (例如：哪些行被执行，哪些行没有被执行)\n- istanbul-lib-instrument\n- istanbul-lib-report\n- istanbul-lib-source-maps\n- istanbul-reports \n- istanbul-middleware https://github.com/gotwarlost/istanbul-middleware/blob/master/README.md\n","isLeaf":true},{"key":"/NodeJS/11 coverage/04-前端代码插桩与覆盖率.md","path":"/NodeJS/11 coverage/04-前端代码插桩与覆盖率.md","route":"/NodeJS/11 coverage/04-前端代码插桩与覆盖率.md","leaf":true,"title":"04-前端代码插桩与覆盖率","depth":2,"content":"https://juejin.cn/post/7022928631756226591","isLeaf":true},{"key":"/NodeJS/11 coverage/05-覆盖率实时统计工具.md","path":"/NodeJS/11 coverage/05-覆盖率实时统计工具.md","route":"/NodeJS/11 coverage/05-覆盖率实时统计工具.md","leaf":true,"title":"05-覆盖率实时统计工具","depth":2,"content":"- https://shenlvmeng.github.io/blog/2020/04/16/fe-coverage-scheme/#%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86\n- https://tech.youzan.com/front-coverage/","isLeaf":true},{"key":"/NodeJS/11 coverage/06-酷家乐基于Istanbul 优雅地搭建前端JS覆盖率平台.md","path":"/NodeJS/11 coverage/06-酷家乐基于Istanbul 优雅地搭建前端JS覆盖率平台.md","route":"/NodeJS/11 coverage/06-酷家乐基于Istanbul 优雅地搭建前端JS覆盖率平台.md","leaf":true,"title":"06-酷家乐基于Istanbul 优雅地搭建前端JS覆盖率平台","depth":2,"content":"- https://tech.kujiale.com/qian-duan-fu-gai-lu/","isLeaf":true},{"key":"/NodeJS/11 coverage/07-nyc-对import语句的插桩问题.md","path":"/NodeJS/11 coverage/07-nyc-对import语句的插桩问题.md","route":"/NodeJS/11 coverage/07-nyc-对import语句的插桩问题.md","leaf":true,"title":"07-nyc-对import语句的插桩问题","depth":2,"content":"```ts\nimport { Controller, Get } from '@nestjs/common';\nimport { AppService } from './app.service';\n\nconst bool = false;\n\n@Controller()\nexport class AppController {\n  constructor(private readonly appService: AppService) {}\n\n  @Get()\n  getHello(): string {\n    if (bool) {\n      return this.appService.getHello();\n    } else {\n      return 'hello'\n    }\n  }\n\n  @Get('coverage')\n  coverageData() {\n    return global.__coverage__;\n  }\n}\n```\n\n插桩后:\n\n```ts\nfunction cov_2hfyi6yc4b() {\n  var path =\n    '/Users/xiong.gao/code/learn-books/demos/nyc-demo/nyc-nestjs/src/app.controller.ts';\n  var hash = '0b26da660683c2d07ef512cf6e4f064c27d36f10';\n  var global = new Function('return this')();\n  var gcv = '__coverage__';\n  var coverageData = {\n    path: '/Users/xiong.gao/code/learn-books/demos/nyc-demo/nyc-nestjs/src/app.controller.ts',\n    statementMap: {\n      '0': { start: { line: 4, column: 13 }, end: { line: 4, column: 18 } },\n      '1': { start: { line: 12, column: 4 }, end: { line: 16, column: 5 } },\n      '2': { start: { line: 13, column: 6 }, end: { line: 13, column: 40 } },\n      '3': { start: { line: 15, column: 6 }, end: { line: 15, column: 20 } },\n      '4': { start: { line: 21, column: 4 }, end: { line: 21, column: 31 } },\n    },\n    fnMap: {\n      '0': {\n        name: '(anonymous_0)',\n        decl: { start: { line: 8, column: 2 }, end: { line: 8, column: 3 } },\n        loc: { start: { line: 8, column: 55 }, end: { line: 8, column: 57 } },\n        line: 8,\n      },\n      '1': {\n        name: '(anonymous_1)',\n        decl: { start: { line: 10, column: 2 }, end: { line: 10, column: 3 } },\n        loc: { start: { line: 11, column: 21 }, end: { line: 17, column: 3 } },\n        line: 11,\n      },\n      '2': {\n        name: '(anonymous_2)',\n        decl: { start: { line: 19, column: 2 }, end: { line: 19, column: 3 } },\n        loc: { start: { line: 20, column: 17 }, end: { line: 22, column: 3 } },\n        line: 20,\n      },\n    },\n    branchMap: {\n      '0': {\n        loc: { start: { line: 12, column: 4 }, end: { line: 16, column: 5 } },\n        type: 'if',\n        locations: [\n          { start: { line: 12, column: 4 }, end: { line: 16, column: 5 } },\n          { start: { line: 12, column: 4 }, end: { line: 16, column: 5 } },\n        ],\n        line: 12,\n      },\n    },\n    s: { '0': 0, '1': 0, '2': 0, '3': 0, '4': 0 },\n    f: { '0': 0, '1': 0, '2': 0 },\n    b: { '0': [0, 0] },\n    _coverageSchema: '1a1c01bbd47fc00a2c39e90264f33305004495a9',\n    hash: '0b26da660683c2d07ef512cf6e4f064c27d36f10',\n  };\n  var coverage = global[gcv] || (global[gcv] = {});\n  if (!coverage[path] || coverage[path].hash !== hash) {\n    coverage[path] = coverageData;\n  }\n  var actualCoverage = coverage[path];\n  {\n    // @ts-ignore\n    cov_2hfyi6yc4b = function () {\n      return actualCoverage;\n    };\n  }\n  return actualCoverage;\n}\ncov_2hfyi6yc4b();\nimport { Controller, Get } from '@nestjs/common';\nimport { AppService } from './app.service';\nconst bool = (cov_2hfyi6yc4b().s[0]++, false);\n@Controller()\nexport class AppController {\n  constructor(private readonly appService: AppService) {\n    cov_2hfyi6yc4b().f[0]++;\n  }\n  @Get() getHello(): string {\n    cov_2hfyi6yc4b().f[1]++;\n    cov_2hfyi6yc4b().s[1]++;\n    if (bool) {\n      cov_2hfyi6yc4b().b[0][0]++;\n      cov_2hfyi6yc4b().s[2]++;\n      return this.appService.getHello();\n    } else {\n      cov_2hfyi6yc4b().b[0][1]++;\n      cov_2hfyi6yc4b().s[3]++;\n      return 'hello';\n    }\n  }\n  @Get('coverage') coverageData() {\n    cov_2hfyi6yc4b().f[2]++;\n    cov_2hfyi6yc4b().s[4]++;\n    return global.__coverage__;\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJjb3ZfMmhmeWk2eWM0YiIsImFjdHVhbENvdmVyYWdlIiwiQ29udHJvbGxlciIsIkdldCIsIkFwcFNlcnZpY2UiLCJib29sIiwicyIsIkFwcENvbnRyb2xsZXIiLCJjb25zdHJ1Y3RvciIsImFwcFNlcnZpY2UiLCJmIiwiZ2V0SGVsbG8iLCJiIiwiY292ZXJhZ2VEYXRhIiwiZ2xvYmFsIiwiX19jb3ZlcmFnZV9fIl0sInNvdXJjZXMiOlsiYXBwLmNvbnRyb2xsZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29udHJvbGxlciwgR2V0IH0gZnJvbSAnQG5lc3Rqcy9jb21tb24nO1xuaW1wb3J0IHsgQXBwU2VydmljZSB9IGZyb20gJy4vYXBwLnNlcnZpY2UnO1xuXG5jb25zdCBib29sID0gZmFsc2U7XG5cbkBDb250cm9sbGVyKClcbmV4cG9ydCBjbGFzcyBBcHBDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBhcHBTZXJ2aWNlOiBBcHBTZXJ2aWNlKSB7fVxuXG4gIEBHZXQoKVxuICBnZXRIZWxsbygpOiBzdHJpbmcge1xuICAgIGlmIChib29sKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcHBTZXJ2aWNlLmdldEhlbGxvKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnaGVsbG8nXG4gICAgfVxuICB9XG5cbiAgQEdldCgnY292ZXJhZ2UnKVxuICBjb3ZlcmFnZURhdGEoKSB7XG4gICAgcmV0dXJuIGdsb2JhbC5fX2NvdmVyYWdlX187XG4gIH1cbn1cbiJdLCJtYXBwaW5ncyI6Im9rREFlWTtBQUFBQSxjQUFBLFNBQUFBLENBQUEsU0FBQUMsY0FBQSxXQUFBQSxjQUFBLEVBQUFELGNBQUEsR0FmWixPQUFTRSxVQUFVLENBQUVDLEdBQUcsS0FBUSxnQkFBZ0IsQ0FDaEQsT0FBU0MsVUFBVSxLQUFRLGVBQWUsQ0FFMUMsS0FBTSxDQUFBQyxJQUFJLEVBQUFMLGNBQUEsR0FBQU0sQ0FBQSxNQUFHLEtBQUssRUFFbEIsQ0FBQ0osVUFBVSxDQUFDLENBQUMsTUFBYixNQUNhLENBQUFLLGFBQWMsQ0FDekJDLFdBQVdBLENBQUMsZ0JBQWlCLENBQUFDLFVBQVUsQ0FBRUwsVUFBVSxDQUFFLENBQUFKLGNBQUEsR0FBQVUsQ0FBQSxNQUFDLENBRXRELENBQUNQLEdBQUcsQ0FBQyxDQUNMUSxRQUFRQSxDQUFBLENBQUUsQ0FBRSxNQUFPLENBQUFYLGNBQUEsR0FBQVUsQ0FBQSxNQUFBVixjQUFBLEdBQUFNLENBQUEsTUFDakIsR0FBSUQsSUFBSSxDQUFFLENBQUFMLGNBQUEsR0FBQVksQ0FBQSxTQUFBWixjQUFBLEdBQUFNLENBQUEsTUFDUixNQUFPLEtBQUksQ0FBQ0csVUFBVSxDQUFDRSxRQUFRLENBQUMsQ0FBQyxDQUNuQyxDQUFDLElBQU0sQ0FBQVgsY0FBQSxHQUFBWSxDQUFBLFNBQUFaLGNBQUEsR0FBQU0sQ0FBQSxNQUNMLE1BQU8sT0FBTyxDQUNoQixDQUNGLENBRUEsQ0FBQ0gsR0FBRyxDQUFDLFVBQVUsQ0FDZlUsWUFBWUEsQ0FBQSxDQUFHLENBQUFiLGNBQUEsR0FBQVUsQ0FBQSxNQUFBVixjQUFBLEdBQUFNLENBQUEsTUFDYixNQUFPLENBQUFRLE1BQU0sQ0FBQ0MsWUFBWSxDQUM1QixDQUNGIn0=\n```\n\n为什么 import 语句没有被插桩呢\n\n```ts\nimport { Controller, Get } from '@nestjs/common';\nimport { AppService } from './app.service';\n```\n\n我以为的：\n```ts\nimport { Controller, Get } from '@nestjs/common';\ncov_2hfyi6yc4b().s[0]++;\nimport { AppService } from './app.service';\ncov_2hfyi6yc4b().s[1]++;\n```\n\n用 `npm run test:cov` 和 自定义的插桩结果不一致\n\n但是报告上却显示这两个语句已经执行，怎么做到的呢\n\n![20230707170338](http://s3.airtlab.com/blog/20230707170338.png)\n\n可以看看它的数据统计：\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<coverage generated=\"1688720531034\" clover=\"3.2.0\">\n  <project timestamp=\"1688720531034\" name=\"All files\">\n    <metrics statements=\"24\" coveredstatements=\"15\" conditionals=\"2\" coveredconditionals=\"1\" methods=\"5\" coveredmethods=\"2\" elements=\"31\" coveredelements=\"18\" complexity=\"0\" loc=\"24\" ncloc=\"24\" packages=\"1\" files=\"4\" classes=\"4\"/>\n    <file name=\"app.controller.ts\" path=\"/Users/xiong.gao/code/learn-books/demos/nyc-demo/nyc-nestjs/src/app.controller.ts\">\n      <metrics statements=\"11\" coveredstatements=\"9\" conditionals=\"2\" coveredconditionals=\"1\" methods=\"3\" coveredmethods=\"2\"/>\n      <line num=\"1\" count=\"1\" type=\"stmt\"/>\n      <line num=\"2\" count=\"1\" type=\"stmt\"/>\n      <line num=\"4\" count=\"1\" type=\"stmt\"/>\n      <line num=\"7\" count=\"1\" type=\"stmt\"/>\n      <line num=\"8\" count=\"1\" type=\"stmt\"/>\n      <line num=\"10\" count=\"1\" type=\"stmt\"/>\n      <line num=\"12\" count=\"1\" type=\"cond\" truecount=\"1\" falsecount=\"1\"/>\n      <line num=\"13\" count=\"0\" type=\"stmt\"/>\n      <line num=\"15\" count=\"1\" type=\"stmt\"/>\n      <line num=\"19\" count=\"1\" type=\"stmt\"/>\n      <line num=\"21\" count=\"0\" type=\"stmt\"/>\n    </file>\n    <file name=\"app.module.ts\" path=\"/Users/xiong.gao/code/learn-books/demos/nyc-demo/nyc-nestjs/src/app.module.ts\">\n      <metrics statements=\"4\" coveredstatements=\"4\" conditionals=\"0\" coveredconditionals=\"0\" methods=\"0\" coveredmethods=\"0\"/>\n      <line num=\"1\" count=\"1\" type=\"stmt\"/>\n      <line num=\"2\" count=\"1\" type=\"stmt\"/>\n      <line num=\"3\" count=\"1\" type=\"stmt\"/>\n      <line num=\"10\" count=\"1\" type=\"stmt\"/>\n    </file>\n    <file name=\"app.service.ts\" path=\"/Users/xiong.gao/code/learn-books/demos/nyc-demo/nyc-nestjs/src/app.service.ts\">\n      <metrics statements=\"3\" coveredstatements=\"2\" conditionals=\"0\" coveredconditionals=\"0\" methods=\"1\" coveredmethods=\"0\"/>\n      <line num=\"1\" count=\"1\" type=\"stmt\"/>\n      <line num=\"4\" count=\"1\" type=\"stmt\"/>\n      <line num=\"6\" count=\"0\" type=\"stmt\"/>\n    </file>\n    <file name=\"main.ts\" path=\"/Users/xiong.gao/code/learn-books/demos/nyc-demo/nyc-nestjs/src/main.ts\">\n      <metrics statements=\"6\" coveredstatements=\"0\" conditionals=\"0\" coveredconditionals=\"0\" methods=\"1\" coveredmethods=\"0\"/>\n      <line num=\"1\" count=\"0\" type=\"stmt\"/>\n      <line num=\"2\" count=\"0\" type=\"stmt\"/>\n      <line num=\"4\" count=\"0\" type=\"stmt\"/>\n      <line num=\"7\" count=\"0\" type=\"stmt\"/>\n      <line num=\"8\" count=\"0\" type=\"stmt\"/>\n      <line num=\"11\" count=\"0\" type=\"stmt\"/>\n    </file>\n  </project>\n</coverage>\n```\n\n我们需要看看他的源码是如何生成这个数据的","isLeaf":true},{"key":"/NodeJS/11 coverage/08-nyc-config-typescript and decorators.md","path":"/NodeJS/11 coverage/08-nyc-config-typescript and decorators.md","route":"/NodeJS/11 coverage/08-nyc-config-typescript and decorators.md","leaf":true,"title":"08-nyc-config-typescript and decorators","depth":2,"content":"https://github.com/istanbuljs/nyc/issues/1437","isLeaf":true},{"key":"/NodeJS/11 coverage/nyc.md","path":"/NodeJS/11 coverage/nyc.md","route":"/NodeJS/11 coverage/nyc.md","leaf":true,"title":"nyc","depth":2,"content":"","isLeaf":true},{"key":"/NodeJS/11 coverage/探索istanbulnyc代码覆盖工具的原理.md","path":"/NodeJS/11 coverage/探索istanbulnyc代码覆盖工具的原理.md","route":"/NodeJS/11 coverage/探索istanbulnyc代码覆盖工具的原理.md","leaf":true,"title":"探索istanbulnyc代码覆盖工具的原理","depth":2,"content":"https://zhuanlan.zhihu.com/p/88524418","isLeaf":true}]},{"key":"/NodeJS/12 socket-proxy","path":"/NodeJS/12 socket-proxy","route":"/NodeJS/12 socket-proxy","leaf":false,"title":"12 socket-proxy","depth":1,"content":"","isLeaf":false,"children":[{"key":"/NodeJS/12 socket-proxy/index.md","path":"/NodeJS/12 socket-proxy/index.md","route":"/NodeJS/12 socket-proxy/index.md","leaf":true,"title":"index","depth":2,"content":"用 nodejs 实现 socket 代理服务器，包括 TCP 和  UDP","isLeaf":true}]},{"key":"/NodeJS/13 simple-rpc","path":"/NodeJS/13 simple-rpc","route":"/NodeJS/13 simple-rpc","leaf":false,"title":"13 simple-rpc","depth":1,"content":"","isLeaf":false,"children":[{"key":"/NodeJS/13 simple-rpc/index.md","path":"/NodeJS/13 simple-rpc/index.md","route":"/NodeJS/13 simple-rpc/index.md","leaf":true,"title":"index","depth":2,"content":"用 nodejs 实现简单的 RPC 框架\n\nhttps://github.com/hustxiaoc/simple-rpc","isLeaf":true}]},{"key":"/NodeJS/index.md","path":"/NodeJS/index.md","route":"/NodeJS/index.md","leaf":true,"title":"index","depth":1,"content":"---\ntitle: 00 nodejs 介绍\n---\n\n![](https://www.persistent.com/wp-content/uploads/2016/02/blog-banner-Is-your-Node.js-application-production-ready-scaled.jpg)\n\nnodejs 学习笔记，内容非完全原创，相关内容会备注原作者。\n\n特别感谢：\n- [Barret李靖](https://github.com/barretlee)\n- [doodlewind](https://www.zhihu.com/people/doodlewind)\n- [淘小杰](https://github.com/hustxiaoc)\n- [做前端的蜗牛](https://space.bilibili.com/486675132)\n- [邱昊宇](https://www.zhihu.com/people/timothyqiu)\n- [小林coding](https://xiaolincoding.com/)\n- [神说要有光](https://www.zhihu.com/people/di-xu-guang-50)\n\n参考资料：\n- NodeJS 技术栈 https://www.nodejs.red/#/README\n- nodejs.dev https://nodeshift.dev/nodejs-reference-architecture/","isLeaf":true}]},{"key":"/achieve","path":"/achieve","route":"/achieve","leaf":false,"title":"achieve","depth":0,"content":"","isLeaf":false,"children":[{"key":"/achieve/h5-vue-template.md","path":"/achieve/h5-vue-template.md","route":"/achieve/h5-vue-template.md","leaf":true,"title":"h5-vue-template","depth":1,"content":"## 1\n- https://sunniejs.github.io/vue-h5-template/guide/\n\n![20230630104041](http://s3.airtlab.com/blog/20230630104041.png)\n\n## 2\n\n- https://github.com/yulimchen/vue3-h5-template\n\n![20230630104710](http://s3.airtlab.com/blog/20230630104710.png)","isLeaf":true},{"key":"/achieve/nestjs-template.md","path":"/achieve/nestjs-template.md","route":"/achieve/nestjs-template.md","leaf":true,"title":"nestjs-template","depth":1,"content":"一个 C 端 API 快速开发模板，源代码见 https://github.com/fiiai/nestjs-template\n\n## 1. 项目介绍\n\n使用 NestJS 进行 API 通用业务框架最佳实践方案，笔者会定期的更新，欢迎指正。API 文档 👉 https://www.apifox.cn/web/project/2299100\n包含如下特性：\n\n- 【规范】工程目录\n- 【规范】代码风格\n- 【监控】异常监控\n- 【特性】日志打印\n- 【特性】配置管理\n- 【特性】唯一 ID\n- 【特性】socket.io 集成\n- 【特性】redis 封装\n- 【特性】mysql 封装\n- 【特性】mongoose 封装\n- 【特性】mailer 封装\n- 【特性】rabbitmq 封装\n- 【特性】qiniu 集成\n- 【特性】API 文档方案\n- 【特性】代码文档方案\n\n## 2. 内置模块\n\n- [x] 账户模块\n- [x] 图文列表\n- [x] 评论模块\n- [x] 上传模块\n- [x] 数据采集\n- [x] 地址管理\n- [x] 钱包功能\n- [x] 授权登录\n  - [x] 微信登录\n- [x] 支付能力\n  - [x] 支付宝支付\n  - [x] 微信支付\n- [x] 权限管理\n- [x] 短信推送\n- [ ] 站内消息\n\n\n## 3. 技术选型\n\n| 名称     | 方案                                                        |\n| -------- | ----------------------------------------------------------- |\n| 框架     | [nestjs](https://nestjs.com/)                               |\n| 时间处理 | [dayjs](https://day.js.org/docs/en/installation/typescript) |\n| 长连接   | [socket.io](https://socket.io/) & nestjs platform           |\n| 日志     | [pino](https://github.com/pinojs/pino)                      |\n| 大数处理 | [bignumber.js](https://mikemcl.github.io/bignumber.js/)     |\n\n## 4. 技术方案\n\n### 4.0 请求生命周期\n\n![20230301191226](http://s3.airtlab.com/blog/20230301191226.png)\n\n### 4.1 工程目录\n\n```text\n├── config\n│   ├── dev.config.yaml\n│   ├── live.config.yaml\n│   └── local.config.yaml\n├── libs\n│   ├── common\n│   │   ├── filters\n│   │   ├── guard\n│   │   ├── interceptor\n│   │   └── middleware\n│   ├── config\n│   ├── constant\n│   ├── logger\n│   ├── mailer\n│   ├── mongo\n│   ├── redis\n│   ├── request\n│   ├── s3\n│   └── utils\n├── src\n│   ├── app.module.ts\n│   ├── domain-admin\n│   │   ├── admin.module.ts\n│   │   ├── common\n│   │   ├── module\n│   │   └── shared\n│   ├── domain-app\n│   │   ├── app.module.ts\n│   │   ├── common\n│   │   ├── module\n│   │   └── shared\n│   ├── exception.ts\n│   ├── global.d.ts\n│   ├── main.ts\n│   ├── modules\n│       ├── common\n│       │   ├── db\n│       │   ├── entity\n│       │   ├── filters\n│       │   ├── middleware\n│       │   ├── pipes\n│       │   ├── prom\n│       │   └── validate\n│       ├── enums\n│       ├── feature\n│       ├── mock\n│       ├── types\n│       ├── utils\n│       └── vos\n├── tsconfig.build.json\n├── tsconfig.json\n└── yarn.lock\n```\n\n### 4.2 代码风格\n\n[Angular 代码风格指南](https://angular.io/guide/styleguide)\n\n### 4.3 异常监控\n\n数据采集 & 展示采用 Prom + Grafana，监控指标设计 TODO。\n\n### 4.4 日志打印\n\n[winston](https://github.com/winstonjs/winston)\n\n\n### 4.5 项目文档\n```shell\nnpx @compodoc/compodoc -p tsconfig.json -s\n```","isLeaf":true},{"key":"/achieve/react-native-template.md","path":"/achieve/react-native-template.md","route":"/achieve/react-native-template.md","leaf":true,"title":"react-native-template","depth":1,"content":"## 1. 项目介绍\nreact native 快速开发模板，希望有时间的朋友一起来完善，加微信进群：gaoxiong957\n\n## 2. 技术选型\n\n### 2.1 技术选型\n\n| 名称     | 方案                                                                                                                    |\n| -------- | ----------------------------------------------------------------------------------------------------------------------- |\n| 路由库   | [react navigation](https://reactnavigation.org)                                                                         |\n| 状态管理 | mobx + context                                                                                                          |\n| SVG 图标 | react-native-svg 搭配 react-native-iconfont-cli                                                                         |\n| 本地存储 | @react-native-async-storage/async-storage                                                                               |\n| 时间处理 | [dayjs](https://day.js.org/docs/en/installation/typescript)                                                             |\n| UI 库    | [native-base](https://docs.nativebase.io/)                                                                              |\n| 唯一 ID  | uuid & react-native-get-random-values                                                                                   |\n| 消息推送 | [react-native-push-notification](https://github.com/zo0r/react-native-push-notification#readme)                         |\n| 日志工具 | [react-native-logs](https://github.com/onubo/react-native-logs)                                                         |\n| 动画     | [lottie-react-native](https://github.com/lottie-react-native/lottie-react-native) [lottie](https://airbnb.io/lottie/#/) |\n| 文件管理 | [react-native-fs](https://github.com/itinance/react-native-fs) |\n| 扫二维码 | [react-native-camera](https://react-native-camera.github.io/react-native-camera/) |\n| 阴影效果 | [react-native-drop-shadow](https://www.npmjs.com/package/react-native-drop-shadow) |\n| Table | [react-native-table-component](https://github.com/wiiai/react-native-table-component) |\n| network-logger | [react-native-network-logger](https://www.npmjs.com/package/react-native-network-logger) |\n| 分包拆包 | TODO                                                                                                                    |\n\n### 2.2 内部架构\n\n```\nsrc\n├── App.tsx\n├── assets\n│   ├── iconfont 图标\n│   └── img 图片\n├── baseUI 通用UI\n├── config 配置\n│   ├── index.ts 常量配置\n│   ├── theme.ts 主题配置\n│   └── request.ts http 请求配置\n├── global.d.ts 全局类型定义\n├── models 状态管理目录\n│   ├── account.ts\n│   └── index.ts\n├── navigator navigation 配置\n│   ├── MainTab.tsx\n│   ├── MainTabBar.tsx\n│   └── index.tsx\n├── pages 页面\n│   ├── contact\n│   │   └── index.tsx\n│   ├── detail\n│   │   └── index.tsx\n│   ├── h5\n│   │   └── index.tsx\n│   ├── home\n│   │   └── index.tsx\n│   ├── login\n│   │   ├── index.tsx\n│   │   └── style.ts\n│   └── me\n│       └── index.tsx\n├── services 接口\n│   └── account.ts\n├── types 类型目录\n│   ├── ResData.ts\n│   └── UserInfo.ts\n├── utils 工具函数\n│   ├── auth.ts 登录相关\n│   ├── screen.ts 页面相关\n│   ├── storage.ts 本地存储\n└── wrappers\n```\n\n### 2.3 启动流程\n\n```tsx\nimport * as React from 'react';\nimport {rootStore, StoreContext} from './models';\nimport Navigator from './navigator';\nimport {NativeBaseProvider} from 'native-base';\nimport {loadCacheUInfo} from './utils/auth';\nimport {View, Text} from 'react-native';\n\nexport default function App() {\n  const [isLoaded, setIsLoaded] = React.useState(false);\n\n  React.useEffect(() => {\n    beforeBootstrap().then(() => {\n      setIsLoaded(true);\n    });\n  }, []);\n\n  // 在应用主框架启动之前要干的事情\n  // 可以在这里配置你想干的事情\n  const beforeBootstrap = async () => {\n    // 从 storage 中取出数据, 加载到内存中\n    return await loadCacheUInfo();\n  };\n\n  if (!isLoaded) {\n    return (\n      <View style={{flex: 1, justifyContent: 'center', alignItems: 'center'}}>\n        <Text>加载中...</Text>\n      </View>\n    );\n  }\n\n  return (\n    <StoreContext.Provider value={rootStore}>\n      <NativeBaseProvider>\n        <Navigator />\n      </NativeBaseProvider>\n    </StoreContext.Provider>\n  );\n}\n```\n\n### 2.4 部署流程\n\n**Android**\n```shell\n# 构建生产包\ncd android && ./gradlew assembleRelease\n```\n\n**IOS**\n\n## 3. 技术方案\n\n### 3.1 状态管理\n\nmobx + context\n\n### 3.2 SVG 图标处理\n\n参考 https://www.npmjs.com/package/react-native-iconfont-cli\n\n```shell\n# 创建 iconfont.json\nnpx iconfont-init\n\n# 将 SVG 处理为 React Component\nnpx iconfont-rn\n```\n\n### 3.3 react-native-camera\n修改 `ViewPropTypes` 的导入，node_modules/react-native-camera/src/RNCamera.js\n![20230413141005](http://s3.airtlab.com/blog/20230413141005.png)\n\n## 4. 基础页面\n\n<table>\n  <tr>\n    <td><img src=\"https://raw.githubusercontent.com/wiiai/react-native-template/master/screenshot/home.png\" style=\"width: 240px\" /></td>\n    <td><img src=\"https://raw.githubusercontent.com/wiiai/react-native-template/master/screenshot/full_bg.png\" style=\"width: 240px\" /></td>\n    <td><img src=\"https://raw.githubusercontent.com/wiiai/react-native-template/master/screenshot/login_screen.png\" style=\"width: 240px\" /></td>\n  </tr>\n  <tr>\n    <td><img src=\"https://raw.githubusercontent.com/wiiai/react-native-template/master/screenshot/me_un_login.png\" style=\"width: 240px\" /></td>\n    <td><img src=\"https://raw.githubusercontent.com/wiiai/react-native-template/master/screenshot/me_login.png\" style=\"width: 240px\" /></td>\n    <td><img src=\"https://raw.githubusercontent.com/wiiai/react-native-template/master/screenshot/animate.gif\" style=\"width: 240px\" /></td>\n  </tr>\n  <tr>\n    <td><img src=\"https://raw.githubusercontent.com/wiiai/react-native-template/master/screenshot/fs.png\" style=\"width: 240px\" /></td>\n    <td><img src=\"https://raw.githubusercontent.com/wiiai/react-native-template/master/screenshot/scan.png\" style=\"width: 240px\" /></td>\n  </tr>\n</table>","isLeaf":true},{"key":"/achieve/sman.md","path":"/achieve/sman.md","route":"/achieve/sman.md","leaf":true,"title":"sman","depth":1,"content":"> git@github.com:Webang/sman.git\n\n## 1、sman 介绍\nsman 是一个 性能监控 + 异常监控 + 数据埋点 工具，体验地址：http://175.178.48.236:3000\n\n## 2、技术架构\nmysql + redis + elasticsearch + kafka\n\n## 3、模块设计\n- [x] 系统管理\n  - [x] 用户管理\n  - [x] 应用管理 \n- [x] 用户分析\n  - [x] 访问轨迹\n  - [x] 用户分布\n- 异常分析\n  - 整体概览\n  - 代码异常\n  - 接口异常\n  - 资源加载\n- 性能分析\n  - 接口性能\n  - 页面性能\n- 漏斗分析\n- 事件分析\n- 埋点分析\n  - 埋点统计\n- 留存分析\n\n## 4、参考资料\n- http://www.webfunny.cn/demo/home.html\n- https://study.163.com/course/introduction.htm?courseId=1006304007&share=1&shareId=1025552318#/courseDetail?tab=1","isLeaf":true},{"key":"/achieve/wow-admin.md","path":"/achieve/wow-admin.md","route":"/achieve/wow-admin.md","leaf":true,"title":"wow-admin","depth":1,"content":"## 1、admin 基础开发模板\n\n- API https://github.com/fiiai/admin-basic-api\n- UI  https://github.com/fiiai/admin-basic-umi","isLeaf":true},{"key":"/achieve/wow-im.md","path":"/achieve/wow-im.md","route":"/achieve/wow-im.md","leaf":true,"title":"wow-im","depth":1,"content":"> https://github.com/wiiai/wow-im\n\n## 项目介绍\n\n`wow-im` 是一款基于的即时通讯产品，支持的终端包括: H5、PC、IOS & Android (ReactNative)\n\n演示:\n- H5 https://wow-im.airtlab.com/mobile\n- PC https://wow-im.airtlab.com/web\n- 安卓 https://github.com/wiiai/wow-im-rn/release\n- IOS https://github.com/wiiai/wow-im-rn/release\n\n源码：\n- 服务端 https://github.com/wiiai/wow-im/server\n- H5 https://github.com/wiiai/wow-im/ui\n- ReactNative https://github.com/wiiai/wow-im-rn\n\n## 已实现功能\n- 账户\n  - [x] 登录\n- 通讯录\n  - [x] 好友列表\n  - [x] 群\n- 聊天\n  - [x] 单聊\n  - [x] 群聊\n  - [x] 视频单聊\n  - [x] 语音单聊\n- 消息内容\n  - [x] 文字\n- 会话\n  - [x] 会话列表\n  - [x] 历史消息\n\n\n## 会议流程\n1、给在线用户发起会议邀请推送，被邀请者点击同意后进入会议详情\n2、任何用户可以通过会议 URL 进入会议 (DB里面需要创建会议信息，会议ID 标识会议)\n\n## 用户在线状态维护\n---","isLeaf":true},{"key":"/achieve/wow-mall.md","path":"/achieve/wow-mall.md","route":"/achieve/wow-mall.md","leaf":true,"title":"wow-mall","depth":1,"content":"","isLeaf":true}]},{"key":"/android","path":"/android","route":"/android","leaf":false,"title":"android","depth":0,"content":"","isLeaf":false,"children":[{"key":"/android/01-basic","path":"/android/01-basic","route":"/android/01-basic","leaf":false,"title":"01-basic","depth":1,"content":"","isLeaf":false,"children":[{"key":"/android/01-basic/01.md","path":"/android/01-basic/01.md","route":"/android/01-basic/01.md","leaf":true,"title":"01","depth":2,"content":"---\ntitle: 01 终端启动模拟器\n---\n\n```shell\ncd ~/Library/Android/sdk/tools\n\n# 要列出您的AVD\n./emulator -list-avds\n\n# 要直接运行某个AVD\n./emulator -avd {AVD_NAME}\n```","isLeaf":true}]},{"key":"/android/01-use-javascriptcore.md","path":"/android/01-use-javascriptcore.md","route":"/android/01-use-javascriptcore.md","leaf":true,"title":"01-use-javascriptcore","depth":1,"content":"---\ntitle: 01 使用 JavascriptCore\ntags: Android\n---\n","isLeaf":true},{"key":"/android/02-react-native.md","path":"/android/02-react-native.md","route":"/android/02-react-native.md","leaf":true,"title":"02-react-native","depth":1,"content":"---\ntitle: 02 React Native 原理\ntags: Android\n---\n\nhttps://www.jianshu.com/p/7e067adaf270","isLeaf":true},{"key":"/android/03-use-quickjs.md","path":"/android/03-use-quickjs.md","route":"/android/03-use-quickjs.md","leaf":true,"title":"03-use-quickjs","depth":1,"content":"---\ntitle: 03 使用 quickjs\ntags: Android\n---\n\n- https://github.com/taoweiji/quickjs-android\n- https://www.jianshu.com/p/6fcc38f09281\n- https://www.jianshu.com/p/6ffe30df4e30","isLeaf":true},{"key":"/android/04-use-yoga.md","path":"/android/04-use-yoga.md","route":"/android/04-use-yoga.md","leaf":true,"title":"04-use-yoga","depth":1,"content":"---\ntitle: 04 use yoga\ntags: Android\n---\n\nYoga 布局引擎实际上是一个数值计算引擎，它实际上是与 UI 视图无关的。\n\n在 Yoga 中，布局的每个元素都是一个节点(YogaNode)，这个 YogaNode 会代表界面上的某个元素（比如一个 TextView），但是两者没有直接关联。\n\n- https://cloud.tencent.com/developer/article/1006148?from=15425&areaSource=102001.2&traceId=dMKXhKr6CYMolCNoQIPPY\n- https://maxiee.github.io/post/ReactNativeCode12md/\n\n```java\n  FrameLayout container = new FrameLayout(this);\n\n  /**\n   * 布局纯数值计算\n   */\n  float screenWidth = getWindowManager().getDefaultDisplay().getWidth();\n  float screenHeight = getWindowManager().getDefaultDisplay().getHeight() - 56 - 24;\n\n  YogaNode root = new YogaNodeJNIFinalizer();\n  root.setWidth(screenWidth);\n  root.setHeight(screenHeight);\n  root.setFlexDirection(YogaFlexDirection.ROW);\n\n  YogaNode rect1 = new YogaNodeJNIFinalizer();\n    rect1.setFlex(1);\n\n  YogaNode rect2 = new YogaNodeJNIFinalizer();\n    rect2.setFlex(2);\n\n  YogaNode rect3 = new YogaNodeJNIFinalizer();\n    rect3.setFlex(1);\n\n  root.addChildAt(rect1, 0);\n  root.addChildAt(rect2, 1);\n  root.addChildAt(rect3, 2);\n\n  // 给定屏幕长宽，求解屏幕元素位置\n  root.calculateLayout(screenWidth, screenHeight);\n\n  View v1 = new View(this);\n  v1.setBackgroundColor(Color.parseColor(\"#d50000\"));\n  rect1.setData(v1);\n\n  View v2 = new View(this);\n  v2.setBackgroundColor(Color.parseColor(\"#ff1744\"));\n  rect2.setData(v2);\n\n  View v3 = new View(this);\n  v3.setBackgroundColor(Color.parseColor(\"#ff5252\"));\n  rect3.setData(v3);\n\n  container.addView(v1);\n  container.addView(v2);\n  container.addView(v3);\n\n  v1.setX(rect1.getLayoutX());\n  v1.setY(rect1.getLayoutY());\n  v1.setLayoutParams(new FrameLayout.LayoutParams((int)(rect1.getLayoutWidth()), (int)(rect1.getLayoutHeight())));\n\n  v2.setX(rect2.getLayoutX());\n  v2.setY(rect2.getLayoutY());\n  v2.setLayoutParams(new FrameLayout.LayoutParams((int)(rect2.getLayoutWidth()), (int)(rect2.getLayoutHeight())));\n\n  v3.setX(rect3.getLayoutX());\n  v3.setY(rect3.getLayoutY());\n  v3.setLayoutParams(new FrameLayout.LayoutParams((int)(rect3.getLayoutWidth()), (int)(rect3.getLayoutHeight())));\n\n  setContentView(container);\n```","isLeaf":true},{"key":"/android/05-layout-inspector.md","path":"/android/05-layout-inspector.md","route":"/android/05-layout-inspector.md","leaf":true,"title":"05-layout-inspector","depth":1,"content":"---\ntitle: 05 使用布局检查器\ntags: Android\n---\n\nhttps://developer.android.com/studio/debug/layout-inspector?hl=zh-cn","isLeaf":true},{"key":"/android/06-Litho.md","path":"/android/06-Litho.md","route":"/android/06-Litho.md","leaf":true,"title":"06-Litho","depth":1,"content":"---\ntags: Android\n---\n\nhttps://fblitho.com/docs/mainconcepts/props/#combining-a-style-from-above-with-a-local-style","isLeaf":true}]},{"key":"/backend","path":"/backend","route":"/backend","leaf":false,"title":"backend","depth":0,"content":"","isLeaf":false,"children":[{"key":"/backend/nginx","path":"/backend/nginx","route":"/backend/nginx","leaf":false,"title":"nginx","depth":1,"content":"","isLeaf":false,"children":[{"key":"/backend/nginx/01-introduce.md","path":"/backend/nginx/01-introduce.md","route":"/backend/nginx/01-introduce.md","leaf":true,"title":"01-introduce","depth":2,"content":"---\ntitle: 01 nginx 介绍\ntoc: true\ntags: nginx\ncategories: 中间件\ndate: 2018-05-01\n---\n\n## 1、nginx 介绍\n\nNginx 是一个免费开源的、高性能的Web服务器软件，可用做：\n- 反向代理\n- 负载均衡\n- HTTP缓存\n- 动静分离\n\nNginx 最初由Igor Sysoev开发，现由 NGINX INC. 维护。\n\nNginx 是基于**事件驱动**的方式实现的，它采用**异步非阻塞I/O模型**，在处理高并发请求时性能比传统的阻塞式Web服务器更优秀。Nginx可以在一台服务器上同时处理数万个并发请求，对高流量网站来说是非常有用的。\n\n在反向代理中，Nginx可以将客户端请求转发到多个后端Web服务器进行处理，实现负载均衡，保证服务器的高可用性和性能弹性。\n\nNginx可以通过模块和插件扩展功能，例如增加HTTPS支持，实现动态内容的FastCGI代理，缓存和压缩数据等等。\n\nNginx易于配置和使用，具有较高的可靠性和稳定性，在Linux和UNIX等操作系统上广泛应用于高性能Web服务器，云计算领域和大型企业级应用系统中。\n\n## 2、nginx 架构\n\n![20230609162440](http://s3.airtlab.com/blog/20230609162440.png)\n\nNginx服务器的进程模型有两种：`Single模型` 和 `Master-Worker模型`。`Single模型` 为单进程方式，性能较差，一般在实际工作中不使用。`Master-Worker模型` 实际上被更广泛地称为 `Master-Slave模型`。在Nginx服务器中，充当Slave角色的是工作进程。\n\n## 3、学习资源\n**(1) 官方文档**\n\n对每个模块的使用都介绍的非常清楚。http://nginx.org/en/docs\n\n**(2)《Nginx高性能Web服务器详解 》**\n\n此书对新手非常友好，能够快速上手 以及 了解 Nginx 的工作模式。https://weread.qq.com/web/bookDetail/e8d3200059fb19e8d3b2af6\n","isLeaf":true},{"key":"/backend/nginx/02-root-vs-alias.md","path":"/backend/nginx/02-root-vs-alias.md","route":"/backend/nginx/02-root-vs-alias.md","leaf":true,"title":"02-root-vs-alias","depth":2,"content":"---\ntitle: 02 root 和 alias 的区别\ntoc: true\ntags: nginx\ncategories: 中间件\ndate: 2018-05-01\n---\n\nnginx 指定文件路径有两种方式 root 和 alias，两者的主要区别在于 nginx 如何解释 location 后面的 uri。\n\n## 1、真实目录与虚拟目录\n\n官方的说，alias 指令用来重置当前文件的目录，lacation 后面的uri 是虚拟目录，而使用 root 时，lacation 后面的 uri 是真实目录。\n\n举个例子，对于相同配置，访问 [http://localhost/test/index.html](http://localhost/test/index.html)\n\n```nginx\nlocation ^~ /test/ {\n  root /www/root/html/;\n}\n```\n\n将会访问服务器的 /www/root/html/test/index.html 资源。\n\n```nginx\nlocation ^~ /test/ {\n  alias /www/root/html/;\n}\n```\n\n将会访问服务器的 /www/root/html/index.html 资源。\n\n## 2、使用建议\n\n一般情况下，在 nginx 配置中的良好习惯是：\n\n- 1）在location / 中配置root目录；\n- 2）在location /path 中配置alias虚拟目录。\n\n当然，使用 root + rewrite 可以 实现虚拟目录的功能。alias 后面也可以使用 reweite 功能，比如：\n\n```nginx\nlocation /web1 {\n  # index index.html index;\n  alias /Users/user/Desktop/html;\n  rewrite /web1 /web2/web2;\n}\n\nlocation /web2 {\n  # index index.html index;\n  alias /Users/user/Desktop/html;\n}\n```","isLeaf":true},{"key":"/backend/nginx/03-if-condition.md","path":"/backend/nginx/03-if-condition.md","route":"/backend/nginx/03-if-condition.md","leaf":true,"title":"03-if-condition","depth":2,"content":"---\ntitle: 03 nginx 条件判断\ntoc: true\ntags: nginx\ncategories: 中间件\ndate: 2018-05-01\n---\n\n初用 nginx ，发现 nginx 不支持if嵌套，逻辑与，逻辑或。但是可以采用变量叠加的方式来实现，举例：\n\n```nginx\nlocation ~ / {\n  root /Users/manba/Desktop/html;\n\n  set $talent_static_flag \"0\";\n\n  if ($request_uri ~* \"\\.(gif|jpg|jpeg|bmp|png|ico|txt|json|svg|js|css)$\") {\n    # 请求资源类型为静态资源\n    set $talent_static_flag \"1\";\n  }\n\n  if ($http_referer ~ \".*\\/talent\\/?\") {\n    # 请求referer包含 /talent\n    set $talent_static_flag \"{$talent_static_flag}1\"; # 这里的值包含 {}，😂暂时不知道如何去掉 \n  }\n\n  if ($talent_static_flag = \"{1}1\") {\n    rewrite /(.*) / break;\n    proxy_pass http://demo.airtlab.com;\n    break;\n  }\n}\n```","isLeaf":true},{"key":"/backend/nginx/04-set-header.md","path":"/backend/nginx/04-set-header.md","route":"/backend/nginx/04-set-header.md","leaf":true,"title":"04-set-header","depth":2,"content":"---\ntitle: 04 header 操作\ntoc: true\ntags: nginx\ncategories: 中间件\ndate: 2018-05-01\n---\n\n## 1. ngx_http_headers_module\n\n这是一个自带模块，已经集成到了 nginx 的二进制安装包。\n\n### 1) 添加 header 字段\n\n- 语法：`add_header name value [always];`\n- 上下文：`http, server, location, if in location`\n\n```nginx\nlocation = /test2 {\n  add_header x-server nginx;\n}\n```\n\n> 默认当响应状态码为 200, 201 (1.3.10), 204, 206, 301, 302, 303, 304, 307 (1.1.16, 1.0.13), or 308 (1.13.0). add_header 才会被使用，如果希望忽略状态码，可以使用是 4 个参数 always。\n\n> There could be several add_header directives. These directives are inherited from the previous configuration level if and only if there are no add_header directives defined on the current level. 您可能会配置多个 add_header，但是 nginx 只会遵循就近原则，最终只有一个会生效。\n\n另外，当您使用了代理服务器时，当出现了同名的字段，add_header 不能覆盖原有的 header 字段，只会再次增加，这会带来一些 BUG。\n\n### 2) 设置过期时间 expires\n\n```nginx\nlocation / {\n  expires    24h;\n}\n```\n\n直接看文档：[http://nginx.org/en/docs/http/ngx_http_headers_module.html#expires](http://nginx.org/en/docs/http/ngx_http_headers_module.html#expires)\n\n## 2. headers_more 模块\n\n源码地址：https://github.com/openresty/headers-more-nginx-module。用于添加，设置，清除输入和输出的头信息。nginx 源码没有包含该模块，需要另行添加。\n\n该模块是 `ngx_http_headers_module` 模块的增强版，提供了更多的实用工具，比如复位或清除内置头信息，如 Content-Type, Content-Length, 和 Server。\n\n主要区别：\n\n1. 该模块的指示适用于所有的状态码，包括 4xx 和 5xx 的。 add_header 只适用于 200，201，204，206，301，302，303，304，或 307。\n2. 可以添加或者替换。\n\n主要指令：\n\n- more_set_headers 用于添加、修改、清除响应头\n- more_clear_headers 用于清除响应头\n- more_set_input_headers 用于添加、修改、清除请求头，常常和 proxy_pass 一起使用。\n- more_clear_input_headers 用于清除请求头，常常和 proxy_pass 一起使用。\n\n```nginx\nlocation /bar {\n  more_set_headers 'X-1: 1' 'X-2: 1';\n  more_clear_headers 'Content-Type';\n  # proxy_pass ...\n}\n\nlocation /foo {\n  set $my_host 'my dog';\n  more_set_input_headers 'Host: $my_host';\n  # proxy_pass ...\n}\n```\n\n## 3. ngx_http_proxy_module\n用于给代理下游服务添加请求头\n\n### 1) proxy_set_header\n\n语法: `proxy_set_header field value;`\n默认:\n\n```\nproxy_set_header Host $proxy_host;\nproxy_set_header Connection close;\n```\n\n上下文: http, server, location\n使用这个指令特别注意，如果你的代理服务和客户端是同一个 HOST，那么转发设置是这样的：\n\n```nginx\nproxy_set_header Host       $http_host\n```\n\n如果不是同一个 HOST，那你应该改成你需要的：\n\n```nginx\nproxy_set_header Host       $host;\n```\n\n![](https://img2020.cnblogs.com/blog/2032346/202012/2032346-20201209090752688-1537133429.png#id=wqEca&originHeight=456&originWidth=2044&originalType=binary&ratio=1&status=done&style=none)\n","isLeaf":true},{"key":"/backend/nginx/05-timeout-set.md","path":"/backend/nginx/05-timeout-set.md","route":"/backend/nginx/05-timeout-set.md","leaf":true,"title":"05-timeout-set","depth":2,"content":"---\ntitle: 05 nginx 超时设置\ntoc: true\ntags: nginx\ncategories: 中间件\ndate: 2018-05-01\n---\n\n## 1. 长链接超时 keepalive\n- 语法: `keepalive_timeout timeout [ header_timeout ]`\n- 默认值：75s\n- 上下文: http server location\n\n说明：\n\n- 第一个参数指定了与 client 的 keep-alive 连接超时时间。服务器将会在这个时间后关闭连接，建议设置为 60s。\n- 可选的第二个参数指定了在响应头 Keep-Alive: timeout=time中的time值。这个头能够让一些浏览器主动关闭连接，这样服务器就不必要去关闭连接了。\n- keepalive_timeout 的值应该大于 client_body_timeout\n\n可以在浏览器上通过 connectionId 测试。\n\n## 2. 客户端 header 超时 client_header_timeout\n\n- 语法: `client_header_timeout 15s;`\n- 默认值：60s\n\n客户端向服务端发送一个完整的 request header 的超时时间，如果60s内没有收到完整的 http request header，则为超时。如果客户端超时，nginx 返回 HTTP 408（Request Timed Out）。\n\n当 cookie 很大很大时，容易出现。\n\n## 3. 客户端 body 超时 client_body_timeout\n\n- 语法：`client_body_timeout 15s;`\n- 默认值：60s\n\n客户端向服务端发送 request body 的超时时间，如果连续的60s内没有收到客户端的1个字节，则表示超时，如果客户端超时，nginx 返回 HTTP 408（Request Timed Out）。\n\n## 4. 向客户端发送数据超时 send_timeout\n\n- 语法：`send_timeout 15s;`\n- 默认值: 60s\n\nsend_timeout 指定客户端的响应超时时间。这个设置指的是在这段时间内，客户端没有读取任何数据，nginx就会关闭连接。\n\n## 5. 大文件上传\n有大文件上传时，需要指定body的最大值:\n```nginx\nclient_max_body_size          50m;` # 默认1M\n```\n\n超过这个值会返回 413 状态码。\n\n## 6. 大文件下载\n如果有大文件下载，建议限制下载速度，否则会导致网站奔溃。\n\n## 7. nginx 作为反向代理服务器\n通常需要注意以下配置：\n\n- 定义与被代理服务器建立连接的超时，应该注意，这个超时通常不能超过75秒。\n```nginx\nproxy_connect_timeout 60s;\n```\n\n- 设置向被代理服务器传输请求的超时。超时仅在两个连续的写操作之间设置，而不用于传输整个请求。如果代理服务器在此期间没有接收到任何内容，则关闭连接。\n```nginx\nproxy_send_timeout 60s;\n```\n\n- 定义从被代理服务器读取响应的超时。超时仅在两个连续的读取操作之间设置，而不用于传输整个响应。如果代理服务器在此期间没有传输任何内容，则关闭连接。\n```nginx\nproxy_read_timeout 60s;\n```\n","isLeaf":true},{"key":"/backend/nginx/06-content-phase.md","path":"/backend/nginx/06-content-phase.md","route":"/backend/nginx/06-content-phase.md","leaf":true,"title":"06-content-phase","depth":2,"content":"---\ntitle: 06 content 阶段疑惑\ntoc: true\ntags: nginx\ncategories: 中间件\ndate: 2018-05-01\n---\n\n```nginx\nlocation /renwu/ {\n  # 1\n  rewrite /renwu(.*) /api/index.html break;\n\n  # 2\n  proxy_pass http://renwu.airtlab.com;\n}\n```\n\n之前对这一块不了解，自己看不懂上面的配置，以为这里的 proxy_pass 是无效的，当访问 /renwu/ 时永远都是访问\n`/api/index.html` 这个资源。\n\n今天接手了同事的项目，发现这样配置是有效的，于是查了相关文档搞清楚了，这里涉及到两个知识点。\n\n（1）rewrite 比 proxy_pass 先执行，而且重定向后的 path 会替代 proxy_pass 的 URI\n\n![20230512205118](http://s3.airtlab.com/blog/20230512205118.png)\n\n（2）proxy_pass 有效的原因是，proxy_pass 在 conetnt 阶段执行。\n\n> CONTENT 阶段有些特殊，它不像其他阶段只能执行固定的 handler 链，还有一个特殊的 content_handler，每个 location 可以有自己独立的 content handler，而且当有 content handler 时，CONTENT 阶段只会执行 content handler，不再执行本阶段的 handler 链。\n\n\n> 默认情况下，nginx 会在 CONTENT 阶段的 handler链挂上index模块，静态文件处理模块等的 handler。另外模块还可以设置独立的 content handler，比如ngx_http_proxy_module的proxy_pass指令会设置一个名为ngx_http_proxy_handler的content handler。\n\n这里解释了为什么这里的 proxy_pass 有效的原因，参考文章见：[http://tengine.taobao.org/book/chapter_12.html#content](http://tengine.taobao.org/book/chapter_12.html#content)","isLeaf":true},{"key":"/backend/nginx/07-rate-limit.md","path":"/backend/nginx/07-rate-limit.md","route":"/backend/nginx/07-rate-limit.md","leaf":true,"title":"07-rate-limit","depth":2,"content":"---\ntitle: 07 访问限速\ntoc: true\ntags: nginx\ncategories: 中间件\ndate: 2018-05-01\n---\n\n- 使用 nginx 限制单个 IP 的并发连接数能够减少一些采集程序或者 DDOS 的攻击\n- 使用 nginx 限制下载速度，可以防止下载大文件时，导致网站不可访问\n\n```nginx\nhttp {\n  # ...\n\n  # 限制当前站点最大并发数 50\n  limit_conn perserver 50;\n\n  # 设置单个 IP 的并发连接数为 10\n  limit_conn perip 10;\n\n  # 限制客户端下载速度100KB/秒，此限制是针对单个线程\n  limit_rate       50k;\n\n  # 500k 以后开始限速\n  limit_rate_after 500k;\n\n  # ...\n}\n```","isLeaf":true},{"key":"/backend/nginx/08-log-setting.md","path":"/backend/nginx/08-log-setting.md","route":"/backend/nginx/08-log-setting.md","leaf":true,"title":"08-log-setting","depth":2,"content":"---\ntitle: 08 日志配置\ntoc: true\ntags: nginx\ncategories: 中间件\ndate: 2018-05-01\n---\n\n## 1. nginx 日志功能\n\n在 nginx 中有两种日志：\n\n- access_log：访问日志，通过访问日志可以获取用户的IP、请求处理的时间、浏览器信息等\n- error_log：错误日志，记录了访问出错的信息，可以用于定位错误的原因\n\n## 2. 设置 access_log\n\n访问日志主要用于记录客户端的请求。客户端向 nginx 服务器发起的每一次请求都会被记录到 access_log 中。\n\n包含请求 IP、时间、访问 url 等等，当然访问日志中具体记录哪些日志信息我们可以通过 log_format 设置。\n\n### access_log 指令语法\n\n```bash\naccess_log path [format [buffer=size] [gzip[=level]] [flush=time] [if=condition]]; # 设置访问日志\naccess_log off; # 关闭访问日志\n\n- path 表示指定日志存放位置\n- format 表示日志格式即日志中记录的内容\n- buffer 用于指定日志写入时的缓存大小，默认 64k\n- gzip 日志写入前先压缩。压缩率可以指定，从1到9数值越大压缩比越高，同时压缩的速度也越慢，默认1\n- flush 设置缓存的时间，如果超过flush指定的时间，缓存中的内容将被清空\n- if 判断条件，如果指定的条件计算为0或空字符串，那么该请求不会被写入日志\n```\n\n设置 buffer 的目的，是为了避免高频对磁盘进行读写操作，即暂时先不将日志写入磁盘，而是存入内存中，等达到了设置缓存大小之后再一次性写入。\n\n注意 flush 指令是和 buffer 一起使用的，即指定 buffer=size 之后，如果超过 flush 指令设定的时间仍然未达到缓存区大小，则也会被写入到磁盘，没有 buffer 而只有 flush 则会报错。\n\n### access_log 配置示例\n\n```bash\naccess_log /var/logs/nginx-access.log\n```\n\n上面的例子指定日志的写入路径为 /var/logs/nginx-access.log 日志格式默认使用 combined：\n\n```bash\naccess_log /var/logs/nginx-access.log buffer=32k gzip flush=1m\n```\n\n该例子指定日志写入路径为 `/var/logs/nginx-access.log` 日志格式默认使用 combined ，日志的缓存大小为 32k，日志写入前启用 gzip 压缩，压缩比值 1，缓存数据的有效时间为 1 分钟。\n\n需要注意，在 nginx.conf 文件中 access_log 默认是关闭的：\n![20230512205539](http://s3.airtlab.com/blog/20230512205539.png)\n\n去掉注释：\n![](http://c1.airtlab.com/15953369053114.jpg#id=yK5bl&originHeight=700&originWidth=2190&originalType=binary&ratio=1&status=done&style=none)\n\n### access_log 日志查看\n\n通过 cat 命令查看日志：\n![](http://c1.airtlab.com/15953370482388.jpg#id=Atj9p&originHeight=490&originWidth=2878&originalType=binary&ratio=1&status=done&style=none)\n\n它的格式为：\n![](http://c1.airtlab.com/15953374175706.jpg#id=lTOrp&originHeight=164&originWidth=1136&originalType=binary&ratio=1&status=done&style=none)\n\n```bash\n127.0.0.1 - - [21/Jul/2020:21:10:27 +0800] \"GET / HTTP/1.1\" 304 0 \"-\" \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36\" \"-\"\n\n1. $remote_addr(客户端(用户) IP地址) 127.0.0.1\n2. $remote_user(需要在基于认证规则的时候，才有) ''\n3. $time_local(访问时间) 21/Jul/2020:21:10:27 +0800\n4. $request(请求的 url 地址) \"GET / HTTP/1.1\"\n5. $body_bytes_sent(nginx返回给客户端的响应体的字节数，即不含响应头) 0\n6. $status(请求状态) 304 \n7. $http_referer(请求来源) \"-\"\n8. $http_user_agent(客户端信息) \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36\"\n9. $http_x_forwarded_for(表示 HTTP 请求端真实 IP) \"-\"\n```\n\n我们也可以根据自己需要日志信息在 nginx 配置文件中修改日志格式。\n\n## 3. 设置 error_log\n\nerror_log 错误日志，记录了访问出错的信息，可以用于定位错误的原因。\n\n### error_log 指令语法\n\n```bash\nerror_log file [level];\n```\n\n第一个参数指写入错误日志的路径\n第二个参数指日志的级别。level 可以是：debug、info、notice、warn、error、crit、alert、emerg 中的任意值。只有日志的错误级别大于等于level 指定的值才会被写入错误日志中，默认值是 error。\n\n### error_log 配置示例\n\n```bash\nerror_log logs/error.log error;\n```\n\n### error_log 日志查看\n\n![](http://c1.airtlab.com/15953384654024.jpg#id=XaDjw&originHeight=568&originWidth=2856&originalType=binary&ratio=1&status=done&style=none)\n\n```bash\n2020/07/21 18:21:47 [emerg] 57325#0: bind() to 0.0.0.0:9000 failed (48: Address already in use)\n\n1. 发生错误时间：2020/07/21 18:21:47 \n2. 日志级别：emerg \n3. 详细信息：bind() to 0.0.0.0:9000 failed (48: Address already in use)\n```\n\n## 4. 参考文章\n1. [https://www.cnblogs.com/aoniboy/p/4866395.html](https://www.cnblogs.com/aoniboy/p/4866395.html)\n2. [https://www.cnblogs.com/leeyongbard/p/10880356.html](https://www.cnblogs.com/leeyongbard/p/10880356.html)","isLeaf":true},{"key":"/backend/nginx/09-log-cutting.md","path":"/backend/nginx/09-log-cutting.md","route":"/backend/nginx/09-log-cutting.md","leaf":true,"title":"09-log-cutting","depth":2,"content":"---\ntitle: 09 nginx 日志切割\ntoc: true\ntags: nginx\ncategories: 中间件\ndate: 2018-05-01\n---\n\nnginx web 服务器中 access 日志，默认是不能按时间分隔的，每次日志都是打在access.log上，这样久而久之这个日志文件就特别的大，也不利于清理和管理，故此我们肯定是需要做时间上的切割的，那么如何做到完美的切割的呢？\n\n我们采取的方案是利用shell脚本和crontab定时任务来做：每天 23:59:59 将日志取出来并新建文件，比如：error-2020-07-20.log。\n\n创建shell脚本 `cut_nginx_log.sh`：\n\n```shell\n#!/bin/bash\nyear=`date +%Y`\nmonth=`date +%m`\nday=`date +%d`\nlogs_backup_path=\"/usr/local/Cellar/nginx/1.15.8/logs\"  \n\nlogs_path=\"/usr/local/Cellar/nginx/1.15.8/logs/\" \nlogs_access=\"access\" \nlogs_error=\"error\"\npid_path=\"/usr/local/etc/nginx/logs/nginx.pid\"\n\n[ -d $logs_backup_path ]||mkdir -p $logs_backup_path\nrq=`date +%Y_%m_%d`\n\nif [ -f \"/usr/local/Cellar/nginx/1.15.8/logs/access.log\" ];then\nmv ${logs_path}${logs_error}.log ${logs_backup_path}/${logs_error}_${rq}.log\nfi\n\nif [ -f \"/usr/local/Cellar/nginx/1.15.8/logs/error.log\" ];then\nmv ${logs_path}${logs_access}.log ${logs_backup_path}/${logs_access}_${rq}.log\nfi\n\n# 刷新 nginx 日志文件\nkill -USR1 $(cat /usr/local/etc/nginx/logs/nginx.pid)\n```\n\n创建定时任务：\n\n```shell\n# 每天 23:59:分开始执行\ncrontab –e 59 23 * * * bash cut_nginx_log.sh\n```\n\n`kill -USR1 ...` 用于向nginx服务主进程发送信号, USR1为信号类型，它支持以下几种：\n![](http://c1.airtlab.com/15954265846281.jpg#id=y1tYR&originHeight=602&originWidth=1964&originalType=binary&ratio=1&status=done&style=none)\n\n需要注意的是，在上面的脚本中，我将 nginx 的安装路径写死了，应该尽量避免这种做法，通用性不强，应该改为使用shell命令获取。","isLeaf":true},{"key":"/backend/nginx/10-interview.md","path":"/backend/nginx/10-interview.md","route":"/backend/nginx/10-interview.md","leaf":true,"title":"10-interview","depth":2,"content":"---\ntitle: 10 nginx 常见问题\ntoc: true\ntags: nginx\ncategories: 中间件\ndate: 2018-05-01\n---\n\n- https://blog.csdn.net/weixin_43122090/article/details/105461971\n- https://zhuanlan.zhihu.com/p/101907416?hmsr=toutiao.io\n- https://www.zhihu.com/zvideo/1304102200206655488","isLeaf":true},{"key":"/backend/nginx/11-proxy.md","path":"/backend/nginx/11-proxy.md","route":"/backend/nginx/11-proxy.md","leaf":true,"title":"11-proxy","depth":2,"content":"---\ntitle: 11 反向代理配置\ntoc: true\ntags: nginx\ncategories: 中间件\ndate: 2018-05-01\n---\n\n```nginx\nserver {\n  listen 80;\n  server_name www.example.com example.com;\n\n  location /app {\n    proxy_pass http://127.0.0.1:8080;\n  }\n}\n```\n\n上面的配置指示 nginx 将所有以 `/app` 开头的请求传递到到 `http://127.0.0.1:8080` 服务\n\n将请求头 Host 字段的值更改为 $host，并将 Accept-Encoding 值设置为空字符串来删除标头 Accept-Encoding 请求头。\n\n```nginx\nlocation / {\n  proxy_set_header Host $host;\n  proxy_set_header Accept-Encoding \"\";\n  proxy_pass http://localhost:3000;\n}\n```\n\n参考 https://www.myfreax.com/nginx-reverse-proxy","isLeaf":true},{"key":"/backend/nginx/12-rewrite.md","path":"/backend/nginx/12-rewrite.md","route":"/backend/nginx/12-rewrite.md","leaf":true,"title":"12-rewrite","depth":2,"content":"---\ntitle: 12 重定向功能\ntoc: true\ntags: nginx\ncategories: 中间件\ndate: 2018-05-01\n---\n\n## 1. return 指令\n\n(1) 语法\n\n![20230512210550](http://s3.airtlab.com/blog/20230512210550.png)\n\n(2) CODE\n\n-  301 永久重定向 \n-  302 临时重定向，禁止缓存 \n-  303 临时重定向，允许改变请求方法，临时重定向，禁止缓存 \n-  307 临时重定向，不允许改变请求方法，临时重定向，禁止缓存 \n-  308 永久重定向，不允许改变请求方法 \n\n(3) return 在各上下文的执行顺序\nserver return > location return > error_page\n\n![20230512210612](http://s3.airtlab.com/blog/20230512210612.png)\n\n## 2. return 不下载文件\n\n![20230512211033](http://s3.airtlab.com/blog/20230512211033.png)\n\nnginx 使用 return 指令，会下载文件，配置返回内容的编码格式即可：\n\n```nginx\nlocation /test {\n  default_type text/html ;\n  return 200 \"hello $remote_addr\";\n}\n```\n\n## 3. rewrite 指令\n\n![20230512210642](http://s3.airtlab.com/blog/20230512210642.png)\n\n### 1. last 和 break 区别演示\n\n假设 html 根目录如下：\n\n![20230512210730](http://s3.airtlab.com/blog/20230512210730.png)\n\n```\n\n```nginx\nlocation /first {\n  rewrite /first(.*) /second$1 break;\n  return 200 \"first\";\n}\n\nlocation /second {\n  rewrite /second(.*) /third$1 last;\n  return 200 \"second\";\n}\n\nlocation /test {\n  rewrite /xxxtest(.*) /second$1 break;\n  return 200 \"test\";\n}\n\nlocation /third {\n  return 200 \"third\";\n}\n```\n\n演示 last 与 break 区别：\n\n（1）访问 /first/1.html，会重定向到 /second$1，此时使用了 break，则停止继续匹配，直接访问 /second/1.html，这里返回 404\n\n（2）访问 /second/3.html，会重定向到 /third$1，此时使用了 last，所以不会直接输出 /third/3.html，而是继续匹配，进入 `location /third`，然后返回 `third`。\n\n（3）访问 /test/1.html，此时 `location /test` 下的 rewrite 重定向失败(匹配失败)，会直接走后面的 return 语句，返回 `test`。\n\n### 2. rewrite 301/302 重定向\n\n![20230512210801](http://s3.airtlab.com/blog/20230512210801.png)\n\n### 3. 开启 rewrite_log\n\nrewrite_log 开启后，可以看到重定向日志，以便调试\n\n![20230512210943](http://s3.airtlab.com/blog/20230512210943.png)","isLeaf":true},{"key":"/backend/nginx/13-try_file.md","path":"/backend/nginx/13-try_file.md","route":"/backend/nginx/13-try_file.md","leaf":true,"title":"13-try_file","depth":2,"content":"---\ntitle: 13 try_file 指令\ntoc: true\ntags: nginx\ncategories: 中间件\ndate: 2018-05-01\n---\n\n## 1、演示1\n\n```nginx\nlocation / {\n  root data;\n  index index.html index.htm;\n  try_files $uri $uri/ /index.html;\n}\n```\n\n**解释配置**\n- root：设置静态根目录为 data\n- index：设置目录的默认文件为 index.html 、index.htm\n- try_files：设置文件查找规则为 $uri $uri/ /index.html。即3个规则，先从 $uri 查找，再从 $uri/ 目录中查找，最后查找 /index.html。\n\n例子：根据上面的配置，当请求 http://localhost:3004/api 时，$uri 为 /api。当前try_file 具体为：/api、/api/、/index.html，其中 / 表示根目录（根据 root 或 alias 来指定）。\n\n**查找逻辑**\n- 首先：检查 data 目录中是否存在 api 文件，如果存在，则返回文件；如果不存在，则进行下一步。\n- 其次：检查 data 目录中是否存在 api/ 目录，如果存在，则在检查 api/ 目录中是否存在 index.html 或者 index.htm 文件（由 index 指定）；如果存在，则返回该文件。如果不存在，则进行下一步。\n- 最后：检查 data 目录中是否存在 index.html 文件。如果存在，则返回文件；如果不存在，则返回 404。\n\n## 2、演示2\n```nginx\nlocation /pngs/ {\n  root /data/user/;\n  index index.html index.htm;\n  try_files $uri   $uri/  /pngs/file.png; \n}\n```\n\n根据上面的配置，当请求 http://localhost:3003/pngs/rule.png 时， $uri 为 /pngs/rule.png，当前 try_file 查找顺序为\n- 首先是：/data/user/pngs/rule.png\n- 其次是：/data/user/pngs/rule.png/ 文件下的 index 所配置的文件，即： index.html、index.htm\n- 最后是： /data/user/pngs/file.png。","isLeaf":true},{"key":"/backend/nginx/14-get-url-param.md","path":"/backend/nginx/14-get-url-param.md","route":"/backend/nginx/14-get-url-param.md","leaf":true,"title":"14-get-url-param","depth":2,"content":"---\ntitle: 14 获取URL参数\ntoc: true\ntags: nginx\ncategories: 中间件\ndate: 2018-05-01\n---\n\n## $args\n\n在 nginx 中获取 URL 参数可以使用 `ngx_http_core_module` 模块提供的 `$args` 变量，该变量包含整个请求中的 URL 参数字符串。\n要获取特定参数的值，可以使用 `ngx_http_set_misc_module` 模块提供的 `set` 指令。以下是一个示例配置：\n\n```nginx\nlocation /example {\n  set $param1 '';\n  set $param2 '';\n\n  if ($args ~* \"param1=([^&]+)\") {\n    set $param1 $1;\n  }\n\n  if ($args ~* \"param2=([^&]+)\") {\n    set $param2 $1;\n  }\n\n  # do something with $param1 and $param2 here...\n}\n```\n\n在上面的配置中，我们首先定义两个变量 `param1` 和 `param2`，然后使用 `if` 语句和正则表达式来提取参数值。例如，如果 URL 包含参数 `param1=foo`，那么 `$param1` 变量将被设置为 `foo`；如果参数不存在，则 `$param1` 将保持为空字符串。最后，我们可以使用 `$param1` 和 `$param2` 变量执行任何必要的操作。\n\n## $arg_{name}\n\n通过 $arg_{name} 获得单个参数值，比如 $arg_name 用于获取 name 的值，$arg_age 用于获取 age 的值","isLeaf":true},{"key":"/backend/nginx/15-match-question-mark.md","path":"/backend/nginx/15-match-question-mark.md","route":"/backend/nginx/15-match-question-mark.md","leaf":true,"title":"15-match-question-mark","depth":2,"content":"---\ntitle: 15  normalized URI 不包含查询字符串\ntoc: true\ntags: nginx\ncategories: 中间件\ndate: 2018-05-01\n---\n\n期望当访问 `localhost:5000/bill/detail/1234?a=1&b=2` 时重定向到 `http://localhost:5000/bill/detail/?a=1&b=2&term=123`\n\n## 1、代码测试\n\n```conf\n  location /bill/detail {\n    # $1 匹配 数字部分\n    # $2 匹配 query string\n    rewrite  ^/bill/detail/([\\d]+)\\?(.*)$ https://www.baidu.com?$2&term=$1 redirect;\n  }\n```\n\n```\n2023/06/03 20:20:38 [notice] 3128#0: *5 \"^/bill/detail/([\\d]+)\\?(.*)$\" does not match \"/bill/detail/1234\", client: 127.0.0.1, server: 127.0.0.1, request: \"GET /bill/detail/1234?a=1&b=2 HTTP/1.1\", host: \"localhost:5000\"\n```\n\n## 2、相关问题\n\n(1) https://stackoverflow.com/questions/58019632/how-to-rewrtite-in-nginx-uri-with-a-question-mark\n\n![20230603203523](http://s3.airtlab.com/blog/20230603203523.png)\n  \n(2) https://stackoverflow.com/questions/15713934/how-to-match-question-mark-as-regexp-on-nginx-conf-location\n\n![20230603204049](http://s3.airtlab.com/blog/20230603204049.png)\n\n这里是说 `location ~ match` match 不能匹配 ? query string 部分\n\n(3) https://stackoverflow.com/questions/40551769/nginx-rewrite-rule-add-trailing-slash-before-question-mark\n\n这是一个类似问题，作者也想匹配 `?`\n\n## 3、参考资料\n\n- http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#rewrite\n\n## 4、原因\n\n`The ? marks the start of the query string which is not part of the normalized URI used in location and rewrite directives.` 参考 https://stackoverflow.com/questions/40551769/nginx-rewrite-rule-add-trailing-slash-before-question-mark\n\n`The ? and anything following is the query string and is not part of the normalised URI used by nginx in location and rewrite directives.`\n\nhttps://stackoverflow.com/questions/44782411/nginx-rewrite-question-mark\n\n\n问号和问号后面的内容是查询字符串，不是由nginx在位置和重写指示中使用的标准化URI的一部分。查询字符串是HTTP请求中用于将额外的参数传递给服务器的一部分，而URI（统一资源标识符）则指定了要访问的资源的标识符。因此，对于使用nginx的位置和重写指令的服务器来说，查询字符串需要单独处理。\n\n## 5、最终方案\n\n```nginx\nlocation /bill/detail {\n  rewrite ^/bill/detail/([\\d]+)(.*)$ https://www.baidu.com/?term=$1&$args? redirect;\n}\n```","isLeaf":true},{"key":"/backend/nginx/16-why-args-duplicate.md","path":"/backend/nginx/16-why-args-duplicate.md","route":"/backend/nginx/16-why-args-duplicate.md","leaf":true,"title":"16-why-args-duplicate","depth":2,"content":"---\ntitle: 16 why-args-duplicate\ntoc: true\ntags: nginx\ncategories: 中间件\ndate: 2018-05-01\n---\n\n## 1、测试 1\n```nginx\nlocation /bill/detail {\n  rewrite ^/bill/detail/([\\d]+)(.*)$ https://www.baidu.com/?$args redirect;\n}\n```\n\n`http://localhost:5000/bill/detail/1234?a=1`\n\n=>\n\n`https://www.baidu.com/?a=1&a=1`\n\n## 2、测试 2\n\n```nginx\nlocation /bill/detail {\n  rewrite ^/bill/detail/([\\d]+)(.*)$ https://www.baidu.com/?term=$1&$args redirect;\n}\n```\n\n`http://localhost:5000/bill/detail/1234?a=1&b=2`\n\n=>\n\n`https://www.baidu.com/?term=1234&a=1&b=2&a=1&b=2`\n\n## 3、解释 \n\n> Nginx appends the query string automatically if there are other get parameters in the rewritten URL. If you're adding $args yourself you should add a ? (question mark) at the end of the rewritten URL to avoid having duplicate parameters.\n\n```nginx\nrewrite ^(...)$ /destination$is_args$args? [permanent|redirect];\n```\n\nhttps://stackoverflow.com/questions/23635203/using-args-in-nginx-rewrite-causing-duplicate-url-parameters","isLeaf":true},{"key":"/backend/nginx/17-config-template.md","path":"/backend/nginx/17-config-template.md","route":"/backend/nginx/17-config-template.md","leaf":true,"title":"17-config-template","depth":2,"content":"---\ntitle: 17 常用配置\ntoc: true\ntags: nginx\ncategories: 中间件\ndate: 2018-05-01\n---\n\n## 1、try_file\n\n```nginx\nlocation / {\n  index index.html index;\n  try_files $uri $uri/ /index.html =404;\n}\n```\n\n## 2、反向代理\n\n```nginx\nserver {\n  listen 80;\n  server_name www.example.com example.com;\n\n  location /api {\n    proxy_set_header Host $host;\n    proxy_set_header Accept-Encoding \"\";\n    proxy_pass http://localhost:3000;\n  }\n}\n```\n\n注意这里 `http://localhost:3000` 和 `http://localhost:3000/` 的区别\n\n## 3、重定向\n\n```nginx\nlocation /bill/detail {\n  rewrite ^/bill/detail/([\\d]+)(.*)$ https://www.baidu.com/?$args redirect;\n}\n```\n\n## 4、大文件上传\n\n```nginx\nserver {\n  listen       80;\n  server_name  localhost;\n  \n  client_max_body_size     50m;  # 限制请求体的大小，若超过所设定的大小，返回413错误，默认1m\n  client_header_timeout    1m;  # 读取请求头的超时时间，若超过所设定的大小，返回408错误\n  client_body_timeout      1m; # 读取请求实体的超时时间，若超过所设定的大小，返回413错误\n  proxy_connect_timeout     60s; # http请求无法立即被容器(tomcat, netty等)处理，被放在nginx的待处理池中等待被处理。此参数为等待的最长时间，默认为60秒，官方推荐最长不要超过75秒\n  proxy_read_timeout      1m;  # http请求被容器(tomcat, netty等)处理后，nginx会等待处理结果，也就是容器返回的response。此参数即为服务器响应时间，默认60秒\n  proxy_send_timeout      1m; # http请求被服务器处理完后，把数据传返回给Nginx的用时，默认60秒\n\n  location  / {\n      # ...\n  }\n}   \n```\n\n## 5、虚拟目录\n\n```\nlocation /web2 {\n  # index index.html index;\n  alias /Users/user/Desktop/html;\n}\n```\n\n使用 root + rewrite 可以 实现虚拟目录的功能\n","isLeaf":true},{"key":"/backend/nginx/18-nginx-single-process.md","path":"/backend/nginx/18-nginx-single-process.md","route":"/backend/nginx/18-nginx-single-process.md","leaf":true,"title":"18-nginx-single-process","depth":2,"content":"---\ntoc: true\ntags: nginx\ncategories: 中间件\ndate: 2018-05-01\n---\n\nnginx 在处理每一个用户请求时，都是按照若干个不同的阶段依次处理的，与配置文件上的顺序没有关系，详细内容可以阅读《深入理解nginx:模块开发与架构解析》这本书，这里只做简单介绍；\n\n（1）post-read\n\n读取请求内容阶段，nginx读取并解析完请求头之后就立即开始运行；\n\n（2）server-rewrite\n\nserver请求地址重写阶段；\n\n（3）find-config\n\n配置查找阶段，用来完成当前请求与location配重块之间的配对工作；\n\n（4）rewrite\n\nlocation请求地址重写阶段，当ngx_rewrite指令用于location中，就是再这个阶段运行的；\n\n（5）post-rewrite\n\n请求地址重写提交阶段，当nginx完成rewrite阶段所要求的内部跳转动作，如果rewrite阶段有这个要求的话；\n\n（6）preaccess\n\n访问权限检查准备阶段，ngx_limit_req和ngx_limit_zone在这个阶段运行，ngx_limit_req可以控制请求的访问频率，ngx_limit_zone可以控制访问的并发度；\n\n（7）access\n\n权限检查阶段，ngx_access在这个阶段运行，配置指令多是执行访问控制相关的任务，如检查用户的访问权限，检查用户的来源IP是否合法；\n\n（8）post-access\n\n访问权限检查提交阶段；\n\n（9）try-files\n\n配置项try_files处理阶段；\n\n（10）content\n\n内容产生阶段，是所有请求处理阶段中最为重要的阶段，因为这个阶段的指令通常是用来生成HTTP响应内容的；\n\n（11）log\n\n日志模块处理阶段；","isLeaf":true},{"key":"/backend/nginx/19-nginx-with-lua.md","path":"/backend/nginx/19-nginx-with-lua.md","route":"/backend/nginx/19-nginx-with-lua.md","leaf":true,"title":"19-nginx-with-lua","depth":2,"content":"---\ntoc: true\ntags: nginx\ncategories: 中间件\ndate: 2018-05-01\n---\n\nnginx 中嵌入 lua 脚本环境搭建：\n\n## 1. 环境搭建\n\n### 1.1 源码编译安装\n可以参考 https://segmentfault.com/a/1190000018641801\n\n### nginx-mod-http-lua 集成环境\n\n安装这个包后，会安装 nginx 以及 lua 相关的依赖\n\n```Dockerfile\nFROM alpine:3.6\n\nRUN apk add --no-cache nginx-mod-http-lua\n\n# Delete default config\nRUN rm -r /etc/nginx/conf.d && rm /etc/nginx/nginx.conf\n\n# Create folder for PID file\nRUN mkdir -p /run/nginx\n\n# Add our nginx conf\nCOPY ./nginx.conf /etc/nginx/nginx.conf\n\nRUN mkdir www\nCOPY html/ www\n\nCMD [\"nginx\"]\n\nEXPOSE 80\n```\n\n**使用演示**\n\n```nginx\nload_module /usr/lib/nginx/modules/ndk_http_module.so;\nload_module /usr/lib/nginx/modules/ngx_http_lua_module.so;\n\npcre_jit on;\n\nevents {\n  worker_connections 1024;\n}\n\nhttp {\n  include       mime.types;\n  default_type  application/octet-stream;\n\n  gzip on;\n  gzip_min_length 1k;\n  gzip_comp_level 1;\n  gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript;\n  gzip_vary on;\n  server_tokens       off;  # returns \"Server: nginx\"\n\n  log_format custom '$host - $remote_addr - $remote_user [$time_local] '\n                          '\"$request\" $status $body_bytes_sent '\n                          '\"$http_referer\" \"$http_user_agent\" \"$gzip_ratio\"';\n\n  gzip_disable \"MSIE [1-6]\\.\";\n  sendfile        on;\n\n  server {\n    listen 80;\n\n    location / {\n      root /www;\n      index  index.html index.htm;\n    }\n\n    location /lua {\n      # 定义MIME类型\n      default_type 'text/plain';\n      content_by_lua_block {\n        ngx.say('Hello,world!')\n      }\n    }\n  }\n}\n\ndaemon off;\n```\n\n## 2. 加载动态模块\n\n在nginx中，load_module指令用于加载动态模块，以扩展nginx的功能。\n\n动态模块是指可以在nginx运行时动态加载和卸载的一些二进制文件。通过加载动态模块，可以为nginx添加各种功能，如支持新的协议、文件格式、认证方式等。\n\n在 nginx 配置文件中，load_module 指令用于指定要加载的动态模块文件的路径和名称。当nginx启动时，它会自动加载并初始化指定的动态模块，从而扩展其功能。\n\n例如，要加载一个名为 mod_http_echo.so 的动态模块，只需在nginx配置文件中添加如下指令：\n\n```nginx\nload_module /path/to/mod_http_echo.so;\n```\n\n这将加载 mod_http_echo.so 动态模块，并使其在nginx中可用。\n\n## 3. openrestry\n\nOpenResty 是一个基于 nginx 服务器的 Web 应用开发框架。它提供了丰富的 Lua 库和第三方模块，并通过内置的 Lua 解释器将 Lua 语言嵌入 Nginx 的配置文件和服务器中。\nOpenResty 包含了一系列的组件，例如：\n\n- Nginx：为 HTTP/HTTPS 服务器提供平台。\n- LuaJIT： 高性能 Lua VM 的快速 JIT 编译器。\n- ngx_lua：将 Lua 脚本编写成 Nginx 的模块。\n- ngx_stream_lua：将 Lua 脚本编写成 Nginx 的 TCP 或 UDP 的模块。\n- LuaRocks：开源的 Lua 库和工具管理系统。\n\nOpenResty 通过将 Lua 脚本编写成 Nginx 模块，使得这些模块可以通过 Nginx 的事件模型异步处理请求，并高效地执行各种操作，如：数据处理、访问数据库、HTTP 缓存等等，并且，在 Lua 语言中编写业务逻辑更加简单和灵活。\n\nOpenResty 已经在许多高性能 Web 应用场景得到应用，例如：API Gateway、反向代理、Web 应用防火墙、分布式缓存和负载均衡等等。","isLeaf":true},{"key":"/backend/nginx/20-openrestry.md","path":"/backend/nginx/20-openrestry.md","route":"/backend/nginx/20-openrestry.md","leaf":true,"title":"20-openrestry","depth":2,"content":"---\ntoc: true\ntags: nginx\ncategories: 中间件\ndate: 2018-05-01\n---\n\n## 1. OpenResty 介绍\n\nOpenResty 是一个基于 nginx 服务器的 Web 应用开发框架。它提供了丰富的 Lua 库和第三方模块，并通过内置的 Lua 解释器将 Lua 语言嵌入 Nginx 的配置文件和服务器中。\nOpenResty 包含了一系列的组件，例如：\n\n- Nginx：为 HTTP/HTTPS 服务器提供平台。\n- LuaJIT： 高性能 Lua VM 的快速 JIT 编译器。\n- ngx_lua：将 Lua 脚本编写成 Nginx 的模块。\n- ngx_stream_lua：将 Lua 脚本编写成 Nginx 的 TCP 或 UDP 的模块。\n- LuaRocks：开源的 Lua 库和工具管理系统。\n\nOpenResty 通过将 Lua 脚本编写成 Nginx 模块，使得这些模块可以通过 Nginx 的事件模型异步处理请求，并高效地执行各种操作，如：数据处理、访问数据库、HTTP 缓存等等，并且，在 Lua 语言中编写业务逻辑更加简单和灵活。\n\nOpenResty 已经在许多高性能 Web 应用场景得到应用，例如：API Gateway、反向代理、Web 应用防火墙、分布式缓存和负载均衡等等。\n\n## 2. 配置 \n\n![20230609174240](http://s3.airtlab.com/blog/20230609174240.png)\n\n**/usr/local/openresty/nginx/nginx.conf.default**\n```nginx\n#user  nobody;\nworker_processes  1;\n\n#error_log  logs/error.log;\n#error_log  logs/error.log  notice;\n#error_log  logs/error.log  info;\n\n#pid        logs/nginx.pid;\n\n\nevents {\n    worker_connections  1024;\n}\n\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n\n    #log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n    #                  '$status $body_bytes_sent \"$http_referer\" '\n    #                  '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\n    #access_log  logs/access.log  main;\n\n    sendfile        on;\n    #tcp_nopush     on;\n\n    #keepalive_timeout  0;\n    keepalive_timeout  65;\n\n    #gzip  on;\n\n    server {\n        listen       80;\n        server_name  localhost;\n\n        #charset koi8-r;\n\n        #access_log  logs/host.access.log  main;\n\n        location / {\n            root   html;\n            index  index.html index.htm;\n        }\n\n        #error_page  404              /404.html;\n\n        # redirect server error pages to the static page /50x.html\n        #\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n\n        # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n        #\n        #location ~ \\.php$ {\n        #    proxy_pass   http://127.0.0.1;\n        #}\n\n        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n        #\n        #location ~ \\.php$ {\n        #    root           html;\n        #    fastcgi_pass   127.0.0.1:9000;\n        #    fastcgi_index  index.php;\n        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n        #    include        fastcgi_params;\n        #}\n\n        # deny access to .htaccess files, if Apache's document root\n        # concurs with nginx's one\n        #\n        #location ~ /\\.ht {\n        #    deny  all;\n        #}\n    }\n\n\n    # another virtual host using mix of IP-, name-, and port-based configuration\n    #\n    #server {\n    #    listen       8000;\n    #    listen       somename:8080;\n    #    server_name  somename  alias  another.alias;\n\n    #    location / {\n    #        root   html;\n    #        index  index.html index.htm;\n    #    }\n    #}\n\n\n    # HTTPS server\n    #\n    #server {\n    #    listen       443 ssl;\n    #    server_name  localhost;\n\n    #    ssl_certificate      cert.pem;\n    #    ssl_certificate_key  cert.key;\n\n    #    ssl_session_cache    shared:SSL:1m;\n    #    ssl_session_timeout  5m;\n\n    #    ssl_ciphers  HIGH:!aNULL:!MD5;\n    #    ssl_prefer_server_ciphers  on;\n\n    #    location / {\n    #        root   html;\n    #        index  index.html index.htm;\n    #    }\n    #}\n\n}\n```\n\n**/usr/local/openresty/nginx/conf/nginx.conf**\n\n```nginx\n# nginx.conf  --  docker-openresty\n#\n# This file is installed to:\n#   `/usr/local/openresty/nginx/conf/nginx.conf`\n# and is the file loaded by nginx at startup,\n# unless the user specifies otherwise.\n#\n# It tracks the upstream OpenResty's `nginx.conf`, but removes the `server`\n# section and adds this directive:\n#     `include /etc/nginx/conf.d/*.conf;`\n#\n# The `docker-openresty` file `nginx.vh.default.conf` is copied to\n# `/etc/nginx/conf.d/default.conf`.  It contains the `server section\n# of the upstream `nginx.conf`.\n#\n# See https://github.com/openresty/docker-openresty/blob/master/README.md#nginx-config-files\n#\n\n#user  nobody;\n#worker_processes 1;\n\n# Enables the use of JIT for regular expressions to speed-up their processing.\npcre_jit on;\n\n\n\n#error_log  logs/error.log;\n#error_log  logs/error.log  notice;\n#error_log  logs/error.log  info;\n\n#pid        logs/nginx.pid;\n\n\nevents {\n    worker_connections  1024;\n}\n\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n\n    # Enables or disables the use of underscores in client request header fields.\n    # When the use of underscores is disabled, request header fields whose names contain underscores are marked as invalid and become subject to the ignore_invalid_headers directive.\n    # underscores_in_headers off;\n\n    #log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n    #                  '$status $body_bytes_sent \"$http_referer\" '\n    #                  '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\n    #access_log  logs/access.log  main;\n\n        # Log in JSON Format\n        # log_format nginxlog_json escape=json '{ \"timestamp\": \"$time_iso8601\", '\n        # '\"remote_addr\": \"$remote_addr\", '\n        #  '\"body_bytes_sent\": $body_bytes_sent, '\n        #  '\"request_time\": $request_time, '\n        #  '\"response_status\": $status, '\n        #  '\"request\": \"$request\", '\n        #  '\"request_method\": \"$request_method\", '\n        #  '\"host\": \"$host\",'\n        #  '\"upstream_addr\": \"$upstream_addr\",'\n        #  '\"http_x_forwarded_for\": \"$http_x_forwarded_for\",'\n        #  '\"http_referrer\": \"$http_referer\", '\n        #  '\"http_user_agent\": \"$http_user_agent\", '\n        #  '\"http_version\": \"$server_protocol\", '\n        #  '\"nginx_access\": true }';\n        # access_log /dev/stdout nginxlog_json;\n\n    # See Move default writable paths to a dedicated directory (#119)\n    # https://github.com/openresty/docker-openresty/issues/119\n    client_body_temp_path /var/run/openresty/nginx-client-body;\n    proxy_temp_path       /var/run/openresty/nginx-proxy;\n    fastcgi_temp_path     /var/run/openresty/nginx-fastcgi;\n    uwsgi_temp_path       /var/run/openresty/nginx-uwsgi;\n    scgi_temp_path        /var/run/openresty/nginx-scgi;\n\n    sendfile        on;\n    #tcp_nopush     on;\n\n    #keepalive_timeout  0;\n    keepalive_timeout  65;\n\n    #gzip  on;\n\n    include /etc/nginx/conf.d/*.conf;\n\n    # Don't reveal OpenResty version to clients.\n    # server_tokens off;\n}\n```\n\n```nginx\n# nginx.vh.default.conf  --  docker-openresty\n#\n# This file is installed to:\n#   `/etc/nginx/conf.d/default.conf`\n#\n# It tracks the `server` section of the upstream OpenResty's `nginx.conf`.\n#\n# This config (and any other configs in `etc/nginx/conf.d/`) is loaded by\n# default by the `include` directive in `/usr/local/openresty/nginx/conf/nginx.conf`.\n#\n# See https://github.com/openresty/docker-openresty/blob/master/README.md#nginx-config-files\n#\n\n\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/local/openresty/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/local/openresty/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           /usr/local/openresty/nginx/html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n```","isLeaf":true}]},{"key":"/backend/redis","path":"/backend/redis","route":"/backend/redis","leaf":false,"title":"redis","depth":1,"content":"","isLeaf":false,"children":[{"key":"/backend/redis/01-Redis.md","path":"/backend/redis/01-Redis.md","route":"/backend/redis/01-Redis.md","leaf":true,"title":"01-Redis","depth":2,"content":"---\ntags: Redis\n---\n\n- Redis协议详细规范 https://redis.com.cn/topics/protocol.html","isLeaf":true},{"key":"/backend/redis/02-Failed-to-refresh-slots-cache.md","path":"/backend/redis/02-Failed-to-refresh-slots-cache.md","route":"/backend/redis/02-Failed-to-refresh-slots-cache.md","leaf":true,"title":"02-Failed-to-refresh-slots-cache","depth":2,"content":"---\ntags: Redis\n---\n\n```text\nClusterAllFailedError: Failed to refresh slots cache.\n```\n\n可能是地址不正确","isLeaf":true}]}]},{"key":"/cpp","path":"/cpp","route":"/cpp","leaf":false,"title":"cpp","depth":0,"content":"","isLeaf":false,"children":[{"key":"/cpp/01-cpp-basic","path":"/cpp/01-cpp-basic","route":"/cpp/01-cpp-basic","leaf":false,"title":"01-cpp-basic","depth":1,"content":"","isLeaf":false,"children":[{"key":"/cpp/01-cpp-basic/01-about-cpp.md","path":"/cpp/01-cpp-basic/01-about-cpp.md","route":"/cpp/01-cpp-basic/01-about-cpp.md","leaf":true,"title":"01-about-cpp","depth":2,"content":"---\ntitle: 01 C++ 瞎聊\ntags: CPP\n---\n\n> \"用了C++就要接受它的麻烦\" 著名前同事王大爷如是说道","isLeaf":true},{"key":"/cpp/01-cpp-basic/02-diffrent-type-in-vector.md","path":"/cpp/01-cpp-basic/02-diffrent-type-in-vector.md","route":"/cpp/01-cpp-basic/02-diffrent-type-in-vector.md","leaf":true,"title":"02-diffrent-type-in-vector","depth":2,"content":"---\ntitle: 02 C++ 容器怎么存放不同类型的值？\ntags: CPP\n---\n\n> https://www.zhihu.com/question/33594512\n\n```cpp\ntypedef boost::variant<int, std::string> Value;\n```","isLeaf":true}]},{"key":"/cpp/02-cpp-mysql","path":"/cpp/02-cpp-mysql","route":"/cpp/02-cpp-mysql","leaf":false,"title":"02-cpp-mysql","depth":1,"content":"","isLeaf":false,"children":[{"key":"/cpp/02-cpp-mysql/01-mysqlclient.md","path":"/cpp/02-cpp-mysql/01-mysqlclient.md","route":"/cpp/02-cpp-mysql/01-mysqlclient.md","leaf":true,"title":"01-mysqlclient","depth":2,"content":"---\ntitle: 01 使用 mysqlclient-dev\ntags: CPP\n---\n\n# mysqlclient-dev\n\n- **[这个教程写的很详细，使用 C 操作 mysql](https://blog.csdn.net/qq_41453285/article/details/102640756)**\n\n## 1、安装 mysqlclient-dev\n\n这个例子在 ubuntu 上进行\n\n```shell\napt-get install libmysqlclient-dev\nsudo ldconfig # 刷新动态链接库\n```\n\n头文件位置 `/usr/include/mysql`，动态库位置 `/usr/lib/mysql`\n\n```shell\ngcc -I/usr/include/mysql main.c -L/usr/lib/mysql -lmysqlclient -o main\n```\n\n## 2、增删改查操作\n\n### 1) 连接 mysql 服务器\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <mysql.h>\n#include <mysqld_error.h>\n#include <errmsg.h>\n\nint main(int argc, char *argv[])\n{\n    MYSQL mysql;\n    mysql_init(&mysql);\n\n    if (mysql_real_connect(&mysql, \"10.53.100.113\", \"root\",\n                           \"123456\", \"test\", 0, NULL, 0))\n    {\n        printf(\"Connect success\\n\");\n\n        // insert\n        if (mysql_query(&mysql, \"insert into user(name) values('Ann')\") != 0)\n        {\n            fprintf(stderr, \"mysql_query failed:\\n\\tcode:%d\\n\\treason:%s\\n\", mysql_errno(&mysql), mysql_error(&mysql));\n        }\n        else\n        {\n            printf(\"Insert success, affect row are %lu\\n\", mysql_affected_rows(&mysql));\n        }\n\n        mysql_close(&mysql);\n    }\n    else\n    {\n        fprintf(stderr, \"Connect failed:\\n\");\n        if (mysql_errno(&mysql))\n        {\n            printf(\"\\terror code is %d\\n\\treason:%s\\n\", mysql_errno(&mysql), mysql_error(&mysql));\n        }\n    }\n\n    return 0;\n}\n```\n\n### 2) 修改数据\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <mysql.h>\n#include <mysqld_error.h>\n#include <errmsg.h>\n\nint main(int argc, char *argv[])\n{\n    MYSQL mysql;\n    mysql_init(&mysql);\n\n    if (mysql_real_connect(&mysql, \"10.53.100.113\", \"root\",\n                           \"123456\", \"test\", 0, NULL, 0))\n    {\n        printf(\"Connect success\\n\");\n\n        // update\n        if (mysql_query(&mysql, \"update user set name='tony' where id = 1\") != 0)\n        {\n            fprintf(stderr, \"mysql_query failed:\\n\\tcode:%d\\n\\treason:%s\\n\",\n                    mysql_errno(&mysql), mysql_error(&mysql));\n        }\n        else\n        {\n            printf(\"Update success,affect row are %lu\\n\",\n                   mysql_affected_rows(&mysql));\n        }\n\n        mysql_close(&mysql);\n    }\n    else\n    {\n        fprintf(stderr, \"Connect failed:\\n\");\n        if (mysql_errno(&mysql))\n        {\n            printf(\"\\terror code is %d\\n\\treason:%s\\n\", mysql_errno(&mysql), mysql_error(&mysql));\n        }\n    }\n\n    return 0;\n}\n```\n\n### 3) 查询操作\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <mysql.h>\n#include <mysqld_error.h>\n#include <errmsg.h>\n\nint main(int argc, char *argv[])\n{\n    MYSQL mysql;\n    MYSQL_RES *res;\n    MYSQL_ROW sqlrow;\n\n    mysql_init(&mysql);\n\n    if (mysql_real_connect(&mysql, \"10.53.100.113\", \"root\",\n                           \"123456\", \"test\", 0, NULL, 0))\n    {\n        printf(\"Connect success\\n\");\n\n        // select\n        if (mysql_query(&mysql, \"select * from user\") != 0)\n        {\n            fprintf(stderr, \"mysql_query failed:\\n\\tcode:%d\\n\\treason:%s\\n\",\n                    mysql_errno(&mysql), mysql_error(&mysql));\n        }\n        else\n        {\n            // get result\n            res = mysql_store_result(&mysql);\n            if (res != NULL)\n            {\n                // show rows\n                printf(\"Retrived %lu rows:\\n\", (unsigned long)mysql_num_rows(res));\n                // Get one row at a time\n                while (sqlrow = mysql_fetch_row(res))\n                {\n                    printf(\"\\tFetch row...\\n\");\n                }\n            }\n            else\n            {\n                if (mysql_errno(&mysql))\n                {\n                    printf(\"\\terror code is %d\\n\\treason:%s\\n\",\n                           mysql_errno(&mysql), mysql_error(&mysql));\n                }\n            }\n        }\n\n        mysql_close(&mysql);\n    }\n    else\n    {\n        fprintf(stderr, \"Connect failed:\\n\");\n        if (mysql_errno(&mysql))\n        {\n            printf(\"\\terror code is %d\\n\\treason:%s\\n\",\n                   mysql_errno(&mysql), mysql_error(&mysql));\n        }\n    }\n\n    return 0;\n}\n```\n\n### 4) 获取字段信息\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <mysql.h>\n#include <mysqld_error.h>\n#include <errmsg.h>\n\nvoid display_header(MYSQL_RES *result);\nvoid display_show(MYSQL *mysql, MYSQL_ROW *sqlrow);\n\nint main(int argc, char *argv[])\n{\n    int isHeader;\n    MYSQL mysql;\n    MYSQL_RES *res;\n    MYSQL_ROW sqlrow;\n    isHeader = 1;\n\n    mysql_init(&mysql);\n\n    if (mysql_real_connect(&mysql, \"10.53.100.113\", \"root\",\n                           \"123456\", \"test\", 0, NULL, 0))\n    {\n        printf(\"Connect success\\n\");\n\n        // select\n        if (mysql_query(&mysql, \"select * from user\") != 0)\n        {\n            fprintf(stderr, \"mysql_query failed:\\n\\tcode:%d\\n\\treason:%s\\n\",\n                    mysql_errno(&mysql), mysql_error(&mysql));\n        }\n        else\n        {\n            // get result\n            res = mysql_use_result(&mysql);\n            if (res != NULL)\n            {\n                // Get one row at a time\n                while (sqlrow = mysql_fetch_row(res))\n                {\n                    if (isHeader)\n                    {\n                        display_header(res);\n                        isHeader = 0;\n                        printf(\"Row Deails:\\n\");\n                    }\n                    display_show(&mysql, &sqlrow);\n                }\n            }\n            else\n            {\n                if (mysql_errno(&mysql))\n                {\n                    printf(\"\\terror code is %d\\n\\treason:%s\\n\",\n                           mysql_errno(&mysql), mysql_error(&mysql));\n                }\n            }\n        }\n        mysql_close(&mysql);\n    }\n    else\n    {\n        fprintf(stderr, \"Connect failed:\\n\");\n        if (mysql_errno(&mysql))\n        {\n            printf(\"\\terror code is %d\\n\\treason:%s\\n\",\n                   mysql_errno(&mysql), mysql_error(&mysql));\n        }\n    }\n\n    return 0;\n}\n\nvoid display_header(MYSQL_RES *result)\n{\n    printf(\"Column Details:\\n\");\n    MYSQL_FIELD *field;\n    // 循环，每次返回一个字段\n    while ((field = mysql_fetch_field(result)) != NULL)\n    {\n        // 1\n        printf(\"\\tcol_name:%s\", field->name);\n\n        // 2\n        if (IS_NUM(field->type))\n        {\n            printf(\" ,type:%s\", \"Number\");\n        }\n        else\n        {\n            switch (field->type)\n            {\n            case FIELD_TYPE_DECIMAL:\n                printf(\" ,type:%s\", \"Decimal\");\n                break;\n            case FIELD_TYPE_LONG:\n                printf(\" ,type:%s\", \"Long\");\n                break;\n            case FIELD_TYPE_STRING:\n                printf(\" ,type:%s\", \"String\");\n                break;\n            case FIELD_TYPE_VAR_STRING:\n                printf(\" ,type:%s\", \"Var_String\");\n                break;\n            }\n        }\n        // 3\n        printf(\" ,column width:%ld\", field->length);\n        // 4\n        if (field->flags & AUTO_INCREMENT_FLAG)\n        {\n            printf(\n                \" ,column flags:%s\", \"AUTO_INCREMENT_ FLAG\");\n        }\n        printf(\"\\n\");\n    }\n}\n\nvoid display_show(MYSQL *mysql, MYSQL_ROW *sqlrow)\n{\n    unsigned int count = 0;\n    while (count < mysql_field_count(mysql))\n    {\n        if ((*sqlrow)[count])\n        {\n            printf(\"\\t%s\", (*sqlrow)[count]);\n        }\n        else\n        {\n            printf(\"NULL\");\n        }\n        count++;\n    }\n    printf(\"\\n\");\n}\n```","isLeaf":true},{"key":"/cpp/02-cpp-mysql/02-connector-for-cpp.md","path":"/cpp/02-cpp-mysql/02-connector-for-cpp.md","route":"/cpp/02-cpp-mysql/02-connector-for-cpp.md","leaf":true,"title":"02-connector-for-cpp","depth":2,"content":"---\ntitle: 02 使用 connector/cpp\ntags: CPP\n---\n\n# connector/cpp\n\n## 1、安装\n\n```shell\napt-get -y install libmysqlcppconn-dev\n```\n\n```shell\ng++ -I/usr/include/mysql -std=c++11 01-select.cpp -lmysqlcppconn -o main && ./main\n```\n\n- **[Mac os 上用C++进行MYSQL开发配置](https://www.cnblogs.com/laohehexiaohe/p/5436295.html)**\n- **https://github.com/mysql/mysql-connector-cpp**\n\n## 2、操作\n\n### 1) 查询操作\n```cpp\n#include <stdio.h>\n#include <mysql_connection.h>\n#include <mysql_driver.h>\n#include <mysql_error.h>\n#include <cppconn/driver.h>\n#include <cppconn/exception.h>\n#include <cppconn/resultset.h>\n#include <cppconn/statement.h>\n\nusing namespace std;\n\nint main()\n{\n    sql::Driver *driver;\n    sql::Connection *con;\n    sql::Statement *stmt;\n    sql::ResultSet *res;\n\n    driver = get_driver_instance();\n    con = driver->connect(\"tcp://10.53.100.113:3306\", \"root\", \"123456\");\n    con->setSchema(\"test\");\n\n    stmt = con->createStatement();\n    res = stmt->executeQuery(\"SELECT * FROM user\");\n\n    while (res->next())\n    {\n        cout << \"--------- row ---------\\n\";\n        cout << \"\\tname: \" << res->getString(\"name\") << endl;\n        cout << \"\\t  id: \" << res->getString(\"id\") << endl;\n    }\n\n    delete res;\n    delete stmt;\n    delete con;\n}\n```\n\n### 2) 修改\n\n```cpp\n#include <stdio.h>\n#include <mysql_connection.h>\n#include <mysql_driver.h>\n#include <mysql_error.h>\n#include <cppconn/driver.h>\n#include <cppconn/exception.h>\n#include <cppconn/resultset.h>\n#include <cppconn/statement.h>\n\nusing namespace std;\n\nint main()\n{\n    sql::Driver *driver;\n    sql::Connection *con;\n    sql::Statement *stmt;\n    sql::ResultSet *res;\n\n    driver = get_driver_instance();\n    con = driver->connect(\"tcp://10.53.100.113:3306\", \"root\", \"123456\");\n    con->setSchema(\"test\");\n\n    stmt = con->createStatement();\n    int  effectRows = stmt->executeUpdate(\"UPDATE user SET name = 'frank' WHERE id = 1\");\n\n    cout << \"修改数据成功\" << effectRows << \"行受影响！\" << endl; \n\n    delete res;\n    delete stmt;\n    delete con;\n}\n```\n\n### 3) 插入\n```cpp\n#include <stdio.h>\n#include <mysql_connection.h>\n#include <mysql_driver.h>\n#include <mysql_error.h>\n#include <cppconn/driver.h>\n#include <cppconn/exception.h>\n#include <cppconn/resultset.h>\n#include <cppconn/statement.h>\n\nusing namespace std;\n\nint main()\n{\n    sql::Driver *driver;\n    sql::Connection *con;\n    sql::Statement *stmt;\n    sql::ResultSet *res;\n\n    driver = get_driver_instance();\n    con = driver->connect(\"tcp://10.53.100.113:3306\", \"root\", \"123456\");\n    con->setSchema(\"test\");\n\n    stmt = con->createStatement();\n    stmt->execute(\"INSERT INTO user(name) VALUES('hello')\");\n\n    delete stmt;\n    delete con;\n\n    return 0;\n}\n```","isLeaf":true},{"key":"/cpp/02-cpp-mysql/03-why-cpp-in-mysql-so-hard.md","path":"/cpp/02-cpp-mysql/03-why-cpp-in-mysql-so-hard.md","route":"/cpp/02-cpp-mysql/03-why-cpp-in-mysql-so-hard.md","leaf":true,"title":"03-why-cpp-in-mysql-so-hard","depth":2,"content":"---\ntitle: 03 CPP + Mysql 不容易\ntags: CPP\n---\n\n根据 Mysql 的查询协议，field packet 记录了字段的所有信息。难点在于哪里呢？业务统一查询层很蹩脚。首先统一查询的结果返回一个列表`Vector<map<string, value>>`，有些字段的类型为 varchar, 有些是 int，但是 map 的 value 不支持多个类型。\n\n所以有的做法是返回 `Vector<map<string, string>>`，上游可以再根据这个结果序列化为 `Vector<CustomStruct>`","isLeaf":true}]},{"key":"/cpp/03-cpp-json","path":"/cpp/03-cpp-json","route":"/cpp/03-cpp-json","leaf":false,"title":"03-cpp-json","depth":1,"content":"","isLeaf":false,"children":[{"key":"/cpp/03-cpp-json/01-rapidjson.md","path":"/cpp/03-cpp-json/01-rapidjson.md","route":"/cpp/03-cpp-json/01-rapidjson.md","leaf":true,"title":"01-rapidjson","depth":2,"content":"---\ntags: CPP\n---","isLeaf":true},{"key":"/cpp/03-cpp-json/02-jsoncpp.md","path":"/cpp/03-cpp-json/02-jsoncpp.md","route":"/cpp/03-cpp-json/02-jsoncpp.md","leaf":true,"title":"02-jsoncpp","depth":2,"content":"---\ntags: CPP\n---\n\n入门教程 https://www.bilibili.com/video/BV1pb4y1W7ZZ/\n\n## 1、安装\n\n- Mac 中使用可以通过 brew 安装 https://formulae.brew.sh/formula/jsoncpp\n\n\n## 2、使用\n\n### 1) 构建 Json Value\n\n```cpp\n#include \"json/json.h\"\n#include <iostream>\n\n/** \\brief Write a Value object to a string.\n * Example Usage:\n * $g++ stringWrite.cpp -ljsoncpp -std=c++11 -o stringWrite\n * $./stringWrite\n * {\n *     \"action\" : \"run\",\n *     \"data\" :\n *     {\n *         \"number\" : 1\n *     }\n * }\n */\n\nint main() {\n  Json::Value root;\n  Json::Value data;\n  constexpr bool shouldUseOldWay = false;\n\n  root[\"action\"] = \"run\";\n  data[\"number\"] = 1;\n  root[\"data\"] = data;\n\n  if (shouldUseOldWay) {\n    Json::FastWriter writer;\n    const std::string json_file = writer.write(root);\n    std::cout << json_file << std::endl;\n  } else {\n    Json::StreamWriterBuilder builder;\n    // 缩进默认为 \\t\n    builder[\"indentation\"] = \"\";\n    const std::string json_file = Json::writeString(builder, root);\n    std::cout << json_file << std::endl;\n  }\n\n  return EXIT_SUCCESS;\n}\n``` \n\n### 2）数组的构建\n\n```cpp\n#include \"json/json.h\"\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Person\n{\npublic:\n  string name;\n  int age;\n\npublic:\n  Person(string name, int age)\n  {\n    this->name = name;\n    this->age = age;\n  }\n};\n\nvoid my_print(Person *it, Json::Value *value)\n{\n  (*value)['name'] = (*it).name;\n  (*value)['age'] = (*it).age;\n}\n\nint main() {\n  vector<Person*> v;\n\n  Person *p1 = new Person(\"h1\", 10);\n  Person *p2 = new Person(\"h2\", 12);\n  Person *p3 = new Person(\"h3\", 8);\n\n  v.push_back(p1);\n  v.push_back(p2);\n  v.push_back(p3);\n  \n  Json::Value root;\n  Json::Value data;\n  Json::Value list;\n  constexpr bool shouldUseOldWay = false;\n\n  for (vector<Person*>::iterator it = v.begin(); it != v.end(); it++)\n  {\n    Json::Value data;\n    data[\"name\"] = (*it)->name;\n    data[\"age\"] = (*it)->age;\n    list.append(data);\n  }\n\n  root[\"action\"] = \"run\";\n  data[\"number\"] = 1;\n  root[\"data\"] = data;\n  root[\"list\"] = list;\n\n  Json::StreamWriterBuilder builder;\n  builder[\"indentation\"] = \"\";\n  const std::string json_file = Json::writeString(builder, root);\n  std::cout << json_file << std::endl;\n\n  return EXIT_SUCCESS;\n}\n```\n\n```json\n{\"action\":\"run\",\"data\":{\"number\":1},\"list\":[{\"age\":10,\"name\":\"h1\"},{\"age\":12,\"name\":\"h2\"},{\"age\":8,\"name\":\"h3\"}]}\n```","isLeaf":true}]},{"key":"/cpp/04-cmake","path":"/cpp/04-cmake","route":"/cpp/04-cmake","leaf":false,"title":"04-cmake","depth":1,"content":"","isLeaf":false,"children":[{"key":"/cpp/04-cmake/01-add_executable.md","path":"/cpp/04-cmake/01-add_executable.md","route":"/cpp/04-cmake/01-add_executable.md","leaf":true,"title":"01-add_executable","depth":2,"content":"---\ntags: CPP\n---\n\n## 1、add_executable 用法\n\n在 CMakeLists.txt 文件中，add_executable() 函数用于创建一个可执行文件，并可以将源文件添加到此可执行文件中。其语法如下：\n```\nadd_executable(executable_name source1 [source2 ...])\n```\n\n其中，`executable_name` 是生成的可执行文件的名称，`source1` 是可执行文件的主源文件，`source2`、`source3`、……则是可选的其他源文件。\n\n下面是一个示例：\n\n```\ncmake_minimum_required(VERSION 3.10)\n\nproject(my_project)\n\nadd_executable(my_executable main.cpp helper.cpp)\n```\n\n## 2、add_executable 参数过长\n此示例中，CMakeLists.txt 文件指定生成一个名称为 my_executable 的可执行文件，并将主源文件 main.cpp 和辅助源文件 helper.cpp 添加到可执行文件中。\n\n如果源文件比较多，也可以通过使用变量，将源文件名列表提取出来，以便使 CMakeLists.txt 文件更加清晰简洁。可以使用 `set()` 函数创建一个包含源文件名的变量，然后把这个变量传递给 `add_executable()` 函数。示例如下：\n```\ncmake_minimum_required(VERSION 3.10)\n\nproject(my_project)\n\n# 使用 set() 函数创建包含所有源文件名的变量\nset(SOURCES\n    main.cpp\n    helper.cpp\n    some_other_file.cpp\n    ... # 更多文件名\n)\n\n# 将 SOURCES 变量传递给 add_executable() 函数\nadd_executable(my_executable ${SOURCES})\n```\n\n这样可以将所有源文件名集中在一个变量中，更容易管理和更新，也可以避免命令行过长的问题。\n\n## 3、add_executable 目录参数\n\n可以将源文件指定为目录而不是单个文件。在 CMake 中，它被称为目录范围（directory scope），而不是文件范围（file scope）。\n\n在这种情况下，`add_executable()` 函数将递归地搜索指定的目录，找到所有可编译的源文件，并将它们添加到执行目标中。\n\n可以使用 `aux_source_directory()` 函数指定目录，并从目录中收集源文件。具体示例如下：\n\n```\ncmake_minimum_required(VERSION 3.10)\n\nproject(my_project)\n\n# 将源文件目录作为参数传递给 aux_source_directory() 函数\naux_source_directory(src SOURCES)\n\n# 将 SOURCES 变量传递给 add_executable() 函数\nadd_executable(my_executable ${SOURCES})\n```\n\n此示例中，`src` 目录下的所有源文件都将被添加到 `SOURCES` 变量中。`add_executable()` 函数将使用此变量创建可执行文件。\n\n## 4、目录范围不包含头文件\n\n不包括头文件。 `aux_source_directory()` 函数只会查找并添加源文件，但不会包含头文件，因为头文件通常不是可编译的源代码（除非它们是 `inline` 或者 `template` 形式的），它们不会被编译成目标文件，header 文件更像是库的一部分或者接口的一部分，用于定义类、定义函数、定义宏等等，被用于在许多代码文件中进行 #include 引用。\n在使用 `aux_source_directory()` 时，应该将标头文件包含在使用这些源文件的文件中，并且应该使用 `target_include_directories()` 函数将相应目录添加为可执行文件或库的包含目录。 例如：\n\n```\ncmake_minimum_required(VERSION 3.10)\n\nproject(my_project)\n\n# 将源文件目录作为参数传递给 aux_source_directory() 函数\naux_source_directory(src SOURCES)\n\n# 将头文件目录添加为可执行文件或库的包含目录\ntarget_include_directories(my_executable PUBLIC include)\n\n# 将 SOURCES 变量传递给 add_executable() 函数\nadd_executable(my_executable ${SOURCES})\n```\n\n在这个例子中，`include` 目录路径被添加为可执行文件或库的包含目录，该目录中包含所有必要的头文件。 添加 `target_include_directories()` 函数后，使用变量 `SOURCES` 添加所有源文件即可。","isLeaf":true},{"key":"/cpp/04-cmake/02-add_definitions.md","path":"/cpp/04-cmake/02-add_definitions.md","route":"/cpp/04-cmake/02-add_definitions.md","leaf":true,"title":"02-add_definitions","depth":2,"content":"---\ntags: CPP\n---\n\nadd_definitions 是 CMake 中的一个函数，用于向编译器添加预定义的符号。在 CMake 中，您可以通过在 CMakeLists.txt 文件中调用 add_definitions 函数来为您的应用程序添加符号。\n\n添加符号的基本目的是为了在编译时定义一些宏，这些宏在源代码中使用，可以控制应用程序的行为。例如，您可以使用 add_definitions(-DDEBUG) 添加一个名为 DEBUG 的符号，在源代码中使用 #ifdef DEBUG 和 #ifndef DEBUG 对程序进行调试。\n\n除了控制程序行为之外，使用 add_definitions 还可以为不同的平台配置不同的编译标记和参数。例如，您可以使用 add_definitions(-DMY_LINUX_BUILD) 来指定在 Linux 系统上编译。\n\n总的来说，add_definitions 函数帮助您向编译器添加预定义的符号，并为您的应用程序提供更大的灵活性和可配置性。","isLeaf":true}]},{"key":"/cpp/05-gcc","path":"/cpp/05-gcc","route":"/cpp/05-gcc","leaf":false,"title":"05-gcc","depth":1,"content":"","isLeaf":false,"children":[{"key":"/cpp/05-gcc/01-gcc.md","path":"/cpp/05-gcc/01-gcc.md","route":"/cpp/05-gcc/01-gcc.md","leaf":true,"title":"01-gcc","depth":2,"content":"---\ntitle: 01 gcc 的使用\ntags: CPP\n---\n\n## 1、通过 `-L` 设置动态库查找路径\n\n### 1) `-L` 说明\n在C++中，可以使用以下命令来指定动态库的位置：\n```\n-L<path>\n```\n\n其中，`<path>`是指动态库文件所在的目录路径。这条命令告诉编译器在指定路径下查找动态库文件。\n\n例如，如果要在Linux系统中使用`g++`编译`example.cpp`文件，并链接名为`libexample.so`的动态库文件，可以在命令行中输入以下命令：\n\n```\ng++ example.cpp -L/path/to/dynamic/library -lexample\n```\n\n其中，`/path/to/dynamic/library`是指动态库文件`libexample.so`所在的目录。`-lexample`则是告诉编译器链接`libexample.so`动态库文件。\n\n在Windows系统中，可以使用以下命令来指定动态库的位置：\n\n```\n-L<path> -l<library_name>\n```\n\n其中，`<path>`是指动态库文件所在的目录路径，`<library_name>`是动态库的名称。\n\n例如，如果要在Windows系统中使用`g++`编译`example.cpp`文件，并链接名为`example.dll`的动态库文件，可以在命令行中输入以下命令：\n\n```\ng++ example.cpp -L/path/to/dynamic/library -l example\n```\n\n其中，`/path/to/dynamic/library`是指动态库文件`example.dll`所在的目录。`-l example`则是告诉编译器链接`example.dll`动态库文件。注意，在Windows系统中，在库名称前需要加上`lib`前缀。例如，如果库名称为`example.dll`，则需要写成`libexample.dll`。\n\n### 2) 可以多次使用 `-L`\n\n在一次编译中可以使用多次`-L`来指定多个动态库的路径。例如，如果有两个不同的动态库路径需要链接，可以使用以下命令：\n\n```\ng++ example.cpp -L/path/to/first/dynamic/library -L/path/to/second/dynamic/library -lexample1 -lexample2\n```\n\n这个命令将在`/path/to/first/dynamic/library`和`/path/to/second/dynamic/library`目录中查找`libexample1.so`和`libexample2.so`。\n\n请注意，在使用多个`-L`参数时，编译器按照指定参数的顺序搜索路径，因此，如果两个路径中都有同名的库，则可能会发生链接错误。\n\n### 3) `-L` 演示\n\n**创建动态链接库**\n```c\n#include<stdio.h>\nvoid hello()\n{\n  printf(\"hello world/n\");\n}\n```\n\n```shell\ng++ -std=c++11 -fPIC -shared hello.c -o libhello.so\n```\n\n- `-shared`: 该选项指定生成动态连接库（让连接器生成T类型的导出符号表，有时候也生成弱连接W类型的导出符号），不用该标志外部程序无法连接。相当于一个可执行文件\n- `-fpic`: 表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时是通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码段共享的目的\n\n**链接动态库**\n```c\n#include<stdio.h>\n\nvoid: hello();\n\nint main()\n{\n  printf(\"call hello()\");\n  hello();\n}\n```\n\n```shell\n# 需要使用-L选项，告诉 hello 库的位置\ng++ -std=c++11 main.c -o main -lhello -L.\n```\n\n## 2、`-I` 指定头文件的包含路径\n\n比如这里指定 mysql 头文件所在位置\n\n```shell\ngcc -I/usr/include/mysql main.c -L/usr/lib/mysql -lmysqlclient -o main\n```\n\n应该将`-L`放在`-l`之前。","isLeaf":true},{"key":"/cpp/05-gcc/02-vcpkg.md","path":"/cpp/05-gcc/02-vcpkg.md","route":"/cpp/05-gcc/02-vcpkg.md","leaf":true,"title":"02-vcpkg","depth":2,"content":"---\ntitle: 02 包管理器\ntags: CPP\n---\n\n## 1、基本介绍\n\nC++ vcpkg 是一个用于管理 C++ 第三方库的跨平台包管理器。它能够在不同的操作系统上安装库并处理其依赖关系，能够为开发人员提供一个方便的方式来获取和使用 C++ 第三方库。\n\nC++ vcpkg 支持 Windows、Linux 和 MacOS 等多个操作系统。它使用一个命令行界面来管理包，支持自动下载、编译和安装 C++ 库，也可以手动配置安装库。\n\n使用 C++ vcpkg，开发人员可以通过简单的命令行操作快速获取需要的库，并在项目中使用它们。此外，C++ vcpkg 还具有一些高级功能，如版本控制、库升级、构建选项等。\n\n总之，C++ vcpkg 是一个非常有用的工具，可以帮助开发人员轻松管理 C++ 第三方库，并在不同的平台上进行开发。\n\n## 2、使用步骤\n\n以下是使用 vcpkg 进行 C++ 包管理的基本步骤：\n1. 下载和安装 vcpkg 工具\n   - 首先需要在 GitHub 上下载 vcpkg 的最新版本：https://github.com/microsoft/vcpkg\n   - 推荐将 vcpkg 所在目录添加到系统环境变量 PATH 中。\n\n2. 通过 vcpkg 安装所需的库\n   - 打开命令行，进入 vcpkg 目录。\n   - 使用以下命令安装所需的库：`vcpkg install <package-name>`\n   - 例如，安装 OpenSSL 库可以用命令：`vcpkg install openssl` \n\n3. 配置 C++ 项目以使用 vcpkg 安装的库\n   - 在 C++ 项目中打开配置文件（如 Visual Studio 中的 .vcxproj 文件）。\n   - 将以下几行代码添加到vcxproj中：\n    ```\n    <ItemGroup>\n        <PackageReference Include=\"openssl\" Version=\"*\" />\n    </ItemGroup>\n    ```\n  - 上述语句将 `<PackageReference>` 元素添加到项目文件中，因此可以使用库的名称作为其中的包引用 。\n\n4. 构建和运行程序\n   - 使用 C++ 编译器构建和编译项目。\n   - 运行可执行程序以确保库已被成功添加以及项目以正常工作。\n\n这是使用 vcpkg 进行基本 C++ 包管理的简单步骤。可以根据具体情况调整这些步骤，如掌握更多的编译选项、通过 vcpkg 查看包列表和版本等。","isLeaf":true}]},{"key":"/cpp/06-v8","path":"/cpp/06-v8","route":"/cpp/06-v8","leaf":false,"title":"06-v8","depth":1,"content":"","isLeaf":false,"children":[{"key":"/cpp/06-v8/01-build-v8.md","path":"/cpp/06-v8/01-build-v8.md","route":"/cpp/06-v8/01-build-v8.md","leaf":true,"title":"01-build-v8","depth":2,"content":"---\ntitle: 源码构建 V8\ntags: CPP\n---\n\nhttps://v8.js.cn/docs/build/","isLeaf":true}]}]},{"key":"/docker","path":"/docker","route":"/docker","leaf":false,"title":"docker","depth":0,"content":"","isLeaf":false,"children":[{"key":"/docker/01-command.md","path":"/docker/01-command.md","route":"/docker/01-command.md","leaf":true,"title":"01-command","depth":1,"content":"---\ntags: Docker\ndate: 2018-05-02\n---\n\n## 1、docker 简介\nDocker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux机器或Windows 机器上，也可以实现虚拟化，容器是完全使用沙箱机制，相互之间不会有任何接口。\n\n一个完整的Docker有以下几个部分组成：\n1. DockerClient 客户端\n2. Docker Daemon 守护进程\n3. Docker Image 镜像\n4. DockerContainer 容器\n\n\n## 2、镜像操作\n\n```shell\n# 制作镜像\ndocker build -t gaollard/hello:v1 .\n\n# 推送镜像\ndocker push gaollard/hello:v1 \n\n# 删除镜像(删除之前，需要先停止相关的容器)\ndocker rmi IMAGE_ID\n\n# 强制删除\ndocker rmi c7309a89f296 -f\n\n# 从远程拉取镜像\ndocker pull nginx\n\n# 搜索镜像\ndocker search httpd\n```\n\n## 3、容器操作\n\n```shell\n# 停止容器\ndocker stop CONTAINER_ID\n\n# 制作容器\ndocker run -p 7001:80 --name tnginx -d gaollard/hello:v1\n\n# 挂载数据卷\ndocker run -p 7002:80 --name tnginx2 -v /Users/arraybuffer/Desktop/html:/usr/share/nginx/html -d nginx\n\n# 查看容器\ndocker ps\n```\n\n**删除容器**\n\n语法：\n\n```shell\ndocker rm [OPTIONS] 容器名，其中options有三种类型：\n```\n\n- -f ：通过SIGKILL信号强制删除一个运行中的容器\n- -l ：移除容器间的网络连接，而非容器本身-v ：-v 删除与容器关联的卷\n\n容器删除举例：\n\n```bash\ndocker rm -v nginx 这句话的意思是删除nginx容器，并解除与nginx容器关联的卷\ndocker rm -l db 这句命令的意思是：移除容器A对容器B的连接db\ndocker rm -f db01 db02 这句命令的意思是删除容器db01和db02\n```\n\n容器的删除可以一次删除一个或多个，在使用时直接以空格隔开就行。\n\n## 4、docker 容器安装 vim\n在使用docker容器时，有时候里边没有安装vim，敲vim命令时提示说：vim: command not found，这个时候就需要安装vim，可是当你敲apt-get install vim命令时，提示：\n\n```text\nReading package lists... Done\nBuilding dependency tree       \nReading state information... Done\nE: Unable to locate package vim\n```\n \n这时候需要敲：apt-get update，这个命令的作用是：同步 /etc/apt/sources.list 和 /etc/apt/sources.list.d 中列出的源的索引，这样才能获取到最新的软件包。\n\n等更新完毕以后再敲命令：apt-get install vim命令即可。\n\n```shell\n$ > apt-get update\n$ > apt-get install vim\n```\n\n## 5、yaml 语法\nhttps://www.jianshu.com/p/cea930923f3d","isLeaf":true},{"key":"/docker/02-deploy-nginx.md","path":"/docker/02-deploy-nginx.md","route":"/docker/02-deploy-nginx.md","leaf":true,"title":"02-deploy-nginx","depth":1,"content":"---\ntags: Docker\ndate: 2018-05-02\n---\n\n## 1. 简单部署\n第一步：前端打包生成 dist 文件\n```shell\nnpm run build\n```\n\n第二步：在项目根目录创建 dockerfile 文件\n```shell\n# 设置基础镜像\nFROM nginx\n\n# 定义作者\nMAINTAINER gaollard\n\n# 将dist文件中的内容复制到 /usr/share/nginx/html/ 这个目录下面\nCOPY dist/  /usr/share/nginx/html/\n```\n\n第三步：构建镜像\n```shell\n# 在项目根目录执行 iname 为镜像名称\ndocker build -t iname .\n\n# 查看镜像\ndocker ps\n```\n\n第四步：启动容器\n```shell\n# -p ：配置端口映射，格式是外部访问端口：容器内端口\n# -d ：后台运行  \n# --name : 给容器取名\n# cname: 容器名称\n# iname: 镜像名称\n\ndocker run -p 3000:80 -d --name cname iname\n```\n\n第五步：查看是否运行成功\n```shell\ndocker ps\n```\n\n![20230512162713](http://s3.airtlab.com/blog/20230512162713.png)\n\n## 2. 脚本化部署\n```shell\n# 备份原代码\ntar -zcvf gentle-vue.tar ./gentle-vue\n \n# 删除原代码文件夹\nrm -rf gentle-vue\n \n# 拉取代码\ngit clone https://gitee.com/FJ_WoMenDeShiJie/gentle-vue.git\necho -e \"\\033[32m\\n代码拉取\\n\\033[0m\"\n \n# 拷贝 node_modules\ncp ./node.tar ./gentle-vue\n \n# build 打包 vue 项目，生成 dist 文件夹\ncd ./gentle-vue\ntar -zxvf node.tar\nnpm run build\necho -e \"\\033[32m\\nvue项目打包完成\\n\\033[0m\"\n \n# 删除原镜像\ndocker rmi gentle-vue &> /dev/null\necho  -e \"\\033[32m\\n删除原镜像文件\\n\\033[0m\"\n \n# 拷贝 dockerfile 到工程目录下\ncp ../dockerfile ./\n \n# 构建镜像\ndocker build -t gentle-vue .\necho -e \"\\033[32m\\n新镜像构建成功\\n\\033[0m\"\n \n# 删除原容器\ndocker rm -f gentle-vue\n \n# 启动容器\ndocker run -p 3000:80 -d --name gentle-vue gentle-vue\necho -e \"\\033[32m\\n前端工程部署完成\\n\\033[0m\"\n```\n\n## 3. 参考文档\n[https://blog.csdn.net/jiangyu1013/article/details/84572582](https://blog.csdn.net/jiangyu1013/article/details/84572582)\n","isLeaf":true},{"key":"/docker/03-deploy-sentry.md","path":"/docker/03-deploy-sentry.md","route":"/docker/03-deploy-sentry.md","leaf":true,"title":"03-deploy-sentry","depth":1,"content":"---\ntags: Docker\ndate: 2018-05-02\n---\n\nhttps://blog.csdn.net/u014265398/article/details/105877084","isLeaf":true},{"key":"/docker/04-install-ssh.md","path":"/docker/04-install-ssh.md","route":"/docker/04-install-ssh.md","leaf":true,"title":"04-install-ssh","depth":1,"content":"---\ntags: Docker\ndate: 2018-05-02\n---\n\n1. https://www.jianshu.com/p/426f0d8e6cbf\n2. https://www.cnblogs.com/mengw/p/11413461.html","isLeaf":true},{"key":"/docker/05-docker-network.md","path":"/docker/05-docker-network.md","route":"/docker/05-docker-network.md","leaf":true,"title":"05-docker-network","depth":1,"content":"---\ntags: Docker\ndate: 2018-05-02\n---\n\n### 1、创建一个新的 Docker 网络\n\n```\n$ docker network create -d bridge test-net\n```\n\n![20230512163028](http://s3.airtlab.com/blog/20230512163028.png)\n\n参数说明：\n- -d：参数指定 Docker 网络类型，有 bridge、overlay。 其中 overlay 网络类型用于 Swarm mode，在本小节中你可以忽略它。\n\n### 2、连接容器\n运行一个容器并连接到新建的 test-net 网络:\n\n```shell\n$ docker run -itd --name test1 --network test-net ubuntu /bin/bash\n```\n\n打开新的终端，再运行一个容器并加入到 test-net 网络:\n\n```shell\n$ docker run -itd --name test2 --network test-net ubuntu /bin/bash\n```\n\n点击图片查看大图：\n\n![20230512163120](http://s3.airtlab.com/blog/20230512163120.png)\n\n下面通过 ping 来证明 test1 容器和 test2 容器建立了互联关系。\n如果 test1、test2 容器内中无 ping 命令，则在容器内执行以下命令安装 ping（即学即用：可以在一个容器里安装好，提交容器到镜像，在以新的镜像重新运行以上俩个容器）。\n\n```shell\napt-get update\napt install iputils-ping\n```\n\n在 test1 容器输入以下命令：\n\n![20230512163154](http://s3.airtlab.com/blog/20230512163154.png)\n\n\n同理在 test2 容器也会成功连接到:\n\n![20230512163213](http://s3.airtlab.com/blog/20230512163213.png)\n\n这样，test1 容器和 test2 容器建立了互联关系。\n如果你有多个容器之间需要互相连接，推荐使用 Docker Compose，后面会介绍。\n","isLeaf":true},{"key":"/docker/06-exec-vs-attach.md","path":"/docker/06-exec-vs-attach.md","route":"/docker/06-exec-vs-attach.md","leaf":true,"title":"06-exec-vs-attach","depth":1,"content":"---\ntags: Docker\ndate: 2018-05-02\n---\n\n![20230512163246](http://s3.airtlab.com/blog/20230512163246.png)","isLeaf":true},{"key":"/docker/07-image-export-import.md","path":"/docker/07-image-export-import.md","route":"/docker/07-image-export-import.md","leaf":true,"title":"07-image-export-import","depth":1,"content":"---\ntags: Docker\ndate: 2018-05-02\n---\n\n参考文档：[https://blog.csdn.net/ncdx111/article/details/79878098](https://blog.csdn.net/ncdx111/article/details/79878098)\n\n> 通过镜像名称导出时，导入镜像时，镜像名称不会丢失，通过镜像ID导出，镜像名称会丢失。\n\n\n### 1、镜像导出\n#### save\n\n```bash\ndocker save -o nginx.tar nginx:latest\ndocker save > nginx.tar nginx:latest\n```\n\nnginx:latest 可以改为镜像 ID\n\n#### export\n\n```bash\ndocker export [options] container\ndocker export -o nginx-test.tar nginx-test\n```\n\n其中-o表示输出到文件，nginx-test.tar为目标文件，nginx-test是源容器名（name）\n\n### 2、镜像导入\n#### load\n\n```bash\ndocker load -i nginx.tar\ndocker load < nginx.tar\n```\n\n#### import\n\n```bash\ndocker import [options] file|URL|- [REPOSITORY[:TAG]]\n```\n\n```bash\ndocker import nginx-test.tar nginx:imp\n\n# 或\ncat nginx-test.tar | docker import - nginx:imp\n```\n","isLeaf":true},{"key":"/docker/08-host-and-container.md","path":"/docker/08-host-and-container.md","route":"/docker/08-host-and-container.md","leaf":true,"title":"08-host-and-container","depth":1,"content":"---\ntags: Docker\ndate: 2018-05-02\n---\n\n容器和宿主机文件互导\n\n```shell\n# 从宿主机拷贝到容器\ndocker cp [宿主机文件路径] [容器名]:[容器路径]\n\n# 从容器中拷贝文件到宿主机\ndocker cp [容器名]:[容器路径] [宿主机文件路径]\n```","isLeaf":true},{"key":"/docker/09-docker-logs.md","path":"/docker/09-docker-logs.md","route":"/docker/09-docker-logs.md","leaf":true,"title":"09-docker-logs","depth":1,"content":"---\ntags: Docker\ndate: 2018-05-02\n---\n\nhttps://www.runoob.com/docker/docker-logs-command.html\n\ndocker logs : 获取容器的日志\n\n```shell\ndocker logs [OPTIONS] CONTAINER\n```\n\nOPTIONS说明：\n- -f : 跟踪日志输出\n- --since :显示某个开始时间的所有日志\n- -t : 显示时间戳\n- --tail :仅列出最新N条容器日志","isLeaf":true},{"key":"/docker/10-enter-container.md","path":"/docker/10-enter-container.md","route":"/docker/10-enter-container.md","leaf":true,"title":"10-enter-container","depth":1,"content":"---\ntags: Docker\ndate: 2018-05-02\n---\n\n### 1. exec\n[https://www.cnblogs.com/xhyan/p/6593075.html](https://www.cnblogs.com/xhyan/p/6593075.html)\n\n在使用 docker 创建容器的时候，我们可以通过 -it 参数指定，直接进入容器：\n\n```bash\n# micro-web 为容器名称, 其他固定写法\ndocker exec -it micro-web /bin/bash\n```\n\n### 2. attach\n\ndocker attach退出容器，容器会停止运行的解决方法 [https://blog.csdn.net/enter89/article/details/89291691](https://blog.csdn.net/enter89/article/details/89291691)\n\n```shell\ndocker attach [OPTIONS] CONTAINER\n```\n","isLeaf":true},{"key":"/docker/11-volume.md","path":"/docker/11-volume.md","route":"/docker/11-volume.md","leaf":true,"title":"11-volume","depth":1,"content":"---\ntags: Docker\ndate: 2018-05-02\n---\n\n```shell\ndocker run -it -v /host/path:/container/path centos /bin/bash\n```\n\n1. https://www.jianshu.com/p/8c22cdfc0ffd\n2. https://blog.csdn.net/hnmpf/article/details/80924494","isLeaf":true},{"key":"/docker/12-dockerfile.md","path":"/docker/12-dockerfile.md","route":"/docker/12-dockerfile.md","leaf":true,"title":"12-dockerfile","depth":1,"content":"---\ntags: Docker\ndate: 2018-05-02\n---\n\nhttps://www.runoob.com/docker/docker-dockerfile.html\n\nARG & ENV 指令\nhttps://www.cnblogs.com/panpanwelcome/p/12604269.html\nhttps://www.cntofu.com/book/139/image/dockerfile/arg.md","isLeaf":true},{"key":"/docker/13-docker-compose.md","path":"/docker/13-docker-compose.md","route":"/docker/13-docker-compose.md","leaf":true,"title":"13-docker-compose","depth":1,"content":"---\ntags: Docker\ndate: 2018-05-02\n---\n\nCompose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。\n\nCompose 使用的三个步骤：\n\n- 使用 Dockerfile 定义应用程序的环境。\n- 使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。\n- 最后，执行 docker-compose up 命令来启动并运行整个应用程序。\n\n### 1、为什么需要 docker-compose\n维护一个容器很简单，通常有以下步骤：\n\n- 获取镜像：从 Dockerfile build image 或者在 dockerhub 拉取 image\n- 创建容器：创建多个 container\n- 管理容器：管理这些 container（启动停止删除）\n\n有时候一个项目很多个容器(10个以上)，如果每个容器的管理都要重新操作一遍，那工作量实在是太大了而且容易出错，那么如何管理和维护这些容器呢？\n\n我们需要一个 **批处理** 工具，docker-compose 正是这样的工具。\n\n### 2、docker-compose 命令\n```bash\nDefine and run multi-container applications with Docker.\n\nUsage:\n  docker-compose [-f <arg>...] [options] [COMMAND] [ARGS...]\n  docker-compose -h|--help\n\nOptions:\n  -f, --file FILE             Specify an alternate compose file\n                              (default: docker-compose.yml)\n  -p, --project-name NAME     Specify an alternate project name\n                              (default: directory name)\n  --verbose                   Show more output\n  --log-level LEVEL           Set log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)\n  --no-ansi                   Do not print ANSI control characters\n  -v, --version               Print version and exit\n  -H, --host HOST             Daemon socket to connect to\n\n  --tls                       Use TLS; implied by --tlsverify\n  --tlscacert CA_PATH         Trust certs signed only by this CA\n  --tlscert CLIENT_CERT_PATH  Path to TLS certificate file\n  --tlskey TLS_KEY_PATH       Path to TLS key file\n  --tlsverify                 Use TLS and verify the remote\n  --skip-hostname-check       Don't check the daemon's hostname against the\n                              name specified in the client certificate\n  --project-directory PATH    Specify an alternate working directory\n                              (default: the path of the Compose file)\n  --compatibility             If set, Compose will attempt to convert keys\n                              in v3 files to their non-Swarm equivalent\n  --env-file PATH             Specify an alternate environment file\n  \n  \n  Commands:\n  build              Build or rebuild services\n  config             Validate and view the Compose file\n  create             Create services\n  down               Stop and remove containers, networks, images, and volumes\n  events             Receive real time events from containers\n  exec               Execute a command in a running container\n  help               Get help on a command\n  images             List images\n  kill               Kill containers\n  logs               View output from containers\n  pause              Pause services\n  port               Print the public port for a port binding\n  ps                 List containers\n  pull               Pull service images\n  push               Push service images\n  restart            Restart services\n  rm                 Remove stopped containers\n  run                Run a one-off command\n  scale              Set number of containers for a service\n  start              Start services\n  stop               Stop services\n  top                Display the running processes\n  unpause            Unpause services\n  up                 Create and start containers\n  version            Show the Docker-Compose version information\n```\n#### up  (Create and start containers)\n```bash\ndocker-compose -f docker-compose-prod.yml up\n```\n#### stop (Stop services)\n```bash\ndocker-compose -f docker-compose-prod.yml stop\n```\n### 3、exmaple project\n\n![20230512163948](http://s3.airtlab.com/blog/20230512163948.png)","isLeaf":true},{"key":"/docker/14-cmd-entrypoint.md","path":"/docker/14-cmd-entrypoint.md","route":"/docker/14-cmd-entrypoint.md","leaf":true,"title":"14-cmd-entrypoint","depth":1,"content":"---\ntags: Docker\ndate: 2018-05-02\n---\n\n> https://www.cnblogs.com/sparkdev/p/8461576.html 这篇文章讲的很好\n\n```\nENTRYPOINT [\"executable\", \"param1\", \"param2\"]   // 这是 exec 模式的写法，注意需要使用双引号。\nENTRYPOINT command param1 param2                // 这是 shell 模式的写法。\n```","isLeaf":true}]},{"key":"/frontend","path":"/frontend","route":"/frontend","leaf":false,"title":"frontend","depth":0,"content":"","isLeaf":false,"children":[{"key":"/frontend/01-common","path":"/frontend/01-common","route":"/frontend/01-common","leaf":false,"title":"01-common","depth":1,"content":"","isLeaf":false,"children":[{"key":"/frontend/01-common/toc.md","path":"/frontend/01-common/toc.md","route":"/frontend/01-common/toc.md","leaf":true,"title":"toc","depth":2,"content":"---\ntitle: 锚点定位双向更新 ⭕\ndate: 2020-12-02\ntags: FE\ndescription: \n---\n\nTOC 目录在页面中起到一个很好的索引作用，当页面滑动时，TOC 会随着页面滑动对应更新，如下图\n\n![20230605150435](http://s3.airtlab.com/blog/20230605150435.png)\n\n交互逻辑：\n\n- 页面滑动时，目录对应条目高亮\n- 点击目录对应条目，页面滑动到对应位置\n\n## 1、点击目录，更新页面位置\n\n这个比较好处理，给每个标题一个链接锚点，锚点为\n\n```js\n`${window.location.hostname}${window.location.pathname}#${标题id}/`\n```\n\n比如 `字符串匹配`的路径可能为 `https://example.com/path/#字符串匹配`，点击目录滚动到对应锚点即可。\n\n1. 通过`a`标签，`<a href=\"https://example.com/path/#字符串匹配\">`跳转\n\n2. 通过`scrollIntoView` 滑动, id为对应的标题id\n\n   ```js\n    document\n       .getElementById(id)\n       .scrollIntoView({ inline: 'nearest', behavior: 'smooth' });\n   ```\n\n## 2、页面位置变更，目录对应更新\n\n这里有两个方案\n\n1. 监听页面滚动位置，判断哪个标题内容进入到视图，然后更新对应的目录标题样式\n2. 浏览器提供了原生的API `IntersectionObserver`, 用于观测DOM元素的交叉情况，我们使用 `IntersectionObserver` 监听各个标题区块即可\n\n### 1. 通过滚动位置判断\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>TOC</title>\n  <style>\n    .article {\n      width: 1200px;\n      margin: 0 auto;\n      line-height: 30px;\n    }\n\n    .toc {\n      position: fixed;\n      right: 600px;\n      top: 30px;\n      padding-right: 60px;\n      padding-left: 20px;\n      background-color: #f5f5f5;\n    }\n\n    .toc ul {\n      padding-left: 0;\n    }\n\n    .toc a {\n      color: #666;\n      text-decoration: none;\n    }\n\n    .toc .active a {\n      color: #3c3ce7;\n    }\n  </style>\n</head>\n\n<body>\n  <div class=\"article\">\n    <h2 id=\"hash1\">hash1</h2>\n    <div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n    </div>\n    <h3 id=\"hash2\">hash2</h3>\n    <div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n    </div>\n    <h3 id=\"hash3\">hash3</h3>\n    <div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n    </div>\n    <h2 id=\"hash4\">hash4</h2>\n    <div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n    </div>\n    <h3 id=\"hash5\">hash5</h3>\n    <div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n    </div>\n    <h3 id=\"hash6\">hash6</h3>\n    <div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n    </div>\n    <h2 id=\"hash7\">hash7</h2>\n    <div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n    </div>\n    <h3 id=\"hash8\">hash8</h3>\n    <div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n    </div>\n    <h3 id=\"hash9\">hash9</h3>\n    <div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n    </div>\n  </div>\n  <div class=\"toc\"></div>\n</body>\n\n<script>\n  var headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6')\n  var toc = document.querySelector('.toc');\n  var html = '<ul>'\n\n  function init() {\n    headings.forEach((heading, index) => {\n      const title = heading.textContent\n      const id = `heading-${index}`\n      heading.setAttribute('id', id)\n      const level = parseInt(heading.tagName.replace('H', ''), 10)\n\n      html += `\n    <li style=\"margin-left: ${(level - 1) * 16}px\">\n      <a href=\"#${id}\">\n        ${title}\n      </a>\n    </li>\n  `\n    })\n\n    html += '</ul>'\n\n    toc.innerHTML = html;\n\n    const navList = document.querySelectorAll(\".toc li\");\n\n    navList[0].className = \"active\"\n\n    for (let i = 0; i < headings.length; i++) {\n      console.log(`offset`, headings[i].offsetTop)\n    }\n\n    window.addEventListener('scroll', function () {\n      var top = document.documentElement.scrollTop\n      console.log(`current scroll top`, top)\n\n      for (let i = 0; i < headings.length; i++) {\n        navList.forEach((it) => {\n          it.className = ''\n        })\n      }\n\n      for (let i = 0; i < headings.length; i++) {\n        if (headings[i].offsetTop > top) {\n          navList[i].className = \"active\";\n          break;\n        }\n      }\n    })\n  }\n\n  if (headings.length) {\n    init()\n  }\n\n</script>\n\n</html>\n```\n\n### 2. 使用 IntersectionObserver 观测\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>TOC</title>\n  <style>\n    .article {\n      width: 1200px;\n      margin: 0 auto;\n      line-height: 30px;\n    }\n\n    .toc {\n      position: fixed;\n      right: 600px;\n      top: 30px;\n      padding-right: 60px;\n      padding-left: 20px;\n      background-color: #f5f5f5;\n    }\n\n    .toc ul {\n      padding-left: 0;\n    }\n\n    .toc a {\n      color: #666;\n      text-decoration: none;\n    }\n\n    .toc .active a {\n      color: #3c3ce7;\n    }\n  </style>\n</head>\n\n<body>\n  <div class=\"article\">\n    <h2 id=\"hash1\">hash1</h2>\n    <div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n    </div>\n    <h3 id=\"hash2\">hash2</h3>\n    <div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n    </div>\n    <h3 id=\"hash3\">hash3</h3>\n    <div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n    </div>\n    <h2 id=\"hash4\">hash4</h2>\n    <div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n    </div>\n    <h3 id=\"hash5\">hash5</h3>\n    <div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n    </div>\n    <h3 id=\"hash6\">hash6</h3>\n    <div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n    </div>\n    <h2 id=\"hash7\">hash7</h2>\n    <div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n    </div>\n    <h3 id=\"hash8\">hash8</h3>\n    <div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n    </div>\n    <h3 id=\"hash9\">hash9</h3>\n    <div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n      <div>首先，我们导入了内置的fs模块，然后定义了要检查的目录路径。接下来，我们使用我们使用</div>\n    </div>\n  </div>\n  <div class=\"toc\"></div>\n</body>\n\n<script>\n  var headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6')\n  var toc = document.querySelector('.toc');\n  var html = '<ul>'\n\n  function init() {\n    const anchorsId = [];\n    headings.forEach((heading, index) => {\n      const title = heading.textContent\n      const id = `heading-${index}`\n      anchorsId.push(id)\n      heading.setAttribute('id', id)\n      const level = parseInt(heading.tagName.replace('H', ''), 10)\n\n      html += `\n    <li style=\"margin-left: ${(level - 1) * 16}px\">\n      <a href=\"#${id}\">\n        ${title}\n      </a>\n    </li>\n  `\n    })\n\n    html += '</ul>'\n\n    toc.innerHTML = html;\n\n    const navList = document.querySelectorAll(\".toc li\");\n\n    navList[0].className = \"active\"\n\n    // 观测进入到视图的内容\n    const observer = new IntersectionObserver(entries => {\n      entries.forEach(entry => {\n        if (entry.isIntersecting) {\n          console.log(entry.target.id)\n          // setActiveAnchor(entry.target.id);\n        }\n      });\n    });\n\n    forEach(anchorsId, id => observer.observe(document.getElementById(id)));\n\n    /**\n     * 对一个可遍历对象每一个元素操作\n     * @param iterator 可遍历对象\n     * @param func 操作函数\n     */\n    function forEach(iterator, func) {\n      for (let val of iterator) {\n        func(val);\n      }\n    }\n  }\n\n  if (headings.length) {\n    init()\n  }\n\n</script>\n\n</html>\n```\n\n## 3、从 HTML 或者 Markdown 中解析出 TOC\n\n- markdown 可借助 `markdown-it-table-of-contents` 修改下源码 暴露 headings \n- html \n\n## 4、总结\n使用滚动距离比使用 IntersectionObserver 的方式更符合习惯\n\n## 5、参考\n- https://github.com/feikerwu/shan-hai-jing/blob/main/content/blog/toc.md\n","isLeaf":true}]},{"key":"/frontend/02-javascript","path":"/frontend/02-javascript","route":"/frontend/02-javascript","leaf":false,"title":"02-javascript","depth":1,"content":"","isLeaf":false,"children":[{"key":"/frontend/02-javascript/01-integer-overflow.md","path":"/frontend/02-javascript/01-integer-overflow.md","route":"/frontend/02-javascript/01-integer-overflow.md","leaf":true,"title":"01-integer-overflow","depth":2,"content":"---\ntags: Javascript\n---\n\n整数溢出在日常开发中比较常见，可以分为几种场景：\n- 在 JS 代码中进行数值运算\n- 拿到 HTTP Response 后通过 JSON.parse 序列化\n\n## 1、JSON.parse 序列化\n\n```js\nconsole.log(Number.MAX_SAFE_INTEGER) // 9007199254740991\n\nvar a = '{\"an\": 90071992547409912}'\nconsole.log(JSON.parse(a))\n```\n\n打印结果\n```js\n{an: 90071992547409920}\n```\n\n不能直接使用 `JSON.parse` ，可以考虑将数值转为字符串，也就是：\n\n```\n'{\"an\": '90071992547409912'}'\n```\n\n相当于自己写一个 JSON 语法解析器，当读取 90071992547409912 时，发现他是一个数值，但是超过了范围，因此序列化为字符串。\n\n## 1、JSON.stringify\n\n```js\nvar JSONbig = require('json-bigint');\n \nvar json = '{ \"value\" : 9223372036854775807, \"v2\": 123 }';\n\nvar r1 = JSONbig.parse(json);\nconsole.log('JSONbig.parse(input).value : ', r1.value.toString());\nconsole.log('JSONbig.stringify(JSONbig.parse(input)):', JSONbig.stringify(r1));\n```","isLeaf":true}]},{"key":"/frontend/04-webpack","path":"/frontend/04-webpack","route":"/frontend/04-webpack","leaf":false,"title":"04-webpack","depth":1,"content":"","isLeaf":false,"children":[]},{"key":"/frontend/05-react","path":"/frontend/05-react","route":"/frontend/05-react","leaf":false,"title":"05-react","depth":1,"content":"","isLeaf":false,"children":[{"key":"/frontend/05-react/01-React.Element-and-React.ReactNode.md","path":"/frontend/05-react/01-React.Element-and-React.ReactNode.md","route":"/frontend/05-react/01-React.Element-and-React.ReactNode.md","leaf":true,"title":"01-React.Element-and-React.ReactNode","depth":2,"content":"\n`React.Element` 和 `React.ReactNode` 都是 React 的类型定义，它们之间的区别在于 `Element` 主要用于描述 `React` 元素的类型，而 `Node` 则是用于描述任何可以作为 `React` 子节点的类型。\n\n举个例子来说，如果你定义一个组件并返回一个 React 元素，这个元素可以是一个div标签：\n\n```js\nfunction MyComponent(): React.Element {\n  return <div>Hello World!</div>;\n}\n```\n\n在这个例子中，React.Element类型用于描述由Hello World字符串组成的React元素（div标签）。\n\n相反，如果你定义一个组件并在其props中传递一个React节点，则可以使用React.ReactNode类型来描述该节点的类型。例如：\n\n```js\ninterface MyProps {\n  children: React.ReactNode;\n}\n\nfunction MyComponent(props: MyProps): React.Element {\n  return <div>{props.children}</div>;\n}\n```\n\n在这个例子中，React.ReactNode类型用于描述MyComponent的props中的children属性，该属性可以是任何允许作为React节点的类型。由于props.children可以是任何类型的React节点（例如元素、字符串、数组等），因此我们在这里使用React.ReactNode而不是React.Element。\n\n总之，React.Element和React.ReactNode在React中具有不同的角色和用途。Element主要用于描述React元素的类型，而Node用于描述可以作为React子节点的类型。","isLeaf":true}]},{"key":"/frontend/cross-platform","path":"/frontend/cross-platform","route":"/frontend/cross-platform","leaf":false,"title":"cross-platform","depth":1,"content":"","isLeaf":false,"children":[{"key":"/frontend/cross-platform/01-uniapp.md","path":"/frontend/cross-platform/01-uniapp.md","route":"/frontend/cross-platform/01-uniapp.md","leaf":true,"title":"01-uniapp","depth":2,"content":"---\ntitle: 01 uni-app 指南\n---\n\n> 参考文档：https://uniapp.dcloud.net.cn\n\n基于 uni-app + vue3 + typescript + uni-ui 这样的一个模板 `https://github.com/fiiai/mall-uniapp`","isLeaf":true}]},{"key":"/frontend/nextjs","path":"/frontend/nextjs","route":"/frontend/nextjs","leaf":false,"title":"nextjs","depth":1,"content":"","isLeaf":false,"children":[{"key":"/frontend/nextjs/01-utf8-path-error.md","path":"/frontend/nextjs/01-utf8-path-error.md","route":"/frontend/nextjs/01-utf8-path-error.md","leaf":true,"title":"01-utf8-path-error","depth":2,"content":"在 使用 next.js 时发现文件名包含中文字符时，访问页面 404，在 next.js github 上已经有人提了 issue: **Pages with utf-8 name don't work properly under SSR** https://github.com/vercel/next.js/issues/10084\n\n比如当 URL 中包含中文时 404 `http://localhost:5001/Javascript%E7%AD%89%E7%AD%89/01-oversize-number`\n\n![20230517173057](http://s3.airtlab.com/blog/20230517173057.png)\n\n![20230530222452](http://s3.airtlab.com/blog/20230530222452.png)","isLeaf":true}]}]},{"key":"/git","path":"/git","route":"/git","leaf":false,"title":"git","depth":0,"content":"","isLeaf":false,"children":[{"key":"/git/01-introduce.md","path":"/git/01-introduce.md","route":"/git/01-introduce.md","leaf":true,"title":"01-introduce","depth":1,"content":"---\ntitle: 01 Git 介绍\ntag: Git\n---\n\n## 1. 可视化客户端\n- mac sourcetree\n- win tortoisegit\n\n## 2. 辅助记忆工具\n![20230512161907](http://s3.airtlab.com/blog/20230512161907.png)","isLeaf":true},{"key":"/git/02-set-proxy.md","path":"/git/02-set-proxy.md","route":"/git/02-set-proxy.md","leaf":true,"title":"02-set-proxy","depth":1,"content":"---\ntitle: 02 Git 设置代理\ntags: Git\n---\n\nhttps://www.cnblogs.com/cscshi/p/15705045.html\n\n`git config http.proxy` 设置 HTTP 协议的代理地址，即指定 Git 在通过 HTTP 协议进行网络连接时所使用的代理服务器。此功能通常用于在公司或组织等内部网络环境中访问外部Git仓库时的需要。\n\n具体来说，当 Git 通过 HTTP 协议进行网络连接时，其会尝试直接连接目标服务器进行通信。但在一些网络环境中，直接连接可能被禁止或无法正常工作。此时，可以通过配置 HTTP 代理服务器来让 Git 通过代理服务器进行网络连接。\n\n使用代理服务器可以实现对网络流量的过滤和控制，加强对网络安全的保护，也可以提高网络连接的稳定性和性能。\n\n```shell\n# 去掉代理设置\ngit config --global --unset http.proxy\ngit config --global --unset https.proxy\n\n# 这里我使用了丰巢客户端\ngit config --global http.proxy http://127.0.0.1:7890\ngit config --global https.proxy https://127.0.0.1:7890\n```","isLeaf":true},{"key":"/git/03-use-submodule.md","path":"/git/03-use-submodule.md","route":"/git/03-use-submodule.md","leaf":true,"title":"03-use-submodule","depth":1,"content":"---\ntitle: 03 Git 使用 submodule\ntags: Git\n---\n\n> 参考文档 [https://git-scm.com/book/zh/v2/Git-工具-子模块](https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97)\n\n```bash\nusage: git submodule [--quiet] [--cached]\n   or: git submodule [--quiet] add [-b <branch>] [-f|--force] [--name <name>] [--reference <repository>] [--] <repository> [<path>]\n   or: git submodule [--quiet] status [--cached] [--recursive] [--] [<path>...]\n   or: git submodule [--quiet] init [--] [<path>...]\n   or: git submodule [--quiet] deinit [-f|--force] (--all| [--] <path>...)\n   or: git submodule [--quiet] update [--init] [--remote] [-N|--no-fetch] [-f|--force] [--checkout|--merge|--rebase] [--[no-]recommend-shallow] [--reference <repository>] [--recursive] [--[no-]single-branch] [--] [<path>...]\n   or: git submodule [--quiet] set-branch (--default|--branch <branch>) [--] <path>\n   or: git submodule [--quiet] set-url [--] <path> <newurl>\n   or: git submodule [--quiet] summary [--cached|--files] [--summary-limit <n>] [commit] [--] [<path>...]\n   or: git submodule [--quiet] foreach [--recursive] <command>\n   or: git submodule [--quiet] sync [--recursive] [--] [<path>...]\n   or: git submodule [--quiet] absorbgitdirs [--] [<path>...]\n```\n\n### 1、添加子模块\n\n```shell\n# 添加子模块\ngit submodule add git@github.com:gaollard/test_submodule_B.git  projectB\n\n# 可设置子模块在当前项目的相对路径\ngit submodule add http://test.com/backend src/vendor/\n```\n\n### 2、检出项目的指定版本\n\n```shell\n# 检出项目的指定版本(HEAD), 注意它并不是指向一个分支\ngit submodule update\n```\n\n### 3、拉取项目时拉取子模块\n\n```shell\n# 可在拉取项目时把依赖的子模块同时拉取下来\ngit clone –recursive\n```\n\n### 4、submodule ignore 选项\n\n```\nuntracked ：忽略在子模块B(projectB目录)新添加的，未受版本控制内容\ndirty     ：忽略对projectB目录下受版本控制的内容进行了修改\nall       ：同时忽略untracked和dirty\n```\n\n### 5、modified: XXX (new commits)\n\n说明当前主仓库依赖的 HEAD 和 本地仓库提交不匹配了，这个时候要特别注意。\n\n- 如果希望使用旧的 `HEAD`，使用 `git submodule update`；\n- 如果希望使用新的 `HEAD`，那么就 `git add` 提交代码；\n\n### 6、git submodule update --remote\n\n更新子模块为远程项目的最新版本\n\n### 7、init & update\n\n```shell\ngit submodule init\ngit submodule update\n\n# 合并\ngit submodule update --init\n```\n\n### 8、git submodule update --remote\n更新为远程\n\n### 9、submodule 冲突怎么办\nsubmodule 冲突时，应先合并 submodule, 再来合并主仓库\n\n### 10、查询 submodule 状态\n![20230717185232](http://s3.airtlab.com/blog/20230717185232.png)","isLeaf":true},{"key":"/git/04-what-is-head.md","path":"/git/04-what-is-head.md","route":"/git/04-what-is-head.md","leaf":true,"title":"04-what-is-head","depth":1,"content":"---\ntitle: 04 Git 对 head 的理解\ntags: Git\n---\n\nhttps://www.zsythink.net/archives/3412/ 这篇文章讲的非常详细。\n\n1) 通常情况下 HEAD指针 ——–> 分支指针 ——–> 最新提交。也就是说，HEAD 指针总是通过分支指针，间接的指向了当前分支的最新提交。\n2) 有些情况下，HEAD指针没有指向分支指针，而是直接指向了某个提交，这被称作 detached head 分离头。","isLeaf":true},{"key":"/git/05-cherry-pick.md","path":"/git/05-cherry-pick.md","route":"/git/05-cherry-pick.md","leaf":true,"title":"05-cherry-pick","depth":1,"content":"---\ntitle: 05 cherry-pick\ntags: Git\n---\n\n(1) 拷贝依赖缺失\ncherry-pick 可以拷贝一次 commit 信息，如果你在分支 A 拷贝来自分支 B 的 commit id m1, 但是在代码上 m1 依赖了B分支的 m2，那么这个操作是错误的。","isLeaf":true},{"key":"/git/06-mege-commit.md","path":"/git/06-mege-commit.md","route":"/git/06-mege-commit.md","leaf":true,"title":"06-mege-commit","depth":1,"content":"---\ntitle: 06 Git 合并多个 commit\ntags: Git\n---\n\n## 1、合并方式\n- 使用 git rebase -i head~{number} 不会产生新的 commit\n- 使用 git reset 会产生新的 commit (更不友好的做法)\n\n## 2、坏味道\n`git rebase` 这种方式需要强制推送，它是一种坏味道做法，最好通知到项目的组员","isLeaf":true},{"key":"/git/07-merge-vs-rebase.md","path":"/git/07-merge-vs-rebase.md","route":"/git/07-merge-vs-rebase.md","leaf":true,"title":"07-merge-vs-rebase","depth":1,"content":"---\ntags: Git\ntitle: 07 merge-vs-rebase\n---\n\n使用 rebase 进行代码合并，可以让 git log 更清晰","isLeaf":true},{"key":"/git/08-diff.md","path":"/git/08-diff.md","route":"/git/08-diff.md","leaf":true,"title":"08-diff","depth":1,"content":"---\ntags: Git\ntitle: 08 读懂 diff\n---\n\nGit diff 变更的原因有：\n- 新增文件\n- 修改文件\n- 删除文件\n\n## 1、用法\n```text\nusage: git diff [<options>] [<commit>] [--] [<path>...]\n   or: git diff [<options>] --cached [<commit>] [--] [<path>...]\n   or: git diff [<options>] <commit> [--merge-base] [<commit>...] <commit> [--] [<path>...]\n   or: git diff [<options>] <commit>...<commit>] [--] [<path>...]\n   or: git diff [<options>] <blob> <blob>]\n   or: git diff [<options>] --no-index [--] <path> <path>]\n```\n\n- options 表示可选参数\n- commit 表示 commit id\n- path 设置文件\n\n### 1.1 --no-index\n`--no-index` 用于比较两个独立的文件或文件夹的差异。它告诉 Git diff 命令跳过对 Git 存储库的处理，并将其用于非Git文件。\n当您想要比较两个文件或文件夹而不在Git存储库中时，可以使用 `--no-index` 选项。这对于跨不同Git存储库或在没有Git存储库的环境中进行比较很有用。它提供了一种比较的方式，不依赖于Git存储库的版本控制信息。\n\n以下是使用`--no-index`选项的示例：\n\n1. 比较两个文件的差异：\n   ```\n   git diff --no-index file1.txt file2.txt\n   ```\n\n2. 比较两个文件夹的差异：\n   ```\n   git diff --no-index dir1/ dir2/\n   ```\n\n请注意，`--no-index`选项不会处理Git存储库中的更改历史记录或版本控制信息。它只会提供一种比较两个文件或文件夹之间差异的方式，因此可能会在某些情况下产生不同的输出结果。\n\n### 1.2 常见用法\n\n1. 比较工作目录和暂存区之间的差异：\n   ```\n   git diff\n   ```\n\n2. 比较暂存区和最后一次提交之间的差异：\n   ```\n   git diff --staged\n   ```\n\n3. 比较两个提交之间的差异：\n   ```\n   git diff commit1 commit2\n   ```\n\n4. 比较两个分支之间的差异：\n   ```\n   git diff branch1 branch2\n   ```\n\n5. 显示文件中具体的更改内容：\n   ```\n   git diff --word-diff\n   ```\n\n6. 生成可供打印的简洁差异：\n   ```\n   git diff --color-words\n   ```\n\n这只是一些基本的用法示例。Git diff还有很多其他可选项和参数，可以根据需要进行进一步的定制。您可以通过运行`git diff --help`命令来查看所有可用选项和参数的详细信息。\n\n### 1.3 默认输出格式\n\n执行\n```shell\ngit diff 801aae133e70fe312223faccd97072e8afc07404\n````\n\n其输出是下面这样的一个列表，每一项代表某个文件前后对比\n\n```text\ndiff --git a/libs/grpc/src/grpc.service.ts b/libs/grpc/src/grpc.service.ts\nindex 3b551ff..33b5a94 100644\n--- a/libs/grpc/src/grpc.service.ts\n+++ b/libs/grpc/src/grpc.service.ts\n@@ -12,6 +12,7 @@ import { dynamicProxyUrl, localService } from '@app/config/local.service';\n import { migrationMap } from '@app/shared/migrationMap';\n import { rpcMetrics } from '@/prom/prom.client';\n import { CURRENT_ETCD } from '@app/shared/etcd.config';\n+import { isThDGL } from '@app/shared/utils/getFromContext';\n \n @Injectable()\n export class GrpcService {\n@@ -41,6 +42,10 @@ export class GrpcService {\n       );\n     }\n \n+    if (region === 'th') {\n+      body = { ...body, licenseType: isThDGL() ? 'Digi' : 'CCC' };\n+    }\n+\n     const rpcAction = getRpc(service, rpc, address as string);\n     let makeParam =\n       (body && body['migrationMap']) || service === Service.LoanCoreDebt\n```\n\n**1) diff 格式**\n\n第一行表示结果为 git 格式的 diff:\n```\ndiff --git a/libs/grpc/src/grpc.service.ts b/libs/grpc/src/grpc.service.ts\n```\n\n**2) diff 对象**\n\n第二行表示两个版本的git哈希值\n```\nindex 3b551ff..33b5a94 100644\n```\n\nindex 区域的 3b551ff 对象 与工作目录区域的 33b5a94 对象进行比较，最后的六位数字是对象的模式（普通文件，644权限）\n\n**3) 变动范围**\n\n\"---\"表示变动前的文件，\"+++\"表示变动后的文件，变动的位置用两个@作为起首和结束，`@@ -12,6 +12,7 @@`\n\n前面的\"-12,6\"分成三个部分：减号表示第一个文件（即f1），\"12\"表示第12行，\"6\"表示连续6行。合在一起，就表示下面是第一个文件从第16行开始的连续6行。同样的，\"+12,7\"表示变动后，成为第二个文件从第12行开始的连续7行。\n\n**4) 变动的具体内容**\n\n```text\nimport { dynamicProxyUrl, localService } from '@app/config/local.service';\nimport { migrationMap } from '@app/shared/migrationMap';\nimport { rpcMetrics } from '@/prom/prom.client';\nimport { CURRENT_ETCD } from '@app/shared/etcd.config';\n\n@Injectable()\nexport class GrpcService {\n```\n\n```text\n import { dynamicProxyUrl, localService } from '@app/config/local.service';\n import { migrationMap } from '@app/shared/migrationMap';\n import { rpcMetrics } from '@/prom/prom.client';\n import { CURRENT_ETCD } from '@app/shared/etcd.config';\n+import { isThDGL } from '@app/shared/utils/getFromContext';\n \n @Injectable()\n export class GrpcService {\n```\n\n### 1.4 diff 可视化展示\n\n根据 `@@` 进行分割，进行逐行对比，即可找到某行是被删除、还是增加。\n\n## 2、参数\n\n```text\n  -z            output diff-raw with lines terminated with NUL.\n  -p            output patch format.\n  -u            synonym for -p.\n  --patch-with-raw\n                output both a patch and the diff-raw format.\n  --stat        show diffstat instead of patch.\n  --numstat     show numeric diffstat instead of patch.\n  --patch-with-stat\n                output a patch and prepend its diffstat.\n  --name-only   show only names of changed files.\n  --name-status show names and status of changed files.\n  --full-index  show full object name on index lines.\n  --abbrev=<n>  abbreviate object names in diff-tree header and diff-raw.\n  -R            swap input file pairs.\n  -B            detect complete rewrites.\n  -M            detect renames.\n  -C            detect copies.\n  --find-copies-harder\n                try unchanged files as candidate for copy detection.\n  -l<n>         limit rename attempts up to <n> paths.\n  -O<file>      reorder diffs according to the <file>.\n  -S<string>    find filepair whose only one side contains the string.\n  --pickaxe-all\n                show all files diff when -S is used and hit is found.\n  -a  --text    treat all files as text.\n```\n\n### 2.1 name-only 只展示文件名\n```shell\ngit diff --name-only  master\n```\n\n```text\nlibs/config/src/th/local.config.ts\nlibs/config/src/th/test.config.ts\nlibs/config/src/th/uat.config.ts\nlibs/db/src/db.service.ts\nlibs/elastic/src/elastic.interface.ts\nlibs/elastic/src/elastic.service.ts\nlibs/grpc/src/grpc.service.ts\nlibs/grpc/src/proto/protobuf-uc\n```\n\n看不出文件是改动、删除或者新增\n\n### 2.2 --stat 显示文件差异的摘要信息\n\n使用 `--stat` 选项可以帮助您快速了解文件间的大致差异，以便更好地理解Git存储库中的改动情况。\n\n```shell\ngit diff --stat 801aae133e70fe312223faccd97072e8afc07404\n```\n\n```text\nlibs/grpc/src/grpc.service.ts     | 5 +++++ [增加5行]\nlibs/grpc/src/proto/protobuf-uc   | 2 +-    [增加1行，删除1行]\nlibs/grpc/src/services/BaseRpc.ts | 5 +++++ [增加5行]\n3 files changed, 11 insertions(+), 1 deletion(-)\n```\n\n### 2.3 `--numstat` 以数字形式显示文件差异的摘要信息\n\n用于以数字形式显示文件差异的摘要信息。它会显示出每个文件被添加、删除和修改的行数。\n\n```shell\n$ git diff --numstat 801aae133e70fe312223faccd97072e8afc07404\n5       0       libs/grpc/src/grpc.service.ts\n1       1       libs/grpc/src/proto/protobuf-uc\n5       0       libs/grpc/src/services/BaseRpc.ts\n```\n\n### 2.4 --name-status 展示文件修改类型\n\n```shell\ngit diff --name-status  801aae133e70fe312223faccd97072e8afc07404\nM       libs/grpc/src/grpc.service.ts\nM       libs/grpc/src/proto/protobuf-uc\nM       libs/grpc/src/services/BaseRpc.ts\n```\n\n`--name-status` 用于以文件名和状态的形式显示文件差异的摘要信息。它会显示出每个文件的状态，包括被添加、被修改和被删除。\n当您执行Git diff命令，并添加了`--name-status`选项，Git会为每个文件产生一个摘要，以文件名和其状态的形式显示文件的差异统计信息。输出结果包含两个字段：文件的状态和文件名。\n\n以下是一个使用`--name-status`选项的示例：\n\n```\ngit diff --name-status\n```\n\n这将显示出Git存储库中当前分支和上一个分支之间的文件差异的统计信息。输出结果可能类似于下面的样式：\n\n```\nA       file1.txt\nM       file2.txt\nD       file3.txt\n```\n\n这个示例告诉我们，`file1.txt` 文件是被添加的（Added），`file2.txt` 文件是被修改的（Modified），`file3.txt` 文件是被删除的（Deleted）。\n\n`--name-status` 选项对于需要以文件状态形式获取文件差异统计信息的情况很有用。它可以帮助您了解每个文件的状态，包括添加、修改和删除等操作。\n\n## 3、参考文档\n\n- [读懂diff] https://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html","isLeaf":true},{"key":"/git/09-multile-github.md","path":"/git/09-multile-github.md","route":"/git/09-multile-github.md","leaf":true,"title":"09-multile-github","depth":1,"content":"---\ntags: Git\n---\n\n1台电脑上使用两个github账户，参考 https://juejin.cn/post/6844904086085582862 或者可以通过 github token 来避免这个问题","isLeaf":true},{"key":"/git/10-commit-rule.md","path":"/git/10-commit-rule.md","route":"/git/10-commit-rule.md","leaf":true,"title":"10-commit-rule","depth":1,"content":"---\ntags: Git\n---\n\n## 1、提交格式\n```text\ntype(scope): message\n```\n\n## 2、type\n- feat：新功能的开发\n- fix：bug的修复\n- docs：文档格式的改动\n- style：代码格式改变\n- refactor：对已有的功能进行重构\n- perf：性能优化\n- test：增加测试\n- build：改变了build工具\n- revert：撤销上一次的commit提交\n- chore：日常的一些小更改\n\n## 3、scope\n用于说明 commit 影响的范围，比如：权限模块、还是首页","isLeaf":true},{"key":"/git/11-use-hooks.md","path":"/git/11-use-hooks.md","route":"/git/11-use-hooks.md","leaf":true,"title":"11-use-hooks","depth":1,"content":"---\ntags: Git\n---\n\n参考 https://www.cnblogs.com/woai3c/p/15033530.html 特别注意 hooks 文件的权限问题","isLeaf":true},{"key":"/git/12-file-timeline.md","path":"/git/12-file-timeline.md","route":"/git/12-file-timeline.md","leaf":true,"title":"12-file-timeline","depth":1,"content":"---\ntags: Git\n---\n\n## 1、sourcetree\n使用 git 命令不够直观，可以使用 sourcetree, 点击文件 【查看选中的修改日志】\n\n## 2、vscode\n可以查看当前窗口文件的时间线","isLeaf":true},{"key":"/git/13-git-log.md","path":"/git/13-git-log.md","route":"/git/13-git-log.md","leaf":true,"title":"13-git-log","depth":1,"content":"---\ntags: Git\n---\n\n参考 https://zhuanlan.zhihu.com/p/183131156\n\n```shell\ngit log --oneline\ngit log --stat\n```","isLeaf":true},{"key":"/git/14-gen-ssh-key.md","path":"/git/14-gen-ssh-key.md","route":"/git/14-gen-ssh-key.md","leaf":true,"title":"14-gen-ssh-key","depth":1,"content":"---\ntags: Git\n---\n\n```shell\n# make\nssh-keygen -t rsa -C \"2856116089@qq.com\"\n\n# config\ngit config --global user.name \"waisai\"\ngit config --global user.email \"2856116089@qq.com\"\n```","isLeaf":true},{"key":"/git/15-rm-cached.md","path":"/git/15-rm-cached.md","route":"/git/15-rm-cached.md","leaf":true,"title":"15-rm-cached","depth":1,"content":"---\ntags: Git\n---\n\n有时候，我们需要忽略掉以前提交过的文件，因为git已经索引了该文件，所以我们先要删除掉该文件的缓存，如文件 main.ts 已经提交过了，现在我们想忽略，这是我们先在 .gitignore 中设置该文件为忽略。\n\n- 使用 git rm --cached 从 Git 的数据库中删除对于该文件的追踪\n- 把对应的规则写入 .gitignore，让忽略真正生效\n\n```shell\ngit rm --cached main.ts\n\n# 若是文件夹\ngit rm -r --cached folder/\n```","isLeaf":true},{"key":"/git/16-reset-vs-revert.md","path":"/git/16-reset-vs-revert.md","route":"/git/16-reset-vs-revert.md","leaf":true,"title":"16-reset-vs-revert","depth":1,"content":"---\ntags: Git\n---\n\n- reset 是彻底回退到指定的commit版本，该commit后的所有commit都将被清除，包括提交历史记录；\n- revert 仅仅是撤销指定commit的修改，并不影响后续的commit，但所撤销的commit被后续的commit修改了同一地方则会产生冲突；\n- reset 执行后不会产生记录，revert执行后会产生记录；\n- reset 执行后无法再次恢复，revert执行后因为不会清除记录，并且会产生新纪录，所以文件不会丢失，你可以多次执行revert恢复到某次改变之前的状态；\n- reset 执行后HEAD会后移，而revert的HEAD则一直是向前的；\n\nhttps://blog.csdn.net/baiyuliang2013/article/details/120646835","isLeaf":true},{"key":"/git/17-case-sensitive.md","path":"/git/17-case-sensitive.md","route":"/git/17-case-sensitive.md","leaf":true,"title":"17-case-sensitive","depth":1,"content":"---\ntags: Git\n---\n\n文件系统大小写敏感是非常重要，会带来诸多问题。比如不敏感时，当你希望修改文件目录从小写到大写时，git 状态是未发生变更，意味着你无法提交。","isLeaf":true}]},{"key":"/macos","path":"/macos","route":"/macos","leaf":false,"title":"macos","depth":0,"content":"","isLeaf":false,"children":[{"key":"/macos/homebrew.md","path":"/macos/homebrew.md","route":"/macos/homebrew.md","leaf":true,"title":"homebrew","depth":1,"content":"## 1、Running Homebrew as root is extremely dangerous and no longer supported\n\n在 macOS High Sierra(10.13.6) 及以上版本的 Mac 上面，使用 brew install 安装时老是报错，因为苹果已经不允许 Homebrew 作为根来安装了。当你添加 `sudo brew install xxxx` 时提示：危险操作。\n\n网上很多做法是把 `/usr/local` 路径改成当前用户路径，但是在高版本的Mac上面已经不允许了：\n\n```shell\nsudo chown -R $(whoami) /usr/local\nchown: /usr/local: Operation not permitted\n```\n\n修复：\n\n```shell\nsudo chown -R `whoami` /usr/local/Homebrew/\nsudo chown -R $(whoami) $(brew --prefix)/*\nsudo mkdir /usr/local/Frameworks\nsudo chown -R `whoami` /usr/local/Frameworks/\n```\n\n**下面是 chatgtp 给出的方案**\n\n要解决您在以root用户身份运行Homebrew的问题，您可以按照以下步骤进行操作：\n1. 卸载Homebrew：在终端中运行以下命令：\n```\nsudo rm -rf /usr/local/Homebrew\n```\n\n2. 修改目录权限：继续在终端中运行以下命令：\n```\nsudo chown -R $(whoami) $(brew --prefix)/*\n```\n\n3. 移除残留文件：还在终端中运行以下命令，以删除可能残留的配置文件：\n```\nrm -rf ~/Library/Caches/Homebrew\n```\n\n4. 重新安装Homebrew：现在，您可以按照常规用户的方式重新安装Homebrew。 在终端中运行以下命令：\n```\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n```\n\n上述步骤将帮助您彻底卸载并重新安装 Homebrew。记得在安装后，按照常规用户的方式，而不是root用户，来使用Homebrew进行操作和安装软件包。\n \n请注意，对于具体的操作，我强烈建议您查阅Homebrew的官方文档以获取最新的指引和说明。","isLeaf":true}]},{"key":"/network","path":"/network","route":"/network","leaf":false,"title":"network","depth":0,"content":"","isLeaf":false,"children":[{"key":"/network/01-basic","path":"/network/01-basic","route":"/network/01-basic","leaf":false,"title":"01-basic","depth":1,"content":"","isLeaf":false,"children":[{"key":"/network/01-basic/01-Hierarchy-of-Network-Models.md","path":"/network/01-basic/01-Hierarchy-of-Network-Models.md","route":"/network/01-basic/01-Hierarchy-of-Network-Models.md","leaf":true,"title":"01-Hierarchy-of-Network-Models","depth":2,"content":"---\ntags: network\n---\n\n### 1. 七层模型\n- 应用->表示->会话\n- 传输->网络->数据\n- 物理\n\n![20230619112439](http://s3.airtlab.com/blog/20230619112439.png)\n\n![20230619112446](http://s3.airtlab.com/blog/20230619112446.png)\n\n![20230619112455](http://s3.airtlab.com/blog/20230619112455.png)\n\n![20230619112501](http://s3.airtlab.com/blog/20230619112501.png)\n\n\n### 2. 五层模型\n\n- 应用层\n- 传输层（TCP/UDP）\n- 网络层 （IP ICMP ARP）\n- 数据链路层\n- 物理层","isLeaf":true},{"key":"/network/01-basic/02-http-authorization-basic.md","path":"/network/01-basic/02-http-authorization-basic.md","route":"/network/01-basic/02-http-authorization-basic.md","leaf":true,"title":"02-http-authorization-basic","depth":2,"content":"---\ntags: network\n---\n\n在 http 头部加上 `authorization: value`，其中 value 等于 `Basic base64串`，其中 `base64` 串 为 \"user:password\" 进行 base64 编码。\n\n![20230511110151](http://s3.airtlab.com/blog/20230511110151.png)","isLeaf":true},{"key":"/network/01-basic/03-loopback-host.md","path":"/network/01-basic/03-loopback-host.md","route":"/network/01-basic/03-loopback-host.md","leaf":true,"title":"03-loopback-host","depth":2,"content":"---\ntitle: 02 回环地址\ntags: network\n---\n\n网卡中的回环地址是“127.0.0.1”，也被称为“本地主机”或“环回地址”。在计算机网络中，回环地址是指计算机本身使用的一种虚拟网络接口，数据包发送到回环地址时会被本机接收并在本机上进行处理，而不会发送到网络上。\n\n回环地址被广泛用于网络应用程序和测试。例如，开发人员可以在没有连接到网络的情况下测试网络应用程序的功能，只需要将地址设置为回环地址即可模拟网络数据流。同时，回环地址也用于验证网络接口和运行诊断程序。","isLeaf":true},{"key":"/network/01-basic/04-Used-application-layer-protocol.md","path":"/network/01-basic/04-Used-application-layer-protocol.md","route":"/network/01-basic/04-Used-application-layer-protocol.md","leaf":true,"title":"04-Used-application-layer-protocol","depth":2,"content":"---\ntags: network\n---\n\n- HTTP 超文本传输协议（基于TCP）\n- DNS 域名系统协议（基于UDP）\n- FTP 文件传输协议\n- SSH 安全外壳协议\n- TELENT TCP/IP 终端仿真协议\n- SMTP 简单邮件传输协议\n- POP3 邮局协议第3版","isLeaf":true},{"key":"/network/01-basic/05-curl-and-ping.md","path":"/network/01-basic/05-curl-and-ping.md","route":"/network/01-basic/05-curl-and-ping.md","leaf":true,"title":"05-curl-and-ping","depth":2,"content":"---\ntags: network\n---\n\n使用 curl 可以访问 http://blog.airtlab.com，为什么 ping blog.airtlab.com 却 Request timeout\n\n可能是由于网络防火墙或路由器设置的规则导致 ping 请求被阻止了。curl 的工作方式与 ping 不同，curl 发送的是 HTTP 请求，而 ping 发送的是 ICMP 请求，网络设备可能会针对不同类型的请求做出不同的响应。 \n\n此外，http://blog.airtlab.com 和 blog.airtlab.com 可能是不同的域名（比如前者可能要跳转到后者），ping 命令默认使用 DNS 协议解析主机名，而 curl 默认不会解析主机名。因此，可能需要先使用 dig 或 nslookup 等工具来查找主机名所对应的 IP 地址，然后使用 ping 命令指定 IP 地址来进行测试。","isLeaf":true}]},{"key":"/network/10-protocol","path":"/network/10-protocol","route":"/network/10-protocol","leaf":false,"title":"10-protocol","depth":1,"content":"","isLeaf":false,"children":[{"key":"/network/10-protocol/01-dns.md","path":"/network/10-protocol/01-dns.md","route":"/network/10-protocol/01-dns.md","leaf":true,"title":"01-dns","depth":2,"content":"---\ntags: network\n---\n\n## 1、域名的概念\n\n域名是在 [互联网](https://developer.mozilla.org/zh-CN/docs/Glossary/Internet) 的网站的地址。域名被用于 [URL](https://developer.mozilla.org/zh-CN/docs/Glossary/URL) 识别一个服务器属于哪个特定的网站。域名包含由句号点（”.“）分隔的名称的分级序列并以 [扩展名](https://developer.mozilla.org/en-US/docs/Glossary/TLD) 作为结尾。\n\n1. 比如 [www.baidu.com](https://link.zhihu.com/?target=https%3A//www.baidu.com) (www.baidu.com.)（注意最后面有一个点号）就是一个域名，每个域名的最后面都有一个点号 \".\" 表示根域名，为了方便在实际使用的时候被省略了；\n2. 顶级域名：.com 就是顶级域名，常见的顶级域名后缀有 .com、.cn、.net、.org 等固定值，不能自己修改；\n3. 一级域名：又称主域名，顶级域名的下一级又是权威域名，如 [baidu.com](https://link.zhihu.com/?target=http%3A//baidu.com) 中的 .baidu；\n4. 顶级域名下就是主机名，www.baidu.com 中的 www 是指主机名;\n5. 二级域名：baidu.com 叫主域名，www.baidu.com 叫做二级域名；\n\n![20230619111413](http://s3.airtlab.com/blog/20230619111413.png)\n\n![20230619111430](http://s3.airtlab.com/blog/20230619111430.png)\n\n## 2、DNS的介绍\n\n![20230619111526](http://s3.airtlab.com/blog/20230619111526.png)\n\ndns 即是 domain name system 域名系统的缩写，将 域名 和 ip 的映射关系保存在一个分布式数据库中。DNS 是分级的。\nDNS的一种简单设计模式就是只使用一个DNS服务器，该服务器包含所有的映射，客户机直接将所有查询请求发往单一的DNS服务器，同时该DNS服务器直接对所有查询客户机做出响应，这种集中式设计会有单点故障，不能支持全球的DNS查询，所以DSN采用下面的树状结构：\n\n\n## 3、DNS资源记录\n\n在 DNS 服务器上，一个域名及其下级域名组成一个区域。相关的 DNS 信息构成一个数据库文件。所以每个区域数据库文件都是由资源记录构成的，一个资源记录就是一行文本，提供了一组有用的 DNS 配置信息。常见的资源记录类型如表所示：\n\n| 类型 | 编码 | 内容 |\n| --- | --- | --- |\n| A | 1 | 将 DNS 域名映射到 IPv4 地址，基本作用是说明一个域名对应了哪些 IPv4 地址 |\n| NS | 2 | 权威名称服务器记录，用于说明这个区域有哪些 DNS 服务器负责解析 |\n| CNAME | 5 | 别名记录，主机别名对应的规范名称 |\n| SOA | 6 | 起始授权机构记录，NS 记录说明了有多台服务器在进行解析，但哪一个才是主服务器，NS 并没有说明，SOA 记录了说明在众多 NS 记录里哪一台才是主要的服务器 |\n| PTR | 12 | IP 地址反向解析，是 A 记录的逆向记录，作用是把 IP 地址解析为域名 |\n| MX | 15 | 邮件交换记录，指定负责接收和发送到域中的电子邮件的主机 |\n| TXT | 16 | 文本资源记录，用来为某个主机名或域名设置的说明 |\n| AAAA | 28 | 将 DNS 域名映射到 IPv6 地址，基本作用是说明一个域名对应了哪些 IPv6 地址 |\n\n当你在云服务商购买域名后，将域名解析到主机是，就需要添加DNS解析记录。\n\n## 4、域名解析过程\n1、在浏览器中输入www.qq.com域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。\n\n2、如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。\n\n3、如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/IP参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。\n\n4、如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。\n\n5、如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至 “根DNS服务器”，“根DNS服务器”收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。\n\n本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找qq.com域服务器，重复上面的动作，进行查询，直至找到www.qq.com主机。\n\n6、如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。\n\n不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。\n\n## 5、DNS 的迭代查询\n\n![20230619111623](http://s3.airtlab.com/blog/20230619111623.png)\n\n递归：客户端只发一次请求，要求对方给出最终结果。\n迭代：客户端发出一次请求，对方如果没有授权回答，它就会返回一个能解答这个查询的其它名称服务器列表，客户端会再向返回的列表中发出请求，直到找到最终负责所查域名的名称服务器，从它得到最终结果。\n\n## 6、dig 命令\ndig 是一个常用的 DNS 工具，可以在终端中通过域名查询 DNS 相关信息，包括域名解析得到的 IP 地址、DNS 服务器的相关信息、MX 记录等。其原理是通过 DNS 协议与目标 DNS 服务器进行通信，发送查询请求并接收响应，最终将响应数据返回给用户。\ndig 命令的常见用法如下：\n\n1. 查询域名对应的 IP 地址\n\n```bash\ndig example.com\n```\n\n这个命令会通过本地 DNS 服务器去查询 example.com 的 IP 地址，并返回查询结果。\n\n2. 查询 MX 记录\n\n```bash\ndig example.com MX\n```\n\n这个命令会查询 example.com 的 MX 记录，MX 记录用于指定该域名的邮件服务器，可以通过该记录查询邮件服务器的 IP 地址。\n\n3. 指定 DNS 服务器\n\n```bash\ndig example.com @8.8.8.8\n```\n\n这个命令会指定通过 8.8.8.8 这个 DNS 服务器去查询 example.com 的 IP 地址。\n\n4. 查询详细信息\n\n```bash\ndig example.com +trace\n```\n\n这个命令会显示从本地 DNS 服务器开始到目标 DNS 服务器的查询路径，并将所有相关信息显示出来，包括 TTL、Authoritative、ANSWER 等等。\n\n总之，dig 是一个非常有用且强大的网络工具，尤其是在进行系统维护、网络故障排除等方面有很大的帮助。\n\n## 7、参考文章\n\n1. 浅谈dns域名解析过程 [https://zhuanlan.zhihu.com/p/58108010](https://zhuanlan.zhihu.com/p/58108010)\n2. [DNS递归查询与迭代查询](https://www.cnblogs.com/qingdaofu/p/7399670.html) [https://www.cnblogs.com/qingdaofu/p/7399670.html](https://www.cnblogs.com/qingdaofu/p/7399670.html)","isLeaf":true},{"key":"/network/10-protocol/02-icmp.md","path":"/network/10-protocol/02-icmp.md","route":"/network/10-protocol/02-icmp.md","leaf":true,"title":"02-icmp","depth":2,"content":"---\ntags: network\n---\n\n## 1、ICMP 介绍\n因特网控制报文协议(ICMP) 是TCP/IP 套件的协议之一。 它是一种网络层协议，用于实现错误报告和网络路径诊断功能。 ICMP 回传请求和ICMP 回传应答消息通常称为ping 消息。 ICMP Ping 是一个故障诊断工具，用于测试网络设备之间的连接。\n\n## 2、Ping 命令\nPing不使用端口，而是使用协议。Ping通过将Internet控制消息协议（ICMP）回显请求数据包发送到目标主机并等待ICMP回显应答来进行操作。但是，出于安全考虑，通常你可以禁用ping功能。 转载必须保留本文地址:http://xiiie.com/html/1301016.html\n\n## 3、检查 ping 是否支持\n通常情况下，Linux 系统默认是开启 ping 命令的，除非被系统管理员或者安全人员关闭或限制。您可以通过以下方法来检查 Linux 服务器是否可以 ping 通。\n\n1. 使用 ping 命令来尝试 ping 目标地址，如果能够 ping 通，则说明服务器可以正常 ping 通目标地址，否则则说明服务器上的 ping 命令被限制或禁用。\n\n```bash\nping 39.108.138.156\n```\n\n如果服务器返回数据包，则说明服务器支持 ping 命令，如果无法返回数据包，则说明服务器上的 ping 命令被禁用或 ping 目标地址时被防火墙限制了。\n\n2. 检查防火墙规则，ping 命令需要 ICMP 协议支持，因此如果服务器的防火墙规则中禁用了 ICMP 协议，则 ping 命令无法正常工作。您可以使用以下命令检查 iptables 防火墙规则中是否存在 ICMP 协议限制规则：\n\n```bash\nsudo iptables -L -v | grep icmp\n```\n\n如果输出结果中包含 DROP 或 REJECT 规则，则说明 ICMP 协议被禁用。\n\n3. 检查 SELinux 选项，如果 SELinux 开启并设置为 enforcing 模式，则可能会限制 ping 的执行。可以查看 /etc/selinux/config 文件中的 SELINUX 选项是否为 enforcing：\n\n```bash\ncat /etc/selinux/config | grep SELINUX\n```\n\n如果输出结果中 SELINUX=enforcing，则说明 SELinux 模式为 enforcing 模式，需要禁用或修改 SELinux 配置。\n\n注意：如果您没有 root 权限或者无法访问服务器，则可能无法确定系统是否对 ping 命令进行了限制。\n","isLeaf":true},{"key":"/network/10-protocol/03-ssh.md","path":"/network/10-protocol/03-ssh.md","route":"/network/10-protocol/03-ssh.md","leaf":true,"title":"03-ssh","depth":2,"content":"---\ntags: network\n---\n\nSSH 为 [Secure Shell](https://baike.baidu.com/item/Secure%20Shell) 的缩写，安全外壳协议，专为 [远程登录](https://baike.baidu.com/item/%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/1071998) 会话和其他网络服务提供安全性的协议。\n### 1. SSH 存在的意义\n\n- 数据压缩\n- 数据加密\n\n传统的网络服务程序，如：[ftp](https://baike.baidu.com/item/ftp)、pop 和 [telnet](https://baike.baidu.com/item/telnet) 在本质上都是不安全的，因为它们在网络上用[明文](https://baike.baidu.com/item/%E6%98%8E%E6%96%87)传送口令和数据，别有用心的人非常容易就可以截获这些口令和数据。容易受到中间人攻击，所谓“中间人”的攻击方式， 就是“中间人”冒充真正的[服务器](https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8)接收你传给服务器的数据，然后再冒充你把数据传给真正的服务器。\n\n通过使用SSH，你可以把所有传输的数据进行加密，这样\"中间人\"这种攻击方式就不可能实现了，而且也能够防止DNS欺骗和IP欺骗。使用SSH，还有一个额外的好处就是传输的数据是经过压缩的，所以可以加快传输的[速度](https://baike.baidu.com/item/%E9%80%9F%E5%BA%A6/5456)。SSH有很多功能，它既可以代替 [Telnet](https://baike.baidu.com/item/Telnet)，又可以为[FTP](https://baike.baidu.com/item/FTP)、[PoP](https://baike.baidu.com/item/PoP)、甚至为[PPP](https://baike.baidu.com/item/PPP)提供一个安全的\"通道\" [1]  。\n\n### 2. SSH 组成结构\n\n- 传输层协议 [SSH-TRANS]：通常运行在[TCP/IP](https://baike.baidu.com/item/TCP%2FIP)连接上\n- 用户认证协议 [SSH-USERAUTH]：用于向服务器提供客户端用户鉴别功能。\n- 连接协议 [SSH-CONNECT]：将多个加密隧道分成逻辑通道。它运行在用户认证协议上。它提供了交互式登录话路、远程命令执行、转发 TCP/IP 连接和转发 X11 连接。\n\n### 3. 用户认证方式\n\n- 第一种级别（基于口令的安全验证）\n- 第二种级别（基于密匙的安全验证）","isLeaf":true},{"key":"/network/10-protocol/04-url.md","path":"/network/10-protocol/04-url.md","route":"/network/10-protocol/04-url.md","leaf":true,"title":"04-url","depth":2,"content":"---\ntags: network\n---\n\n```\nfoo://example.com:8042/over/there?name=ferret#nose\n   \\_/ \\______________/ \\________/\\_________/ \\__/\n    |         |              |         |        |\n  scheme     authority                path      query   fragment\n```\n\n\nscheme 也可以成为 protocol。example.com被称为 hostname。\n\n## **哪些字符需要URL编码**\n\n- `#`\n- `&`","isLeaf":true},{"key":"/network/10-protocol/05-websocket.md","path":"/network/10-protocol/05-websocket.md","route":"/network/10-protocol/05-websocket.md","leaf":true,"title":"05-websocket","depth":2,"content":"---\ntags: network\n---\n\n通过 HTTP 协议来建立连接\n\n### 1. WebSocket 通过HTTP协议连接\nWebSocket协议在建立连接时会使用HTTP协议，意味着 WebSocket 协议是基于HTTP协议实现的\n\n### 2. WebSocket是应用层协议\nWebSocket是基于TCP的应用层协议，用于在C/S架构的应用中实现双向通信，关于WebSocket协议的详细规范和定义参见 [rfc6455](https://tools.ietf.org/html/rfc6455)。\n\n![20230619112051](http://s3.airtlab.com/blog/20230619112051.png)\n\n\n### 3. 连接过程\n\n![20230619112102](http://s3.airtlab.com/blog/20230619112102.png)\n\n- Connection: Connection 必须设置为Upgrade，表示客户端希望连接升级\n- Upgrade: Upgrade 必须设置为 WebSocket，表示在取得服务器响应之后，使用HTTP升级将HTTP协议转换(升级)为WebSocket协议。\n- Sec-WebSocket-key: 随机字符串，用于验证协议是否为WebSocket协议而非HTTP协议\n- Sec-WebSocket-Version: 表示使用WebSocket的哪一个版本。\n- Sec-WebSocket-Accept: 根据Sec-WebSocket-Accept和特殊字符串计算。验证协议是否为WebSocket协议。\n- Sec-WebSocket-Location: 与Host字段对应，表示请求WebSocket协议的地址。\n- HTTP/1.1 101 Switching Protocols:101 状态码表示升级协议，在返回101状态码后，HTTP协议完成工作，转换为WebSocket协议。此时就可以进行全双工双向通信了。","isLeaf":true},{"key":"/network/10-protocol/06-udp.md","path":"/network/10-protocol/06-udp.md","route":"/network/10-protocol/06-udp.md","leaf":true,"title":"06-udp","depth":2,"content":"---\ntags: network\n---\n\n### 1. UDP 协议特点\n1、UDP是无连接的，发送数据之前不需要建立连接（也没有连接可释放），减少了开销和发送数据之前的时延；\n2、UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表；\n3、UDP是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界；\n4、UDP没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低；\n5、UDP支持一对一、一对多、多对一和多对多的交互通信；\n6、UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短；\n### 2. UDP 报文格式\n\n![20230619112204](http://s3.airtlab.com/blog/20230619112204.png)\n\n![20230619112214](http://s3.airtlab.com/blog/20230619112214.png)\n\n![20230619112223](http://s3.airtlab.com/blog/20230619112223.png)\n\n### 3. 校验和的计算\n伪首部不是真实存在的，它主要用来计算校验和：\n\n![20230619112244](http://s3.airtlab.com/blog/20230619112244.png)\n\n![20230619112255](http://s3.airtlab.com/blog/20230619112255.png)","isLeaf":true}]},{"key":"/network/TCP-packet-fragmentation.md","path":"/network/TCP-packet-fragmentation.md","route":"/network/TCP-packet-fragmentation.md","leaf":true,"title":"TCP-packet-fragmentation","depth":1,"content":"---\ntags: network\n---\n\n> [关于TCP粘包问题的终结] https://zhuanlan.zhihu.com/p/157887818\n\n## 1、TCP packet fragmentation\n\nTCP packet fragmentation 是指在TCP/IP 协议中，由于网络传输的延迟，导致多个数据包粘在一起，被一次性接收。 这就会导致应用层程序无法正确解析数据包，从而出现问题。这被国人发明为 “TCP 粘包问题”，实际上这压根就不是问题，只是有些人不清楚本质罢了。\n\nTCP粘包指的是在TCP协议通信过程中，发送端连续发送的多个数据包，在接收端接收时会粘合在一起形成一个大数据包的现象。\n\nTCP协议是面向流的传输协议，发送端把待发送的数据划分为多个数据段来发送，每个数据段有自己的TCP头部信息。当发送端在短时间内向接收端连续发送多个小数据包时，由于TCP协议是IP层面上的数据报文服务，它只负责数据的分包和组包，不做处理。这会导致在接收端，多个小数据包在接收缓冲区中紧密的排列在一起，由于没有明确的边界标志表示哪些数据属于一个消息，所以在应用层对数据进行解析时，可能将多个小数据包误解为一个大的数据包，此现象就是TCP粘包。\n\nTCP粘包会导致传输的数据包出现混淆，特别是在数据包中包含了命令信息时，可能会影响系统的正常运行。解决TCP粘包问题的方式，一般都是在应用层进行拆包和封包处理，以便应用程序能正确处理多个小数据包。\n\n## 2、特性演示\n\n**client.js**\n```js\nconst net = require('net');\n\nconst client = net.createConnection({ port: 8080 }, () => {\n  console.log('connected to server!');\n});\n\nlet data = '';\nclient.on('data', (chunk) => {\n  // 这里只触发了一次 hello_world\n  console.log('data', chunk.toString());\n});\n\nclient.on('end', () => {\n  console.log('disconnected from server');\n});\n```\n\n**server.js**\n```javascript\nconst net = require('net');\n\nconst server = net.createServer((socket) => {\n  console.log('client connected');\n  socket.write('hello_');\n  socket.write('world');\n});\n\nserver.listen(8080, () => {\n  console.log('server started');\n});\n```\n\n## 3、解决方案\n\n解决这个问题的方法有很多, 包括：\n- 使用消息头来指示数据包的长度\n- 在服务端写入分隔符来表示数据包的边界\n\n### 1. 使用消息头来指示数据包的长度\n\n### 2. 写入分隔符来表示数据包的边界","isLeaf":true}]},{"key":"/parser","path":"/parser","route":"/parser","leaf":false,"title":"parser","depth":0,"content":"","isLeaf":false,"children":[{"key":"/parser/css","path":"/parser/css","route":"/parser/css","leaf":false,"title":"css","depth":1,"content":"","isLeaf":false,"children":[{"key":"/parser/css/index.md","path":"/parser/css/index.md","route":"/parser/css/index.md","leaf":true,"title":"index","depth":2,"content":"- 自己实现的简单版本的 postcss https://github.com/compiler-all/compilers/tree/master/css-parser","isLeaf":true},{"key":"/parser/css/postcss.md","path":"/parser/css/postcss.md","route":"/parser/css/postcss.md","leaf":true,"title":"postcss","depth":2,"content":"- postcss 使用指南 https://github.com/gaollard/postcss-demo","isLeaf":true}]},{"key":"/parser/html","path":"/parser/html","route":"/parser/html","leaf":false,"title":"html","depth":1,"content":"","isLeaf":false,"children":[{"key":"/parser/html/html.md","path":"/parser/html/html.md","route":"/parser/html/html.md","leaf":true,"title":"html","depth":2,"content":"在 JavaScript 中，有以下几个常用的 HTML 解析器：\n1. DOM Parser：DOM Parser 是 JavaScript 内置的一个解析器，通过解析 HTML 文件将其转换成一个 DOM 对象，使我们可以对 HTML 文件的结构进行操作。\n\n2. jQuery：jQuery 是一个流行的 JavaScript 库，它能够快速地解析 HTML，并通过 CSS 选择器获取 DOM 元素。由于其简单易用和广泛使用，因此在许多 Web 开发项目中广泛采用。\n\n3. Cheerio：Cheerio 是另一个流行的 JavaScript HTML 解析器，它模仿了 jQuery 的 API，并可以在服务器端和客户端上使用。它使用类似于 jQuery 的语法来解析 HTML 文件，并以一个 DOM 树的形式返回解析结果。\n\n4. jsdom：jsdom 是一个在 Node.js 上运行的 JavaScript 环境，它可以模拟一个浏览器环境，并解析 HTML 文档。它也可以用于测试 jQuery 和其他库的代码，同时还支持 DOM 操作。\n\n5. HTML5 Parser：HTML5 Parser 是一个用于解析 HTML5 文档的 JavaScript 库，它使用了新的 HTML5 规范，并能够处理不规范的标记和特性。\n\n6. htmlparser2 htmlparser2 is the fastest HTML parser, and takes some shortcuts to get there. If you need strict HTML spec compliance, have a look at parse5.","isLeaf":true},{"key":"/parser/html/htmlparser2.md","path":"/parser/html/htmlparser2.md","route":"/parser/html/htmlparser2.md","leaf":true,"title":"htmlparser2","depth":2,"content":"- AST test https://astexplorer.net/#/2AmVrGuGVJ\n\n## 1、使用 htmlparser2 解析 heading\n\n需要注意 pre + code 或者 xmp 的处理\n\n```js\nconst fs = require('fs')\nconst htmlparser = require(\"htmlparser2\");\n\nfunction resolveHeadings (content) {\n  const headings = []\n  let heading;\n  let isHeading = false;\n  let isTag = true;\n  const parser = new htmlparser.Parser({\n    onopentag: function (name, attributes) {\n      if (name === 'xmp') {\n        isTag = false;\n      }\n\n      if (isTag) {\n        if (\n          name === \"h1\" ||\n          name === \"h2\" ||\n          name === \"h3\" ||\n          name === \"h4\" ||\n          name === \"h5\" ||\n          name === \"h6\"\n        ) {\n          isHeading = true;\n          heading = {\n            level: name,\n            text: '',\n            attributes\n          }\n          headings.push(heading)\n        } else {\n          isHeading = false;\n        }\n      }\n    },\n    onclosetag: function (name, attributes) {\n      if (name === 'xmp') {\n        isTag = true;\n      }\n\n      if (\n        name === \"h1\" ||\n        name === \"h2\" ||\n        name === \"h3\" ||\n        name === \"h4\" ||\n        name === \"h5\" ||\n        name === \"h6\"\n      ) {\n        isHeading = false;\n      }\n    },\n\n    ontext: function(text) {\n      if (isHeading) {\n        heading.text = text\n      }\n    }\n  });\n\n  parser.write(content);\n  parser.end();\n\n  return headings;\n}\n\nconsole.log(resolveHeadings(fs.readFileSync('./index.html', 'utf8')))\n```\n\n```text\n[\n  { level: 'h1', text: 'h1', attributes: { id: 'h1' } },\n  { level: 'h2', text: 'h2', attributes: {} }\n]\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n\n<body>\n  <h1 id=\"h1\">h1</h1>\n  <div>哈哈哈哈电话</div>\n  <h2>h2</h2>\n  <div>哈哈哈哈电话</div>\n  <xmp>\n    <h3>h3</h3>\n  </xmp>\n</body>\n</html>\n```","isLeaf":true}]},{"key":"/parser/markdown","path":"/parser/markdown","route":"/parser/markdown","leaf":false,"title":"markdown","depth":1,"content":"","isLeaf":false,"children":[{"key":"/parser/markdown/markdown.md","path":"/parser/markdown/markdown.md","route":"/parser/markdown/markdown.md","leaf":true,"title":"markdown","depth":2,"content":"## 1、markdown 解析哪家强？\n\n- markdown-it\n- marked\n- Pandoc：用于转换文档格式的通用工具，可以将 Markdown 转换为其他格式（如 PDF、 Word 和 HTML）\n- GitHub Flavored Markdown：GitHub 所使用的 Markdown 解析器，可以在 GitHub 上创建了支持代码语法高亮、任务列表等扩展的 Markdown\n\n## 2、实现一个markdown解析器需要具备哪些知识？\n\nhttps://www.zhihu.com/question/28756456","isLeaf":true},{"key":"/parser/markdown/markown-it.md","path":"/parser/markdown/markown-it.md","route":"/parser/markdown/markown-it.md","leaf":true,"title":"markown-it","depth":2,"content":"- 中文文档 https://markdown-it.docschina.org\n\n## 1、演示\n\n```js\nconst fs = require(\"fs\");\nconst markdown = require(\"markdown-it\");\nconst anchr = require(\"markdown-it-anchor\");\nconst frontmatter = require(\"markdown-it-front-matter\");\n\nconst md = markdown({\n  html: false,\n  xhtmlOut: true,\n  typographer: true,\n  // highlight: (code, lang) => {\n  //   return highlighter.codeToHtml(code, { lang })\n  // }\n})\n  .use(frontmatter, (fm) => {\n    console.log(fm); // fm 是一个对象，包含 YAML 头部数据\n  })\n  .use(anchr)\n  // .use(toc)\n  .use(require(\"markdown-it-table-of-contents\"), {\n    format(content, md) {\n      // console.log(222, content, md);\n      return content;\n    },\n    resolveHeadings (headings) {\n      console.log(headings)\n    }\n  });\n\nconst html = md.render(fs.readFileSync(\"./markdown.md\", \"utf8\"));\n// console.log(html);\n\n```\n\n## 2、结合 highlight.js \n\nhttps://blog.csdn.net/fxss5201/article/details/103567578\n\n## 3、结合 shiki","isLeaf":true}]}]},{"key":"/python","path":"/python","route":"/python","leaf":false,"title":"python","depth":0,"content":"","isLeaf":false,"children":[{"key":"/python/01-version-conflict.md","path":"/python/01-version-conflict.md","route":"/python/01-version-conflict.md","leaf":true,"title":"01-version-conflict","depth":1,"content":"- Mac自带的 python2 版本，在 `/System/Library/Frameworks/Python.framework/Versions` 里面\n- 自己从官网安装的在 `/Library/Frameworks/Python.framework/` 里面\n- 通过 homebrew 安装的在 `/usr/local/Cellar/` 里面\n\n## 1、看看你用的 python\n```shell\nwhich python\n# /usr/bin/python\n\nls -l /usr/bin/python\n# lrwxr-xr-x  1 root  wheel  75 Jan  1  2020 /usr/bin/python -> ../../System/Library/Frameworks/Python.framework/Versions/2.7/bin/python2.7\n```\n这里显示我用的是系统自带的，`oh shit` 难怪经常报错\n  \n## 2、pyenv 管理 python 版本\n\n![20230515151400](http://s3.airtlab.com/blog/20230515151400.png)\n\nhttps://stackoverflow.com/questions/60298514/how-to-reinstall-python2-from-homebrew\n\n**安装错误**\n\nERROR: The Python zlib extension was not compiled. Missing the zlib?\n\n## 3、easy_install 的作用\n\n`easy_install` 是 Python 的一个包管理工具，它可以自动下载，安装，升级和卸载 Python 包(package)。它可以在 PyPI（Python 包索引）中搜索所需的包，然后执行必要的操作来安装和配置这些包。\n\n使用 `easy_install`，您可以很方便地安装 Python 包并自动解决所依赖的其他包的问题。\n\n`easy_install` 与 Python 自带的 `pip` 功能类似，但已被弃用，目前已建议使用 `pip` 进行包管理。\n\n## 4、brew install python\n\n```shell\n$ brew install python@2\n\nWarning: No available formula with the name \"python@2\". Did you mean ipython, bpython, jython or cython?\n==> Searching for similarly named formulae and casks...\n==> Formulae\nipython                            bpython                            jython                             cython\n\nTo install ipython, run:\n  brew install ipython\n```\n\n报错了 shit...\n\n## 5、pip install 报错\n\n\n```text\nDefaulting to user installation because normal site-packages is not writeable\nCollecting mysql-utilities\n  Using cached mysql-utilities-1.4.3.tar.gz (564 kB)\n    ERROR: Command errored out with exit status 1:\n     command: /System/Library/Frameworks/Python.framework/Versions/2.7/Resources/Python.app/Contents/MacOS/Python -c 'import sys, setuptools, tokenize; sys.argv[0] = '\"'\"'/private/var/folders/ft/95_cj6t91fd72fthj6ggvwp80000gq/T/pip-install-2Ka5JP/mysql-utilities/setup.py'\"'\"'; __file__='\"'\"'/private/var/folders/ft/95_cj6t91fd72fthj6ggvwp80000gq/T/pip-install-2Ka5JP/mysql-utilities/setup.py'\"'\"';f=getattr(tokenize, '\"'\"'open'\"'\"', open)(__file__);code=f.read().replace('\"'\"'\\r\\n'\"'\"', '\"'\"'\\n'\"'\"');f.close();exec(compile(code, __file__, '\"'\"'exec'\"'\"'))' egg_info --egg-base /private/var/folders/ft/95_cj6t91fd72fthj6ggvwp80000gq/T/pip-pip-egg-info-Y6Ndcn\n         cwd: /private/var/folders/ft/95_cj6t91fd72fthj6ggvwp80000gq/T/pip-install-2Ka5JP/mysql-utilities/\n    Complete output (5 lines):\n    Traceback (most recent call last):\n      File \"<string>\", line 1, in <module>\n      File \"/private/var/folders/ft/95_cj6t91fd72fthj6ggvwp80000gq/T/pip-install-2Ka5JP/mysql-utilities/setup.py\", line 36, in <module>\n        from info import META_INFO, INSTALL\n    ImportError: No module named info\n    ----------------------------------------\nERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs for full command output.\n```\n\n明明在 `.zshrc` 里面已经指定了 python 为 /Lib 目录下，但是他查找出来的不是，无奈只能 指定 python 版本安装：\n\n```shell\npython3.6 -m pip install <package_name>  # 可以在python3.6下安装包\npython3.7 -m pip install <package_name>  # 可以在python3.7下安装包\npython3.8 -m pip install <package_name>  # 可以在python3.8下安装包\n```","isLeaf":true}]},{"key":"/sourcemap","path":"/sourcemap","route":"/sourcemap","leaf":false,"title":"sourcemap","depth":0,"content":"","isLeaf":false,"children":[{"key":"/sourcemap/01-Source map的格式.md","path":"/sourcemap/01-Source map的格式.md","route":"/sourcemap/01-Source map的格式.md","leaf":true,"title":"01-Source map的格式","depth":1,"content":"```json\n　{\n　　　　version : 3,\n　　　　file: \"out.js\",\n　　　　sourceRoot : \"\",\n　　　　sources: [\"foo.js\", \"bar.js\"],\n　　　　names: [\"src\", \"maps\", \"are\", \"fun\"],\n　　　　mappings: \"AAgBC,SAAQ,CAAEA\"\n　　}\n```\n\n```\n　　- version：Source map的版本，目前为3。\n　　- file：转换后的文件名。\n　　- sourceRoot：转换前的文件所在的目录。如果与转换前的文件在同一目录，该项为空。\n　　- sources：转换前的文件。该项是一个数组，表示可能存在多个文件合并。\n　　- names：转换前的所有变量名和属性名。\n　　- mappings：记录位置信息的字符串，下文详细介绍。\n```","isLeaf":true},{"key":"/sourcemap/02-mappings属性.md","path":"/sourcemap/02-mappings属性.md","route":"/sourcemap/02-mappings属性.md","leaf":true,"title":"02-mappings属性","depth":1,"content":"关键就是map文件的mappings属性。这是一个很长的字符串，它分成三层。\n\n\n　　第一层是行对应，以分号（;）表示，每个分号对应转换后源码的一行。所以，第一个分号前的内容，就对应源码的第一行，以此类推。\n\n　　第二层是位置对应，以逗号（,）表示，每个逗号对应转换后源码的一个位置。所以，第一个逗号前的内容，就对应该行源码的第一个位置，以此类推。\n\n　　第三层是位置转换，以VLQ编码表示，代表该位置对应的转换前的源码位置。\n\n\n举例来说，假定mappings属性的内容如下：\n\n　　mappings:\"AAAAA,BBBBB;CCCCC\"\n\n就表示，转换后的源码分成两行，第一行有两个位置，第二行有一个位置。","isLeaf":true},{"key":"/sourcemap/03-位置对应的原理.md","path":"/sourcemap/03-位置对应的原理.md","route":"/sourcemap/03-位置对应的原理.md","leaf":true,"title":"03-位置对应的原理","depth":1,"content":"每个位置使用五位，表示五个字段。\n\n从左边算起\n\n　- 第一位，表示这个位置在（转换后的代码的）的第几列。\n\n　　- 第二位，表示这个位置属于sources属性中的哪一个文件。\n\n　　- 第三位，表示这个位置属于转换前代码的第几行。\n\n　　- 第四位，表示这个位置属于转换前代码的第几列。\n\n　　- 第五位，表示这个位置属于names属性中的哪一个变量。","isLeaf":true},{"key":"/sourcemap/04-VLQ编码.md","path":"/sourcemap/04-VLQ编码.md","route":"/sourcemap/04-VLQ编码.md","leaf":true,"title":"04-VLQ编码","depth":1,"content":"如果某个位置是AAAAA，由于A在VLQ编码中表示0，因此这个位置的五个位实际上都是0。\n\n它的意思是，该位置在转换后代码的第0列，对应sources属性中第0个文件，属于转换前代码的第0行第0列，对应names属性中的第0个变量。\n\n\n最后，谈谈如何用VLQ编码表示数值。\n\n这种编码最早用于MIDI文件，后来被多种格式采用。它的特点就是可以非常精简地表示很大的数值。\n\n\nVLQ编码是变长的。如果（整）数值在-15到+15之间（含两个端点），用一个字符表示；超出这个范围，就需要用多个字符表示。它规定，每个字符使用6个两进制位，正好可以借用Base 64编码的字符表。\n\n\n![20230710161209](http://s3.airtlab.com/blog/20230710161209.png)","isLeaf":true},{"key":"/sourcemap/05-source-map库.md","path":"/sourcemap/05-source-map库.md","route":"/sourcemap/05-source-map库.md","leaf":true,"title":"05-source-map库","depth":1,"content":"https://github.com/mozilla/source-map","isLeaf":true},{"key":"/sourcemap/06-演示.md","path":"/sourcemap/06-演示.md","route":"/sourcemap/06-演示.md","leaf":true,"title":"06-演示","depth":1,"content":"```json\n{\n  \"version\": 3,\n  \"file\": \"my-first-webpack.bundle.js\",\n  \"mappings\": \"MAKA,MAAMA,GAJFC,QAAQC,IAAI,KACL,KAKXD,QAAQC,IAAIF,EAAG,I\",\n  \"sources\": [\n    \"webpack://sourcemap-demo/./src/main.js\"\n  ],\n  \"sourcesContent\": [\n    \"function sleep() {\\n    console.log(222)\\n    return 200;\\n}\\n\\nconst a = sleep()\\n\\nconsole.log(a, 111)\"\n  ],\n  \"names\": [\n    \"a\",\n    \"console\",\n    \"log\"\n  ],\n  \"sourceRoot\": \"\"\n}\n```\n\noutput\n\n```js\n(()=>{const o=(console.log(222),200);console.log(o,111)})();\n//# sourceMappingURL=my-first-webpack.bundle.js.map\n```\n\n## mappings\n\n\"MAKA,MAAMA,GAJFC,QAAQC,IAAI,KACL,KAKXD,QAAQC,IAAIF,EAAG,I\",","isLeaf":true},{"key":"/sourcemap/javascript_source_map-阮一峰.md","path":"/sourcemap/javascript_source_map-阮一峰.md","route":"/sourcemap/javascript_source_map-阮一峰.md","leaf":true,"title":"javascript_source_map-阮一峰","depth":1,"content":"https://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html","isLeaf":true}]},{"key":"/system","path":"/system","route":"/system","leaf":false,"title":"system","depth":0,"content":"","isLeaf":false,"children":[{"key":"/system/ASCII.md","path":"/system/ASCII.md","route":"/system/ASCII.md","leaf":true,"title":"ASCII","depth":1,"content":"### ASCII 编码\n\n![20230619114042](http://s3.airtlab.com/blog/20230619114042.png)\n\nASCII 码主要支持英文和部分西欧语言，它不支持中文的编码。\n\n![20230619114049](http://s3.airtlab.com/blog/20230619114049.png)\n\n标准 ASCII 码 主要用来表示大小写字母/标点符号/美式英语中的控制符等。\n扩展 ASCII 码 主要用来表示特殊字符/外来语言字符等。\n\n### ASCII 编码表\n\n| Bin (二进制) | Oct (八进制) | Dec (十进制) | Hex (十六进制) | 缩写/字符 | 解释 |\n| --- | --- | --- | --- | --- | --- |\n| 0000 0000 | 00 | 0 | 0x00 | NUL(null) | 空字符 |\n| 0000 0001 | 01 | 1 | 0x01 | SOH(start of headline) | 标题开始 |\n| 0000 0010 | 02 | 2 | 0x02 | STX (start of text) | 正文开始 |\n| 0000 0011 | 03 | 3 | 0x03 | ETX (end of text) | 正文结束 |\n| 0000 0100 | 04 | 4 | 0x04 | EOT (end of transmission) | 传输结束 |\n| 0000 0101 | 05 | 5 | 0x05 | ENQ (enquiry) | 请求 |\n| 0000 0110 | 06 | 6 | 0x06 | ACK (acknowledge) | 收到通知 |\n| 0000 0111 | 07 | 7 | 0x07 | BEL (bell) | 响铃 |\n| 0000 1000 | 010 | 8 | 0x08 | BS (backspace) | 退格 |\n| 0000 1001 | 011 | 9 | 0x09 | HT (horizontal tab) | 水平制表符 |\n| 0000 1010 | 012 | 10 | 0x0A | LF (NL line feed, new line) | 换行键 |\n| 0000 1011 | 013 | 11 | 0x0B | VT (vertical tab) | 垂直制表符 |\n| 0000 1100 | 014 | 12 | 0x0C | FF (NP form feed, new page) | 换页键 |\n| 0000 1101 | 015 | 13 | 0x0D | CR (carriage return) | 回车键 |\n| 0000 1110 | 016 | 14 | 0x0E | SO (shift out) | 不用切换 |\n| 0000 1111 | 017 | 15 | 0x0F | SI (shift in) | 启用切换 |\n| 0001 0000 | 020 | 16 | 0x10 | DLE (data link escape) | 数据链路转义 |\n| 0001 0001 | 021 | 17 | 0x11 | DC1 (device control 1) | 设备控制1 |\n| 0001 0010 | 022 | 18 | 0x12 | DC2 (device control 2) | 设备控制2 |\n| 0001 0011 | 023 | 19 | 0x13 | DC3 (device control 3) | 设备控制3 |\n| 0001 0100 | 024 | 20 | 0x14 | DC4 (device control 4) | 设备控制4 |\n| 0001 0101 | 025 | 21 | 0x15 | NAK (negative acknowledge) | 拒绝接收 |\n| 0001 0110 | 026 | 22 | 0x16 | SYN (synchronous idle) | 同步空闲 |\n| 0001 0111 | 027 | 23 | 0x17 | ETB (end of trans. block) | 结束传输块 |\n| 0001 1000 | 030 | 24 | 0x18 | CAN (cancel) | 取消 |\n| 0001 1001 | 031 | 25 | 0x19 | EM (end of medium) | 媒介结束 |\n| 0001 1010 | 032 | 26 | 0x1A | SUB (substitute) | 代替 |\n| 0001 1011 | 033 | 27 | 0x1B | ESC (escape) | 换码(溢出) |\n| 0001 1100 | 034 | 28 | 0x1C | FS (file separator) | 文件分隔符 |\n| 0001 1101 | 035 | 29 | 0x1D | GS (group separator) | 分组符 |\n| 0001 1110 | 036 | 30 | 0x1E | RS (record separator) | 记录分隔符 |\n| 0001 1111 | 037 | 31 | 0x1F | US (unit separator) | 单元分隔符 |\n| 0010 0000 | 040 | 32 | 0x20 | (space) | 空格 |\n| 0010 0001 | 041 | 33 | 0x21 | ! | 叹号 |\n| 0010 0010 | 042 | 34 | 0x22 | \" | 双引号 |\n| 0010 0011 | 043 | 35 | 0x23 | # | 井号 |\n| 0010 0100 | 044 | 36 | 0x24 | $ | 美元符 |\n| 0010 0101 | 045 | 37 | 0x25 | % | 百分号 |\n| 0010 0110 | 046 | 38 | 0x26 | & | 和号 |\n| 0010 0111 | 047 | 39 | 0x27 | ' | 闭单引号 |\n| 0010 1000 | 050 | 40 | 0x28 | ( | 开括号 |\n| 0010 1001 | 051 | 41 | 0x29 | ) | 闭括号 |\n| 0010 1010 | 052 | 42 | 0x2A | * | 星号 |\n| 0010 1011 | 053 | 43 | 0x2B | + | 加号 |\n| 0010 1100 | 054 | 44 | 0x2C | , | 逗号 |\n| 0010 1101 | 055 | 45 | 0x2D | - | 减号/破折号 |\n| 0010 1110 | 056 | 46 | 0x2E | . | 句号 |\n| 0010 1111 | 057 | 47 | 0x2F | / | 斜杠 |\n| 0011 0000 | 060 | 48 | 0x30 | 0 | 字符0 |\n| 0011 0001 | 061 | 49 | 0x31 | 1 | 字符1 |\n| 0011 0010 | 062 | 50 | 0x32 | 2 | 字符2 |\n| 0011 0011 | 063 | 51 | 0x33 | 3 | 字符3 |\n| 0011 0100 | 064 | 52 | 0x34 | 4 | 字符4 |\n| 0011 0101 | 065 | 53 | 0x35 | 5 | 字符5 |\n| 0011 0110 | 066 | 54 | 0x36 | 6 | 字符6 |\n| 0011 0111 | 067 | 55 | 0x37 | 7 | 字符7 |\n| 0011 1000 | 070 | 56 | 0x38 | 8 | 字符8 |\n| 0011 1001 | 071 | 57 | 0x39 | 9 | 字符9 |\n| 0011 1010 | 072 | 58 | 0x3A | : | 冒号 |\n| 0011 1011 | 073 | 59 | 0x3B | ; | 分号 |\n| 0011 1100 | 074 | 60 | 0x3C | < | 小于 |\n| 0011 1101 | 075 | 61 | 0x3D | = | 等号 |\n| 0011 1110 | 076 | 62 | 0x3E | > | 大于 |\n| 0011 1111 | 077 | 63 | 0x3F | ? | 问号 |\n| 0100 0000 | 0100 | 64 | 0x40 | @ | 电子邮件符号 |\n| 0100 0001 | 0101 | 65 | 0x41 | A | 大写字母A |\n| 0100 0010 | 0102 | 66 | 0x42 | B | 大写字母B |\n| 0100 0011 | 0103 | 67 | 0x43 | C | 大写字母C |\n| 0100 0100 | 0104 | 68 | 0x44 | D | 大写字母D |\n| 0100 0101 | 0105 | 69 | 0x45 | E | 大写字母E |\n| 0100 0110 | 0106 | 70 | 0x46 | F | 大写字母F |\n| 0100 0111 | 0107 | 71 | 0x47 | G | 大写字母G |\n| 0100 1000 | 0110 | 72 | 0x48 | H | 大写字母H |\n| 0100 1001 | 0111 | 73 | 0x49 | I | 大写字母I |\n| 01001010 | 0112 | 74 | 0x4A | J | 大写字母J |\n| 0100 1011 | 0113 | 75 | 0x4B | K | 大写字母K |\n| 0100 1100 | 0114 | 76 | 0x4C | L | 大写字母L |\n| 0100 1101 | 0115 | 77 | 0x4D | M | 大写字母M |\n| 0100 1110 | 0116 | 78 | 0x4E | N | 大写字母N |\n| 0100 1111 | 0117 | 79 | 0x4F | O | 大写字母O |\n| 0101 0000 | 0120 | 80 | 0x50 | P | 大写字母P |\n| 0101 0001 | 0121 | 81 | 0x51 | Q | 大写字母Q |\n| 0101 0010 | 0122 | 82 | 0x52 | R | 大写字母R |\n| 0101 0011 | 0123 | 83 | 0x53 | S | 大写字母S |\n| 0101 0100 | 0124 | 84 | 0x54 | T | 大写字母T |\n| 0101 0101 | 0125 | 85 | 0x55 | U | 大写字母U |\n| 0101 0110 | 0126 | 86 | 0x56 | V | 大写字母V |\n| 0101 0111 | 0127 | 87 | 0x57 | W | 大写字母W |\n| 0101 1000 | 0130 | 88 | 0x58 | X | 大写字母X |\n| 0101 1001 | 0131 | 89 | 0x59 | Y | 大写字母Y |\n| 0101 1010 | 0132 | 90 | 0x5A | Z | 大写字母Z |\n| 0101 1011 | 0133 | 91 | 0x5B | [ | 开方括号 |\n| 0101 1100 | 0134 | 92 | 0x5C | \\\\ | 反斜杠 |\n| 0101 1101 | 0135 | 93 | 0x5D | ] | 闭方括号 |\n| 0101 1110 | 0136 | 94 | 0x5E | ^ | 脱字符 |\n| 0101 1111 | 0137 | 95 | 0x5F | _ | 下划线 |\n| 0110 0000 | 0140 | 96 | 0x60 | ` | 开单引号 |\n| 0110 0001 | 0141 | 97 | 0x61 | a | 小写字母a |\n| 0110 0010 | 0142 | 98 | 0x62 | b | 小写字母b |\n| 0110 0011 | 0143 | 99 | 0x63 | c | 小写字母c |\n| 0110 0100 | 0144 | 100 | 0x64 | d | 小写字母d |\n| 0110 0101 | 0145 | 101 | 0x65 | e | 小写字母e |\n| 0110 0110 | 0146 | 102 | 0x66 | f | 小写字母f |\n| 0110 0111 | 0147 | 103 | 0x67 | g | 小写字母g |\n| 0110 1000 | 0150 | 104 | 0x68 | h | 小写字母h |\n| 0110 1001 | 0151 | 105 | 0x69 | i | 小写字母i |\n| 0110 1010 | 0152 | 106 | 0x6A | j | 小写字母j |\n| 0110 1011 | 0153 | 107 | 0x6B | k | 小写字母k |\n| 0110 1100 | 0154 | 108 | 0x6C | l | 小写字母l |\n| 0110 1101 | 0155 | 109 | 0x6D | m | 小写字母m |\n| 0110 1110 | 0156 | 110 | 0x6E | n | 小写字母n |\n| 0110 1111 | 0157 | 111 | 0x6F | o | 小写字母o |\n| 0111 0000 | 0160 | 112 | 0x70 | p | 小写字母p |\n| 0111 0001 | 0161 | 113 | 0x71 | q | 小写字母q |\n| 0111 0010 | 0162 | 114 | 0x72 | r | 小写字母r |\n| 0111 0011 | 0163 | 115 | 0x73 | s | 小写字母s |\n| 0111 0100 | 0164 | 116 | 0x74 | t | 小写字母t |\n| 0111 0101 | 0165 | 117 | 0x75 | u | 小写字母u |\n| 0111 0110 | 0166 | 118 | 0x76 | v | 小写字母v |\n| 0111 0111 | 0167 | 119 | 0x77 | w | 小写字母w |\n| 0111 1000 | 0170 | 120 | 0x78 | x | 小写字母x |\n| 0111 1001 | 0171 | 121 | 0x79 | y | 小写字母y |\n| 0111 1010 | 0172 | 122 | 0x7A | z | 小写字母z |\n| 0111 1011 | 0173 | 123 | 0x7B | { | 开花括号 |\n| 0111 1100 | 0174 | 124 | 0x7C | &#124; | 垂线 |\n| 0111 1101 | 0175 | 125 | 0x7D | } | 闭花括号 |\n| 0111 1110 | 0176 | 126 | 0x7E | ~ | 波浪号 |\n| 0111 1111 | 0177 | 127 | 0x7F | DEL (delete) | 删除 |\n\n### **Unicode 编码**\nUnicode编码的目标是支持世界上所有的字符集表示。\n\n![20230619114100](http://s3.airtlab.com/blog/20230619114100.png)\n\nUnicode 都是4位的，而且用16进制来表示。","isLeaf":true},{"key":"/system/Virtual-machine","path":"/system/Virtual-machine","route":"/system/Virtual-machine","leaf":false,"title":"Virtual-machine","depth":1,"content":"","isLeaf":false,"children":[{"key":"/system/Virtual-machine/01-Virtual-machine.md","path":"/system/Virtual-machine/01-Virtual-machine.md","route":"/system/Virtual-machine/01-Virtual-machine.md","leaf":true,"title":"01-Virtual-machine","depth":2,"content":"## 虚拟机的认识\n- 什么是物理机/宿主机？\n- 什么是虚拟机？\n- 虚拟机的用途？\n- 使用虚拟机的好处？\n   - 可以装多个系统\n   - 起到隔离作用\n- 软件模拟硬件设备？\n\n![20230619113906](http://s3.airtlab.com/blog/20230619113906.png)\n\n## 常见虚拟机比较\n\n![20230619113916](http://s3.airtlab.com/blog/20230619113916.png)\n\n## 使用虚拟机的好处\n\n![20230619113927](http://s3.airtlab.com/blog/20230619113927.png)\n","isLeaf":true},{"key":"/system/Virtual-machine/02-Virtual-machine-network-connection-type.md","path":"/system/Virtual-machine/02-Virtual-machine-network-connection-type.md","route":"/system/Virtual-machine/02-Virtual-machine-network-connection-type.md","leaf":true,"title":"02-Virtual-machine-network-connection-type","depth":2,"content":"---\ntitle: 虚拟机网络连接类型\n---\n\n![20230619113715](http://s3.airtlab.com/blog/20230619113715.png)","isLeaf":true}]},{"key":"/system/bit-operation.md","path":"/system/bit-operation.md","route":"/system/bit-operation.md","leaf":true,"title":"bit-operation","depth":1,"content":"[https://www.runoob.com/w3cnote/bit-operation.html](https://www.runoob.com/w3cnote/bit-operation.html)\n\n| 符号 | 描述 | 运算规则 |\n| --- | --- | --- |\n| & | 与 | 两个位都为1时，结果才为1 |\n| &#124; | 或 | 两个位都为0时，结果才为0 |\n| ^ | 异或 | 两个位相同为0，相异为1 |\n| ~ | 取反 | 0变1，1变0 |\n| << | 左移 | 各二进位全部左移若干位，高位丢弃，低位补0 |\n| >> | 右移 | 各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移） |\n\n### << 左移\n\n```javascript\n// 3 的二进制表示 0000 0011\n// 左移 4位 0011\n// 右侧补0  =>  00110000，变为十进制 48\n\nconsole.log(3 << 4) // 48\n```\n\n### >> 右移\n\n```javascript\n// 1. 十进制 32 的二进制表示为：0010 0000\n// 2. 右移 4位 0000 0010\nconsole.log(32 >> 4) // 2\n```\n```javascript\n// 1. 十进制 40 的二进制表示为：0010 1000\n// 2. 右移 4位 0000 0010\nconsole.log(40 >> 4) // 2\n```\n\n### | 或运算\n\n```javascript\n// 010\n// 011\n// 011 => 3\n2 | 3\n```\n\n### & 与运算\n```javascript\n// 010\n// 011\n// 010 => 2\n2 & 3\n\n// 011\n// 101\n// 001\n// 3 & 5 => 1\n```","isLeaf":true},{"key":"/system/english","path":"/system/english","route":"/system/english","leaf":false,"title":"english","depth":1,"content":"","isLeaf":false,"children":[{"key":"/system/english/01-workarounds.md","path":"/system/english/01-workarounds.md","route":"/system/english/01-workarounds.md","leaf":true,"title":"01-workarounds","depth":2,"content":"---\ntags: english\n---\n\nworkarounds 表示变通方法、解决方案\n\n```\nJust think the amount of time that a web developer saves without having to code hacks and workarounds for IE.\n```\n\n试想一下，这将为网络开发人员节省多少时间，因为他们无需为针对 IE 的二次修改和解决方案进行编码。","isLeaf":true},{"key":"/system/english/02-consume.md","path":"/system/english/02-consume.md","route":"/system/english/02-consume.md","leaf":true,"title":"02-consume","depth":2,"content":"---\ntags: english\n---\n\n```\nthese machines consume 5 percent of the natural gas in the U.S\n```\n这些机器消耗了美国 5% 的天然气\n\n```\npeople consume a good deal of sugar in drinks\n```\n人们在饮料中摄入大量糖分\n\n```\nThis plugin can consume local files, node modules or web_modules.\n```\n此插件可以使用本地文件、节点模块或 web_modules。","isLeaf":true},{"key":"/system/english/03-forgry.md","path":"/system/english/03-forgry.md","route":"/system/english/03-forgry.md","leaf":true,"title":"03-forgry","depth":2,"content":"---\ntags: english\n---\n\n```\nthe action of forging or producing a copy of a document, signature, banknote, or work of art.\n```\n伪造或制作文件、签名、钞票或艺术品的副本的行为。\n\n```\nhe was found guilty of forgery\n```\n他被判犯有伪造罪","isLeaf":true},{"key":"/system/english/04-appendix.md","path":"/system/english/04-appendix.md","route":"/system/english/04-appendix.md","leaf":true,"title":"04-appendix","depth":2,"content":"---\ntags: english\n---\n\n```\na list of such activities was published as an appendix to the report\n```\n此类活动的清单已作为报告的附录公布","isLeaf":true}]},{"key":"/system/linux","path":"/system/linux","route":"/system/linux","leaf":false,"title":"linux","depth":1,"content":"","isLeaf":false,"children":[{"key":"/system/linux/01-dig.md","path":"/system/linux/01-dig.md","route":"/system/linux/01-dig.md","leaf":true,"title":"01-dig","depth":2,"content":"---\ntags: linux\n---\n\n## 1、dig 介绍\n\ndig 是一种用于查询域名系统（DNS）服务器的命令行工具。默认情况下，dig 确实使用本地主机的 DNS 解析器来执行查询。但是，在某些情况下，dig 可能会绕过本地主机的 DNS 解析器，例如：\n\n1. 指定了其他 DNS 服务器：如果您在使用 dig 时显式指定了其他 DNS 服务器，则 dig 会直接与该 DNS 服务器进行通信而不会使用本地主机的 DNS 解析器。\n\n2. 主机配置错误：如果您的主机的 DNS 配置不正确，则 dig 可能无法正确解析域名。例如，如果主机的 DNS 配置未正确设置，或者您的 DNS 服务器停止工作，则 dig 将无法使用本地主机的 DNS 解析器并返回错误。\n\n3. 缓存问题：如果 dig 在其缓存中具有与您查询的域名相同的信息，则它将返回其缓存中的数据而不会使用本地主机的 DNS 解析器。这可能会导致 dig 绕过本地主机的 DNS 解析器而返回意外的结果。\n\n## 2、dig 输出解释\n\n在使用 dig 命令时，您可以得到以下各种输出。下面是常见的 dig 输出及其含义：\n\n1. 查询结果信息\n\n   - ;; QUESTION SECTION: 提问区域 - 显示您要查询的域名。\n   - ;; ANSWER SECTION: 回答区域 - 显示来自 DNS 服务器的回答，包括 IP 地址和其他资源记录。\n   - ;; AUTHORITY SECTION: 权威区域 - 显示来自授权 DNS 服务器的信息，用于该域的名称服务器。\n   - ;; ADDITIONAL SECTION: 附加区域 - 显示其他信息，例如 DNS 服务器的 IPv6 地址等。\n\n2. 域名服务器信息\n\n   - ;; SERVER: 服务器地址 - 显示 DNS 服务器的 IP 地址或名称。\n   - ;; WHEN: 时间戳 - 显示查询时间戳。\n\n3. 查询状态信息\n   - ;; Query time: 时间 - 显示查询时间，通常以毫秒为单位。\n   - ;; MSG SIZE rcvd: 大小 - 显示接收到的消息大小，以字节为单位。\n\n其他可能的输出包括警告和错误信息，如格式错误等。您可以使用 dig 的不同选项来控制和更改输出内容的详细程度。\n\n## 3、使用 dig 显示 dns 寻址过程\n\nhttps://www.cnblogs.com/chanshuyi/p/dns_dig_command.html\n\n## 4、dig 结果 和 /etc/hosts 有关吗\n\n是的，dig命令的结果可以与/etc/hosts文件有关。/etc/hosts文件是Linux系统中的本地主机名解析器，它包含IP地址与主机名之间的映射关系，可以用于绕过DNS服务器直接解析主机名。\n当您使用dig命令查询域名时，dig查询先查看本地hosts文件是否已经存在该域名的解析信息。如果hosts文件中包含了该域名的IP地址对应关系，则dig优先使用该信息完成查询，而不会继续向DNS服务器发送查询请求。因此，如果您的/etc/hosts文件中存在与要查询的域名有关的条目，则dig输出结果中的IP地址可能会与您在该文件中定义的地址相匹配。\n\n需要注意的是，如果您在查询时指定了使用某个DNS服务器进行查询，则dig不会使用本地主机名解析器查找/etc/hosts文件中的主机名和IP地址映射关系，而是直接查询指定的DNS服务器。\n","isLeaf":true},{"key":"/system/linux/02-nc.md","path":"/system/linux/02-nc.md","route":"/system/linux/02-nc.md","leaf":true,"title":"02-nc","depth":2,"content":"---\ntags: linux\n---\n\nLinux 系统上有很多工具可以用来发送 TCP 包，其中最常用的是 `netcat`（也称作 nc）。`netcat` 是一个终端工具，它允许你使用网络连接发送和接收数据。\n\n要发送 TCP 包，可以使用 nc 命令，例如：\n\n```shell\nnc -vz example.com 80\n```\n\n除了 netcat 之外，还有许多其他工具可以用来发送 TCP 包，例如：\n\n- telnet：一个终端工具，可以用来连接远程主机。\n- hping3：一个网络测试工具，可以用来发送各种类型的网络数据包。\n\n还有许多其他工具，你可以根据自己的需要来选择使用。","isLeaf":true}]},{"key":"/system/macos","path":"/system/macos","route":"/system/macos","leaf":false,"title":"macos","depth":1,"content":"","isLeaf":false,"children":[]},{"key":"/system/reentrant.md","path":"/system/reentrant.md","route":"/system/reentrant.md","leaf":true,"title":"reentrant","depth":1,"content":"---\ntitle: 函数可重入性\ntags: system\n---\n\nhttps://zh.wikipedia.org/wiki/%E5%8F%AF%E9%87%8D%E5%85%A5\n\n> 若一个程序或子程序可以“在任意时刻被中断然后操作系统调度执行另一段代码，这段代码又使用了该副程序不会出错”，则称其为可重入（reentrant 或 re-entrant）的。即当该副程序正在运作时，执行线程可以再次进入并执行它，仍然可得到符合设计时所预期的结果。与多线程并发执行的线程安全不同，可重入强调对单一线程执行时重新进入同一个子程序仍然是安全的。\n\n在实时系统的设计中，经常会出现多个任务调用同一个函数的情况。如果有一个函数不幸被设计成为这样：那么不同任务调用这个函数时可能修改其他任务调用这个函数的数据，从而导致不可预料的后果。这样的函数是不安全的函数，也叫不可重入函数。\n\n相反，肯定有一个安全的函数，这个安全的函数又叫可重入函数。那么什么是可重入函数呢？所谓可重入是指一个可以被多个任务调用的过程，任务在调用时不必担心数据是否会出错。\n\n一个可重入的函数简单来说就是可以被中断的函数，也就是说，可以在这个函数执行的任何时刻中断它，转入OS调度下去执行另外一段代码，而返回控制时不会出现什么错误；而不可重入的函数由于使用了一些系统资源，比如全局变量区，中断向量表等，所以它如果被中断的话，可能会出现问题，这类函数是不能运行在多任务环境下的。\n\n也可以这样理解，重入即表示重复进入，首先它意味着这个函数可以被中断，其次意味着它除了使用自己栈上的变量以外不依赖于任何环境（包括 static），这样的函数就是purecode（纯代码）可重入，可以允许有该函数的多个副本在运行，由于它们使用的是分离的栈，所以不会互相干扰。如果确实需要访问全局变量（包括 static），一定要注意实施互斥手段。可重入函数在并行运行环境中非常重要，但是一般要为访问全局变量付出一些性能代价\n\n![20230619104326](http://s3.airtlab.com/blog/20230619104326.png)\n\n![20230619104512](http://s3.airtlab.com/blog/20230619104512.png)","isLeaf":true},{"key":"/system/time-formats.md","path":"/system/time-formats.md","route":"/system/time-formats.md","leaf":true,"title":"time-formats","depth":1,"content":"这两个时间标记的区别在于它们的表示方式和时区信息。\n\n`2023-05-29 16:00:00.000Z` 是一个ISO 8601格式的时间戳，表示为 `UTC +0` 时间，并且没有指定任何时区信息。这个时间标记是基于国际标准的协调世界时 `UTC`，也被称为 `GMT（格林威治时间）`。这意味着无论哪个时区，这个时间都是相同的，因为它没有受到任何地理位置的影响。\n\n`2023-05-29T16:00:00:00+08:00` 也是一个ISO 8601格式的时间戳，但它包含了时区信息。这个时间标记中的“+08:00”表示这个时间是基于 `UTC +8` 的时区，也被称为中国标准时间 `CST`。因此，在北京等处，这个时间戳就是2023年5月29日下午4点。\n\n总之，两个时间戳都代表同一时间点，只是表示方式和时区信息不同。","isLeaf":true},{"key":"/system/website-performance","path":"/system/website-performance","route":"/system/website-performance","leaf":false,"title":"website-performance","depth":1,"content":"","isLeaf":false,"children":[{"key":"/system/website-performance/01-website-performance-test.md","path":"/system/website-performance/01-website-performance-test.md","route":"/system/website-performance/01-website-performance-test.md","leaf":true,"title":"01-website-performance-test","depth":2,"content":"一个网站除了满足业务功能，还要满足性能需求，如果性能不好，随着用户的增长将出现性能瓶颈，对用户最直接的感官影响就是响应变慢，一般2秒以内算是比较好的体验，超过5秒体验就比较差了，极端情况下用户并发高的情况下，网站直接拒绝服务，严重影响业务运营。在理论上我们如何判定一个Web应用的性能程序呢？其实已经有一套比较完整的评价体系了。\n\n## 1. 网站性能指标\n 对于网站的性能指标，重要的是 响应时间、吞吐量、并发数。\n\n- 响应时间是一次请求从发送请求到收到响应的总时间，直观的反映系统的快慢。\n- 吞吐量是单位时间处理的请求数，通常用TPS来表示，是系统容量的直观体现。\n- 并发数是系统同时能处理的请求数，对于同时在线用户数高的，短时间有大量用户使用的，譬如抢购类网站要求高，如果要让用户在短时间内都能访问到系统，需要有极高的并发能力支持。\n\n可以用高速公路收费站来类比，响应时间就是收费窗口处理**收费事件的时间，**吞吐量是**单位时间收费窗口总共收了多少辆车**，并发量就是总共**有多少个收费通道**。\n\n这几个指标之间的关系是什么呢？\n> 假如该收费站收一笔费用耗时30秒（RT=30s），共有5个窗口(p=5)，那么正常情况下1分钟该收费站能处理10个收费请求【v= (P/RT)*60s=10】，即吞吐量是10次/分钟。\n> 如果前端每隔30秒有5辆车（即每分钟有10辆车）进入高速公路，该收费站将满负荷运行，收费人员馬不停蹄，车辆没有积压。如果每分钟有20辆车进入高速公路，那么第一分钟进入收费站的20辆车将有10辆车积压等待30秒，第二分钟进入的20辆车将最多等待90秒，以此类推，积压将越来越多，高速公路上将慢慢排队成长龙，车辆通过收费站的时长将越来越长，对应的是网站收到响应时间越来越长，直到超时不可用。\n\n通过apache bench 工具ab测试网站性能指标可以看出，并发越大响应时间越长。从曲线看并发到70个响应时间就开始恶化，最大支持的并发就是70条每秒，正常响应时间是5.87毫秒，吞吐量TPS是170。此时的CPU利用率，链接数相对平稳，未达到资源的瓶颈。\n\n## 2. 响应时间(RT) \n响应时间是指系统对请求作出响应的时间。直观上看，这个指标与人对软件性能的主观感受是非常一致的，因为它完整地记录了整个计算机系统处理请求的时间。由于一个系统通常会提供许多功能，而不同功能的处理逻辑也千差万别，因而不同功能的响应时间也不尽相同，甚至同一功能在不同输入数据的情况下响应时间也不相同。所以，在讨论一个系统的响应时间时，人们通常是指该系统所有功能的平均时间或者所有功能的最大响应时间。当然，往往也需要对每个或每组功能讨论其平均响应时间和最大响应时间。 \n　\n对于单机的没有并发操作的应用系统而言，人们普遍认为响应时间是一个合理且准确的性能指标。需要指出的是，响应时间的绝对值并不能直接反映软件的性能的高低，软件性能的高低实际上取决于用户对该响应时间的接受程度。对于一个游戏软件来说，响应时间小于100毫秒应该是不错的，响应时间在1秒左右可能属于勉强可以接受，如果响应时间达到3秒就完全难以接受了。而对于编译系统来说，完整编译一个较大规模软件的源代码可能需要几十分钟甚至更长时间，但这些响应时间对于用户来说都是可以接受的。 \n\n## 2. 吞吐量(Throughput) \n吞吐量是指系统在单位时间内处理请求的数量。对于无并发的应用系统而言，吞吐量与响应时间成严格的反比关系，实际上此时吞吐量就是响应时间的倒数。前面已经说过，对于单用户的系统，响应时间（或者系统响应时间和应用延迟时间）可以很好地度量系统的性能，但对于并发系统，通常需要用吞吐量作为性能指标。 \n\n对于一个多用户的系统，如果只有一个用户使用时系统的平均响应时间是t，当有你n个用户使用时，每个用户看到的响应时间通常并不是n×t，而往往比n×t小很多（当然，在某些特殊情况下也可能比n×t大，甚至大很多）。这是因为处理每个请求需要用到很多资源，由于每个请求的处理过程中有许多不走难以并发执行，这导致在具体的一个时间点，所占资源往往并不多。也就是说在处理单个请求时，在每个时间点都可能有许多资源被闲置，当处理多个请求时，如果资源配置合理，每个用户看到的平均响应时间并不随用户数的增加而线性增加。实际上，不同系统的平均响应时间随用户数增加而增长的速度也不大相同，这也是采用吞吐量来度量并发系统的性能的主要原因。一般而言，吞吐量是一个比较通用的指标，两个具有不同用户数和用户使用模式的系统，如果其最大吞吐量基本一致，则可以判断两个系统的处理能力基本一致。 \n\n## 3. 并发用户数 \n并发用户数是指系统可以同时承载的正常使用系统功能的用户的数量。与吞吐量相比，并发用户数是一个更直观但也更笼统的性能指标。实际上，并发用户数是一个非常不准确的指标，因为用户不同的使用模式会导致不同用户在单位时间发出不同数量的请求。一网站系统为例，假设用户只有注册后才能使用，但注册用户并不是每时每刻都在使用该网站，因此具体一个时刻只有部分注册用户同时在线，在线用户就在浏览网站时会花很多时间阅读网站上的信息，因而具体一个时刻只有部分在线用户同时向系统发出请求。这样，对于网站系统我们会有三个关于用户数的统计数字：注册用户数、在线用户数和同时发请求用户数。由于注册用户可能长时间不登陆网站，使用注册用户数作为性能指标会造成很大的误差。而在线用户数和同事发请求用户数都可以作为性能指标。相比而言，以在线用户作为性能指标更直观些，而以同时发请求用户数作为性能指标更准确些。 \n\n## 4. QPS/TPS\nQPS：Queries Per Second意思是“每秒查询率”，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。\n\nTPS：是TransactionsPerSecond的缩写，也就是事务数/秒。它是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。\n\nTps即每秒处理事务数，包括了：\n1）用户请求服务器\n2）服务器自己的内部处理\n3）服务器返回给用户\n\n这三个过程，每秒能够完成N个这三个过程，Tps也就是N；\n\nQps基本类似于Tps，但是不同的是，对于一个页面的一次访问，形成一个Tps；但一次页面请求，可能产生多次对服务器的请求，服务器对这些请求，就可计入“Qps”之中。例如：访问一个页面会请求服务器3次，一次放，产生一个“T”，产生3个“Q” 。\n\n## 5. 应用实例\n在电商系统中，瓶颈通常为下单操作。这里的下单指的就是一个事物，比如要求为：TPS 300/S。\n在电商系统中，订单查询通常也比较慢，这里的订单查询速度的衡量为QPS，比如要求为：QPS 300/S。","isLeaf":true},{"key":"/system/website-performance/02-website-performance-tools.md","path":"/system/website-performance/02-website-performance-tools.md","route":"/system/website-performance/02-website-performance-tools.md","leaf":true,"title":"02-website-performance-tools","depth":2,"content":"## 1. [gtmetrix](https://gtmetrix.com/?job_error=IHk37HNt)\n官网 [https://gtmetrix.com/?job_error=IHk37HNt](https://gtmetrix.com/?job_error=IHk37HNt)\n参考 [https://www.cnblogs.com/youcong/p/9954031.html](https://www.cnblogs.com/youcong/p/9954031.html)","isLeaf":true}]}]},{"key":"/test","path":"/test","route":"/test","leaf":false,"title":"test","depth":0,"content":"","isLeaf":false,"children":[{"key":"/test/e2e.md","path":"/test/e2e.md","route":"/test/e2e.md","leaf":true,"title":"e2e","depth":1,"content":"---\ntags: 测试方法论\n---\n\nE2E（End-to-End）测试是一种软件测试方法，旨在模拟真实的用户场景，测试整个应用程序的功能和性能。它测试了整个软件系统的端到端功能，涵盖了从用户界面到后端系统的所有组件。\n\nE2E测试需要将应用程序视为一个整体，从用户的角度观察应用程序的行为。测试过程中，通过模拟用户的行为、输入和环境条件，验证整个应用程序在不同场景下的功能和性能。这种测试方法可以用来检查应用程序在不同操作系统、浏览器和设备上的交互和兼容性。\n\nE2E测试的优点是可以发现整个应用程序以及其组件之间的集成问题和潜在的错误。它还可以验证应用程序是否符合用户需求和预期功能，以确保用户获得无缝的用户体验。\n\n一些常用的E2E测试工具包括Selenium、Cypress、Appium等，它们提供了一些功能和API，用于自动化模拟用户操作并验证应用程序的行为。","isLeaf":true},{"key":"/test/jest.md","path":"/test/jest.md","route":"/test/jest.md","leaf":true,"title":"jest","depth":1,"content":"---\ntags: 测试方法论\n---\n\n在 JavaScript 中，Jest 是一个流行的测试框架，用于编写和运行单元测试和集成测试。Jest 提供了一种方便的方式来编写、运行和报告测试结果。\n`jest --coverage`命令用于生成代码覆盖率报告。代码覆盖率是衡量测试代码对应用程序代码的覆盖程度的指标。它告诉您测试案例是否足够全面，以验证应用程序的各个部分。\n\n当您在运行`jest`命令时添加`--coverage`选项，Jest将执行测试案例并收集有关每个测试文件中每个函数、分支和语句的覆盖信息。它会生成一个代码覆盖率报告，其中包含以下内容：\n- 行覆盖率：每个文件中执行的测试行数与总行数的比例。\n- 分支覆盖率：每个条件/分支中执行的测试比例。\n- 函数覆盖率：每个函数中执行的测试比例。\n- 语句覆盖率：每个语句中执行的测试比例。\n\n覆盖率报告可以帮助您确定测试的质量和完整性。通过查看哪些部分缺乏足够的测试，您可以增加测试案例以提高代码覆盖率。此外，您还可以使用覆盖率报告来检查不常用的代码分支和功能，以确保它们也得到了适当的测试覆盖。\n\n## 可视化生成\n\n覆盖率可视化报告 = 据原代码 + coverage data\n![20230706115121](http://s3.airtlab.com/blog/20230706115121.png)\n\n## 参考\n\n- [Jest | 测试框架实战之-coverage命令实现原理](https://juejin.cn/post/7035139783911276551)\n- [Nest的test中的best是Jest框架](https://justin3go.com/%E5%8D%9A%E5%AE%A2/2023/05/01Nest%E7%9A%84test%E4%B8%AD%E7%9A%84best%E6%98%AFJest%E6%A1%86%E6%9E%B6.html#jest%E7%BC%96%E5%86%99%E5%8D%95%E6%B5%8B%E7%94%A8%E4%BE%8B)\n\n\n```js\n\"use strict\";\n\n/* istanbul ignore next */\nfunction cov_1i38u7idc3() {\n  var path = \"/Users/xiong.gao/code/learn-books/demos/nyc-demo/nyc-nestjs/src/app.service.ts\";\n  var hash = \"25afe50c22c12ffc15e6f7fe8099588dd5984899\";\n  var global = new Function(\"return this\")();\n  var gcv = \"__coverage__\";\n  var coverageData = {\n    path: \"/Users/xiong.gao/code/learn-books/demos/nyc-demo/nyc-nestjs/src/app.service.ts\",\n    statementMap: {\n      \"0\": {\n        start: {\n          line: 2,\n          column: 17\n        },\n        end: {\n          line: 7,\n          column: 1\n        }\n      },\n      \"1\": {\n        start: {\n          line: 3,\n          column: 12\n        },\n        end: {\n          line: 3,\n          column: 28\n        }\n      },\n      \"2\": {\n        start: {\n          line: 3,\n          column: 34\n        },\n        end: {\n          line: 3,\n          column: 125\n        }\n      },\n      \"3\": {\n        start: {\n          line: 4,\n          column: 4\n        },\n        end: {\n          line: 5,\n          column: 150\n        }\n      },\n      \"4\": {\n        start: {\n          line: 4,\n          column: 79\n        },\n        end: {\n          line: 4,\n          column: 131\n        }\n      },\n      \"5\": {\n        start: {\n          line: 5,\n          column: 9\n        },\n        end: {\n          line: 5,\n          column: 150\n        }\n      },\n      \"6\": {\n        start: {\n          line: 5,\n          column: 22\n        },\n        end: {\n          line: 5,\n          column: 43\n        }\n      },\n      \"7\": {\n        start: {\n          line: 5,\n          column: 58\n        },\n        end: {\n          line: 5,\n          column: 150\n        }\n      },\n      \"8\": {\n        start: {\n          line: 5,\n          column: 81\n        },\n        end: {\n          line: 5,\n          column: 150\n        }\n      },\n      \"9\": {\n        start: {\n          line: 6,\n          column: 4\n        },\n        end: {\n          line: 6,\n          column: 66\n        }\n      },\n      \"10\": {\n        start: {\n          line: 8,\n          column: 0\n        },\n        end: {\n          line: 8,\n          column: 62\n        }\n      },\n      \"11\": {\n        start: {\n          line: 9,\n          column: 0\n        },\n        end: {\n          line: 9,\n          column: 28\n        }\n      },\n      \"12\": {\n        start: {\n          line: 10,\n          column: 17\n        },\n        end: {\n          line: 10,\n          column: 42\n        }\n      },\n      \"13\": {\n        start: {\n          line: 11,\n          column: 17\n        },\n        end: {\n          line: 15,\n          column: 1\n        }\n      },\n      \"14\": {\n        start: {\n          line: 13,\n          column: 8\n        },\n        end: {\n          line: 13,\n          column: 30\n        }\n      },\n      \"15\": {\n        start: {\n          line: 16,\n          column: 0\n        },\n        end: {\n          line: 18,\n          column: 15\n        }\n      },\n      \"16\": {\n        start: {\n          line: 19,\n          column: 0\n        },\n        end: {\n          line: 19,\n          column: 32\n        }\n      }\n    },\n    fnMap: {\n      \"0\": {\n        name: \"(anonymous_0)\",\n        decl: {\n          start: {\n            line: 2,\n            column: 46\n          },\n          end: {\n            line: 2,\n            column: 47\n          }\n        },\n        loc: {\n          start: {\n            line: 2,\n            column: 87\n          },\n          end: {\n            line: 7,\n            column: 1\n          }\n        },\n        line: 2\n      },\n      \"1\": {\n        name: \"(anonymous_1)\",\n        decl: {\n          start: {\n            line: 12,\n            column: 4\n          },\n          end: {\n            line: 12,\n            column: 5\n          }\n        },\n        loc: {\n          start: {\n            line: 12,\n            column: 15\n          },\n          end: {\n            line: 14,\n            column: 5\n          }\n        },\n        line: 12\n      }\n    },\n    branchMap: {\n      \"0\": {\n        loc: {\n          start: {\n            line: 2,\n            column: 17\n          },\n          end: {\n            line: 7,\n            column: 1\n          }\n        },\n        type: \"binary-expr\",\n        locations: [{\n          start: {\n            line: 2,\n            column: 18\n          },\n          end: {\n            line: 2,\n            column: 22\n          }\n        }, {\n          start: {\n            line: 2,\n            column: 26\n          },\n          end: {\n            line: 2,\n            column: 41\n          }\n        }, {\n          start: {\n            line: 2,\n            column: 46\n          },\n          end: {\n            line: 7,\n            column: 1\n          }\n        }],\n        line: 2\n      },\n      \"1\": {\n        loc: {\n          start: {\n            line: 3,\n            column: 34\n          },\n          end: {\n            line: 3,\n            column: 125\n          }\n        },\n        type: \"cond-expr\",\n        locations: [{\n          start: {\n            line: 3,\n            column: 42\n          },\n          end: {\n            line: 3,\n            column: 48\n          }\n        }, {\n          start: {\n            line: 3,\n            column: 51\n          },\n          end: {\n            line: 3,\n            column: 125\n          }\n        }],\n        line: 3\n      },\n      \"2\": {\n        loc: {\n          start: {\n            line: 3,\n            column: 51\n          },\n          end: {\n            line: 3,\n            column: 125\n          }\n        },\n        type: \"cond-expr\",\n        locations: [{\n          start: {\n            line: 3,\n            column: 67\n          },\n          end: {\n            line: 3,\n            column: 118\n          }\n        }, {\n          start: {\n            line: 3,\n            column: 121\n          },\n          end: {\n            line: 3,\n            column: 125\n          }\n        }],\n        line: 3\n      },\n      \"3\": {\n        loc: {\n          start: {\n            line: 4,\n            column: 4\n          },\n          end: {\n            line: 5,\n            column: 150\n          }\n        },\n        type: \"if\",\n        locations: [{\n          start: {\n            line: 4,\n            column: 4\n          },\n          end: {\n            line: 5,\n            column: 150\n          }\n        }, {\n          start: {\n            line: 5,\n            column: 9\n          },\n          end: {\n            line: 5,\n            column: 150\n          }\n        }],\n        line: 4\n      },\n      \"4\": {\n        loc: {\n          start: {\n            line: 4,\n            column: 8\n          },\n          end: {\n            line: 4,\n            column: 77\n          }\n        },\n        type: \"binary-expr\",\n        locations: [{\n          start: {\n            line: 4,\n            column: 8\n          },\n          end: {\n            line: 4,\n            column: 35\n          }\n        }, {\n          start: {\n            line: 4,\n            column: 39\n          },\n          end: {\n            line: 4,\n            column: 77\n          }\n        }],\n        line: 4\n      },\n      \"5\": {\n        loc: {\n          start: {\n            line: 5,\n            column: 58\n          },\n          end: {\n            line: 5,\n            column: 150\n          }\n        },\n        type: \"if\",\n        locations: [{\n          start: {\n            line: 5,\n            column: 58\n          },\n          end: {\n            line: 5,\n            column: 150\n          }\n        }, {\n          start: {\n            line: undefined,\n            column: undefined\n          },\n          end: {\n            line: undefined,\n            column: undefined\n          }\n        }],\n        line: 5\n      },\n      \"6\": {\n        loc: {\n          start: {\n            line: 5,\n            column: 85\n          },\n          end: {\n            line: 5,\n            column: 149\n          }\n        },\n        type: \"binary-expr\",\n        locations: [{\n          start: {\n            line: 5,\n            column: 86\n          },\n          end: {\n            line: 5,\n            column: 143\n          }\n        }, {\n          start: {\n            line: 5,\n            column: 148\n          },\n          end: {\n            line: 5,\n            column: 149\n          }\n        }],\n        line: 5\n      },\n      \"7\": {\n        loc: {\n          start: {\n            line: 5,\n            column: 86\n          },\n          end: {\n            line: 5,\n            column: 143\n          }\n        },\n        type: \"cond-expr\",\n        locations: [{\n          start: {\n            line: 5,\n            column: 94\n          },\n          end: {\n            line: 5,\n            column: 98\n          }\n        }, {\n          start: {\n            line: 5,\n            column: 101\n          },\n          end: {\n            line: 5,\n            column: 143\n          }\n        }],\n        line: 5\n      },\n      \"8\": {\n        loc: {\n          start: {\n            line: 5,\n            column: 101\n          },\n          end: {\n            line: 5,\n            column: 143\n          }\n        },\n        type: \"cond-expr\",\n        locations: [{\n          start: {\n            line: 5,\n            column: 109\n          },\n          end: {\n            line: 5,\n            column: 126\n          }\n        }, {\n          start: {\n            line: 5,\n            column: 129\n          },\n          end: {\n            line: 5,\n            column: 143\n          }\n        }],\n        line: 5\n      },\n      \"9\": {\n        loc: {\n          start: {\n            line: 6,\n            column: 11\n          },\n          end: {\n            line: 6,\n            column: 62\n          }\n        },\n        type: \"binary-expr\",\n        locations: [{\n          start: {\n            line: 6,\n            column: 11\n          },\n          end: {\n            line: 6,\n            column: 16\n          }\n        }, {\n          start: {\n            line: 6,\n            column: 20\n          },\n          end: {\n            line: 6,\n            column: 21\n          }\n        }, {\n          start: {\n            line: 6,\n            column: 25\n          },\n          end: {\n            line: 6,\n            column: 62\n          }\n        }],\n        line: 6\n      }\n    },\n    s: {\n      \"0\": 0,\n      \"1\": 0,\n      \"2\": 0,\n      \"3\": 0,\n      \"4\": 0,\n      \"5\": 0,\n      \"6\": 0,\n      \"7\": 0,\n      \"8\": 0,\n      \"9\": 0,\n      \"10\": 0,\n      \"11\": 0,\n      \"12\": 0,\n      \"13\": 0,\n      \"14\": 0,\n      \"15\": 0,\n      \"16\": 0\n    },\n    f: {\n      \"0\": 0,\n      \"1\": 0\n    },\n    b: {\n      \"0\": [0, 0, 0],\n      \"1\": [0, 0],\n      \"2\": [0, 0],\n      \"3\": [0, 0],\n      \"4\": [0, 0],\n      \"5\": [0, 0],\n      \"6\": [0, 0],\n      \"7\": [0, 0],\n      \"8\": [0, 0],\n      \"9\": [0, 0, 0]\n    },\n    inputSourceMap: {\n      file: \"/Users/xiong.gao/code/learn-books/demos/nyc-demo/nyc-nestjs/src/app.service.ts\",\n      mappings: \";;;;;;;;;AAAA,2CAA4C;AAGrC,IAAM,UAAU,GAAhB,MAAM,UAAU;IACrB,QAAQ;QACN,OAAO,cAAc,CAAC;IACxB,CAAC;CACF,CAAA;AAJY,UAAU;IADtB,IAAA,mBAAU,GAAE;GACA,UAAU,CAItB;AAJY,gCAAU\",\n      names: [],\n      sources: [\"/Users/xiong.gao/code/learn-books/demos/nyc-demo/nyc-nestjs/src/app.service.ts\"],\n      sourcesContent: [\"import { Injectable } from '@nestjs/common';\\n\\n@Injectable()\\nexport class AppService {\\n  getHello() {\\n    return 'Hello World!';\\n  }\\n}\\n\"],\n      version: 3\n    },\n    _coverageSchema: \"1a1c01bbd47fc00a2c39e90264f33305004495a9\",\n    hash: \"25afe50c22c12ffc15e6f7fe8099588dd5984899\"\n  };\n  var coverage = global[gcv] || (global[gcv] = {});\n  if (!coverage[path] || coverage[path].hash !== hash) {\n    coverage[path] = coverageData;\n  }\n  var actualCoverage = coverage[path];\n  {\n    // @ts-ignore\n    cov_1i38u7idc3 = function () {\n      return actualCoverage;\n    };\n  }\n  return actualCoverage;\n}\ncov_1i38u7idc3();\nvar __decorate =\n/* istanbul ignore next */\n(cov_1i38u7idc3().s[0]++,\n/* istanbul ignore next */\n(cov_1i38u7idc3().b[0][0]++, this) &&\n/* istanbul ignore next */\n(cov_1i38u7idc3().b[0][1]++, this.__decorate) ||\n/* istanbul ignore next */\n(cov_1i38u7idc3().b[0][2]++, function (decorators, target, key, desc) {\n  /* istanbul ignore next */\n  cov_1i38u7idc3().f[0]++;\n  var c =\n    /* istanbul ignore next */\n    (cov_1i38u7idc3().s[1]++, arguments.length),\n    r =\n    /* istanbul ignore next */\n    (cov_1i38u7idc3().s[2]++, c < 3 ?\n    /* istanbul ignore next */\n    (cov_1i38u7idc3().b[1][0]++, target) :\n    /* istanbul ignore next */\n    (cov_1i38u7idc3().b[1][1]++, desc === null ?\n    /* istanbul ignore next */\n    (cov_1i38u7idc3().b[2][0]++, desc = Object.getOwnPropertyDescriptor(target, key)) :\n    /* istanbul ignore next */\n    (cov_1i38u7idc3().b[2][1]++, desc))),\n    d;\n  /* istanbul ignore next */\n  cov_1i38u7idc3().s[3]++;\n  if (\n  /* istanbul ignore next */\n  (cov_1i38u7idc3().b[4][0]++, typeof Reflect === \"object\") &&\n  /* istanbul ignore next */\n  (cov_1i38u7idc3().b[4][1]++, typeof Reflect.decorate === \"function\")) {\n    /* istanbul ignore next */\n    cov_1i38u7idc3().b[3][0]++;\n    cov_1i38u7idc3().s[4]++;\n    r = Reflect.decorate(decorators, target, key, desc);\n  } else {\n    /* istanbul ignore next */\n    cov_1i38u7idc3().b[3][1]++;\n    cov_1i38u7idc3().s[5]++;\n    for (var i =\n    /* istanbul ignore next */\n    (cov_1i38u7idc3().s[6]++, decorators.length - 1); i >= 0; i--) {\n      /* istanbul ignore next */\n      cov_1i38u7idc3().s[7]++;\n      if (d = decorators[i]) {\n        /* istanbul ignore next */\n        cov_1i38u7idc3().b[5][0]++;\n        cov_1i38u7idc3().s[8]++;\n        r =\n        /* istanbul ignore next */\n        (cov_1i38u7idc3().b[6][0]++, c < 3 ?\n        /* istanbul ignore next */\n        (cov_1i38u7idc3().b[7][0]++, d(r)) :\n        /* istanbul ignore next */\n        (cov_1i38u7idc3().b[7][1]++, c > 3 ?\n        /* istanbul ignore next */\n        (cov_1i38u7idc3().b[8][0]++, d(target, key, r)) :\n        /* istanbul ignore next */\n        (cov_1i38u7idc3().b[8][1]++, d(target, key)))) ||\n        /* istanbul ignore next */\n        (cov_1i38u7idc3().b[6][1]++, r);\n      } else\n      /* istanbul ignore next */\n      {\n        cov_1i38u7idc3().b[5][1]++;\n      }\n    }\n  }\n  /* istanbul ignore next */\n  cov_1i38u7idc3().s[9]++;\n  return (\n    /* istanbul ignore next */\n    (cov_1i38u7idc3().b[9][0]++, c > 3) &&\n    /* istanbul ignore next */\n    (cov_1i38u7idc3().b[9][1]++, r) &&\n    /* istanbul ignore next */\n    (cov_1i38u7idc3().b[9][2]++, Object.defineProperty(target, key, r)), r\n  );\n}));\n/* istanbul ignore next */\ncov_1i38u7idc3().s[10]++;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/* istanbul ignore next */\ncov_1i38u7idc3().s[11]++;\nexports.AppService = void 0;\nconst common_1 =\n/* istanbul ignore next */\n(cov_1i38u7idc3().s[12]++, require(\"@nestjs/common\"));\n/* istanbul ignore next */\ncov_1i38u7idc3().s[13]++;\nlet AppService = class AppService {\n  getHello() {\n    /* istanbul ignore next */\n    cov_1i38u7idc3().f[1]++;\n    cov_1i38u7idc3().s[14]++;\n    return 'Hello World!';\n  }\n};\n/* istanbul ignore next */\ncov_1i38u7idc3().s[15]++;\nAppService = __decorate([(0, common_1.Injectable)()], AppService);\n/* istanbul ignore next */\ncov_1i38u7idc3().s[16]++;\nexports.AppService = AppService;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJjb3ZfMWkzOHU3aWRjMyIsImFjdHVhbENvdmVyYWdlIiwiY29tbW9uXzEiLCJzIiwicmVxdWlyZSIsIkFwcFNlcnZpY2UiLCJnZXRIZWxsbyIsImYiLCJfX2RlY29yYXRlIiwiSW5qZWN0YWJsZSIsImV4cG9ydHMiXSwic291cmNlcyI6WyIvVXNlcnMveGlvbmcuZ2FvL2NvZGUvbGVhcm4tYm9va3MvZGVtb3MvbnljLWRlbW8vbnljLW5lc3Rqcy9zcmMvYXBwLnNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0BuZXN0anMvY29tbW9uJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEFwcFNlcnZpY2Uge1xuICBnZXRIZWxsbygpIHtcbiAgICByZXR1cm4gJ0hlbGxvIFdvcmxkISc7XG4gIH1cbn1cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQUd1QjtJQUFBQSxjQUFBLFlBQUFBLENBQUE7TUFBQSxPQUFBQyxjQUFBO0lBQUE7RUFBQTtFQUFBLE9BQUFBLGNBQUE7QUFBQTtBQUFBRCxjQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFIdkIsTUFBQUUsUUFBQTtBQUFBO0FBQUEsQ0FBQUYsY0FBQSxHQUFBRyxDQUFBLFFBQUFDLE9BQUE7QUFBNEM7QUFBQUosY0FBQSxHQUFBRyxDQUFBO0FBR3JDLElBQU1FLFVBQVUsR0FBaEIsTUFBTUEsVUFBVTtFQUNyQkMsUUFBUUEsQ0FBQTtJQUFBO0lBQUFOLGNBQUEsR0FBQU8sQ0FBQTtJQUFBUCxjQUFBLEdBQUFHLENBQUE7SUFDTixPQUFPLGNBQWM7RUFDdkI7Q0FDRDtBQUFBO0FBQUFILGNBQUEsR0FBQUcsQ0FBQTtBQUpZRSxVQUFVLEdBQUFHLFVBQUEsRUFEdEIsSUFBQU4sUUFBQSxDQUFBTyxVQUFVLEdBQUUsQyxFQUNBSixVQUFVLENBSXRCO0FBQUE7QUFBQUwsY0FBQSxHQUFBRyxDQUFBO0FBSllPLE9BQUEsQ0FBQUwsVUFBQSxHQUFBQSxVQUFBIn0=\n```","isLeaf":true}]},{"key":"/thinking","path":"/thinking","route":"/thinking","leaf":false,"title":"thinking","depth":0,"content":"","isLeaf":false,"children":[{"key":"/thinking/01-language.md","path":"/thinking/01-language.md","route":"/thinking/01-language.md","leaf":true,"title":"01-language","depth":1,"content":"---\ntitle: 01 编程语言思考\n---\n","isLeaf":true},{"key":"/thinking/02-bad-react-code.md","path":"/thinking/02-bad-react-code.md","route":"/thinking/02-bad-react-code.md","leaf":true,"title":"02-bad-react-code","depth":1,"content":"---\ntitle: 02 这个 React 代码没法看\n---\n\n最近在帮另外一个小组的同事做一个技术项目，他原本的主要工作偏向后台开发，第一次写 React 代码，当我接手这个项目傻眼了。\n\n首先这个项目本身并不简单，他还是很厉害的，但是代码写的实在是难以理解。特别是层级很深的 prop 传递 (很多 6/7 层)，以及很多匿名的组件，导致当我想找到页面上某个视图所对应的文件时，根本无从下手啊，也可能有其他我不知道的姿势，如果你知道，麻烦告诉我 😂。\n\n虽然无副作用的函数，从架构设计上来讲是最优的，但是在 UI 开发领域，当组件深度太大时，代码不容易理解，心智负担大。\n\n我想到办法可以将页面抽象为一个树，我可以查看树上的任意一个节点的依赖 和 被依赖，具体有几个点：\n\n- (1) 从入口分析代码，解析出一个树 或者 多个树，和 webpack 的依赖树差不多\n- (2) 在开发模式下，当我的鼠标悬浮在页面某个节点时，会在侧边提示器代码所在文件\n\n举个例子：\n\n```tsx\nconst Box = (\n  <div>\n    <div>hello world</div>\n    <div>hello world</div>\n  </div>\n);\n```\n\n=>\n\n```tsx\nconst Box = (\n  <div data-file=\"src/components/Box.tsx\">\n    <div>hello world</div>\n    <div>hello world</div>\n  </div>\n);\n\n// 或者\nconst Box = (\n  <div data-file=\"src/components/Box.tsx\">\n    <div data-file=\"src/components/Box.tsx\">hello world</div>\n    <div data-file=\"src/components/Box.tsx\">hello world</div>\n  </div>\n);\n```\n\n在每个组件的根标签 或者 所有标签加一个 data-code 属性\n\n![20230511222239](http://s3.airtlab.com/blog/20230511222239.png)\n\n插件代码非常简单：\n\n```js\nconst types = require(\"@babel/types\");\n\nmodule.exports = function () {\n  return {\n    visitor: {\n      JSXOpeningElement(path) {\n        const t = types;\n        const _this = this;\n\n        if (\n          !path.parent.openingElement.name ||\n          ![\"div\", \"span\", \"p\", \"ul\", \"li\"].includes(\n            path.parent.openingElement.name.name\n          )\n        ) {\n          return;\n        }\n\n        const existingProp = path.node.attributes.find(\n          (node) => node.name && node.name.name === \"data-code\"\n        );\n\n        if (existingProp) {\n          existingProp.node.value.value === \"data-code\";\n          return;\n        }\n\n        const newProp = t.jSXAttribute(\n          t.jSXIdentifier(\"data-code\"),\n          t.stringLiteral(_this.filename)\n        );\n\n        path.node.attributes.push(newProp);\n      },\n    },\n  };\n};\n```\n","isLeaf":true},{"key":"/thinking/03-swagger-json-to-axios.md","path":"/thinking/03-swagger-json-to-axios.md","route":"/thinking/03-swagger-json-to-axios.md","leaf":true,"title":"03-swagger-json-to-axios","depth":1,"content":"作为一个全栈开发者，日常的API开发中，针对 DTO 层，nodejs 中要写一遍，React 项目中也要写一遍，其实可以根据 swagger json schema 生成前端所需要的接口，可以按照接口标签划分文件。\n\n![20230516170511](http://s3.airtlab.com/blog/20230516170511.png)\n\n写了这个 npm cli 工具 https://github.com/wiiai/swagger-doc-to-axios 极大的提升开发效率。","isLeaf":true},{"key":"/thinking/04-dependency-tree-in-react.md","path":"/thinking/04-dependency-tree-in-react.md","route":"/thinking/04-dependency-tree-in-react.md","leaf":true,"title":"04-dependency-tree-in-react","depth":1,"content":"---\ntitle: 04 React 项目依赖分析树\n---\n\n在复杂的项目开发中，一个组件可能被很多个组件所引用，没有办法直观的查看其依赖关系图，这个图是很有价值的，比如在代码 review 时可以作为参考资料。\n\n有两种视角来分析问题：\n- 1）查看某个文件自顶向下的依赖关系\n- 2）查看某个文件自底向上的依赖关系\n\n在日常开发中，可以结合 git 变更，进行更小范围的筛选。\n\n## 1、自顶向下\n\n![20230627165028](http://s3.airtlab.com/blog/20230627165028.png)\n\n## 2、自底向上\n","isLeaf":true},{"key":"/thinking/05-add-number-for-article-heading.md","path":"/thinking/05-add-number-for-article-heading.md","route":"/thinking/05-add-number-for-article-heading.md","leaf":true,"title":"05-add-number-for-article-heading","depth":1,"content":"在一篇文章中，有很多 h1、h2、h3、h4、h5、h6 标题，而且我们喜欢给这些标题加上数字索引，比如：\n\n```text\n1、nodejs\n  1.1 基础用法\n  1.2 高级用法\n2、babel\n  1.1 基础用法\n  1.2 高级用法\n```\n\n手动加的话，容易出错，而且当进行插入操作的话，需要修改的地方比较多，因此可以写一个 `format` 方法，给他自动加上，封装为 vscode 插件，以方便在 vscode 中写作。","isLeaf":true}]},{"key":"/third","path":"/third","route":"/third","leaf":false,"title":"third","depth":0,"content":"","isLeaf":false,"children":[{"key":"/third/wexin.md","path":"/third/wexin.md","route":"/third/wexin.md","leaf":true,"title":"wexin","depth":1,"content":"## 1、微信 cgi-bin 和sns目录下的接口什么区别啊？\n\nhttps://developers.weixin.qq.com/community/develop/doc/483552123f44973079500c2e6d09a18e\n\n## 2、`https://api.weixin.qq.com/sns/userinfo` 和 `https://api.weixin.qq.com/cgi-bin/user/info` 的区别\n\n这两个微信的API有一些区别，以下是它们的主要区别：\n1. 接口功能：https://api.weixin.qq.com/sns/userinfo 是微信开发者平台的API，主要用于获取用户的基本信息和授权后的用户信息。https://api.weixin.qq.com/cgi-bin/user/info 是微信公众平台的API，主要用于获取公众号用户的信息。\n\n2. 接口地址：https://api.weixin.qq.com/sns/userinfo 的路径中包含了\"sns\"，表示该接口主要用于处理基于OAuth2.0的用户授权流程。https://api.weixin.qq.com/cgi-bin/user/info 的路径中没有\"sns\"，表示该接口主要用于公众号用户信息的获取。\n\n3. 接口调用方式：https://api.weixin.qq.com/sns/userinfo 需要通过OAuth2.0的用户授权流程获得用户的access_token，然后再通过该接口获取用户信息。https://api.weixin.qq.com/cgi-bin/user/info 则需要使用公众号的access_token直接调用该接口获取用户信息。\n\n4. 返回的数据：https://api.weixin.qq.com/sns/userinfo 返回的是JSON格式的数据，包含用户的基本信息和授权后的用户信息。https://api.weixin.qq.com/cgi-bin/user/info 返回的也是JSON格式的数据，包含公众号用户的信息。\n\n总结来说，https://api.weixin.qq.com/sns/userinfo 主要用于处理用户授权流程，获取用户基本信息和授权信息；https://api.weixin.qq.com/cgi-bin/user/info 主要用于公众号用户信息的获取。","isLeaf":true}]},{"key":"/tools","path":"/tools","route":"/tools","leaf":false,"title":"tools","depth":0,"content":"","isLeaf":false,"children":[{"key":"/tools/01-build-docs.md","path":"/tools/01-build-docs.md","route":"/tools/01-build-docs.md","leaf":true,"title":"01-build-docs","depth":1,"content":"---\ntitle: 01 技术文档搭建\ntags: tools\ndate: 2022-06-10 00:00:00\n---\n\n## 1、Nextra\n\nNextra 是一个便捷的静态网站生成工具，他底层依赖 `nextjs`。\n\n- nextra 有两种风格 博客风格 和 文档风格，更适合用作文档，可以自己搭建，也可以拉模板进行修改。\n- nextra 官方文档也是用 nextra 搭建的，可以作为一个参考\n- 文档代码仓库 https://github.com/shuding/nextra\n- 文档展示地址 https://nextra.site\n\n**文档风格**\n\n![20230630100840](http://s3.airtlab.com/blog/20230630100840.png)\n\n## 2、VitePress\n\nVitePress 是一个由 Vue.js 驱动的静态网站生成器。\n\n- 它专注于为`技术文档`、`博客`和其他类似内容生成静态网站。\n- VitePress 具有快速的开发速度和热模块重加载功能，可以实时预览和调试网站\n- 支持 Markdown 格式的文档编写。\n- 适用于构建以文档为主的网站，并提供了便捷的工具，例如自动生成的导航栏、侧边栏和搜索功能等。\n- 案例1 https://sunniejs.github.io/vue-h5-template/guide/\n\n## 3、hugo\n\nHugo 是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。\n\n这个主题比较漂亮 https://github.com/WingLim/hugo-tania 🤌 https://hugo-tania.netlify.app/\n\n参考 https://blog.chungzh.cn\n\n### 安装 \n\n```shell\nbrew install hugo\n```\n\n### 初始化\n\n```shell\nhugo new site quickstart\ncd quickstart\ngit init\ngit submodule add -b stable https://github.com/jpanther/congo.git themes/congo #下载congo主题到网站\necho \"theme = 'congo'\" >> hugo.toml #将\"\"内的文本内容添加到hugo.toml文件末尾。\nhugo server #创建静态文件并运行本地网站服务器\n```","isLeaf":true},{"key":"/tools/02-wireshark.md","path":"/tools/02-wireshark.md","route":"/tools/02-wireshark.md","leaf":true,"title":"02-wireshark","depth":1,"content":"---\ntitle: 02 wireshark 抓包\ntags: tools\ndate: 2022-06-10 00:00:00\n---\n\n**参考资料**\n\n- https://zhuanlan.zhihu.com/p/82498482\n\n## 1、过滤规则\n### 1）IP 过滤\n- ip.src == 192.168.1.104 显示源地址为192.168.1.104的数据包列表\n- ip.dst == 192.168.1.104, 显示目标地址为192.168.1.104的数据包列表\n- ip.addr == 192.168.1.104 显示源IP地址或目标IP地址为 192.168.1.104 的数据包列表\n\n### 2）HTTP 模式过滤\nhttp.request.method==\"GET\", 只显示HTTP GET方法的。\n\n### 3）协议过滤\n```\nicmp\ntelnet\ntcp\ntcp.ack\n```\n\n### 4) 逻辑运算符为 and/or/not\n过滤多个条件组合时，使用and/or。比如获取IP地址为192.168.1.104的ICMP数据包表达式为ip.addr == 192.168.1.104 and icmp\n\n## 2、TCP 握手过程\n### 1）TCP 报文协议\n![20230506180734](http://s3.airtlab.com/blog/20230506180734.png)\n\n### 2）TCP 抓包演示\n```\ncurl 'http://blog.airtlab.com/' \\\n  -H 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7' \\\n  -H 'Accept-Language: zh-CN,zh;q=0.9' \\\n  -H 'Cache-Control: max-age=0' \\\n  -H 'Connection: keep-alive' \\\n  -H 'If-Modified-Since: Thu, 15 Apr 2021 02:08:45 GMT' \\\n  -H 'Upgrade-Insecure-Requests: 1' \\\n  -H 'User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.3 Mobile/15E148 Safari/604.1' \\\n  --compressed \\\n  --insecure\n```\n\n![20230506180754](http://s3.airtlab.com/blog/20230506180754.png)\n\n前三次通讯即为握手过程\n\n```js\n// 16 进制转换 => 57346\nparseInt(0xe002, 10)\n```\n\n## 3、标记数据包","isLeaf":true},{"key":"/tools/03-sqlite-browser.md","path":"/tools/03-sqlite-browser.md","route":"/tools/03-sqlite-browser.md","leaf":true,"title":"03-sqlite-browser","depth":1,"content":"---\ntitle: 03 sqllite 数据预览工具\ntags: tools\ndate: 2022-06-10 00:00:00\n--- \n\n- 官网 https://sqlitebrowser.org/\n- 下载 https://sqlitebrowser.org/dl/","isLeaf":true},{"key":"/tools/04-ngrok.md","path":"/tools/04-ngrok.md","route":"/tools/04-ngrok.md","leaf":true,"title":"04-ngrok","depth":1,"content":"---\ntitle: 04 内网穿透 ngrok\ntags: tools\ndate: 2022-06-10 00:00:00\n---\n\nhttps://dashboard.ngrok.com/get-started/setup","isLeaf":true},{"key":"/tools/05-whistle.md","path":"/tools/05-whistle.md","route":"/tools/05-whistle.md","leaf":true,"title":"05-whistle","depth":1,"content":"---\ntitle: 05 whistle 教程\ntags: tools\ndate: 2022-06-10 00:00:00\n---\n\n### 1、使用本地资源替换\n```javascript\nwww.gaollard.com file:///Users/gaollard/code/whistle/index.html\n```\n\n### 2、请求转发，将指定域名请求转发到另一个域名\n```javascript\nwww.qq.com ke.qq.com # 指定域名转发生效\n**.qq.com ke.qq.com  # 所有qq.com子域名转发生效\n```\n\n### 3、脚本注入\n将一段脚本（可以使html、js、CSS片段）注入到dom页面中进行调试\n```javascript\n// mac\nrenwu.airtlab.com css:///Users/gaollard/code/whistle/index.css\nrenwu.airtlab.com js:///Users/gaollard/code/whistle/test.js\n```\n\n### 4、请求改写与接口mock\n```javascript\n# 会把内容 append 到请求后面\nhttp://www.text.com/style.css resAppend://{append.css}\n\n# 完全替换请求内容\nrenwu.airtlab.com/api/demand-category resBody://{mock_cate}\n```\n\n### 5、学习资料\n- IMBweb whistle工具全程入门 https://www.imweb.io/topic/596480af33d7f9a94951744c\n- 官方配置文档 http://wproxy.org/whistle/\n- whistle 实用小技巧 https://baijiahao.baidu.com/s?id=1694050105421549643&wfr=spider&for=pc","isLeaf":true},{"key":"/tools/06-typeorm-entity-gen.md","path":"/tools/06-typeorm-entity-gen.md","route":"/tools/06-typeorm-entity-gen.md","leaf":true,"title":"06-typeorm-entity-gen","depth":1,"content":"---\ntitle: 06 typeorm entity 自动生成\ntags: tools\ndate: 2022-06-10 00:00:00\n---\n\n原理：查询数据库表 schema，自动生成对应的 typeorm entity 文件\n\n- typeorm-model-generator https://github.com/Kononnable/typeorm-model-generator\n- typeorm 应该被放弃 https://github.com/Kononnable/typeorm-model-generator/issues/329\n- 如何使用 typeorm-model-generator https://blog.csdn.net/kuangshp128/article/details/98062662\n\n```shell\nrm -rf entities & npx typeorm-model-generator -h hostname -d g_mall -p 3306 -u user -x password -e mysql -o entities --noConfig true\n```","isLeaf":true},{"key":"/tools/07-ddl-to-json.md","path":"/tools/07-ddl-to-json.md","route":"/tools/07-ddl-to-json.md","leaf":true,"title":"07-ddl-to-json","depth":1,"content":"---\ntitle: 07 DDL转JSON\ntags: tools\ndate: 2022-06-10 00:00:00\n---\n\nhttps://github.com/duartealexf/sql-ddl-to-json-schema 这个库可以根据 ddl 生成 JSON Schema，它不仅仅能够识别 `CREATE TABLE` 语句，对 `ALTER` 等修改也能识别。","isLeaf":true},{"key":"/tools/08-ppt-in-code.md","path":"/tools/08-ppt-in-code.md","route":"/tools/08-ppt-in-code.md","leaf":true,"title":"08-ppt-in-code","depth":1,"content":"---\ntitle: 08 使用代码写 PPT\ntags: tools\ndate: 2022-06-10 00:00:00\n---\n\n## 1、使用 reveal.js\n\n使用 html 写动效丰富的 PPT https://revealjs.com/\n\n## 2、使用 PptxGenJS\n\nhttps://gitbrent.github.io/PptxGenJS/","isLeaf":true},{"key":"/tools/09-vscode.md","path":"/tools/09-vscode.md","route":"/tools/09-vscode.md","leaf":true,"title":"09-vscode","depth":1,"content":"---\ntags: tools\ndate: 2022-06-10 00:00:00\n---\n\n1. 选中当前行\n`command + L`","isLeaf":true},{"key":"/tools/10-file-diff.md","path":"/tools/10-file-diff.md","route":"/tools/10-file-diff.md","leaf":true,"title":"10-file-diff","depth":1,"content":"---\ntags: tools\ndate: 2022-06-10 00:00:00\n---\n\n## 1、diff 工具\n\n- 在线工具 https://www.qianbo.com.cn/Tool/Text-Difference/\n- 使用 vscode code --diff filePath1 filePath2\n\n## 2、diff 代码\n\nhttps://github.com/microsoft/vscode/blob/main/src/vs/editor/test/common/diff/diffComputer.test.ts","isLeaf":true},{"key":"/tools/11-yuque-export.md","path":"/tools/11-yuque-export.md","route":"/tools/11-yuque-export.md","leaf":true,"title":"11-yuque-export","depth":1,"content":"---\ntitle: 11 导出语雀文档\ntags: tools\ndate: 2022-06-10 00:00:00\n---\n\n```shell\nYUQUE_TOKEN=XXX npx yuque-exporter gaollard\n```\n\ntoken 在 https://github.com/gaollard/person-tools","isLeaf":true},{"key":"/tools/12-zh-filename-to-en.md","path":"/tools/12-zh-filename-to-en.md","route":"/tools/12-zh-filename-to-en.md","leaf":true,"title":"12-zh-filename-to-en","depth":1,"content":"---\ntitle: 12 将中文文件名转为英文\ntags: tools\ndate: 2022-06-10 00:00:00\n---","isLeaf":true},{"key":"/tools/13-emoji.md","path":"/tools/13-emoji.md","route":"/tools/13-emoji.md","leaf":true,"title":"13-emoji","depth":1,"content":"---\ntags: tools\ndate: 2022-06-10 00:00:00\n---\n\nhttps://emojipedia.org/","isLeaf":true},{"key":"/tools/14-wordpress.md","path":"/tools/14-wordpress.md","route":"/tools/14-wordpress.md","leaf":true,"title":"14-wordpress","depth":1,"content":"---\ntitle: 14 wordpress 建站\ntags: tools\ndate: 2022-06-10 00:00:00\n---\n\n使用 wordpress 搭建博客教程\n\n## 1、下载源码\n\n```shell\nwget https://cn.wordpress.org/latest-zh_CN.zip && unzip latest-zh_CN.zip -d /www/wwwroot\n```\n\n## 2、配置\n\n可参考 https://blog.csdn.net/qq_36234720/article/details/127547705 注意配置文件 wp-config.php\n\n```php\n<?php\ndefine( 'DB_NAME', 'wordpress' );\n\n/** Database username */\ndefine( 'DB_USER', 'root' );\n\n/** Database password */\ndefine( 'DB_PASSWORD', '123456' );\n\n/** Database hostname */\ndefine( 'DB_HOST', 'localhost' );\n\n/** Database charset to use in creating database tables. */\ndefine( 'DB_CHARSET', 'utf8mb4' );\n\n/** The database collate type. Don't change this if in doubt. */\ndefine( 'DB_COLLATE', '' );\n\ndefine( 'AUTH_KEY',         'Al4cZm4c1Ir(TlXxO[0;/pVch9oz|=M@ENnkbrmR%7LDK,{QH$)_0?]JyfQ.WQ7$' );\ndefine( 'SECURE_AUTH_KEY',  'SJh_McK2suE1ie44DunHad;[.Ea||o5]$2fsP$rJ!{L,fe.bPa V t,zqbE~hOt&' );\ndefine( 'LOGGED_IN_KEY',    'zf7K^#Jq{F|rA13p^xW^of?S#Aq0~vXHp{w]W)TfYW3X<w4=&jmjW5!XMH.Wp;3V' );\ndefine( 'NONCE_KEY',        'G]}dSp}:>pn1L}N Pumbwi=11(Vt0o[cTq<+k~S#K-[XoR@8RlRJOR*k2Xa)/QDo' );\ndefine( 'AUTH_SALT',        'FG-FT/r/ KM9h@h ^$8r]/|8t|FbggBBw<13BtU/2K2Mf50a[,5k0%ieozh] mY4' );\ndefine( 'SECURE_AUTH_SALT', '6M*@?Jw|alm/&&0K63lxN%;_N#Z[Q;4pRjrWSn=)6]`zD?VjsQtLx{6FyOf@S@nx' );\ndefine( 'LOGGED_IN_SALT',   'b>8p:(kZJ`l<muL&hsq7bRE.O L3ei.((K]&5GIO`]LaLtBbxs=!D?k}g~Y~#]px' );\ndefine( 'NONCE_SALT',       '4@*.Rh9dB[K8F$lRD).+foBb3[<HROEcC%R8~m?FXo ^[KLP3|;q.]6w0~PC~U}D' );\n\n// define('FTP_BASE', '/www/wwwroot/wordpress');\n// define('FTP_CONTENT_DIR', 'wordpress的内容目录位置');\n// define('FTP_PLUGIN_DI', 'wordpress的插件目录位置');\n// define('FTP_THEMES_DIR', 'wordpress的主体目录位置');\n\n$table_prefix = 'wp_';\n\n\ndefine( 'WP_DEBUG', false );\n\nif ( ! defined( 'ABSPATH' ) ) {\n\tdefine( 'ABSPATH', __DIR__ . '/' );\n}\n\nrequire_once ABSPATH . 'wp-settings.php';\n\nif(is_admin()) {\n\nadd_filter('filesystem_method', create_function('$a', 'return \"direct\";' ));\n\ndefine( 'FS_CHMOD_DIR', 0751 );\n\n}\n```","isLeaf":true},{"key":"/tools/15-hexo.md","path":"/tools/15-hexo.md","route":"/tools/15-hexo.md","leaf":true,"title":"15-hexo","depth":1,"content":"---\ntitle: 15 hexo 搭建博客\ntags: tools\ndate: 2022-06-10 00:00:00\n---\n\n- 官方文档 https://hexo.io/zh-cn/\n- 自己写一个 hexo 主题 https://segmentfault.com/a/1190000006057336\n- 自己写一个 hexo 主题 https://juejin.cn/post/6844904068565958663\n- hexo 原理 https://juejin.cn/user/1538971967685032\n- hexo 原理 https://www.ituring.com.cn/article/199295\n\n## 1、文章排序\n\n## 2、使用插件\n\n## 3、Front-matter\n\n解析 Front-matter\n\n```js\nvar content = `---\\n\ntitle: hello\ntas: Javascript\n---\n\n<h2>hello</h2>\n---\n`;\n\nconst frontMatterRegex = /^---\\s*[\\s\\S]*?\\s*---/;\nconst frontMatterMatch = content.match(frontMatterRegex);\n\nif (frontMatterMatch) {\n  // 取出匹配到的Front-matter部分，并将其转换为JavaScript对象\n  const frontMatterString = frontMatterMatch[0].replace(/---/g, \"\").trim();\n  console.log(frontMatterString);\n  // 使用 Yaml 解析\n} else {\n  console.log(\"没有找到Front-matter部分\");\n}\n```","isLeaf":true},{"key":"/tools/16-regepx-view.md","path":"/tools/16-regepx-view.md","route":"/tools/16-regepx-view.md","leaf":true,"title":"16-regepx-view","depth":1,"content":"---\ntitle: 16 正则可视化\ntags: tools\ndate: 2022-06-10 00:00:00\n---\n\nhttps://regexper.com/#%2F%5E%28%5B%5Cd%5D%2B%29%3F%28.*%29%24%2F","isLeaf":true},{"key":"/tools/17-gatsby.md","path":"/tools/17-gatsby.md","route":"/tools/17-gatsby.md","leaf":true,"title":"17-gatsby","depth":1,"content":"---\ntitle: 17 gatsby 博客搭建\ntags: tools\ndate: 2022-06-10 00:00:00\n---\n\n![20230605004218](http://s3.airtlab.com/blog/20230605004218.png)\n\n参考\n- https://webrtc.mthli.com/\n- https://github.com/mthli/webrtc-tutorial","isLeaf":true},{"key":"/tools/18-nextjs.md","path":"/tools/18-nextjs.md","route":"/tools/18-nextjs.md","leaf":true,"title":"18-nextjs","depth":1,"content":"---\ntitle: 18 nextjs 建站\ntags: tools\ndate: 2022-06-10 00:00:00\n---\n\n提供了很多模板 https://vercel.com/templates/next.js?utm_source=next-site&utm_medium=navbar&utm_campaign=nextjs-templates ","isLeaf":true},{"key":"/tools/19-code-highlight.md","path":"/tools/19-code-highlight.md","route":"/tools/19-code-highlight.md","leaf":true,"title":"19-code-highlight","depth":1,"content":"---\ntitle: 19 代码高亮\ntags: tools\ndate: 2022-06-10 00:00:00\n---\n\n## 1、prismjs\n\n- https://prismjs.com/#examples\n- 在官方下载语言扩展以及主题 https://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript\n\n可以在 nodejs 和 浏览器中使用\n\n```js\nconst Prism = require('prismjs');\n\n// The code snippet you want to highlight, as a string\nconst code = `var data = 1;`;\n\n// Returns a highlighted HTML string\nconst html = Prism.highlight(code, Prism.languages.javascript, 'javascript');\nconsole.log(html)\n```\n\n```html\n<span class=\"token keyword\">var</span> data <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n```\n\n## 2、highlight.js\n\nhttps://highlightjs.org/\n\n可以在 nodejs 和 浏览器中使用\n\n```js\n// require the highlight.js library, including all languages\nconst hljs = require('./highlight.js');\nconst highlightedCode = hljs.highlightAuto('<span>Hello World!</span>').value\n```","isLeaf":true},{"key":"/tools/20-vscode.md","path":"/tools/20-vscode.md","route":"/tools/20-vscode.md","leaf":true,"title":"20-vscode","depth":1,"content":"---\ntitle: 20 vscode\ntags: tools\ndate: 2022-06-10 00:00:00\n---\n\n## 1. 创建软连接\n\n```shell\nsudo ln -fs \"/Applications/Visual Studio Code.app/Contents/Resources/app/bin/code\" /usr/local/bin/\n```\n\n## 2. 插入当前时间\n可以自己写 Vscode 插件实现，比如 `Insert Date String`，Mac 上使用 `shift + command + i`\n\n![20230610000702](http://s3.airtlab.com/blog/20230610000702.png)\n\n## 3. 正则搜索替换\n\n```html\n<a name=(.*)></a>\n```","isLeaf":true},{"key":"/tools/21-create-react-doc.md","path":"/tools/21-create-react-doc.md","route":"/tools/21-create-react-doc.md","leaf":true,"title":"21-create-react-doc","depth":1,"content":"---\ntitle: 21 create react doc\ntags: tools\ndate: 2022-06-10 00:00:00\n---\n\nCreate React Doc 是一个使用 React 的 markdown 文档站点生成工具。就像 create-react-app 一样，开发者可以使用 Create React Doc 来开发、部署文档或者博客站点而无需关心额外的环境配置信息。\n\nhttps://github.com/MuYunyun/create-react-doc","isLeaf":true},{"key":"/tools/22-tcp-packet-sender.md","path":"/tools/22-tcp-packet-sender.md","route":"/tools/22-tcp-packet-sender.md","leaf":true,"title":"22-tcp-packet-sender","depth":1,"content":"---\ntags: tools\n---\n\n有时候我们要测试TCP服务器， 写个客户端当然可以， 不过如果你不能改客户端又想改发送的内容， 用 Packet sender 就很方便。\n首先用客户端发送TCP包到 Packet Sender, 然后用 Packet Sender 保存一下， 就可以在Packet Sender 中发送这个包到别的地方了， 还可以改包值。\n\n![20230612140520](http://s3.airtlab.com/blog/20230612140520.png)","isLeaf":true},{"key":"/tools/23-baidu-translate-openapi.md","path":"/tools/23-baidu-translate-openapi.md","route":"/tools/23-baidu-translate-openapi.md","leaf":true,"title":"23-baidu-translate-openapi","depth":1,"content":"---\ntags: tools\n---\n\n```ts\nimport axios from 'axios';\nimport md5 from 'md5'\n\nvar url = `https://fanyi-api.baidu.com/api/trans/vip/translate`;\nvar app_id = '20230612001709576';\nvar app_secret = `Mv3I6oaIcj48dm2ISiDt`;\nvar salt = '1435660288';\n\nfunction create_sign(q: string) {\n  var content = app_id + q + salt + app_secret;\n  return md5(content);\n}\n\nasync function translate(q: string) {\n  var sign = create_sign(q);\n  var fullUrl =\n    url + `?q=${q}&from=zh&to=en&appid=${app_id}&salt=${salt}&sign=${sign}`;\n\n    axios(fullUrl).then((res) => {\n    console.log(res.status)\n    console.log(res.data)\n  })\n}\n\ntranslate(`基础用法`);\n```","isLeaf":true},{"key":"/tools/25-ui-design.md","path":"/tools/25-ui-design.md","route":"/tools/25-ui-design.md","leaf":true,"title":"25-ui-design","depth":1,"content":"- AI 生成图片\n- 更换背景 https://www.remove.bg/zh/t/change-background","isLeaf":true},{"key":"/tools/26-github-cicd.md","path":"/tools/26-github-cicd.md","route":"/tools/26-github-cicd.md","leaf":true,"title":"26-github-cicd","depth":1,"content":"## travis-ci\n","isLeaf":true},{"key":"/tools/参考博客.md","path":"/tools/参考博客.md","route":"/tools/参考博客.md","leaf":true,"title":"参考博客","depth":1,"content":"https://blog.zhheo.com/archives/\n\n\n![20230711172643](http://s3.airtlab.com/blog/20230711172643.png)","isLeaf":true},{"key":"/tools/文章封面图片在线创作.md","path":"/tools/文章封面图片在线创作.md","route":"/tools/文章封面图片在线创作.md","leaf":true,"title":"文章封面图片在线创作","depth":1,"content":"https://tooltt.com/fontlogo/\n\n![tooltt-fontlogo](http://s3.airtlab.com/blog/tooltt-fontlogo.png)\n\nhttps://zhuanlan.zhihu.com/p/599159170","isLeaf":true}]},{"key":"/typescript","path":"/typescript","route":"/typescript","leaf":false,"title":"typescript","depth":0,"content":"","isLeaf":false,"children":[{"key":"/typescript/tsc api.md","path":"/typescript/tsc api.md","route":"/typescript/tsc api.md","leaf":true,"title":"tsc api","depth":1,"content":"https://github.com/microsoft/TypeScript/wiki/Using-the-Compiler-API","isLeaf":true},{"key":"/typescript/如何 加载 tsconfig.json 内容.md","path":"/typescript/如何 加载 tsconfig.json 内容.md","route":"/typescript/如何 加载 tsconfig.json 内容.md","leaf":true,"title":"如何 加载 tsconfig.json 内容","depth":1,"content":"https://github.com/microsoft/TypeScript/issues/5276\n\n![20230707120323](http://s3.airtlab.com/blog/20230707120323.png)","isLeaf":true}]},{"key":"/uml","path":"/uml","route":"/uml","leaf":false,"title":"uml","depth":0,"content":"","isLeaf":false,"children":[{"key":"/uml/时序图.md","path":"/uml/时序图.md","route":"/uml/时序图.md","leaf":true,"title":"时序图","depth":1,"content":"","isLeaf":true},{"key":"/uml/泳道图.md","path":"/uml/泳道图.md","route":"/uml/泳道图.md","leaf":true,"title":"泳道图","depth":1,"content":"","isLeaf":true},{"key":"/uml/流程图.md","path":"/uml/流程图.md","route":"/uml/流程图.md","leaf":true,"title":"流程图","depth":1,"content":"","isLeaf":true},{"key":"/uml/状态图.md","path":"/uml/状态图.md","route":"/uml/状态图.md","leaf":true,"title":"状态图","depth":1,"content":"","isLeaf":true}]},{"key":"/低代码","path":"/低代码","route":"/低代码","leaf":false,"title":"低代码","depth":0,"content":"","isLeaf":false,"children":[{"key":"/低代码/01 从 0 构建一个基于 ER 图的低代码后端.md","path":"/低代码/01 从 0 构建一个基于 ER 图的低代码后端.md","route":"/低代码/01 从 0 构建一个基于 ER 图的低代码后端.md","leaf":true,"title":"01 从 0 构建一个基于 ER 图的低代码后端","depth":1,"content":"https://zhuanlan.zhihu.com/p/395026008","isLeaf":true}]}]