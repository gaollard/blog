[{"key":"/Babel","path":"/Babel","route":"/Babel","leaf":false,"title":"Babel","depth":0,"content":"","isLeaf":false,"children":[{"key":"/Babel/01 基础教程","path":"/Babel/01 基础教程","route":"/Babel/01 基础教程","leaf":false,"title":"01 基础教程","depth":1,"content":"","isLeaf":false,"children":[{"key":"/Babel/01 基础教程/01-babel-asstes.md","path":"/Babel/01 基础教程/01-babel-asstes.md","route":"/Babel/01 基础教程/01-babel-asstes.md","leaf":true,"title":"01-babel-asstes","depth":2,"content":"---\ntitle: 01 babel 介绍\ntags: Babel\n---\n\n## 1、Babel 介绍\n\nBabel 是一个开源的 JavaScript 编译器工具，用于将新版本的 JavaScript 代码转换为向后兼容的旧版本，以便在不同的浏览器和环境中运行。它可以将使用最新的 ECMAScript 标准编写的代码转换为支持更旧的版本，以便在不同的浏览器中运行。\n\n## 2、Babel 版本\n\n### v6 VS v7\nBabel V7 相对于 Babel V6来说，有以下几个主要的区别：\n\n1. 命令行工具改进：V7 增加了一些新的命令行工具，如 `babel-upgrade` 和 `babel-merge` 等，这些工具让你更方便地维护Babel配置和升级到新的版本。\n\n2. 插件新增：V7 在默认插件集合中新增了一些新的插件，如 `@babel/plugin-transform-runtime` 和 `@babel/plugin-proposal-class-properties` 等，这些插件为开发者提供更多的便利和控制力。\n\n3. 配置文件更改：Babel V7 将配置文件名称从 `.babelrc` 更改为 `babel.config.js`，并支持更复杂的配置选项。\n\n4. 匹配更多的 ECMAScript 特性：Babel V7 支持更多的 ECMAScript 特性，如对象的 Rest 和 Spread 属性，对象的解构赋值，Async 函数和模板字符串标记等。\n\nBabel V7 相对于 Babel V6 的改进主要在于命令行工具、插件集合、配置文件和匹配更多的 ECMAScript 特性等方面。\n\n### V7.4.0\n- @babel/polyfill 被弃用，取而代之的是 `\"core-js/stable\"`\n\n### v7.6.0\n- 支持 TypeScript 命名空间的编译。\n\n## 3、学习资料\n\n### 官方文档\n\n- babel 官方网 [https://babeljs.io/docs/en](https://babeljs.io/docs/en/)\n- babel 中文网 [https://www.babeljs.cn/docs](https://www.babeljs.cn/docs/)\n\n### 调试工具\n\n- AST 在线 <https://astexplorer.net/#/2uBU1BLuJ1>\n- babel 插件开发手册 <https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md>\n\n### 实践经验\n- babel 腾讯云社区文档 <https://cloud.tencent.com/developer/doc/1260> 介绍babel API\n- 最简单 compiler 教程 [the-super-tiny-compiler](https://github.com/jamiebuilds/the-super-tiny-compiler/blob/master/the-super-tiny-compiler.js)\n- [高级前端基础-JavaScript抽象语法树AST](https://segmentfault.com/a/1190000018532745) <https://segmentfault.com/a/1190000018532745>\n- [AST抽象语法树——最基础的javascript重点知识，99%的人根本不了解](https://segmentfault.com/a/1190000016231512?utm_source=tag-newest#articleHeader10)\n- [从零开始写一个wepy转VUE的工具](http://zzfed.com/#/detail/5c8efc30c476e35308705a5b)\n- Babel是如何读懂JS代码的 <https://zhuanlan.zhihu.com/p/27289600>\n- 网易云课堂 JS编译原理： [https://study.163.com/course/courseMain.htm?courseId=1209486877&*trace\\_c\\_p\\_k2*=8ea58ce894c149179bd099a664c39d08](https://study.163.com/course/courseMain.htm?courseId=1209486877&_trace_c_p_k2_=8ea58ce894c149179bd099a664c39d08)","isLeaf":true},{"key":"/Babel/01 基础教程/02-babel-quickstart.md","path":"/Babel/01 基础教程/02-babel-quickstart.md","route":"/Babel/01 基础教程/02-babel-quickstart.md","leaf":true,"title":"02-babel-quickstart","depth":2,"content":"---\ntitle: 02 babel 快速开始\ntags: Babel\n---\n\n## 1、初始化配置\n\n```shell\nyarn add --dev @babel/core @babel/cli @babel/preset-env\n```\n\n- @babel/core 提供了基本功能，包括 AST 解析 以及 AST visit\n- @babel/cli 是一个命令行工具\n- @babel/preset-env 是一个插件集合\n\n**创建配置文件**\n\n```js\nconst presets = [\n  [\n    \"@babel/preset-env\",\n    {\n      targets: {\n        edge: \"17\",\n        firefox: \"60\",\n        chrome: \"67\",\n        safari: \"11.1\",\n      },\n      useBuiltIns: \"usage\",\n      corejs: \"3.6.4\",\n    },\n  ],\n];\n\nmodule.exports = { presets };\n```\n\n```\n./node_modules/.bin/babel src --out-dir lib\n```\n\n## 2、配置文件说明\n\n- 项目范围的配置\n  - `babel.config.*` 文件，具有以下扩展名：.json, .js, .cjs, .mjs, .cts.\n- 文件相关配置\n  - `.babelrc.*` 文件，具有以下扩展名：.json, .js, .cjs, .mjs, .cts.\n  - `.babelrc` 文件，没有扩展名。\n  - `package.json` 文件，\"babel\" key\n\nhttps://babeljs.io/docs/config-files 在这里了解他们的区别，我们应该用哪种？","isLeaf":true},{"key":"/Babel/01 基础教程/03-use-plugin-and-presets.md","path":"/Babel/01 基础教程/03-use-plugin-and-presets.md","route":"/Babel/01 基础教程/03-use-plugin-and-presets.md","leaf":true,"title":"03-use-plugin-and-presets","depth":2,"content":"---\ntitle: 03 使用 plugin 和 preset\ntags: Babel\n---\n\nBabel 插件 和 Preset 是用于在 JavaScript 项目中进行代码转换的工具。\n\n## 1、插件 和 Preset 有什么区别？\n\n- 插件是针对 Babel 的具体功能的单个功能，例如“转换箭头函数为普通函数”，“转换 ES6 类成为普通函数”等，而 preset 则是包含另外一些插件的一个集合，这些插件共同完成一些相关的 tasks。\n\n- 软件预设(packaged presets) 可以轻松地执行多项任务，而不必单独安装和配置多个插件。例如，@babel/preset-env 是一个预设，它帮助您将 ES6+代码转换为符合您指定的目标环境的 JavaScript 代码。\n\n## 2、如何使用？\n\n使用 Babel 插件和 Preset，您需要在项目中安装它们并配置 Babel。在您的项目根目录下创建一个 `.babelrc` 文件，为 Babel 提供配置。\n\n### preset\n\n例如，使用 preset-env 转换 ES6 +代码：\n\n1. 安装 `@babel/preset-env`:\n\n```\nnpm install --save-dev @babel/preset-env\n```\n\n2. 然后在 .babelrc 文件中配置：\n\n```\n{\n  \"presets\": [\"@babel/preset-env\"]\n}\n```\n\n这意味着在项目中的所有 ES6+代码都将被转换为适用于您的所需 JavaScript 环境的标准 JavaScript。\n\n### plugin\n\n```shell\nyarn add --dev @babel/plugin-transform-arrow-functions\n```\n\n```\n./node_modules/.bin/babel src --out-dir lib --plugins=@babel/plugin-transform-arrow-functions\n```\n\n```js\nconst fn = () => 1;\n\n// converted to\nvar fn = function fn() {\n  return 1;\n};\n```\n\n```js\nconst presets = [\n  [\n    \"@babel/preset-env\",\n    {\n      targets: {\n        edge: \"17\",\n        firefox: \"60\",\n        chrome: \"67\",\n        safari: \"11.1\",\n      },\n      useBuiltIns: \"usage\",\n      corejs: \"3.6.4\",\n    },\n  ],\n];\n\nconst plugins = [[\"@babel/plugin-transform-arrow-functions\"]];\n\nmodule.exports = { presets, plugins };\n```\n","isLeaf":true},{"key":"/Babel/01 基础教程/04-babel-plugin-ES2015.md","path":"/Babel/01 基础教程/04-babel-plugin-ES2015.md","route":"/Babel/01 基础教程/04-babel-plugin-ES2015.md","leaf":true,"title":"04-babel-plugin-ES2015","depth":2,"content":"---\ntitle: 04 plugin ES2015\ntags: Babel\n---\n\nBabel 是一个编译器。从宏观角度看，它将运行代码分为3个阶段: 解析，转换，及生成（与其他编译器相同）。\n\n始阶段，Babel 并没有做任何事情。它基本上就相当于 `const babel = code => code;`，先解析代码，然后再次生成相同的代码。你可以为 Babel 添加一些 Plugins 让其去做任何事情( Plugins 会影响 Babel 的第 2 阶段，转换)。\n\n\n## 1、ES3\n\n### [es3-member-expression-literals](https://babel.docschina.org/docs/en/babel-plugin-transform-es3-member-expression-literals)\n\n```javascript\n// 在IE8及以下会报错\nfoo.catch;\n\n// 需要转换为\nfoo[\"catch\"]\n```\n\n### [es3-property-literals](https://babel.docschina.org/docs/en/babel-plugin-transform-es3-property-literals)\n\n```javascript\n// 在IE8及以下会报错\nvar foo = {\n  catch: function () {}\n};\n\n// 需要转换为\nvar foo = {\n  \"catch\": function () {}\n};\n```\n\n\n### [reserved-words](https://babeljs.io/docs/en/babel-plugin-transform-reserved-words)\n\n有些在标识符在ES3为保留字，在ES5及以后就不是了，这个插件可以重命名这些标识符。\n\n```javascript\n// IN\nvar abstract = 1;\nvar x = abstract + 1;\n\n// OUT\nvar _abstract = 1;\nvar x = _abstract + 1;\n```\n\n## 2、ES5\n\n### [property-mutators](https://babeljs.io/docs/en/babel-plugin-transform-property-mutators)\n\n对于 mutate 方法的定义，老版的部分浏览器只支持使用 Object.defineProperties 来定义：\n\n```javascript\n// In\nvar foo = {\n  get bar() {\n    return this._bar;\n  },\n  set bar(value) {\n    this._bar = value;\n  }\n};\n\n// Out\nvar foo = Object.defineProperties({}, {\n  bar: {\n    get: function () {\n      return this._bar;\n    },\n    set: function (value) {\n      this._bar = value;\n    },\n    configurable: true,\n    enumerable: true\n  }\n});\n```\n\n<a name=\"R2DiV\"></a>\n\n## 3、ES2015\n\nES2015 修订文档：<https://www.ecma-international.org/ecma-262/6.0>\n\n### [arrow-functions](https://babeljs.io/docs/en/babel-plugin-transform-arrow-functions)\n\n箭头函数转译\n\n### [block-scoped-functions](https://babeljs.io/docs/en/babel-plugin-transform-block-scoped-functions)\n\n块级作用域函数\n\n```javascript\n// In\n{\n  function name (n) {\n    return n;\n  }\n}\n\nname(\"Steve\");\n\n// Out\n{\n  let name = function (n) {\n    return n;\n  };\n}\nname(\"Steve\");\n```\n\n### [block-scoping](https://babeljs.io/docs/en/babel-plugin-transform-block-scoping)\n\n块及作用域\n\n```javascript\n// In\n{\n  let a = 3\n}\n\nlet a = 3\n\n// Out\n{\n  var _a = 3;\n}\n\nvar a = 3;\n```\n\n### [classes](https://babeljs.io/docs/en/babel-plugin-transform-classes)\n\n使用 class 定义类，如果你的代码包含子类继承 Native class 时，需要额外注意，见文档 [classes](https://babeljs.io/docs/en/babel-plugin-transform-classes)。\n\n```javascript\n// In\nclass Test {\n  constructor(name) {\n    this.name = name;\n  }\n\n  logger () {\n    console.log(\"Hello\", this.name);\n  }\n}\n\n// Out\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar Test = function () {\n  function Test(name) {\n    _classCallCheck(this, Test);\n\n    this.name = name;\n  }\n\n  Test.prototype.logger = function logger() {\n    console.log(\"Hello\", this.name);\n  };\n\n  return Test;\n}();\n```\n\n### [computed-properties](https://babeljs.io/docs/en/babel-plugin-transform-computed-properties)\n\n计算属性或表达式属性\n\n```javascript\n// In\nvar obj = {\n  [\"x\" + foo]: \"heh\",\n  [\"y\" + bar]: \"noo\",\n  foo: \"foo\",\n  bar: \"bar\"\n};\n\n// Out\nvar _obj;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar obj = (\n  _obj = {},\n  _defineProperty(_obj, \"x\" + foo, \"heh\"),\n  _defineProperty(_obj, \"y\" + bar, \"noo\"),\n  _defineProperty(_obj, \"foo\", \"foo\"),\n  _defineProperty(_obj, \"bar\", \"bar\"),\n  _obj\n);\n```\n\n### [destructuring](https://babeljs.io/docs/en/babel-plugin-transform-destructuring)\n\n解构赋值\n\n```javascript\n// In\nlet {x, y} = obj;\nlet [a, b, ...rest] = arr;\n\n// Out\nfunction _toArray(arr) { ... }\n\nlet _obj = obj,\n    x = _obj.x,\n    y = _obj.y;\n\nlet _arr = arr,\n    _arr2 = _toArray(_arr),\n    a = _arr2[0],\n    b = _arr2[1],\n    rest = _arr2.slice(2);\n```\n\n### [duplicate-keys](https://babeljs.io/docs/en/babel-plugin-transform-duplicate-keys)\n\n将重复key转为表达式key，没什么用\n\n```javascript\n// In\nvar x = { a: 5, a: 6 };\nvar y = {\n  get a() {},\n  set a(x) {},\n  a: 3,\n};\n\n// Out\nvar x = { a: 5, [\"a\"]: 6 };\nvar y = {\n  get a() {},\n  set a(x) {},\n  [\"a\"]: 3,\n};\n```\n\n### [for-of](https://babeljs.io/docs/en/babel-plugin-transform-for-of)\n\nfor-of 迭代器\n\n```javascript\n// in\nfor (var i of foo) {}\n\n// out\nvar _iteratorNormalCompletion = true;\nvar _didIteratorError = false;\nvar _iteratorError = undefined;\n\ntry {\n  for (var _iterator = foo[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n    var i = _step.value;\n  }\n} catch (err) {\n  _didIteratorError = true;\n  _iteratorError = err;\n} finally {\n  try {\n    if (!_iteratorNormalCompletion && _iterator.return != null) {\n      _iterator.return();\n    }\n  } finally {\n    if (_didIteratorError) {\n      throw _iteratorError;\n    }\n  }\n}\n```\n\n### [function-name](https://babeljs.io/docs/en/babel-plugin-transform-function-name)\n\n```javascript\n// in\nlet number = (x) => x\n\n// out\nvar number = function number(x) {\n  return x;\n};\n```\n\n### [instanceof](https://babeljs.io/docs/en/babel-plugin-transform-instanceof)\n\nES2015 对 instanceof 操作符进行了修订\n![20230608110441](http://s3.airtlab.com/blog/20230608110441.png)\n\n```javascript\n// in\nfoo instanceof Bar;\n\n// out\nfunction _instanceof(left, right) {\n  if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n    return right[Symbol.hasInstance](left);\n  } else {\n    return left instanceof right;\n  }\n}\n\n_instanceof(foo, Bar);\n```\n\n### [literals](https://babeljs.io/docs/en/babel-plugin-transform-literals)\n\n字面量转换\n\n```javascript\n// in\nvar b = 0b11; // binary integer literal\nvar o = 0o7; // octal integer literal\nconst u = 'Hello\\u{000A}\\u{0009}!'; // unicode string literals, newline and tab\n\n// out\nvar b = 3; // binary integer literal\nvar o = 7; // octal integer literal\nconst u = 'Hello\\n\\t!'; // unicode string literals, newline and tab\n```\n\n### [new-target](https://babeljs.io/docs/en/babel-plugin-transform-new-target)\n\nnew.target返回使用new方法调用类时的类的名称，子类继承父类时，new.target会返回子类。\n\n```javascript\nclass Rectangle {\n  constructor(length, width) {\n    console.log(new.target === Rectangle);\n  }\n}\n \nclass Square extends Rectangle {\n  constructor(length) {\n    super(length, length);\n  }\n}\n```\n\n### [object-super](https://babeljs.io/docs/en/babel-plugin-transform-object-super)\n\nthis 关键字总是指向函数所在的当前对象，ES6 新增了另一个类似的关键字super，指向当前对象的原型对象。\n\n```javascript\nlet obj2 = {\n  say () {\n    // [object Object]World!\n    return super.toString() + \"World!\"\n  }\n}\n```\n\n### [parameters](https://babeljs.io/docs/en/babel-plugin-transform-parameters)\n\n处理 ES2015 函数参数：\n\n- Destructuring parameters 参数解构\n- Default parameters 默认参数\n- Rest parameters 扩展符\n\n```javascript\n// in\nfunction test(x = \"hello\", { a, b }, ...args) {\n  console.log(x, a, b, args);\n}\n\n// out\nfunction test() {\n  var x =\n    arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"hello\";\n  var _ref = arguments[1];\n  var a = _ref.a,\n    b = _ref.b;\n\n  for (\n    var _len = arguments.length,\n      args = Array(_len > 2 ? _len - 2 : 0),\n      _key = 2;\n    _key < _len;\n    _key++\n  ) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  console.log(x, a, b, args);\n}\n```\n\n### [shorthand-properties](https://babeljs.io/docs/en/babel-plugin-transform-shorthand-properties)\n\n```javascript\n// in\nvar o = { a, b, c };\n\n// out\nvar o = { a: a, b: b, c: c };\n```\n\n```javascript\n// in\nvar cat = {\n  getName() {\n    return name;\n  }\n};\n\n// out\nvar cat = {\n  getName: function () {\n    return name;\n  }\n};\n```\n\n### [spread](https://babeljs.io/docs/en/babel-plugin-transform-spread)\n\n扩展运算符，与剩余运算符互为逆运算\n\n```javascript\n// in\nvar a = ['a', 'b', 'c'];\n\nvar b = [...a, 'foo'];\n\nvar c = foo(...a);\n\n// out\nvar a = ['a', 'b', 'c'];\n\nvar b = a.concat(['foo']);\n\nvar c = foo.apply(void 0, a);\n```\n\n### [sticky-regex](https://babeljs.io/docs/en/babel-plugin-transform-sticky-regex)\n\n```javascript\n// in\nconst a = /o+/y;\n\n// out\nvar a = new RegExp(\"o+\", \"y\");\n```\n\ny 修饰符：叫做 “粘连”（sticky）修饰符。用来正确处理匹配粘连的字符串。它的作用和g修饰类似，也是全局匹配。它可以使用新增的正则对象属性sticky来判断正则对象是否设置了y修饰符。y 和 g 的区别\n\n- g 修饰符只要剩余位置中存在匹配的字符串就可以返回成功。而y修饰符确保匹配必须是从剩余的所有位置中的第一个位置开始，这也是粘连的含义。\n- y 修饰符隐含了头部匹配的标志^（^x表示匹配的字符串的首个字符必须是x）\n\n### [template-literals](https://babeljs.io/docs/en/babel-plugin-transform-template-literals)\n\n模版字符串\n\n```javascript\n// in\n`foo${bar}`;\n\n// out\n\"foo\".concat(bar);\n```\n\n### [typeof-symbol](https://babeljs.io/docs/en/babel-plugin-transform-typeof-symbol)\n\nSymbol是原始值，ES6扩展了typeof操作符，返回\"symbol\"。所以可以用typeof来检测变量是否为symbol类型\n\n### [unicode-escapes](https://babeljs.io/docs/en/babel-plugin-transform-unicode-escapes)\n\nCompile ES2015 Unicode escapes to ES5\n\n```javascript\n// in\nvar \\u{1d49c} = \"\\u{Babe1}\";\n\nconsole.log(\\u{1d49c});\n\n// out\nvar _ud835_udc9c = \"\\uDAAA\\uDFE1\";\n\nconsole.log(_ud835_udc9c);\n```\n\n### [unicode-regex](https://babeljs.io/docs/en/babel-plugin-transform-unicode-regex)\n\n```js\n// in\nvar string = \"foo💩bar\";\nvar match = string.match(/foo(.)bar/u);\n```","isLeaf":true},{"key":"/Babel/01 基础教程/05-babel-plugin-ES2016.md","path":"/Babel/01 基础教程/05-babel-plugin-ES2016.md","route":"/Babel/01 基础教程/05-babel-plugin-ES2016.md","leaf":true,"title":"05-babel-plugin-ES2016","depth":2,"content":"---\ntitle: 05 plugin ES2016\ntags: Babel\n---\n\n## 1、ES2016\n\n### [exponentiation-operator](https://babeljs.io/docs/en/babel-plugin-transform-exponentiation-operator)\n\n新增指数运算法\n\n```javascript\n// in\nlet x = 10 ** 2;\n\nx **= 3;\n\n// out\nlet x = Math.pow(10, 2);\nx = Math.pow(x, 3);\n```\n\n## 2、ES2017\n\n### [async-to-generator](https://babeljs.io/docs/en/babel-plugin-transform-async-to-generator)\n\n将 async 转换为 generator\n\n```javascript\n// in\nasync function foo() {\n  await bar();\n}\n\n// out\nvar _asyncToGenerator = function (fn) {\n  ...\n};\n\nvar foo = _asyncToGenerator(function* () {\n  yield bar();\n});\n```\n\n\n## 3、ES2018\n\n### [external-helpers](https://babeljs.io/docs/en/babel-plugin-external-helpers)\n\n内部帮助函数\n\n### [object-assign](https://babeljs.io/docs/en/babel-plugin-transform-object-assign)\n\n```javascript\n// in \nObject.assign(a, b);\n\n// out\nvar _extends = ...;\n\n_extends(a, b);\n```\n\n### [regenerator](https://babeljs.io/docs/en/babel-plugin-transform-regenerator)\n\n这是 facebook 下的一个工具，用于编译 ES6 的 generator 函数，一篇非常好的文章见：<https://www.jianshu.com/p/17a4c00d5831> <a name=\"uzkyg\"></a>\n\n![20230608110538](http://s3.airtlab.com/blog/20230608110538.png)\n\n### [runtime](https://babeljs.io/docs/en/babel-plugin-transform-runtime)\n\nruntime 库，用于重用 @babel/runtime 代码.\n\n### [strict-mode](https://babeljs.io/docs/en/babel-plugin-transform-strict-mode)\n\n编译为严格模式\n\n```javascript\n// in\nfoo();\n\n// out\n\"use strict\";\n\nfoo();\n```\n\n## Modules 模块处理\n\n- [modules-amd](https://babeljs.io/docs/en/babel-plugin-transform-modules-amd)\n- [modules-commonjs](https://babeljs.io/docs/en/babel-plugin-transform-modules-commonjs)\n- [modules-systemjs](https://babeljs.io/docs/en/babel-plugin-transform-modules-systemjs)\n- [modules-umd](https://babeljs.io/docs/en/babel-plugin-transform-modules-umd)\n\n### Experimental\n\n- [class-properties](https://babeljs.io/docs/en/babel-plugin-proposal-class-properties)\n\n扩展类的属性定义\n\n```javascript\nclass Bork {\n    //Property initializer syntax\n    instanceProperty = \"bork\";\n\n    boundFunction = () => {\n      return this.instanceProperty;\n    };\n\n    //Static class properties\n    static staticProperty = \"babelIsCool\";\n    static staticFunction = function() {\n      return Bork.staticProperty;\n    };\n}\n```\n\n- [decorators](https://babeljs.io/docs/en/babel-plugin-proposal-decorators)\n\n装饰器的支持\n\n```javascript\n@annotation\nclass MyClass { }\n\nfunction annotation(target) {\n   target.annotated = true;\n}\n```\n\n- [do-expressions](https://babeljs.io/docs/en/babel-plugin-proposal-do-expressions)\n\ndo 表达式\n\n```javascript\nlet a = do {\n  if(x > 10) {\n    'big';\n  } else {\n    'small';\n  }\n};\n// is equivalent to:\nlet a = x > 10 ? 'big' : 'small';\n```\n\n- [export-default-from](https://babeljs.io/docs/en/babel-plugin-proposal-export-default-from)\n\n快捷到出\n\n```javascript\nexport v from 'mod';\n```\n\n- [export-namespace-from](https://babeljs.io/docs/en/babel-plugin-proposal-export-namespace-from)\n\n快捷导出重命名\n\n```javascript\nexport * as ns from 'mod';\n```\n\n- [function-bind](https://babeljs.io/docs/en/babel-plugin-proposal-function-bind)\n\n快捷的函数 context 绑定\n\n```javascript\nobj::func\n// is equivalent to:\nfunc.bind(obj)\n```\n\n- [function-sent](https://babeljs.io/docs/en/babel-plugin-proposal-function-sent)\n- [logical-assignment-operators](https://babeljs.io/docs/en/babel-plugin-proposal-logical-assignment-operators)\n- [nullish-coalescing-operator](https://babeljs.io/docs/en/babel-plugin-proposal-nullish-coalescing-operator)\n- [numeric-separator](https://babeljs.io/docs/en/babel-plugin-proposal-numeric-separator)\n- [optional-chaining](https://babeljs.io/docs/en/babel-plugin-proposal-optional-chaining)\n- [partial-application](https://babeljs.io/docs/en/babel-plugin-proposal-partial-application)\n- [pipeline-operator](https://babeljs.io/docs/en/babel-plugin-proposal-pipeline-operator)\n- [private-methods](https://babeljs.io/docs/en/babel-plugin-proposal-private-methods)\n- [throw-expressions](https://babeljs.io/docs/en/babel-plugin-proposal-throw-expressions)\n- [private-property-in-object](https://babeljs.io/docs/en/babel-plugin-proposal-private-property-in-object)\n\n\n## React 相关语法\n\n- [react-constant-elements](https://babeljs.io/docs/en/babel-plugin-transform-react-constant-elements)\n- [react-display-name](https://babeljs.io/docs/en/babel-plugin-transform-react-display-name)\n- [react-inline-elements](https://babeljs.io/docs/en/babel-plugin-transform-react-inline-elements)\n- [react-jsx](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx)\n- [react-jsx-compat](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx-compat)\n- [react-jsx-self](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx-self)\n- [react-jsx-source](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx-source)\n","isLeaf":true},{"key":"/Babel/01 基础教程/06-babel-presets.md","path":"/Babel/01 基础教程/06-babel-presets.md","route":"/Babel/01 基础教程/06-babel-presets.md","leaf":true,"title":"06-babel-presets","depth":2,"content":"---\ntitle: 06 babel presets\ntags: Babel\n---\n\npresets 是一些 plugins 的集合。\n\n\n## 1、官方 Presets\n\n- [@babel/preset-env](https://babeljs.io/docs/en/babel-preset-env)\n- [@babel/preset-flow](https://babeljs.io/docs/en/babel-preset-flow)\n- [@babel/preset-react](https://babeljs.io/docs/en/babel-preset-react)\n- [@babel/preset-typescript](https://babeljs.io/docs/en/babel-preset-typescript)\n\n## 2、实验阶段 Presets\n\n- [Stage 0](https://babeljs.io/docs/en/babel-preset-stage-0) - Strawman: just an idea, possible Babel plugin.\n- [Stage 1](https://babeljs.io/docs/en/babel-preset-stage-1) - Proposal: this is worth working on.\n- [Stage 2](https://babeljs.io/docs/en/babel-preset-stage-2) - Draft: initial spec.\n- [Stage 3](https://babeljs.io/docs/en/babel-preset-stage-3) - Candidate: complete spec and initial browser implementations.\n- Stage 4 - Finished: will be added to the next yearly release.\n\n## 3、自定义 presets\n\n```javascript\nmodule.exports = function() {\n  return {\n    plugins: [\n      \"pluginA\",\n      \"pluginB\",\n      \"pluginC\",\n    ]\n  };\n}\n```\n\npresets 中也可以包含其他 presets：\n\n```javascript\nmodule.exports = () => ({\n  presets: [\n    require(\"@babel/preset-env\"),\n  ],\n  plugins: [\n    [require(\"@babel/plugin-proposal-class-properties\"), { loose: true }],\n    require(\"@babel/plugin-proposal-object-rest-spread\"),\n  ],\n});\n```\n\n使用 presets:\n\n```javascript\n// 非 node_modules\n{\n  \"presets\": [\"./myProject/myPreset\"]\n}\n\n// node_modules 下\n{\n  \"presets\": [\"babel-preset-myPreset\"]\n}\n```","isLeaf":true},{"key":"/Babel/01 基础教程/07-preset-react.md","path":"/Babel/01 基础教程/07-preset-react.md","route":"/Babel/01 基础教程/07-preset-react.md","leaf":true,"title":"07-preset-react","depth":2,"content":"---\ntitle: 07 preset react\ntags: Babel\n---\n\nThis preset always includes the following plugins:\n\n- @babel/plugin-syntax-jsx\n- @babel/plugin-transform-react-jsx\n- @babel/plugin-transform-react-display-name\n\nAnd with the development option:\n\nClassic runtime adds:\n\n- @babel/plugin-transform-react-jsx-self\n- @babel/plugin-transform-react-jsx-source\n\n```json\n{\n  \"presets\": [\n    [\n      \"@babel/preset-react\",\n      {\n        \"pragma\": \"dom\", // default pragma is React.createElement (only in classic runtime)\n        \"pragmaFrag\": \"DomFrag\", // default is React.Fragment (only in classic runtime)\n        \"throwIfNamespace\": false, // defaults to true\n        \"runtime\": \"classic\" // defaults to classic\n        // \"importSource\": \"custom-jsx-library\" // defaults to react (only in automatic runtime)\n      }\n    ]\n  ]\n}\n```\n\n## @babel/plugin-syntax-jsx\n\n@babel/plugin-syntax-jsx 是一个用于 Babel 的插件，它的作用是让 Babel 能够识别和转换 JSX 语法的代码。JSX 是一种 JavaScript 的语法扩展，它允许在 JavaScript 中编写类似于 HTML 的标记语言，用于构建用户界面。\n在没有该插件的情况下，Babel 将无法理解 JSX 代码中的标签，会抛出错误。使用 @babel/plugin-syntax-jsx 插件后，Babel 将能够正确地解析并转换 JSX 语法到普通的 JavaScript 代码。\n\n需要注意的是，该插件只是解析 JSX 语法，它并不会将 JSX 转化为真正的 DOM 操作。要将 JSX 转换为可用的 JavaScript 代码，需要使用其他的插件或工具，例如 @babel/preset-react 插件、React 或 Preact 库等。\n\n## @babel/plugin-transform-react-jsx\n\n@babel/plugin-transform-react-jsx 是一个用于 Babel 的插件，它的作用是将 JSX 语法转换为普通的 JavaScript 代码，以便 JavaScript 引擎能够识别和执行这些代码。\nJSX 是一种 JavaScript 的语法扩展，它允许在 JavaScript 中编写类似于 HTML 的标记语言，用于构建用户界面。但是，由于 JavaScript 引擎不能直接执行 JSX 代码，因此需要将其转换为普通的 JavaScript 代码，以便能够在浏览器或 Node.js 等环境中执行。\n\n\n## React 17 介绍全新的 JSX 转换 (React.createElement => jsx)\n\n![20230518151443](http://s3.airtlab.com/blog/20230518151443.png)\n\n![20230518151453](http://s3.airtlab.com/blog/20230518151453.png)\n\n![20230518151506](http://s3.airtlab.com/blog/20230518151506.png)\n\n![20230518151537](http://s3.airtlab.com/blog/20230518151537.png)\n\n![20230518151556](http://s3.airtlab.com/blog/20230518151556.png)","isLeaf":true},{"key":"/Babel/01 基础教程/08-plugin-order.md","path":"/Babel/01 基础教程/08-plugin-order.md","route":"/Babel/01 基础教程/08-plugin-order.md","leaf":true,"title":"08-plugin-order","depth":2,"content":"---\ntitle: 08 plugin 的顺序\ntags: Babel\n---\n\nbabel 插件按顺序执行，那么插件的先后顺序是如何决定的呢？比如在一个项目中使用 React 和 Typescript，那么识别 ts 的语法插件在前面，还是识别 jsx 的语法的插件在前面？\n\n- Plugin 会运行在 Preset 之前。\n- Plugin 会从前到后顺序执行。\n- Preset 的顺序则 刚好相反(从后向前)。\n\n很明显，谁在前，谁就得支持两种语法，`@babel/preset-typescript` 已经支持了 jsx 语法\n\n![20230705145919](http://s3.airtlab.com/blog/20230705145919.png)\n\n`@babel/preset-typescript` 底层依赖，plugin-syntax-typescript ","isLeaf":true}]},{"key":"/Babel/02 Babel API","path":"/Babel/02 Babel API","route":"/Babel/02 Babel API","leaf":false,"title":"02 Babel API","depth":1,"content":"","isLeaf":false,"children":[{"key":"/Babel/02 Babel API/01-@babel_core.md","path":"/Babel/02 Babel API/01-@babel_core.md","route":"/Babel/02 Babel API/01-@babel_core.md","leaf":true,"title":"01-@babel_core","depth":2,"content":"---\ntitle: 01 @babel/core\ntags: Babel\n---\n\n@babel/core 暴露了 `源代码 => AST => 目标代码` 整个过程所需要的方法。\n\n## 1. transform\n\ntransform 方法将源代码处理后返回目标代码，sourcemap 代码，以及ast：\n\n```javascript\n/**\n * @param string code 源代码\n * @param object options 配置项\n * @param function callback 回调函数\n */\nbabel.transform(code: string, options?: Object, callback: Function)\n```\n\n```javascript\nconst babel = require(\"@babel/core\");\nconst code = `const name = 1`\nconst options = {}\n\nbabel.transform(code, options, function(err, result) {\n  result; // => { code, map, ast }\n  console.log(result)\n});\n```\n\n如果需要 ast 和 sourcemap:\n\n```javascript\nconst babel = require(\"@babel/core\");\nconst sourceCode = `var count = 1`\n\nbabel.transform(sourceCode, { ast: true, inputSourceMap: true }, function(err, result) {\n  result; // => { code, map, ast }\n  console.log(result)\n});\n```\n\n这里的 options 用于配置 plugins，helpers 等等，后面会详细介绍。另外 bable 还提供了 transform 的同步方法 transformSync，以及异步Promise API transformAsync:\n\n```javascript\n// 同步API\nvar result = babel.transformSync(\"code();\", options);\nresult.code;\nresult.map;\nresult.ast;\n\n// 异步API\nbabel.transformAsync(\"code();\", options).then(result => {\n  result.code;\n  result.map;\n  result.ast;\n});\n```\n\n## 2. transformFile\n\ntransformFile 用于转换整个JS文件：\n\n```javascript\nbabel.transformFile(filename: string, options?: Object, callback: Function)\n```\n\n其函数签名和 transform 差不多，只是第一个参数从源代码 code 变为了文件路径 filename：\n\n```javascript\nbabel.transformFile(\"filename.js\", options, function (err, result) {\n  result; // => { code, map, ast }\n});\n```\n\n类似的，transformFile 也额外提供了同步和异步API，transformFileSync 和 transformFileAsync。\n\n## 3. parse\n\n该方法会扫码源代码，返回一个 AST，并且 @babel/core 同样额外提供了 parse 方法的异步和同步API: parseAsync 和 parseSync。\n\n```javascript\nbabel.parse(code: string, options?: Object, callback: Function)\n```\n\n```javascript\nconst babel = require(\"@babel/core\");\nconst sourceCode = `var count = 1`\n\nbabel.parse(sourceCode, function(err, result) {\n  console.log(JSON.stringify(result))\n});\n```\n\n结果如下：\n\n```javascript\n{\n\t\"type\": \"File\",\n\t\"start\": 0,\n\t\"end\": 13,\n\t\"loc\": {\n\t\t\"start\": {\n\t\t\t\"line\": 1,\n\t\t\t\"column\": 0\n\t\t},\n\t\t\"end\": {\n\t\t\t\"line\": 1,\n\t\t\t\"column\": 13\n\t\t}\n\t},\n\t\"errors\": [],\n\t\"program\": {\n\t\t\"type\": \"Program\",\n\t\t\"start\": 0,\n\t\t\"end\": 13,\n\t\t\"loc\": {\n\t\t\t\"start\": {\n\t\t\t\t\"line\": 1,\n\t\t\t\t\"column\": 0\n\t\t\t},\n\t\t\t\"end\": {\n\t\t\t\t\"line\": 1,\n\t\t\t\t\"column\": 13\n\t\t\t}\n\t\t},\n\t\t\"sourceType\": \"module\",\n\t\t\"interpreter\": null,\n\t\t\"body\": [{\n\t\t\t\"type\": \"VariableDeclaration\",\n\t\t\t\"start\": 0,\n\t\t\t\"end\": 13,\n\t\t\t\"loc\": {\n\t\t\t\t\"start\": {\n\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\"column\": 0\n\t\t\t\t},\n\t\t\t\t\"end\": {\n\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\"column\": 13\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"declarations\": [{\n\t\t\t\t\"type\": \"VariableDeclarator\",\n\t\t\t\t\"start\": 4,\n\t\t\t\t\"end\": 13,\n\t\t\t\t\"loc\": {\n\t\t\t\t\t\"start\": {\n\t\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\t\"column\": 4\n\t\t\t\t\t},\n\t\t\t\t\t\"end\": {\n\t\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\t\"column\": 13\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"id\": {\n\t\t\t\t\t\"type\": \"Identifier\",\n\t\t\t\t\t\"start\": 4,\n\t\t\t\t\t\"end\": 9,\n\t\t\t\t\t\"loc\": {\n\t\t\t\t\t\t\"start\": {\n\t\t\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\t\t\"column\": 4\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"end\": {\n\t\t\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\t\t\"column\": 9\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"identifierName\": \"count\"\n\t\t\t\t\t},\n\t\t\t\t\t\"name\": \"count\"\n\t\t\t\t},\n\t\t\t\t\"init\": {\n\t\t\t\t\t\"type\": \"NumericLiteral\",\n\t\t\t\t\t\"start\": 12,\n\t\t\t\t\t\"end\": 13,\n\t\t\t\t\t\"loc\": {\n\t\t\t\t\t\t\"start\": {\n\t\t\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\t\t\"column\": 12\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"end\": {\n\t\t\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\t\t\"column\": 13\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\"extra\": {\n\t\t\t\t\t\t\"rawValue\": 1,\n\t\t\t\t\t\t\"raw\": \"1\"\n\t\t\t\t\t},\n\t\t\t\t\t\"value\": 1\n\t\t\t\t}\n\t\t\t}],\n\t\t\t\"kind\": \"var\"\n\t\t}],\n\t\t\"directives\": []\n\t},\n\t\"comments\": []\n}\n```\n\n## 4. transformFromAst\n\n给定一个 [AST](https://astexplorer.net/) ，将它进行转换为和parser方法输入一致的结果，也算是将 parse 方法的输入进行反序列化：\n\n```javascript\nbabel.transformFromAst(ast: Object, code?: string, options?: Object, callback: Function): FileNode | null\n```\n\n```javascript\nvar babel = require(\"@babel/core\");\n\nconst sourceCode = `var count = 1`\n\nbabel.parse(sourceCode, function(err, result) {\n  if (err) {\n    console.log(err);\n    return;\n  }\n\n  // babel.transformFromAst(result, function(err, res) {\n  //   console.log(res) // res === JSON.string(result)\n  // })\n\n  babel.transformFromAst(result, undefined, { ast: true }, function(err, res) {\n    console.log(res)\n  })\n});\n```\n\n## 5. Advanced APIs\n\n许多使用了Babel的系统都喜欢自动注入 plugins 和 presets，或覆盖选项。为了实现此目标，Babel 公开了一些功能，这些功能有助于在不进行转换的情况下部分加载配置。\n\n\n### 5.1 loadOptions\n\n用于解析 Babel 的选项，产生一个 option 对象\n\n```javascript\nbabel.loadOptions(options?: Object)\n```\n\n代码：\n\n```javascript\nvar babel = require(\"@babel/core\");\n\nconst res = babel.loadOptions({\n  \"plugins\": [\"@babel/plugin-transform-arrow-functions\"]\n})\n\nconsole.log(res)\n```\n\n输出：\n\n![20230608023018](http://s3.airtlab.com/blog/20230608023018.png)\n\n### 5.2 loadPartialConfig\n\n```javascript\nbabel.loadPartialConfig(options?: Object): PartialConfig\n```\n\n### 5.3 createConfigItem\n\n```javascript\nbabel.createConfigItem(value: string | {} | Function | [string | {} | Function, {} | void], { dirname?: string, type?: \"preset\" | \"plugin\" }): ConfigItem\n```\n\n## 6. Options 配置\n\n参考文档 <https://babeljs.io/docs/en/options>","isLeaf":true},{"key":"/Babel/02 Babel API/02-@babel_generator.md","path":"/Babel/02 Babel API/02-@babel_generator.md","route":"/Babel/02 Babel API/02-@babel_generator.md","leaf":true,"title":"02-@babel_generator","depth":2,"content":"---\ntitle: 02 @babel/generator\ntags: Babel\n---\n\n```javascript\nimport {parse} from '@babel/parser';\nimport generate from '@babel/generator';\n\nconst code = 'class Example {}';\nconst ast = parse(code);\n\nconst output = generate(ast, { /* options */ }, code);\n```\n\n## 1、格式化输出的选项\n\n| 选项名 | 类型 | 默认值 | 描述 |\n| :--- | :--- | :--- | :--- |\n| auxiliaryCommentBefore | string |  | 可选字符串，在输出文件的开始添加块注释 |\n| auxiliaryCommentAfter | string |  | 可选字符串，在输出文件的末尾添加块注释 |\n| shouldPrintComment | function | opts.comments | 如果注释需要包含在输出中，该函数则需接受注释（作为字符串）并返回 true 。 默认情况下，如果 opts.commoents 为 true 或者 opts.minifed 为 false 并且注释中包含 @preserve 或 @license，则包含注释。 |\n| retainLines | boolean | false | 尝试在输出的代码中使用与源代码相同的行号(有助于保留栈信息跟踪) |\n| retainFunctionParens | boolean | false | 保留函数表达式的上下级 (可用于更改引擎解析行为) |\n| comments | boolean | true | 输出中是否包含注释 |\n| compact | boolean or 'auto' | opts.minified | 设置为 true 以避免添加用于格式化的空格 |\n| minified | boolean | false | 输出是否被压缩 |\n| concise | boolean | false | 设置为 true 以减少空格 (但效果不如 opts.compact ) |\n| quotes | 'single' or 'double' | 基于 ast.tokens 的自动检测 | 输出中对引号的类型进行保留 |\n| filename | string |  | 在警告信息中使用 |\n| flowCommaSeparator | boolean | false | 设置为 true 以使用逗号而不是分号作为 Flow 属性的分隔符 |\n| jsonCompatibleStrings | boolean | false | 设置为 true，使用 \"json\" 运行 jsesc：正确的将 \"\\u00A9\" 打印为 \"©\" ; |\n\nsource maps 的选项:\n\n| 选项名 | 类型 | 默认值 | 描述 |\n| :--- | :--- | :--- | :--- |\n| sourceMaps | boolean | false | 启用生成 source maps |\n| sourceMapTarget | string |  | source map 会与生成代码的文件名进行关联 |\n| sourceRoot | string |  | source map 中所有对应 URLs 的 root |\n| sourceFileName | string |  | 源代码（例如，  code 参数中的代码）的文件名。只会在 code 为字符串时使用。 |\n\n\n## 2、多个来源构建 AST\n\n在大多数情况下，Babel 会将输入文件与输出文件进行 1:1 转换。然而，你可能正在处理从多个来源构建的 AST - JS 文件，模板等。如果出现这种情况，并且你还希望 source map 为你提供正确的来源，则需要将一个对象作为 `code` 参数传递给 `generate`。其中键应该为源文件名称，值应该为源内容。\n\n```javascript\nconst { parse } = require('@babel/parser');\nconst generate = require('@babel/generator').default;\n\nconst a = 'var a = 1;';\nconst b = 'var b = 2;';\n\nconst astA = parse(a, { sourceFilename: 'a.js' });\nconst astB = parse(b, { sourceFilename: 'b.js' });\n\nconst ast = {\n  type: 'Program',\n  body: [].concat(astA.program.body, astB.program.body)\n};\n\nconst { code, map } = generate(ast, { sourceMaps: true }, {\n  'a.js': a,\n  'b.js': b\n});\n\nconsole.log(code)\nconsole.log(map)\n```\n","isLeaf":true},{"key":"/Babel/02 Babel API/03-@babel_helpers.md","path":"/Babel/02 Babel API/03-@babel_helpers.md","route":"/Babel/02 Babel API/03-@babel_helpers.md","leaf":true,"title":"03-@babel_helpers","depth":2,"content":"---\ntitle: 03 @babel/helpers\ntags: Babel\n---\n\n该模块用于提供了编译时的一些帮助函数。\n\n```javascript\nimport * as helpers from '@babel/helpers';\nimport * as t from '@babel/types';\n\nconst typeofHelper = helpers.get('typeof');\n\nt.isExpressionStatement(typeofHelper);\n// true\n```","isLeaf":true},{"key":"/Babel/02 Babel API/04-@babel_parser.md","path":"/Babel/02 Babel API/04-@babel_parser.md","route":"/Babel/02 Babel API/04-@babel_parser.md","leaf":true,"title":"04-@babel_parser","depth":2,"content":"---\ntitle: 04 @babel/parser\ntags: Babel\n---\n\n## 1、@babel/parser 是什么\n\n@babel/parser 主要的任务是将源代码生成AST抽象语法树。按照官网的介绍，@babel/parser 应该在 [acorn](https://github.com/marijnh/acorn) 和 [acorn-jsx](https://github.com/RReverser/acorn-jsx) 的基础上开发的，虽然 @babel/parser 的源码没有依赖 acorn 模块，其中 acorn 主要包含以下3个模块：\n\n> - [acorn](https://github.com/acornjs/acorn/blob/master/acorn/): The main parser 主要的解释器\n> - [acorn-loose](https://github.com/acornjs/acorn/blob/master/acorn-loose/): The error-tolerant parser 错误处理\n> - [acorn-walk](https://github.com/acornjs/acorn/blob/master/acorn-walk/): The syntax tree walker 语法树的遍历\n\n## 2、@babel/parser 源码定义\n\n在 @babel/parser 的 d.ts 文件可以看到，它只提供了两个方法：\n![20230608023126](http://s3.airtlab.com/blog/20230608023126.png)\n\n```typescript\n/**\n * Parse the provided code as an entire ECMAScript program.\n * 解析完整的 ECMAScript 程序\n */\nexport function parse(input: string, options?: ParserOptions): import('@babel/types').File;\n\n/**\n * Parse the provided code as a single expression.\n * 仅仅解析 ECMAScript 表达式\n */\nexport function parseExpression(input: string, options?: ParserOptions): import('@babel/types').Expression;\n```\n\n除此之外还提供了一些 type：\n\n- ParserOptions\n- ParserPlugin\n- ParserPluginWithOptions\n- DecoratorsPluginOptions\n- PipelineOperatorPluginOptions\n- FlowPluginOptions <a name=\"zJB8k\"></a>\n\n## 3、API\n\n### 3.1、parse(code, \\[options])\n\n解析完整的 ECMAScript 程序\n\n```typescript\nconst parser = require('@babel/parser');\n// console.log(parser.parse('const name = 123'))\nconsole.log(JSON.stringify(parser.parse('const name = 123')))\n```\n\n解析后的语法树为：\n\n```javascript\n{\n\t\"type\": \"File\",\n\t\"start\": 0,\n\t\"end\": 16,\n\t\"loc\": {\n\t\t\"start\": {\n\t\t\t\"line\": 1,\n\t\t\t\"column\": 0\n\t\t},\n\t\t\"end\": {\n\t\t\t\"line\": 1,\n\t\t\t\"column\": 16\n\t\t}\n\t},\n\t\"errors\": [],\n\t\"program\": {\n\t\t\"type\": \"Program\",\n\t\t\"start\": 0,\n\t\t\"end\": 16,\n\t\t\"loc\": {\n\t\t\t\"start\": {\n\t\t\t\t\"line\": 1,\n\t\t\t\t\"column\": 0\n\t\t\t},\n\t\t\t\"end\": {\n\t\t\t\t\"line\": 1,\n\t\t\t\t\"column\": 16\n\t\t\t}\n\t\t},\n\t\t\"sourceType\": \"script\",\n\t\t\"interpreter\": null,\n\t\t\"body\": [{\n\t\t\t\"type\": \"VariableDeclaration\",\n\t\t\t\"start\": 0,\n\t\t\t\"end\": 16,\n\t\t\t\"loc\": {\n\t\t\t\t\"start\": {\n\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\"column\": 0\n\t\t\t\t},\n\t\t\t\t\"end\": {\n\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\"column\": 16\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"declarations\": [{\n\t\t\t\t\"type\": \"VariableDeclarator\",\n\t\t\t\t\"start\": 6,\n\t\t\t\t\"end\": 16,\n\t\t\t\t\"loc\": {\n\t\t\t\t\t\"start\": {\n\t\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\t\"column\": 6\n\t\t\t\t\t},\n\t\t\t\t\t\"end\": {\n\t\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\t\"column\": 16\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"id\": {\n\t\t\t\t\t\"type\": \"Identifier\",\n\t\t\t\t\t\"start\": 6,\n\t\t\t\t\t\"end\": 10,\n\t\t\t\t\t\"loc\": {\n\t\t\t\t\t\t\"start\": {\n\t\t\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\t\t\"column\": 6\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"end\": {\n\t\t\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\t\t\"column\": 10\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"identifierName\": \"name\"\n\t\t\t\t\t},\n\t\t\t\t\t\"name\": \"name\"\n\t\t\t\t},\n\t\t\t\t\"init\": {\n\t\t\t\t\t\"type\": \"NumericLiteral\",\n\t\t\t\t\t\"start\": 13,\n\t\t\t\t\t\"end\": 16,\n\t\t\t\t\t\"loc\": {\n\t\t\t\t\t\t\"start\": {\n\t\t\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\t\t\"column\": 13\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"end\": {\n\t\t\t\t\t\t\t\"line\": 1,\n\t\t\t\t\t\t\t\"column\": 16\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\"extra\": {\n\t\t\t\t\t\t\"rawValue\": 123,\n\t\t\t\t\t\t\"raw\": \"123\"\n\t\t\t\t\t},\n\t\t\t\t\t\"value\": 123\n\t\t\t\t}\n\t\t\t}],\n\t\t\t\"kind\": \"const\"\n\t\t}],\n\t\t\"directives\": []\n\t},\n\t\"comments\": []\n}\n```\n\n### 3.2、parseExpression(code, \\[options])\n\n仅仅解析 ECMAScript 表达式\n\n### 3.3、options\n\n- allowImportExportEverywhere：默认情况下，import 并 export 声明只能出现在一个程序的 top level scope。将此选项设置为true允许在任何位置使用。\n- allowAwaitOutsideFunction：默认情况下，await 仅允许在异步函数内部使用，或者当 topLevelAwait 插件被启用后，在模块的 top level scope 内使用。将其设置为 true，则在脚本的 top-level scope 内可使用。\n- allowReturnOutsideFunction：默认情况下，顶层的 return 语句会引发错误。设置 true 为接受这样的代码。\n\n下面的代码将会引发错误：\n\n```typescript\nconst parser = require('@babel/parser');\n// console.log(JSON.stringify(parser.parse('const name = 123')))\n\nconsole.log(JSON.stringify(parser.parse('return 6', {\n  allowReturnOutsideFunction: false\n})))\n```\n\n![20230608023157](http://s3.airtlab.com/blog/20230608023157.png)\n\n设置 allowReturnOutsideFunction 为 true，将不会报错。\n\n- **allowSuperOutsideMethod**\n\n默认情况下，super 不允许在类和对象方法之外使用，设置 true 为接受这样的代码\n\n- **allowUndeclaredExports**\n\n默认情况下，导出在当前模块作用域中未声明的标识符将引发错误。尽管 ECMAScript 模块规范要求此行为，但Babel 的解析器无法在以后可能会插入适当声明的插件管道中预期转换，因此有时设置此选项`true`以防止解析器过早地抛出异常未声明的导出会很重要。\n\n## 4、Output\n\nBabel解析器根据 [Babel AST格式](https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md) 生成AST 。它基于 [ESTree规范](https://github.com/estree/estree)，但存在以下差异：\n\n![20230608023257](http://s3.airtlab.com/blog/20230608023257.png)\n\n## 5、Plugins\n### 5.1、语言插件\n\n| Name | Code Example |\n| --- | --- |\n| `flow`\n&#x20;([repo](https://github.com/facebook/flow)) | `var a: string = \"\";` |\n| `flowComments`\n&#x20;([docs](https://flow.org/en/docs/types/comments/)) | `/*:: type Foo = {...}; */` |\n| `jsx`\n&#x20;([repo](https://facebook.github.io/jsx/)) | `<a attr=\"b\">{s}</a>` |\n| `typescript`\n&#x20;([repo](https://github.com/Microsoft/TypeScript)) | `var a: string = \"\";` |\n| `v8intrinsic` | `%DebugPrint(foo);` |\n\n\n### 5.2、ECMAScript [proposals](https://github.com/babel/proposals)\n\n| Name | Code Example |\n| --- | --- |\n| `asyncGenerators`\n&#x20;([proposal](https://github.com/tc39/proposal-async-iteration)) | `async function*() {}`\n, `for await (let a of b) {}` |\n| `bigInt`\n&#x20;([proposal](https://github.com/tc39/proposal-bigint)) | `100n` |\n| `classProperties`\n&#x20;([proposal](https://github.com/tc39/proposal-class-public-fields)) | `class A { b = 1; }` |\n| `classPrivateProperties`\n&#x20;([proposal](https://github.com/tc39/proposal-private-fields)) | `class A { #b = 1; }` |\n| `classPrivateMethods`\n&#x20;([proposal](https://github.com/tc39/proposal-private-methods)) | `class A { #c() {} }` |\n| `decorators`\n&#x20;([proposal](https://github.com/tc39/proposal-decorators))\n`decorators-legacy` | `@a class A {}` |\n| `doExpressions`\n&#x20;([proposal](https://github.com/tc39/proposal-do-expressions)) | `var a = do { if (true) { 'hi'; } };` |\n| `dynamicImport`\n&#x20;([proposal](https://github.com/tc39/proposal-dynamic-import)) | `import('./guy').then(a)` |\n| `exportDefaultFrom`\n&#x20;([proposal](https://github.com/leebyron/ecmascript-export-default-from)) | `export v from \"mod\"` |\n| `exportNamespaceFrom`\n&#x20;([proposal](https://github.com/leebyron/ecmascript-export-ns-from)) | `export * as ns from \"mod\"` |\n| `functionBind`\n&#x20;([proposal](https://github.com/zenparsing/es-function-bind)) | `a::b`\n, `::console.log` |\n| `functionSent` | `function.sent` |\n| `importMeta`\n&#x20;([proposal](https://github.com/tc39/proposal-import-meta)) | `import.meta.url` |\n| `logicalAssignment`\n&#x20;([proposal](https://github.com/tc39/proposal-logical-assignment)) | `a &&= b` |\n| `nullishCoalescingOperator`\n&#x20;([proposal](https://github.com/babel/proposals/issues/14)) | `a ?? b` |\n| `numericSeparator`\n&#x20;([proposal](https://github.com/samuelgoto/proposal-numeric-separator)) | `1_000_000` |\n| `objectRestSpread`\n&#x20;([proposal](https://github.com/tc39/proposal-object-rest-spread)) | `var a = { b, ...c };` |\n| `optionalCatchBinding`\n&#x20;([proposal](https://github.com/babel/proposals/issues/7)) | `try {throw 0;} catch{do();}` |\n| `optionalChaining`\n&#x20;([proposal](https://github.com/tc39/proposal-optional-chaining)) | `a?.b` |\n| `partialApplication`\n&#x20;([proposal](https://github.com/babel/proposals/issues/32)) | `f(?, a)` |\n| `pipelineOperator`\n&#x20;([proposal](https://github.com/babel/proposals/issues/29)) | `a &#124;> b` |\n| `throwExpressions`\n&#x20;([proposal](https://github.com/babel/proposals/issues/23)) | `() => throw new Error(\"\")` |\n| `topLevelAwait`\n&#x20;([proposal](https://github.com/tc39/proposal-top-level-await/)) | `await promise`\n&#x20;in modules |\n\n## 6、sourceType\n\nsourceType 可以是 \"module\" 或者 \"script\"，它表示 Babylon 应该用哪种模式来解析。 \"module\" 将会在严格模式下解析并且允许模块定义，\"script\" 则不会。\n\n## 7、Example\n\n```typescript\nrequire(\"@babel/parser\").parse(\"code\", {\n  // parse in strict mode and allow module declarations\n  sourceType: \"module\",\n\n  plugins: [\n    // enable jsx and flow syntax\n    \"jsx\",\n    \"flow\"\n  ]\n});\n```\n\n## 8、参考文档\n- [1] acorn github <https://github.com/acornjs/acorn>\n- [2] estree 规范 <https://github.com/estree/estree>","isLeaf":true},{"key":"/Babel/02 Babel API/05-@babel_runtime.md","path":"/Babel/02 Babel API/05-@babel_runtime.md","route":"/Babel/02 Babel API/05-@babel_runtime.md","leaf":true,"title":"05-@babel_runtime","depth":2,"content":"---\ntitle: 05 @babel/runtime\ntags: Babel\n---\n\n5、@babel/runtime\n\n该库提供了一些运行时的帮助函数，避免了在每个文件中都定了一份帮助函数，而统一从 @babel/runtime 中引入。@babel/runtime 主要包含 运行时的 helpers 函数 以及 regenerator runtime。\n\nbabel-plugin-transform-runtime 和 babel-runtime 的区别：\n\n- babel-plugin-transform-runtime 内部依赖了 babel-runtime","isLeaf":true},{"key":"/Babel/02 Babel API/06-@babel_traverse.md","path":"/Babel/02 Babel API/06-@babel_traverse.md","route":"/Babel/02 Babel API/06-@babel_traverse.md","leaf":true,"title":"06-@babel_traverse","depth":2,"content":"---\ntitle: 06 @babel/traverse\ntags: Babel\n---\n\n## 预备知识\n\n### Paths（路径）\n\nAST 通常会有许多节点，那么节点直接如何相互关联呢？ 我们可以使用一个可操作和访问的巨大可变对象表示节点之间的关联关系，或者也可以用Paths（路径）来简化这件事情。Path 是表示两个节点之间连接的对象。例如，如果有下面这样一个节点及其子节点︰\n\n```json\n{\n  \"parent\": {\n    \"type\": \"FunctionDeclaration\",\n    \"id\": {...},\n    ....\n  },\n  \"node\": {\n    \"type\": \"Identifier\",\n    \"name\": \"square\"\n  }\n}\n```\n\n同时它还包含关于该路径的其他元数据：\n\n```json\n{\n  \"parent\": {...},\n  \"node\": {...},\n  \"hub\": {...},\n  \"contexts\": [],\n  \"data\": {},\n  \"shouldSkip\": false,\n  \"shouldStop\": false,\n  \"removed\": false,\n  \"state\": null,\n  \"opts\": null,\n  \"skipKeys\": null,\n  \"parentPath\": null,\n  \"context\": null,\n  \"container\": null,\n  \"listKey\": null,\n  \"inList\": false,\n  \"parentKey\": null,\n  \"key\": null,\n  \"scope\": null,\n  \"type\": null,\n  \"typeAnnotation\": null\n}\n```\n\n当然路径对象还包含添加、更新、移动和删除节点有关的其他很多方法，稍后我们再来看这些方法。在某种意义上，路径是一个节点在树中的位置以及关于该节点各种信息的响应式 **Reactive** 表示。 当你调用一个修改树的方法后，路径信息也会被更新。 Babel 帮你管理这一切，从而使得节点操作简单，尽可能做到无状态。\n\n### Paths in Visitors（访问者中的路径）\n\n当你有一个 `Identifier()` 成员方法的访问者时，你实际上是在访问路径而非节点。 通过这种方式，你操作的就是节点的响应式表示（译注：即路径）而非节点本身。\n\n```json\nconst MyVisitor = {\n  Identifier(path) {\n    console.log(\"Visiting: \" + path.node.name);\n  }\n};\n```\n\n## Visiting 访问\n\n### Get the Path of Sub-Node\n\n为了得到一个AST节点的属性值，我们一般先访问到该节点，然后利用 path.node.property 方法即可： <a name=\"kxNY7\"></a>\n\n## 转换操作\n\n### 访问\n\n#### 获取子节点的Path\n\n为了得到一个AST节点的属性值，我们一般先访问到该节点，然后利用 `path.node.property` 方法即可：\n\n```javascript\n// 获取子节点的Path\n// 下面的例子遍历所有 BinaryExpression, 这里只有一个\n\nimport * as parser from \"@babel/parser\";\nimport traverse from \"@babel/traverse\";\nimport generate from '@babel/generator';\n\nconst code = `function square(n) {\n  return n * n;\n}`;\n\nconst ast = parser.parse(code);\n\ntraverse(ast, {\n  BinaryExpression(path) {\n    console.log(path.node.left) // Identifier Node\n    console.log(path.node.right) // Identifier Node\n    console.log(path.node.operator) // \"*\"\n  }\n});\n```\n\n#### 检查节点的类型\n\n```js\n// 改变函数参数的例子\n\nimport * as parser from \"@babel/parser\";\nimport traverse from \"@babel/traverse\";\nimport generate from '@babel/generator';\nimport helpers from '@babel/helpers';\nimport * as t from '@babel/types';\n\nconst code = `function square(n) {\n  return n * fn(n);\n}`;\n\nconst ast = parser.parse(code);\n\ntraverse(ast, {\n  BinaryExpression(path) {\n    // path.node.left: Identifier 标识符\n    // path.node.right: CallExpression 函数调用表达式\n    if(t.isIdentifier(path.node.left)) {\n      console.log(path.node)\n    }\n  }\n});\n```\n\n#### 检查路径（Path）类型\n\n```javascript\nBinaryExpression(path) {\n  if (path.get('left').isIdentifier({ name: \"n\" })) {\n    // ...\n  }\n}\n\n// 相当于\nBinaryExpression(path) {\n  if (t.isIdentifier(path.node.left, { name: \"n\" })) {\n    // ...\n  }\n}\n```\n\n#### 检查标识符（Identifier）是否被引用\n\n```javascript\n// 改变函数参数的例子\n\nimport * as parser from \"@babel/parser\";\nimport traverse from \"@babel/traverse\";\nimport generate from '@babel/generator';\nimport * as t from '@babel/types';\n\nconst code = `function square(n) {\n  return n * n;\n}`;\n\nconst ast = parser.parse(code);\n\ntraverse(ast, {\n  Identifier(path) {\n    if (path.isReferencedIdentifier()) {\n      // console.log(path.node)\n    }\n  }\n});\n```\n\n## 演示例子\n\n### 修改函数参数\n\n```javascript\n// 改变函数参数的例子\n\nimport * as parser from \"@babel/parser\";\nimport traverse from \"@babel/traverse\";\nimport generate from '@babel/generator';\n\nconst code = `function square(n) {\n  return n * n;\n}`;\n\nconst ast = parser.parse(code);\n\ntraverse(ast, {\n  enter(path) {\n    if (path.isIdentifier({ name: \"n\" })) {\n      path.node.name = \"x\";\n    }\n  }\n});\n\nconst output = generate(ast, { /* options */ }, code);\n\nconsole.log(output.code);\n\n// function square(x) {\n//   return x * x;\n// }\n```\n","isLeaf":true},{"key":"/Babel/02 Babel API/07-@babel_types.md","path":"/Babel/02 Babel API/07-@babel_types.md","route":"/Babel/02 Babel API/07-@babel_types.md","leaf":true,"title":"07-@babel_types","depth":2,"content":"---\ntitle: 07 @babel/types\n---\n\n## Identify 标识符\n\n## Expression 表达式\n\n## Statement 语句\n\n## Literal 字面量\n","isLeaf":true},{"key":"/Babel/02 Babel API/08-@babel_template.md","path":"/Babel/02 Babel API/08-@babel_template.md","route":"/Babel/02 Babel API/08-@babel_template.md","leaf":true,"title":"08-@babel_template","depth":2,"content":"","isLeaf":true}]},{"key":"/Babel/03 插件开发","path":"/Babel/03 插件开发","route":"/Babel/03 插件开发","leaf":false,"title":"03 插件开发","depth":1,"content":"","isLeaf":false,"children":[{"key":"/Babel/03 插件开发/01-docs.md","path":"/Babel/03 插件开发/01-docs.md","route":"/Babel/03 插件开发/01-docs.md","leaf":true,"title":"01-docs","depth":2,"content":"---\ntitle: 01 开发文档\nurl: https://www.yuque.com/gaollard/ubc1q5/kiltvy\n---\n\n<https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-get-the-path-of-a-sub-node>\n","isLeaf":true},{"key":"/Babel/03 插件开发/02-ast.md","path":"/Babel/03 插件开发/02-ast.md","route":"/Babel/03 插件开发/02-ast.md","leaf":true,"title":"02-ast","depth":2,"content":"---\ntitle: 02 AST 遍历\nurl: https://www.yuque.com/gaollard/ubc1q5/mvu0v5\n---\n\n<a name=\"YuHXc\"></a>\n\n### Visitors（访问者）\n\n![20230608092029](http://s3.airtlab.com/blog/20230608092029.png)\n\n***\n\n![20230608092045](http://s3.airtlab.com/blog/20230608092045.png)\n\n***\n![20230608092113](http://s3.airtlab.com/blog/20230608092113.png)\n\n***\n\n![20230608092145](http://s3.airtlab.com/blog/20230608092145.png)\n\n***\n\n![20230608092200](http://s3.airtlab.com/blog/20230608092200.png)\n","isLeaf":true},{"key":"/Babel/03 插件开发/03-node.md","path":"/Babel/03 插件开发/03-node.md","route":"/Babel/03 插件开发/03-node.md","leaf":true,"title":"03-node","depth":2,"content":"---\ntitle: 03 Node 节点\nurl: https://www.yuque.com/gaollard/ubc1q5/vqxtr7\n---\n\n### 1、Node 介绍\n\n![20230608092219](http://s3.airtlab.com/blog/20230608092219.png)\n\n![20230608092257](http://s3.airtlab.com/blog/20230608092257.png)\n\n### 2、Node 定义\n\n```typescript\ninterface BaseNode {\n  type: Node[\"type\"];\n  leadingComments?: Comment[] | null;\n  innerComments?: Comment[] | null;\n  trailingComments?: Comment[] | null;\n  start?: number | null;\n  end?: number | null;\n  loc?: SourceLocation | null;\n  range?: [number, number];\n  extra?: Record<string, unknown>;\n}\n```\n\n```typescript\ndeclare type Node = AnyTypeAnnotation | ArgumentPlaceholder | ArrayExpression | ArrayPattern | ArrayTypeAnnotation | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BigIntLiteral | BinaryExpression | BindExpression | BlockStatement | BooleanLiteral | BooleanLiteralTypeAnnotation | BooleanTypeAnnotation | BreakStatement | CallExpression | CatchClause | ClassAccessorProperty | ClassBody | ClassDeclaration | ClassExpression | ClassImplements | ClassMethod | ClassPrivateMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | ContinueStatement | DebuggerStatement | DecimalLiteral | DeclareClass | DeclareExportAllDeclaration | DeclareExportDeclaration | DeclareFunction | DeclareInterface | DeclareModule | DeclareModuleExports | DeclareOpaqueType | DeclareTypeAlias | DeclareVariable | DeclaredPredicate | Decorator | Directive | DirectiveLiteral | DoExpression | DoWhileStatement | EmptyStatement | EmptyTypeAnnotation | EnumBooleanBody | EnumBooleanMember | EnumDeclaration | EnumDefaultedMember | EnumNumberBody | EnumNumberMember | EnumStringBody | EnumStringMember | EnumSymbolBody | ExistsTypeAnnotation | ExportAllDeclaration | ExportDefaultDeclaration | ExportDefaultSpecifier | ExportNamedDeclaration | ExportNamespaceSpecifier | ExportSpecifier | ExpressionStatement | File | ForInStatement | ForOfStatement | ForStatement | FunctionDeclaration | FunctionExpression | FunctionTypeAnnotation | FunctionTypeParam | GenericTypeAnnotation | Identifier | IfStatement | Import | ImportAttribute | ImportDeclaration | ImportDefaultSpecifier | ImportNamespaceSpecifier | ImportSpecifier | IndexedAccessType | InferredPredicate | InterfaceDeclaration | InterfaceExtends | InterfaceTypeAnnotation | InterpreterDirective | IntersectionTypeAnnotation | JSXAttribute | JSXClosingElement | JSXClosingFragment | JSXElement | JSXEmptyExpression | JSXExpressionContainer | JSXFragment | JSXIdentifier | JSXMemberExpression | JSXNamespacedName | JSXOpeningElement | JSXOpeningFragment | JSXSpreadAttribute | JSXSpreadChild | JSXText | LabeledStatement | LogicalExpression | MemberExpression | MetaProperty | MixedTypeAnnotation | ModuleExpression | NewExpression | Noop | NullLiteral | NullLiteralTypeAnnotation | NullableTypeAnnotation | NumberLiteral$1 | NumberLiteralTypeAnnotation | NumberTypeAnnotation | NumericLiteral | ObjectExpression | ObjectMethod | ObjectPattern | ObjectProperty | ObjectTypeAnnotation | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeInternalSlot | ObjectTypeProperty | ObjectTypeSpreadProperty | OpaqueType | OptionalCallExpression | OptionalIndexedAccessType | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelinePrimaryTopicReference | PipelineTopicExpression | Placeholder | PrivateName | Program | QualifiedTypeIdentifier | RecordExpression | RegExpLiteral | RegexLiteral$1 | RestElement | RestProperty$1 | ReturnStatement | SequenceExpression | SpreadElement | SpreadProperty$1 | StaticBlock | StringLiteral | StringLiteralTypeAnnotation | StringTypeAnnotation | Super | SwitchCase | SwitchStatement | SymbolTypeAnnotation | TSAnyKeyword | TSArrayType | TSAsExpression | TSBigIntKeyword | TSBooleanKeyword | TSCallSignatureDeclaration | TSConditionalType | TSConstructSignatureDeclaration | TSConstructorType | TSDeclareFunction | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSExpressionWithTypeArguments | TSExternalModuleReference | TSFunctionType | TSImportEqualsDeclaration | TSImportType | TSIndexSignature | TSIndexedAccessType | TSInferType | TSInstantiationExpression | TSInterfaceBody | TSInterfaceDeclaration | TSIntersectionType | TSIntrinsicKeyword | TSLiteralType | TSMappedType | TSMethodSignature | TSModuleBlock | TSModuleDeclaration | TSNamedTupleMember | TSNamespaceExportDeclaration | TSNeverKeyword | TSNonNullExpression | TSNullKeyword | TSNumberKeyword | TSObjectKeyword | TSOptionalType | TSParameterProperty | TSParenthesizedType | TSPropertySignature | TSQualifiedName | TSRestType | TSStringKeyword | TSSymbolKeyword | TSThisType | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeLiteral | TSTypeOperator | TSTypeParameter | TSTypeParameterDeclaration | TSTypeParameterInstantiation | TSTypePredicate | TSTypeQuery | TSTypeReference | TSUndefinedKeyword | TSUnionType | TSUnknownKeyword | TSVoidKeyword | TaggedTemplateExpression | TemplateElement | TemplateLiteral | ThisExpression | ThisTypeAnnotation | ThrowStatement | TopicReference | TryStatement | TupleExpression | TupleTypeAnnotation | TypeAlias | TypeAnnotation | TypeCastExpression | TypeParameter | TypeParameterDeclaration | TypeParameterInstantiation | TypeofTypeAnnotation | UnaryExpression | UnionTypeAnnotation | UpdateExpression | V8IntrinsicIdentifier | VariableDeclaration | VariableDeclarator | Variance | VoidTypeAnnotation | WhileStatement | WithStatement | YieldExpression;\n```\n","isLeaf":true},{"key":"/Babel/03 插件开发/04-path.md","path":"/Babel/03 插件开发/04-path.md","route":"/Babel/03 插件开发/04-path.md","leaf":true,"title":"04-path","depth":2,"content":"---\ntitle: 04 Path 路径\nurl: https://www.yuque.com/gaollard/ubc1q5/yhzw27\n---\n\n<a name=\"jNaIt\"></a>\n\n### 1、Path 介绍\n\n![20230608092337](http://s3.airtlab.com/blog/20230608092337.png)\n\n***\n\n![20230608092353](http://s3.airtlab.com/blog/20230608092353.png)\n\n### 2、Paths in Visitors（存在于访问者中的路径）\n\n![20230608092412](http://s3.airtlab.com/blog/20230608092412.png)\n\n### 3、demo 演示\n\n```javascript\nconst fs = require('fs');\nconst babel = require(\"@babel/core\");\n\nconst MyVisitor = {\n  Identifier(path) {\n    console.log(\"Visiting: \" + path.node.name);\n  }\n};\n\nfunction MyPlugin() {\n  return {\n    visitor: MyVisitor\n  }\n}\n\nvar res = babel.transformSync(\"var code = 1; var fn = () => {}\", {\n  ast: true,\n  plugins: [\n    require('@babel/plugin-transform-arrow-functions'),\n    MyPlugin\n  ]\n});\n\nconsole.log(res.code);\n```\n","isLeaf":true},{"key":"/Babel/03 插件开发/05-binding.md","path":"/Babel/03 插件开发/05-binding.md","route":"/Babel/03 插件开发/05-binding.md","leaf":true,"title":"05-binding","depth":2,"content":"---\ntitle: 05 Bindings（绑定）\nurl: https://www.yuque.com/gaollard/ubc1q5/rw3qxv\n---\n\n一个作用域可以创建变量，这种关系被称为绑定。\n\n```typescript\nfunction scopeOnce() {\n  var ref = \"This is a binding\";\n\n  ref; // This is a reference to a binding\n\n  function scopeTwo() {\n    ref; // This is a reference to a binding from a lower scope\n  }\n}\n```\n\n## 1、Binding 的定义\n\n```typescript\nexport type BindingKind = 'var' | 'let' | 'const' | 'module' | 'hoisted' | 'param' | 'local' | 'unknown';\n\nexport class Binding {\n    constructor(opts: { identifier: t.Identifier; scope: Scope; path: NodePath; kind: BindingKind });\n    identifier: t.Identifier;\n    scope: Scope;\n    path: NodePath;\n    kind: BindingKind;\n    referenced: boolean;            // 是否被引用\n    references: number;             // 被引用次数\n    referencePaths: NodePath[];     // 被引用的路径\n    constant: boolean;              // 是否被修改\n    constantViolations: NodePath[];\n    hasDeoptedValue?: boolean;\n    hasValue?: boolean;\n    value?: any;\n\n    deopValue(): void;\n    setValue(value: any): void;\n    clearValue(): void;\n\n    reassign(path: NodePath): void;\n    reference(path: NodePath): void;\n    dereference(): void;\n}\n```\n\n有了这些信息你就可以查找一个绑定的所有引用，并且知道这是什么类型的绑定(参数，定义等等)，查找它所属的作用域，或者拷贝它的标识符。 你甚至可以知道它是不是常量，如果不是，那么是哪个路径修改了它。 <a name=\"I31IK\"></a>\n\n## 2、代码辅助理解\n\n### 1. 引用次数 \\[references]\n\n```typescript\nfunction test1() {\n  var a = 10;\n  console.log(a);\n}\n```\n\n```typescript\nbindings: [Object: null prototype] {\n  a: Binding {\n    identifier: [Node],\n    scope: [Circular],\n    path: [NodePath],\n    kind: 'var',\n    constantViolations: [],\n    constant: true,\n    referencePaths: [Array],\n    referenced: true,\n    references: 1,\n    hasDeoptedValue: false,\n    hasValue: false,\n    value: null\n  }\n}\n```\n\n### 2. 绑定是否是常量 \\[constant]\n\na 没有修改：\n\n```typescript\nfunction test1() {\n  var a = 10;\n  console.log(a);\n}\n```\n\n```typescript\nbindings: [Object: null prototype] {\n  a: Binding {\n    identifier: [Node],\n    scope: [Circular],\n    path: [NodePath],\n    kind: 'var',\n    constantViolations: [],\n    constant: true,\n    referencePaths: [Array],\n    referenced: true,\n    references: 1,\n    hasDeoptedValue: false,\n    hasValue: false,\n    value: null\n  }\n}\n```\n\na 有被修改：\n\n```typescript\nfunction test1() {\n  var a = 10;\n  a = 20;\n  console.log(a);\n}\n```\n\n```typescript\nBinding {\n  identifier: Node {\n    type: 'Identifier',\n    start: 26,\n    end: 27,\n    loc: SourceLocation {\n      start: [Position],\n      end: [Position],\n      filename: undefined,\n      identifierName: 'a'\n    },\n    name: 'a'\n  },\n  scope: Scope {\n    uid: 1,\n    path: NodePath {\n      contexts: [Array],\n      state: undefined,\n      opts: [Object],\n      _traverseFlags: 0,\n      skipKeys: null,\n      parentPath: [NodePath],\n      container: [Array],\n      listKey: 'body',\n      key: 0,\n      node: [Node],\n      type: 'FunctionDeclaration',\n      parent: [Node],\n      hub: undefined,\n      data: null,\n      context: [TraversalContext],\n      scope: [Circular]\n    },\n    block: Node {\n      type: 'FunctionDeclaration',\n      start: 1,\n      end: 63,\n      loc: [SourceLocation],\n      id: [Node],\n      generator: false,\n      async: false,\n      params: [],\n      body: [Node]\n    },\n    labels: Map {},\n    inited: true,\n    bindings: [Object: null prototype] { a: [Circular] },\n    references: [Object: null prototype] {},\n    globals: [Object: null prototype] {},\n    uids: [Object: null prototype] {},\n    data: [Object: null prototype] {},\n    crawling: undefined\n  },\n  path: NodePath {\n    contexts: [],\n    state: {\n      references: [Array],\n      constantViolations: [],\n      assignments: [Array]\n    },\n    opts: {\n      ForStatement: [Object],\n      ImportDeclaration: [Object],\n      LabeledStatement: [Object],\n      AssignmentExpression: [Object],\n      UpdateExpression: [Object],\n      UnaryExpression: [Object],\n      CatchClause: [Object],\n      ClassExpression: [Object],\n      _exploded: true,\n      _verified: true,\n      Identifier: [Object],\n      JSXIdentifier: [Object],\n      enter: [Array],\n      FunctionDeclaration: [Object],\n      VariableDeclaration: [Object],\n      ClassDeclaration: [Object],\n      ExportAllDeclaration: [Object],\n      ExportDefaultDeclaration: [Object],\n      ExportNamedDeclaration: [Object],\n      DeclareClass: [Object],\n      DeclareFunction: [Object],\n      DeclareInterface: [Object],\n      DeclareModule: [Object],\n      DeclareModuleExports: [Object],\n      DeclareTypeAlias: [Object],\n      DeclareOpaqueType: [Object],\n      DeclareVariable: [Object],\n      DeclareExportDeclaration: [Object],\n      DeclareExportAllDeclaration: [Object],\n      InterfaceDeclaration: [Object],\n      OpaqueType: [Object],\n      TypeAlias: [Object],\n      EnumDeclaration: [Object],\n      TSDeclareFunction: [Object],\n      TSInterfaceDeclaration: [Object],\n      TSTypeAliasDeclaration: [Object],\n      TSEnumDeclaration: [Object],\n      TSModuleDeclaration: [Object],\n      ForInStatement: [Object],\n      ForOfStatement: [Object],\n      FunctionExpression: [Object],\n      ObjectMethod: [Object],\n      ArrowFunctionExpression: [Object],\n      ClassMethod: [Object],\n      ClassPrivateMethod: [Object]\n    },\n    _traverseFlags: 0,\n    skipKeys: null,\n    parentPath: NodePath {\n      contexts: [],\n      state: [Object],\n      opts: [Object],\n      _traverseFlags: 0,\n      skipKeys: null,\n      parentPath: [NodePath],\n      container: [Array],\n      listKey: 'body',\n      key: 0,\n      node: [Node],\n      type: 'VariableDeclaration',\n      parent: [Node],\n      hub: undefined,\n      data: null,\n      context: [TraversalContext],\n      scope: [Scope]\n    },\n    container: [ [Node] ],\n    listKey: 'declarations',\n    key: 0,\n    node: Node {\n      type: 'VariableDeclarator',\n      start: 26,\n      end: 32,\n      loc: [SourceLocation],\n      id: [Node],\n      init: [Node]\n    },\n    type: 'VariableDeclarator',\n    parent: Node {\n      type: 'VariableDeclaration',\n      start: 22,\n      end: 33,\n      loc: [SourceLocation],\n      declarations: [Array],\n      kind: 'var'\n    },\n    hub: undefined,\n    data: null,\n    context: TraversalContext {\n      queue: null,\n      priorityQueue: [],\n      parentPath: [NodePath],\n      scope: [Scope],\n      state: [Object],\n      opts: [Object]\n    },\n    scope: Scope {\n      uid: 1,\n      path: [NodePath],\n      block: [Node],\n      labels: Map {},\n      inited: true,\n      bindings: [Object: null prototype],\n      references: [Object: null prototype] {},\n      globals: [Object: null prototype] {},\n      uids: [Object: null prototype] {},\n      data: [Object: null prototype] {},\n      crawling: undefined\n    }\n  },\n  kind: 'var',\n  constantViolations: [\n    NodePath {\n      contexts: [],\n      state: [Object],\n      opts: [Object],\n      _traverseFlags: 0,\n      skipKeys: null,\n      parentPath: [NodePath],\n      container: [Node],\n      listKey: undefined,\n      key: 'expression',\n      node: [Node],\n      type: 'AssignmentExpression',\n      parent: [Node],\n      hub: undefined,\n      data: null,\n      context: [TraversalContext],\n      scope: [Scope]\n    }\n  ],\n  constant: false,\n  referencePaths: [\n    NodePath {\n      contexts: [],\n      state: [Object],\n      opts: [Object],\n      _traverseFlags: 0,\n      skipKeys: null,\n      parentPath: [NodePath],\n      container: [Array],\n      listKey: 'arguments',\n      key: 0,\n      node: [Node],\n      type: 'Identifier',\n      parent: [Node],\n      hub: undefined,\n      data: null,\n      context: [TraversalContext],\n      scope: [Scope]\n    }\n  ],\n  referenced: true,\n  references: 1,\n  hasDeoptedValue: false,\n  hasValue: false,\n  value: null\n}\n\n```\n\n### 3. 只有 变量定义 和 函数定义 拥有 binding\n\n```typescript\nlet binding = scope.getBinding(name);\n// 例如: var a = 123; 这里的 a 就拥有 binding。\n\nfunction test(a,b,c) {};\n// 函数名test以及形参a，b，c均拥有 binding。\n```\n\n### 4. binding.path\n\n用于定位初始拥有binding的path; <a name=\"hn5qZ\"></a>\n\n### 5. binding.referenced\n\n用于判断当前变量是否被引用，true表示代码下面有引用该变量的地方，false表示没有地方引用该变量。注意，引用和改变是分开的。 <a name=\"Y9Wns\"></a>\n\n### 6. binding.referencePaths\n\n它是一个Array类型，包含所有引用的path，多用于替换。\n\n### 7. binding.constantViolations\n\n它是一个Array类型，包含所有改变的path，多用于判断。\n","isLeaf":true},{"key":"/Babel/03 插件开发/06-scope.md","path":"/Babel/03 插件开发/06-scope.md","route":"/Babel/03 插件开发/06-scope.md","leaf":true,"title":"06-scope","depth":2,"content":"---\ntitle: 06 Scopes（作用域）\nurl: https://www.yuque.com/gaollard/ubc1q5/wt5qg7\n---\n\n## 1、Scope 介绍\n\n接下来让我们介绍 [作用域（scope）](https://en.wikipedia.org/wiki/Scope_\\(computer_science\\))的概念。 JavaScript 支持[词法作用域](https://en.wikipedia.org/wiki/Scope_\\(computer_science\\)#Lexical_scoping_vs._dynamic_scoping)，在树状嵌套结构中代码块创建出新的作用域。\n\n```javascript\n// global scope\n\nfunction scopeOne() {\n  // scope 1\n  function scopeTwo() {\n    // scope 2\n  }\n}\n```\n\n在 JavaScript 中，每当你创建了一个引用，不管是通过变量（variable）、函数（function）、类型（class）、参数（params）、模块导入（import）还是标签（label）等，它都属于当前作用域。\n\n```javascript\nvar global = \"I am in the global scope\";\n\nfunction scopeOne() {\n  var one = \"I am in the scope created by `scopeOne()`\";\n\n  function scopeTwo() {\n    var two = \"I am in the scope created by `scopeTwo()`\";\n  }\n}\n```\n\n更深的内部作用域代码可以使用外层作用域中的引用。\n\n```javascript\nfunction scopeOne() {\n  var one = \"I am in the scope created by `scopeOne()`\";\n\n  function scopeTwo() {\n    one = \"I am updating the reference in `scopeOne` inside `scopeTwo`\";\n  }\n}\n```\n\n内层作用域也可以创建和外层作用域同名的引用。\n\n```javascript\nfunction scopeOne() {\n  var one = \"I am in the scope created by `scopeOne()`\";\n\n  function scopeTwo() {\n    var one = \"I am creating a new `one` but leaving reference in `scopeOne()` alone.\";\n  }\n}\n```\n\n当编写一个转换时，必须小心作用域。我们得确保在改变代码的各个部分时不会破坏已经存在的代码。\n我们在添加一个新的引用时需要确保新增加的引用名字和已有的所有引用不冲突。 或者我们仅仅想找出使用一个变量的所有引用， 我们只想在给定的作用域（Scope）中找出这些引用。\n作用域可以被表示为如下形式：\n\n```javascript\n{\n  path: path,\n  block: path.node,\n  parentBlock: path.parent,\n  parent: parentScope,\n  bindings: [...]\n}\n```\n\n当你创建一个新的作用域时，需要给出它的路径和父作用域，之后在遍历过程中它会在该作用域内收集所有的引用(“绑定”)。\n一旦引用收集完毕，你就可以在作用域（Scopes）上使用各种方法，稍后我们会了解这些方法。\n\n## 2、Scope 定义\n\nScope 表示作用域\n\n```typescript\nexport class Scope {\n    constructor(path: NodePath, parentScope?: Scope);\n    path: NodePath;\n    block: Node;\n    parentBlock: Node;\n    parent: Scope;\n    hub: HubInterface;\n    bindings: { [name: string]: Binding };\n\n    /** Traverse node with current scope and path. */\n    traverse<S>(node: Node | Node[], opts: TraverseOptions<S>, state: S): void;\n    traverse(node: Node | Node[], opts?: TraverseOptions, state?: any): void;\n\n    /** Generate a unique identifier and add it to the current scope. */\n    generateDeclaredUidIdentifier(name?: string): t.Identifier;\n\n    /** Generate a unique identifier. */\n    generateUidIdentifier(name?: string): t.Identifier;\n\n    /** Generate a unique `_id1` binding. */\n    generateUid(name?: string): string;\n\n    /** Generate a unique identifier based on a node. */\n    generateUidIdentifierBasedOnNode(parent: Node, defaultName?: string): t.Identifier;\n\n    /**\n     * Determine whether evaluating the specific input `node` is a consequenceless reference. ie.\n     * evaluating it wont result in potentially arbitrary code from being ran. The following are\n     * whitelisted and determined not to cause side effects:\n     *\n     *  - `this` expressions\n     *  - `super` expressions\n     *  - Bound identifiers\n     */\n    isStatic(node: Node): boolean;\n\n    /** Possibly generate a memoised identifier if it is not static and has consequences. */\n    maybeGenerateMemoised(node: Node, dontPush?: boolean): t.Identifier;\n\n    checkBlockScopedCollisions(local: Binding, kind: BindingKind, name: string, id: object): void;\n\n    rename(oldName: string, newName?: string, block?: Node): void;\n\n    dump(): void;\n\n    toArray(node: Node, i?: number): Node;\n\n    registerDeclaration(path: NodePath): void;\n\n    buildUndefinedNode(): Node;\n\n    registerConstantViolation(path: NodePath): void;\n\n    registerBinding(kind: string, path: NodePath, bindingPath?: NodePath): void;\n\n    addGlobal(node: Node): void;\n\n    hasUid(name: string): boolean;\n\n    hasGlobal(name: string): boolean;\n\n    hasReference(name: string): boolean;\n\n    isPure(node: Node, constantsOnly?: boolean): boolean;\n\n    setData(key: string, val: any): any;\n\n    getData(key: string): any;\n\n    removeData(key: string): void;\n\n    crawl(): void;\n\n    push(opts: {\n        id: t.LVal;\n        init?: t.Expression | undefined;\n        unique?: boolean | undefined;\n        kind?: 'var' | 'let' | 'const' | undefined;\n    }): void;\n\n    getProgramParent(): Scope;\n\n    getFunctionParent(): Scope | null;\n\n    getBlockParent(): Scope;\n\n    /** Walks the scope tree and gathers **all** bindings. */\n    getAllBindings(...kinds: string[]): object;\n\n    bindingIdentifierEquals(name: string, node: Node): boolean;\n\n    getBinding(name: string): Binding | undefined;\n\n    getOwnBinding(name: string): Binding | undefined;\n\n    getBindingIdentifier(name: string): t.Identifier;\n\n    getOwnBindingIdentifier(name: string): t.Identifier;\n\n    hasOwnBinding(name: string): boolean;\n\n    hasBinding(name: string, noGlobals?: boolean): boolean;\n\n    parentHasBinding(name: string, noGlobals?: boolean): boolean;\n\n    /** Move a binding of `name` to another `scope`. */\n    moveBindingTo(name: string, scope: Scope): void;\n\n    removeOwnBinding(name: string): void;\n\n    removeBinding(name: string): void;\n}\n\n```\n\n## 3、代码辅助理解\n\n### 1. 查看 scope 结构\n\n```typescript\nimport * as fs from \"fs\";\nimport * as path from 'path';\nimport * as babel from \"@babel/core\";\n\nconst code = `\nfunction test1() {\n  var a = 10;\n}\n`\n\nconst data = babel.parse(code, {\n  presets: [\"@babel/preset-typescript\"],\n  plugins: [\n    [\n      \"@babel/plugin-proposal-decorators\",\n      {\n        legacy: true,\n      },\n    ],\n  ],\n  filename: 'sss',\n});\n\n\nbabel.traverse(data, {\n  FunctionDeclaration(path) {\n    console.log(path.scope)\n  }\n})\n```\n\n```typescript\nScope {\n  uid: 1,\n  path: NodePath {\n    contexts: [ [TraversalContext] ],\n    state: undefined,\n    opts: { FunctionDeclaration: [Object], _exploded: true, _verified: true },\n    _traverseFlags: 0,\n    skipKeys: null,\n    parentPath: NodePath {\n      contexts: [Array],\n      state: undefined,\n      opts: [Object],\n      _traverseFlags: 0,\n      skipKeys: null,\n      parentPath: null,\n      container: [Node],\n      listKey: undefined,\n      key: 'program',\n      node: [Node],\n      type: 'Program',\n      parent: [Node],\n      hub: undefined,\n      data: null,\n      context: [TraversalContext],\n      scope: [Scope]\n    },\n    container: [ [Node] ],\n    listKey: 'body',\n    key: 0,\n    node: Node {\n      type: 'FunctionDeclaration',\n      start: 1,\n      end: 35,\n      loc: [SourceLocation],\n      id: [Node],\n      generator: false,\n      async: false,\n      params: [],\n      body: [Node]\n    },\n    type: 'FunctionDeclaration',\n    parent: Node {\n      type: 'Program',\n      start: 0,\n      end: 36,\n      loc: [SourceLocation],\n      sourceType: 'module',\n      interpreter: null,\n      body: [Array],\n      directives: []\n    },\n    hub: undefined,\n    data: null,\n    context: TraversalContext {\n      queue: [Array],\n      priorityQueue: [],\n      parentPath: [NodePath],\n      scope: [Scope],\n      state: undefined,\n      opts: [Object]\n    },\n    scope: [Circular]\n  },\n  block: Node {\n    type: 'FunctionDeclaration',\n    start: 1,\n    end: 35,\n    loc: SourceLocation {\n      start: [Position],\n      end: [Position],\n      filename: undefined,\n      identifierName: undefined\n    },\n    id: Node {\n      type: 'Identifier',\n      start: 10,\n      end: 15,\n      loc: [SourceLocation],\n      name: 'test1'\n    },\n    generator: false,\n    async: false,\n    params: [],\n    body: Node {\n      type: 'BlockStatement',\n      start: 18,\n      end: 35,\n      loc: [SourceLocation],\n      body: [Array],\n      directives: []\n    }\n  },\n  labels: Map {},\n  inited: true,\n  bindings: [Object: null prototype] {\n    a: Binding {\n      identifier: [Node],\n      scope: [Circular],\n      path: [NodePath],\n      kind: 'var',\n      constantViolations: [],\n      constant: true,\n      referencePaths: [],\n      referenced: false,\n      references: 0,\n      hasDeoptedValue: false,\n      hasValue: false,\n      value: null\n    }\n  },\n  references: [Object: null prototype] {},\n  globals: [Object: null prototype] {},\n  uids: [Object: null prototype] {},\n  data: [Object: null prototype] {},\n  crawling: undefined\n}\n```\n\n- block  该作用域所属的 code block\n- path   该作用域所属的 NodePath\n- bindings  该作用域能够访问变量 <a name=\"Bi4FK\"></a>\n\n### 2. 查看 binding\n\n```typescript\nimport * as fs from \"fs\";\nimport * as path from 'path';\nimport * as babel from \"@babel/core\";\n\nconst code = `\nfunction test1() {\n  var a = 10;\n}\n\nfunction test2() {\n  var b = 10;\n}\n`\n\nconst data = babel.parse(code, {\n  presets: [\"@babel/preset-typescript\"],\n  plugins: [\n    [\n      \"@babel/plugin-proposal-decorators\",\n      {\n        legacy: true,\n      },\n    ],\n  ],\n  filename: 'sss',\n});\n\n\nbabel.traverse(data, {\n  FunctionDeclaration(path) {\n    if (babel.types.isIdentifier(path.node.id)) {\n      console.log(path.node.id.name, path.scope.hasBinding(\"a\"))\n    }\n  }\n})\n\n// test1 true\n// test2 false\n```","isLeaf":true},{"key":"/Babel/03 插件开发/07-state.md","path":"/Babel/03 插件开发/07-state.md","route":"/Babel/03 插件开发/07-state.md","leaf":true,"title":"07-state","depth":2,"content":"---\ntitle: 07 State（状态）\nurl: https://www.yuque.com/gaollard/ubc1q5/prgac1\n---\n\n状态是抽象语法树AST转换的敌人，状态管理会不断牵扯你的精力，而且几乎所有你对状态的假设，总是会有一些未考虑到的语法最终证明你的假设是错误的。\n考虑下列代码：\n\n```javascript\nfunction square(n) {\n  return n * n;\n}\n```\n\n让我们写一个把 n 重命名为 x 的访问者的快速实现:\n\n```javascript\nlet paramName;\n\nconst MyVisitor = {\n  FunctionDeclaration(path) {\n    const param = path.node.params[0];\n    paramName = param.name;\n    param.name = \"x\";\n  },\n\n  Identifier(path) {\n    if (path.node.name === paramName) {\n      path.node.name = \"x\";\n    }\n  }\n};\n```\n\n对上面的例子代码这段访问者代码也许能工作，但它很容易被打破：\n\n```javascript\nfunction square(n) {\n  return n * n;\n}\nn;\n```\n\n更好的处理方式是使用递归，下面让我们来像克里斯托佛·诺兰的电影盗梦空间那样来把一个访问者放进另外一个访问者里面:\n\n```javascript\nconst updateParamNameVisitor = {\n  Identifier(path) {\n    if (path.node.name === this.paramName) {\n      path.node.name = \"x\";\n    }\n  }\n};\n\nconst MyVisitor = {\n  FunctionDeclaration(path) {\n    const param = path.node.params[0];\n    const paramName = param.name;\n    param.name = \"x\";\n\n    path.traverse(updateParamNameVisitor, { paramName });\n  }\n};\n\npath.traverse(MyVisitor);\n```\n\n注意例子中 `path.traverse(updateParamNameVisitor, { paramName })` 第二个参数，在 visitor 中通过 this 可以访问。\n\n这个例子演示了如何从访问者中消除全局状态。\n","isLeaf":true}]},{"key":"/Babel/04 babel-usage","path":"/Babel/04 babel-usage","route":"/Babel/04 babel-usage","leaf":false,"title":"04 babel-usage","depth":1,"content":"","isLeaf":false,"children":[{"key":"/Babel/04 babel-usage/01.md","path":"/Babel/04 babel-usage/01.md","route":"/Babel/04 babel-usage/01.md","leaf":true,"title":"01","depth":2,"content":"---\ntitle: 1、生成 AST\nurl: https://www.yuque.com/gaollard/ubc1q5/fzvnnp\n---\n\n```javascript\nconst fs = require('fs');\nconst babel = require(\"@babel/core\");\n\nvar res = babel.transformSync(\"var code = 1; var fn = () => {}\", {\n  ast: true,\n  plugins: [\n    require('@babel/plugin-transform-arrow-functions')\n  ]\n});\n\nconsole.log(res.code);\n```\n","isLeaf":true},{"key":"/Babel/04 babel-usage/02.md","path":"/Babel/04 babel-usage/02.md","route":"/Babel/04 babel-usage/02.md","leaf":true,"title":"02","depth":2,"content":"---\ntitle: 2、useBuiltIns 的用法\nurl: https://www.yuque.com/gaollard/ubc1q5/xwfbok\n---\n\n","isLeaf":true},{"key":"/Babel/04 babel-usage/03.md","path":"/Babel/04 babel-usage/03.md","route":"/Babel/04 babel-usage/03.md","leaf":true,"title":"03","depth":2,"content":"---\ntitle: 3、插入节点\nurl: https://www.yuque.com/gaollard/ubc1q5/sheq24\n---\n\n### 1. 插入 Node\n\n### 2. 插入 字符串代码\n","isLeaf":true}]},{"key":"/Babel/05 babel-shizhan","path":"/Babel/05 babel-shizhan","route":"/Babel/05 babel-shizhan","leaf":false,"title":"05 babel-shizhan","depth":1,"content":"","isLeaf":false,"children":[{"key":"/Babel/05 babel-shizhan/01-how-to-traverse-jsx.md","path":"/Babel/05 babel-shizhan/01-how-to-traverse-jsx.md","route":"/Babel/05 babel-shizhan/01-how-to-traverse-jsx.md","leaf":true,"title":"01-how-to-traverse-jsx","depth":2,"content":"我在写一个 babel 插件，用于给每一个 div 标签都加一个 css class。现在出现了两种场景。\n\n## 1、`React.createElement('div', {})`\n\n![20230511185255](http://s3.airtlab.com/blog/20230511185255.png)\n\n```js\nmodule.exports = function (api) {\n  api && api.cache(false);\n  return {\n    presets: [\n      [\"@babel/preset-react\", { runtime: \"classic\" }],\n    ],\n    plugins: [\n      // 注意 prefix 中的空格\n      [\"./src/babel-plugin-change-jsx-className\", {\n        prefix: 'f6 '\n      }]\n    ]\n  };\n};\n\n```\n\n```js\nconst fs = require('fs');\nconst { Console } = require('console');\nconst logFile = process.cwd() + '/' + 'a.log'\n\nconst std = fs.createWriteStream(logFile, { flags: 'a' });\nconst console = new Console(std);\nconst types = require('@babel/types');\nlet config = {};\n\nmodule.exports = function (\n  _,\n  options = {\n    prefix: '',\n  },\n) {\n  config = options;\n  return {\n    visitor: {\n      CallExpression,\n      JSXElement(path) {\n        const node = path.node;\n        if (node.openingElement.name.name === \"div\") {\n          console.log(\"Found div:\", node);\n        }\n      },\n      BinaryExpression(path) {\n        console.log(path.node.left); // Identifier Node\n        console.log(path.node.right); // Identifier Node\n        console.log(path.node.operator); // \"*\"\n      },\n    },\n  };\n};\n\nfunction CallExpression(path) {\n  // debugger;\n  const _this = this;\n  const callee = path.node.callee;\n  console.log(444, callee);\n\n  if (callee.type === 'MemberExpression') {\n    const callFn = callee.object.name + '.' + callee.property.name;\n    if (callFn === 'React.createElement') {\n      path.skip();\n\n      const arg1 = path.get('arguments.1');\n\n      if (arg1.node.type === 'NullLiteral') {\n        // null\n        arg1.replaceWith(\n          types.objectExpression([\n            types.objectProperty(\n              types.identifier('className'),\n              types.stringLiteral(config.prefix),\n            ),\n            types.objectProperty(\n              types.identifier('data-code'),\n              types.stringLiteral(_this.filename),\n            ),\n          ]),\n        );\n      } else {\n        // {}\n        if (arg1.node.type === 'ObjectExpression') {\n          const index = arg1.node.properties.findIndex((it) => {\n            return it.key.name === 'className';\n          });\n          if (index !== -1) {\n            const proPath = arg1.get(`properties.${index}`);\n            proPath.node.value = types.binaryExpression(\n              '+',\n              types.StringLiteral(config.prefix),\n              proPath.node.value,\n            );\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n```json\n{\n  \"name\": \"f6\",\n  \"version\": \"0.0.0\",\n  \"description\": \"> TODO: description\",\n  \"author\": \"gaollard <1056834607@qq.com>\",\n  \"homepage\": \"\",\n  \"license\": \"ISC\",\n  \"main\": \"src/index.js\",\n  \"directories\": {\n    \"lib\": \"lib\",\n    \"test\": \"__tests__\"\n  },\n  \"files\": [\n    \"lib\",\n    \"src\"\n  ],\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: run tests from root\\\" && exit 1\",\n    \"build\": \"babel demo/index.js\"\n  },\n  \"dependencies\": {\n    \"@babel/generator\": \"^7.16.5\",\n    \"@babel/preset-react\": \"^7.16.5\",\n    \"@babel/runtime\": \"^7.16.5\",\n    \"@types/react-transition-group\": \"^4.4.4\"\n  },\n  \"devDependencies\": {\n    \"@babel/cli\": \"^7.16.0\",\n    \"@babel/core\": \"^7.16.5\",\n    \"@babel/plugin-syntax-dynamic-import\": \"^7.0.0\",\n    \"@babel/plugin-transform-modules-commonjs\": \"^7.16.5\",\n    \"@babel/plugin-transform-object-assign\": \"^7.0.0\",\n    \"@babel/plugin-transform-runtime\": \"^7.4.4\",\n    \"@babel/polyfill\": \"^7.4.4\",\n    \"@babel/preset-env\": \"^7.16.5\",\n    \"@babel/preset-typescript\": \"^7.3.3\",\n    \"@types/react\": \"^17.0.34\",\n    \"@types/react-dom\": \"^17.0.11\",\n    \"style-loader\": \"^3.3.1\",\n    \"css-loader\": \"^6.5.1\",\n    \"react\": \"^17.0.2\",\n    \"react-dom\": \"^17.0.2\",\n    \"rimraf\": \"^3.0.2\",\n    \"typescript\": \"^4.4.4\"\n  },\n  \"peerDependencies\": {\n    \"classnames\": \"^2.3.1\",\n    \"react\": \"^17.0.2\",\n    \"react-dom\": \"^17.0.2\"\n  }\n}\n```\n\n## 2、_jsx('div', {})\n\n![20230511190028](http://s3.airtlab.com/blog/20230511190028.png)\n\n## 3、遍历 JSXElement 更合理\n\n![20230511191205](http://s3.airtlab.com/blog/20230511191205.png)","isLeaf":true},{"key":"/Babel/05 babel-shizhan/02-plugin-transform-react-jsx.md","path":"/Babel/05 babel-shizhan/02-plugin-transform-react-jsx.md","route":"/Babel/05 babel-shizhan/02-plugin-transform-react-jsx.md","leaf":true,"title":"02-plugin-transform-react-jsx","depth":2,"content":"- 原理\n- 源码分析","isLeaf":true},{"key":"/Babel/05 babel-shizhan/03-add-prop-to-jsx.md","path":"/Babel/05 babel-shizhan/03-add-prop-to-jsx.md","route":"/Babel/05 babel-shizhan/03-add-prop-to-jsx.md","leaf":true,"title":"03-add-prop-to-jsx","depth":2,"content":"https://www.johno.com/add-a-prop-to-jsx-elements-with-babel\n\n```js\nexport default (api) => {\n  const { types: t } = api;\n\n  return {\n    visitor: {\n      JSXOpeningElement(path) {\n        const existingProp = path.node.attributes.find(\n          (node) => node.name && node.name.name === \"favoriteColor\"\n        );\n\n        if (existingProp) {\n          existingProp.node.value.value === \"tomato\";\n          return;\n        }\n\n        const newProp = t.jSXAttribute(\n          t.jSXIdentifier(\"favoriteColor\"),\n          t.stringLiteral(\"tomato\")\n        );\n\n        path.node.attributes.push(newProp);\n      },\n    },\n  };\n};\n```\n","isLeaf":true},{"key":"/Babel/05 babel-shizhan/04-change-jsx-className.md","path":"/Babel/05 babel-shizhan/04-change-jsx-className.md","route":"/Babel/05 babel-shizhan/04-change-jsx-className.md","leaf":true,"title":"04-change-jsx-className","depth":2,"content":"---\ntitle: 01 change-jsx-className\nurl: https://www.yuque.com/gaollard/ubc1q5/nafu7s\n---\n\n<https://github.com/Webang/babel-plugin-change-jsx-className>\n\n```typescript\nconst types = require(\"@babel/types\");\nlet config = {};\n\nmodule.exports = function (\n  _,\n  options = {\n    prefix: \"\",\n  }\n) {\n  config = options;\n  return {\n    visitor: {\n      CallExpression,\n    },\n  };\n};\n\nfunction CallExpression(path) {\n  const callee = path.node.callee;\n  if (callee.type === \"MemberExpression\") {\n    const callFn = callee.object.name + \".\" + callee.property.name;\n    if (callFn === \"React.createElement\") {\n      path.skip();\n\n      const arg1 = path.get(\"arguments.1\");\n\n      if (arg1.node.type === 'NullLiteral') {\n        // null\n        arg1.replaceWith(types.objectExpression([\n          types.objectProperty(types.identifier('className'), types.stringLiteral(config.prefix))\n        ]))\n      } else {\n        // {}\n        if ((arg1.node.type) === 'ObjectExpression') {\n          const index = arg1.node.properties.findIndex(it => {\n            return it.key.name === 'className'\n          });\n          if (index !== -1) {\n            const proPath = arg1.get(`properties.${index}`);\n            proPath.node.value = types.binaryExpression(\n              \"+\",\n              types.StringLiteral(config.prefix),\n              proPath.node.value\n            );\n          }\n        }\n      }\n    }\n  }\n}\n\n```","isLeaf":true},{"key":"/Babel/05 babel-shizhan/05-how-comipler-typescript.md","path":"/Babel/05 babel-shizhan/05-how-comipler-typescript.md","route":"/Babel/05 babel-shizhan/05-how-comipler-typescript.md","leaf":true,"title":"05-how-comipler-typescript","depth":2,"content":"---\ntitle: 05 如何编译 typescript\n---\n\n- 如果没有使用 Babel，首选 TypeScript 自带编译器（配合 ts-loader 使用）\n- 如果项目中有 Babel，安装 @babel/preset-typescript，配合 tsc 做类型检查。\n\n两种编译器不要混用。参考 https://juejin.cn/post/6954304242093932557#heading-7","isLeaf":true},{"key":"/Babel/05 babel-shizhan/06-rename-function-param.md","path":"/Babel/05 babel-shizhan/06-rename-function-param.md","route":"/Babel/05 babel-shizhan/06-rename-function-param.md","leaf":true,"title":"06-rename-function-param","depth":2,"content":"---\ntitle: 06 修改函数参数\n---\n\n```js\nmodule.exports = function({ types: t }) {\n  return {\n    visitor: {\n      FunctionDeclaration(path, state) {\n        path.scope.rename('age', path.scope.generateUidIdentifier(\"age\").name)\n      }\n    }\n  }\n}\n```\n\n```js\nmodule.exports = function({ types: t }) {\n  return {\n    visitor: {\n      FunctionDeclaration(path, state) {\n        const { replaceMap } = state.opts;\n        const params = path.get('params');\n\n        params.forEach((idPath) => {\n          if (replaceMap[idPath.node.name]) {\n            idPath.replaceWith(t.identifier(replaceMap[idPath.node.name]))\n          }\n        })\n\n        Object.keys(path.scope.bindings).forEach((name) => {\n          const referencePaths = path.scope.bindings[name].referencePaths\n          referencePaths.forEach((idPath) => {\n            if (replaceMap[idPath.node.name]) {\n              idPath.replaceWith(t.identifier(replaceMap[idPath.node.name]))\n            }\n          })\n        })\n      }\n    }\n  }\n}\n```\n","isLeaf":true}]},{"key":"/Babel/06 acorn","path":"/Babel/06 acorn","route":"/Babel/06 acorn","leaf":false,"title":"06 acorn","depth":1,"content":"","isLeaf":false,"children":[{"key":"/Babel/06 acorn/00.md","path":"/Babel/06 acorn/00.md","route":"/Babel/06 acorn/00.md","leaf":true,"title":"00","depth":2,"content":"---\ntitle: acorn 源码分析\ntags: acorn\n---\n\n- AST 在线 <https://astexplorer.net/#/2uBU1BLuJ1>\n","isLeaf":true},{"key":"/Babel/06 acorn/01-the-super-tiny-compiler.md","path":"/Babel/06 acorn/01-the-super-tiny-compiler.md","route":"/Babel/06 acorn/01-the-super-tiny-compiler.md","leaf":true,"title":"01-the-super-tiny-compiler","depth":2,"content":"---\ntitle: 01 the-super-tiny-compiler 源码分析\ntags: acornjs\n---\n\n<https://github.com/jamiebuilds/the-super-tiny-compiler>，这个设计库实在太过简单（比如：不支持取反操作），只能用作学习 compiler 的流程设计。\n\n- tokenizer(词法分析器)：划分 token，产生一个 token 数组\n- parser(语法分析器)：接受 token 数组，然后把它转化为 AST <a name=\"bsEHt\"></a>\n\n### 1. 测试 the-super-tiny-compiler\n\n    (add 21 (subtract 4 2))\n\n- (op v1 v2) 括号表示一个 CallExpression 调用表达式\n- add +\n- subtract -\n- token 只包含\n  - NumberLiteral 数字字面量\n  - StringLiteral 字符串字面量\n  - CallExpression 调用表达式\n    - add\n    - subtract\n\n#### 1.1 tokens\n\n```json\n[\n  {\n    \"type\": \"paren\",\n    \"value\": \"(\"\n  },\n  {\n    \"type\": \"name\",\n    \"value\": \"add\"\n  },\n  {\n    \"type\": \"number\",\n    \"value\": \"21\"\n  },\n  {\n    \"type\": \"paren\",\n    \"value\": \"(\"\n  },\n  {\n    \"type\": \"name\",\n    \"value\": \"subtract\"\n  },\n  {\n    \"type\": \"number\",\n    \"value\": \"4\"\n  },\n  {\n    \"type\": \"number\",\n    \"value\": \"2\"\n  },\n  {\n    \"type\": \"paren\",\n    \"value\": \")\"\n  },\n  {\n    \"type\": \"paren\",\n    \"value\": \")\"\n  }\n]\n```\n\n#### 1.2 AST\n\n```json\n{\n  \"type\": \"Program\",\n  \"body\": [\n    {\n      \"type\": \"CallExpression\",\n      \"name\": \"add\",\n      \"params\": [\n        {\n          \"type\": \"NumberLiteral\",\n          \"value\": \"21\"\n        },\n        {\n          \"type\": \"CallExpression\",\n          \"name\": \"subtract\",\n          \"params\": [\n            {\n              \"type\": \"NumberLiteral\",\n              \"value\": \"4\"\n            },\n            {\n              \"type\": \"NumberLiteral\",\n              \"value\": \"2\"\n            }\n          ]\n        }\n      ]\n    }\n  ]\n}\n```\n\n<a name=\"RKRFw\"></a>\n\n### 2. 自己实现\n\n<a name=\"fQ8XC\"></a>\n\n#### 2.1 tokenizer\n\n```javascript\n/**\n * @param {string} input \n */\nfunction tokenizer(input) {\n  let current = 0;\n  let tokens = [];\n\n  const lt_parent_l = '(';\n  const lt_parent_r = ')';\n\n  const type_paren = 'paren';\n  const type_number = 'number';\n  const type_string = 'string';\n  const type_name = 'name';\n\n  const reg_whitespcae = /\\s/;\n  const reg_numbers = /[0-9]/;\n  const reg_letters = /[a-z]/i;\n\n  const isEof = () => current >= input.length;\n\n  const genToken = (type, value, start) => {\n    const token = {\n      type,\n      value\n    }\n    token.loc = {\n      start,\n      end: token.value.length + start\n    }\n    tokens.push(token)\n  } \n\n  while(!isEof()) {\n    let c_char = input[current];\n\n    if (c_char === lt_parent_l) {\n      genToken(type_paren, c_char, current)\n      current++;\n      continue;\n    }\n\n    if (c_char === lt_parent_r) {\n      genToken(type_paren, c_char, current)\n      current++;\n      continue;\n    }\n\n    if (reg_whitespcae.test(c_char)) {\n      current++;\n      continue;\n    }\n\n    if (reg_numbers.test(c_char)) {\n      // 解析出当前的整型字面量\n\n      let value = '';\n      let start = current;\n\n      while(reg_numbers.test(c_char)) {\n        value += c_char;\n        c_char = input[++current];\n      }\n\n      genToken(type_number, value, start)\n      continue;\n    }\n\n    if (c_char === '\"') {\n      // 找出完整的字符串\n\n      let start = current\n      let value = '';\n      c_char = input[current++]; \n\n      while(c_char !== '\"') {\n        value += c_char;\n        c_char = input[++current];\n      }\n\n      // 跳过闭合的双引号\n      c_char = input[++current];\n\n      genToken(type_string, value, start)\n      continue;\n    }\n\n    if (reg_letters.test(c_char)) {\n      // 找出完整的关键字\n      let start = current;\n      let value = '';\n      while(reg_letters.test(c_char)) {\n        value += c_char;\n        c_char = input[++current];\n      }\n\n      genToken(type_name, value, start)\n      continue;\n    }\n\n    // 如果还剩一些字符，说明表达式语法有错误\n    throw new TypeError('I dont know what this character is: ' + char);\n  }\n\n  return tokens;\n}\n```\n\n```javascript\n// (add 21 (subtract 4 2))\n[\n  { type: 'paren', value: '(', loc: { start: 0, end: 1 } },\n  { type: 'name', value: 'add', loc: { start: 1, end: 4 } },\n  { type: 'number', value: '21', loc: { start: 5, end: 7 } },\n  { type: 'paren', value: '(', loc: { start: 8, end: 9 } },\n  { type: 'name', value: 'subtract', loc: { start: 9, end: 17 } },\n  { type: 'number', value: '4', loc: { start: 18, end: 19 } },\n  { type: 'number', value: '2', loc: { start: 20, end: 21 } },\n  { type: 'paren', value: ')', loc: { start: 21, end: 22 } },\n  { type: 'paren', value: ')', loc: { start: 22, end: 23 } }\n]\n```\n\n#### 2.2 parser","isLeaf":true},{"key":"/Babel/06 acorn/01.md","path":"/Babel/06 acorn/01.md","route":"/Babel/06 acorn/01.md","leaf":true,"title":"01","depth":2,"content":"---\ntitle: 简易表达式\ntags: acornjs\n---\n\n### 1. 条件表达式 Condition\n\n```javascript\na = b ? 1 : 2 + 1  // =>  a = b ? 1 : (2 + 1)\n```\n\n### 2. 赋值表达式 Assign\n\n```javascript\na == b ? 1 : 2 + 1 // => (a == b) ? 1 : (2+1)\na += b ? 1 : 0     // => a += (b ? 1 : 0 )\n```\n\n### 3. 更新表达式 Update\n\n```javascript\na++\na--\n```\n\n### 4. 逻辑运算符 Logical\n\n```javascript\na || b\na == b ? 1 : 2 + 1 // => (a == b) ? 1 : (2+1)\n```\n\n### 5. 一元运算符\n\n```javascript\n-5\n+5\n```\n\n### 6. 运算符优先级","isLeaf":true},{"key":"/Babel/06 acorn/02.md","path":"/Babel/06 acorn/02.md","route":"/Babel/06 acorn/02.md","leaf":true,"title":"02","depth":2,"content":"---\ntitle: acorn 解析\ntags: acornjs\n---\n\n## 1. 基础类和接口\n\n### 1.1 Node\n\n所有节点类型都实现以下接口：\n\n```typescript\ninterface Node {\n  type: string; // AST变体类型\n  start: number; // 起始位置\n  end: number; // 结束位置\n  range?: [number, number]; // [起始位置, 结束位置]\n  loc?: SourceLocation;\n}\n```\n\nloc字段表示节点的位置信息。如果解析器没有生成有关节点源位置的信息，则该字段为null。否则它是一个对象，包括一个起始位置 和一个结束位置。每个Position对象由一个line数字（1索引）和一个column数字（0索引）组成：\n\n```typescript\ninterface SourceLocation {\n    start: Position;\n    end: Position;\n    source?: string | null;\n}\n```\n\n```typescript\ninterface Position {\n    line: number >= 1;\n    column: number >= 0;\n}\n```\n\n### 1.2 Programs\n\n```typescript\ninterface Program <: Node {\n    type: \"Program\";\n    sourceType: 'script' | 'module';\n    body: StatementListItem[] | ModuleItem[];\n}\n```\n\n表示一个完整的源代码树。 <a name=\"PB0xS\"></a>\n\n## 2. 脚本和模块\n\n源代码数的来源包括两种，一种是script脚本，一种是modules模块\n\n- 当为script时，body为StatementListItem。\n- 当为modules时，body为ModuleItem。\n\n类型 StatementListItem 和 ModuleItem 类型如下：\n\n```typescript\ntype StatementListItem = Declaration | Statement;\ntype ModuleItem = ImportDeclaration | ExportDeclaration | StatementListItem;\n```\n\n### 2.1 ImportDeclaration\n\nimport语法，导入模块\n\n```typescript\ntype ImportDeclaration {\n    type: 'ImportDeclaration';\n    specifiers: ImportSpecifier[];\n    source: Literal;\n}\n```\n\nImportSpecifier：\n\n```typescript\ninterface ImportSpecifier {\n    type: 'ImportSpecifier' | 'ImportDefaultSpecifier' | 'ImportNamespaceSpecifier';\n    local: Identifier;\n    imported?: Identifier;\n}\n```\n\n#### 2.1.1 ImportSpecifier\n\nimport 部分模块\n\n```typescript\nimport { foo } from './foo';\n```\n\n#### 2.1.2 ImportDefaultSpecifier\n\nimport default 方式\n\n```typescript\nimport foo from './foo';\n```\n\n##### 2.1.3 ImportNamespaceSpecifier\n\n模块重命名\n\n```typescript\nimport * as foo from './foo';\n```\n\n### 2.2 ExportDeclaration\n\n```typescript\ntype ExportDeclaration = ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration;\n```\n\n#### 2.2.1 ExportAllDeclaration\n\n从指定模块中导出\n\n```typescript\ninterface ExportAllDeclaration {\n    type: 'ExportAllDeclaration';\n    source: Literal;\n}\n```\n\n```typescript\nexport * from './foo';\n```\n\n#### 2.2.2 ExportDefaultDeclaration\n\n导出默认模块\n\n```typescript\ninterface ExportDefaultDeclaration {\n    type: 'ExportDefaultDeclaration';\n    declaration: Identifier | BindingPattern | ClassDeclaration | Expression | FunctionDeclaration;\n}\n```\n\n```typescript\nexport default 'foo';\n```\n\n#### 2.2.3 ExportNamedDeclaration\n\n导出部分模块\n\n```typescript\ninterface ExportNamedDeclaration {\n    type: 'ExportNamedDeclaration';\n    declaration: ClassDeclaration | FunctionDeclaration | VariableDeclaration;\n    specifiers: ExportSpecifier[];\n    source: Literal;\n}\n```\n\n```typescript\nexport const foo = 'foo';\n```\n","isLeaf":true},{"key":"/Babel/06 acorn/03.md","path":"/Babel/06 acorn/03.md","route":"/Babel/06 acorn/03.md","leaf":true,"title":"03","depth":2,"content":"---\ntitle: Declarations 声明\ntags: acornjs\nurl: https://www.yuque.com/gaollard/ubc1q5/wluqrk\n---\n\n### 1. VariableDeclarator\n\n变量声明\n\n```typescript\ninterface VariableDeclaration <: Declaration {\n    type: \"VariableDeclaration\";\n    declarations: [ VariableDeclarator ];\n    kind: \"var\" | \"let\" | \"const\";\n}\n```\n\nVariableDeclarator 表示一个变量声明:\n\n```typescript\ninterface VariableDeclarator {\n  type: \"VariableDeclarator\";\n  id: Identifier;\n  init: Expression;\n}\n```\n\n```typescript\nvar c = 30\n```\n\n```json\n{\n  \"type\": \"VariableDeclarator\",\n  \"start\": 28,\n  \"end\": 34,\n  \"id\": {\n    \"type\": \"Identifier\",\n    \"start\": 28,\n    \"end\": 29,\n    \"name\": \"c\"\n  },\n  \"init\": {\n    \"type\": \"Literal\",\n    \"start\": 32,\n    \"end\": 34,\n    \"value\": 30,\n    \"raw\": \"30\"\n  }\n}\n```\n\n### 2. FunctionDeclaration\n\n函数声明，注意与函数表达式的区别\n\n```typescript\ninterface FunctionDeclaration {\n    type: 'FunctionDeclaration';\n    id: Identifier | null;\n    params: FunctionParameter[];\n    body: BlockStatement;\n    generator: boolean;\n    async: boolean;\n    expression: false;\n}\n```\n\n```javascript\n{\n  \"type\": \"Program\",\n  \"start\": 0,\n  \"end\": 17,\n  \"body\": [\n    {\n      \"type\": \"ClassDeclaration\",\n      \"start\": 0,\n      \"end\": 17,\n      \"id\": {\n        \"type\": \"Identifier\",\n        \"start\": 6,\n        \"end\": 12,\n        \"name\": \"Person\"\n      },\n      \"superClass\": null,\n      \"body\": {\n        \"type\": \"ClassBody\",\n        \"start\": 13,\n        \"end\": 17,\n        \"body\": []\n      }\n    }\n  ],\n  \"sourceType\": \"module\"\n}\n```\n\n####\n\n```javascript\nclass Person extends Object {\n\tsleep() {}\n}\n```\n\n### 3. ClassDeclaration\n\n类声明，注意和类表达式的区别\n\n```typescript\ninterface ClassDeclaration {\n  type: 'ClassDeclaration';\n  id: Identifier | null;\n  superClass: Identifier | null;\n  body: ClassBody;\n}\n```\n\nClassBody 类主体:\n\n```typescript\ninterface ClassBody {\n  type: 'ClassBody';\n  body: MethodDefinition[];\n}\n```\n\nMethodDefinition 表示方法定义：\n\n```typescript\ninterface MethodDefinition {\n  type: 'MethodDefinition';\n  key: Expression | null;\n  computed: boolean;\n  value: FunctionExpression | null;\n  kind: 'method' | 'constructor';\n  static: boolean;\n}\n```\n\n```typescript\nclass Fn {\n  constructor() {}\n  method() {}\n};\n```\n","isLeaf":true},{"key":"/Babel/06 acorn/04.md","path":"/Babel/06 acorn/04.md","route":"/Babel/06 acorn/04.md","leaf":true,"title":"04","depth":2,"content":"---\ntitle: Expressions 表达式\ntags: acornjs\nurl: https://www.yuque.com/gaollard/ubc1q5/slzv6w\n---\n\nExpressions 可用类型如下：\n\n```typescript\ntype Expression = ThisExpression | Identifier | Literal |\n    ArrayExpression | ObjectExpression | FunctionExpression | ArrowFunctionExpression | ClassExpression |\n    TaggedTemplateExpression | MemberExpression | Super | MetaProperty |\n    NewExpression | CallExpression | UpdateExpression | AwaitExpression | UnaryExpression |\n    BinaryExpression | LogicalExpression | ConditionalExpression |\n    YieldExpression | AssignmentExpression | SequenceExpression;\n```\n\nJS 中的表达式除了常见的表达式外，还可以是：\n\n- Identifier 标识符\n- Literal 字面量\n- Super\n\n### 1. ThisExpression\n\nthis 表达式\n\n```typescript\ninterface ThisExpression {\n  type: \"ThisExpression\";\n}\n```\n\n```typescript\n(function(ctx){})(this);\n```\n\n```typescript\n{\n  \"type\": \"Program\",\n  \"start\": 0,\n  \"end\": 29,\n  \"body\": [\n    {\n      \"type\": \"ExpressionStatement\",\n      \"start\": 0,\n      \"end\": 29,\n      \"expression\": {\n        \"type\": \"CallExpression\",\n        \"start\": 0,\n        \"end\": 28,\n        \"callee\": {\n          \"type\": \"FunctionExpression\",\n          \"start\": 5,\n          \"end\": 20,\n          \"id\": null,\n          \"expression\": false,\n          \"generator\": false,\n          \"async\": false,\n          \"params\": [\n            {\n              \"type\": \"Identifier\",\n              \"start\": 14,\n              \"end\": 17,\n              \"name\": \"ctx\"\n            }\n          ],\n          \"body\": {\n            \"type\": \"BlockStatement\",\n            \"start\": 18,\n            \"end\": 20,\n            \"body\": []\n          }\n        },\n        \"arguments\": [\n          {\n            \"type\": \"ThisExpression\",\n            \"start\": 23,\n            \"end\": 27\n          }\n        ],\n        \"optional\": false\n      }\n    }\n  ],\n  \"sourceType\": \"module\"\n}\n```\n\n### 2. Identifier\n\n标识符，比如变量名、函数名\n\n```typescript\ninterface Identifier {\n    type: 'Identifier';\n    name: string;\n}\n```\n\n### 3. Literal\n\n基础的字面量，比如\n\n- 字符串\n- 数字\n- 布尔\n- 正则\n\n```typescript\ninterface Literal {\n    type: 'Literal';\n    value: boolean | number | string | RegExp | null;\n    raw: string;\n    regex?: { pattern: string, flags: string };\n}\n```\n\n```typescript\nvar a = 10;\nvar a = 'string';\nvar a = true;\nvar a = /\\d/;\n```\n\n注意，{} 和 \\[] 不被包括在内，他们被分别抽离为 ObjectExpression ArrayExpression <a name=\"RL6b3\"></a>\n\n### 4. ObjectExpression\n\n对象表达式\n\n```typescript\ninterface ObjectExpression {\n    type: 'ObjectExpression';\n    properties: Property[];\n}\n```\n\nproperties为属性列表，Property 表示为对象的属性描述。\n\n```typescript\ninterface Property {\n    type: 'Property';\n    key: Expression;\n    computed: boolean;\n    value: Expression | null;\n    kind: 'get' | 'set' | 'init';\n    method: false;\n    shorthand: boolean;\n}\n```\n\n```typescript\nvar a = {\n\tname: 1\n}\n```\n\n```json\n{\n  \"type\": \"ObjectExpression\",\n  \"start\": 8,\n  \"end\": 20,\n  \"properties\": [\n    {\n      \"type\": \"Property\",\n      \"start\": 11,\n      \"end\": 18,\n      \"method\": false,\n      \"shorthand\": false,\n      \"computed\": false,\n      \"key\": {\n        \"type\": \"Identifier\",\n        \"start\": 11,\n        \"end\": 15,\n        \"name\": \"name\"\n      },\n      \"value\": {\n        \"type\": \"Literal\",\n        \"start\": 17,\n        \"end\": 18,\n        \"value\": 1,\n        \"raw\": \"1\"\n      },\n      \"kind\": \"init\"\n    }\n  ]\n}\n```\n\n注意：{} 既可以表示为表达式，也可以表示为Statement语句，需要结合语义。 <a name=\"H0ybq\"></a>\n\n### 5. ArrayExpression\n\n数组表达式\n\n```typescript\ninterface ArrayExpression {\n    type: 'ArrayExpression';\n    elements: ArrayExpressionElement[];\n}\n```\n\nArrayExpressionElement:\n\n```typescript\ntype ArrayExpressionElement = Expression | SpreadElement;\n```\n\n### 6. SpreadElement\n\n扩展运算符\n\n```typescript\ninterface SpreadElement {\n    type: 'SpreadElement';\n    argument: Expression;\n}\n```\n\n```typescript\nvar a = [1, 2, ...list];\nvar b = {foo: 2, ...obj};\n```\n\n### 7. FunctionExpression\n\nFunctionExpress 表示函数表达式。\n\n```typescript\ninterface FunctionExpression {\n    type: 'FunctionExpression';\n    id: Identifier | null;\n    params: FunctionParameter[];\n    body: BlockStatement;\n    generator: boolean;\n    async: boolean;\n    expression: boolean;\n}\n```\n\n在下面的例子中，等号右边就是一个函数表达式:\n\n```typescript\nvar fn = function(){}\nvar fn = function Person(){}\n```\n\n请注意函数声明和函数表达式的区别。 <a name=\"l647H\"></a>\n\n### 8. ArrowFunctionExpression\n\n箭头函数。\n\n```typescript\ninterface ArrowFunctionExpression {\n    type: 'ArrowFunctionExpression';\n    id: Identifier | null;\n    params: FunctionParameter[];\n    body: BlockStatement | Expression;\n    generator: boolean;\n    async: boolean;\n    expression: false;\n}\n```\n\n```typescript\ntype FunctionParameter = AssignmentPattern | Identifier | BindingPattern;\n```\n\n### 9. TaggedTemplateExpression\n\n### 10. MemberExpression\n\n属性成员表达式\n\n```typescript\ninterface MemberExpression {\n    type: 'MemberExpression';\n    computed: boolean;\n    object: Expression;\n    property: Expression;\n}\n```\n\n```typescript\nconst foo = {bar: 'bar'};\nfoo.bar; // // computed 为 false\nfoo['bar']; // computed 为 true\n```\n\n### 11. Super\n\n父类关键字\n\n```typescript\ninterface Super {\n    type: 'Super';\n}\n```\n\n```typescript\nclass Male extends Person {\n    constructor() {\n        super();\n    }\n}\n```\n\n### 12. MetaProperty\n\nimport.meta 是一个给JavaScript模块暴露特定上下文的元数据属性的对象。它包含了这个模块的信息，比如说这个模块的URL。\n\n```typescript\ninterface MetaProperty {\n    type: 'MetaProperty';\n    meta: Identifier;\n    property: Identifier;\n}\n```\n\n```typescript\nimport.meta\n```\n\n```json\n{\n  \"type\": \"Program\",\n  \"start\": 0,\n  \"end\": 11,\n  \"body\": [\n    {\n      \"type\": \"ExpressionStatement\",\n      \"start\": 0,\n      \"end\": 11,\n      \"expression\": {\n        \"type\": \"MetaProperty\",\n        \"start\": 0,\n        \"end\": 11,\n        \"meta\": {\n          \"type\": \"Identifier\",\n          \"start\": 0,\n          \"end\": 6,\n          \"name\": \"import\"\n        },\n        \"property\": {\n          \"type\": \"Identifier\",\n          \"start\": 7,\n          \"end\": 11,\n          \"name\": \"meta\"\n        }\n      }\n    }\n  ],\n  \"sourceType\": \"module\"\n}\n```\n\n### 13. ClassExpression\n\n类表达式\n\n```typescript\ninterface ClassExpression {\n    type: 'ClassExpression';\n    id: Identifier | null;\n    superClass: Identifier | null;\n    body: ClassBody;\n}\n```\n\n```typescript\nvar Fn = class {\n    constructor() {}\n    method() {}\n};\n```\n\n### 14. NewExpression\n\nnew 表达式\n\n```typescript\ninterface NewExpression {\n    type: 'NewExpression';\n    callee: Expression;\n    arguments: ArgumentListElement[];\n}\n```\n\n```typescript\nnew Person(name)\n```\n\n```json\n{\n  \"type\": \"NewExpression\",\n  \"start\": 0,\n  \"end\": 16,\n  \"callee\": {\n    \"type\": \"Identifier\",\n    \"start\": 4,\n    \"end\": 10,\n    \"name\": \"Person\"\n  },\n  \"arguments\": [\n    {\n      \"type\": \"Identifier\",\n      \"start\": 11,\n      \"end\": 15,\n      \"name\": \"name\"\n    }\n  ]\n}\n```\n\n### 15. CallExpression\n\n函数调用表达式\n\n```typescript\ninterface CallExpression {\n    type: 'CallExpression';\n    callee: Expression | Import;\n    arguments: ArgumentListElement[];\n}\n```\n\nImport 的场景：\n\n```typescript\n(import(''))()\n```\n\n```typescript\ninterface Import {\n    type: 'Import'\n}\n```\n\nArgumentListElement 类型:\n\n```typescript\ntype ArgumentListElement = Expression | SpreadElement;\n```\n\n### 15. UpdateExpression\n\n更新操作符表达式，如 `++`、`--`;\n\n```typescript\ninterface UpdateExpression {\n  type: \"UpdateExpression\";\n  operator: '++' | '--';\n  argument: Expression;\n  prefix: boolean;\n}\n```\n\n```typescript\nvar a = 0;\na++;\n++a; // prefix为true\n```\n\n### 16. AwaitExpression\n\nawait表达式，与 async 一起使用\n\n```typescript\ninterface AwaitExpression {\n    type: 'AwaitExpression';\n    argument: Expression;\n}\n```\n\n```typescript\nasync function slepp() {\n\tawait fn()\n}\n```\n\n```typescript\n{\n  \"type\": \"AwaitExpression\",\n  \"start\": 26,\n  \"end\": 36,\n  \"argument\": {\n    \"type\": \"CallExpression\",\n    \"start\": 32,\n    \"end\": 36,\n    \"callee\": {\n      \"type\": \"Identifier\",\n      \"start\": 32,\n      \"end\": 34,\n      \"name\": \"fn\"\n    },\n    \"arguments\": [],\n    \"optional\": false\n  }\n}\n```\n\n### 17. UnaryExpression\n\n一元操作符表达式\n\n```typescript\ninterface UnaryExpression {\n  type: \"UnaryExpression\";\n  operator: UnaryOperator;\n  prefix: boolean;\n  argument: Expression;\n}\n```\n\nUnaryOperator:\n\n```typescript\nenum UnaryOperator {\n  \"-\" | \"+\" | \"!\" | \"~\" | \"typeof\" | \"void\" | \"delete\" | \"throw\"\n}\n```\n\n### 18. BinaryExpression\n\n二元操作符表达式\n\n```typescript\ninterface BinaryExpression {\n    type: 'BinaryExpression';\n    operator: BinaryOperator;\n    left: Expression;\n    right: Expression;\n}\n```\n\nBinaryOperator:\n\n```typescript\nenum BinaryOperator {\n  \"==\" | \"!=\" | \"===\" | \"!==\"\n     | \"<\" | \"<=\" | \">\" | \">=\"\n     | \"<<\" | \">>\" | \">>>\"\n     | \"+\" | \"-\" | \"*\" | \"/\" | \"%\"\n     | \"**\" | \"|\" | \"^\" | \"&\" | \"in\"\n     | \"instanceof\"\n     | \"|>\"\n}\n```\n\n### 19. LogicalExpression\n\n逻辑运算符表达式\n\n```typescript\ninterface LogicalExpression {\n    type: 'LogicalExpression';\n    operator: '||' | '&&';\n    left: Expression;\n    right: Expression;\n}\n```\n\n```typescript\nvar a = '-';\nvar b = a || '-';\nvar c = a && b || 1\n```\n\n### 20. ConditionalExpression\n\n条件运算符\n\n```typescript\ninterface ConditionalExpression {\n    type: 'ConditionalExpression';\n    test: Expression;\n    consequent: Expression;\n    alternate: Expression;\n}\n```\n\n```typescript\nvar a = 1 ? 'consequent' : 'alternate';\n```\n\n### 21. YieldExpression\n\nyield表达式\n\n```typescript\ninterface YieldExpression {\n    type: 'YieldExpression';\n    argument: Expression | null;\n    delegate: boolean;\n}\n```\n\n```typescript\nfunction* gen(x) {\n  return yield x + 1;\n}\n```\n\n### 22. AssignmentExpression\n\n赋值表达式\n\n```typescript\ninterface AssignmentExpression {\n    type: 'AssignmentExpression';\n    operator: '=' | '*=' | '**=' | '/=' | '%=' | '+=' | '-=' |\n        '<<=' | '>>=' | '>>>=' | '&=' | '^=' | '|=';\n    left: Expression;\n    right: Expression;\n}\n```\n\n### 23. SequenceExpression\n\n使用逗号的序列表达式\n\n```typescript\ninterface SequenceExpression {\n  type: 'SequenceExpression';\n  expressions: Expression[];\n}\n```\n\n```typescript\na = 1, b = 2;\n```\n","isLeaf":true},{"key":"/Babel/06 acorn/05.md","path":"/Babel/06 acorn/05.md","route":"/Babel/06 acorn/05.md","leaf":true,"title":"05","depth":2,"content":"---\ntitle: Statement 语句\ntags: acornjs\n---\n\nJS 规范可以参考 <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference>\nstatements，即语句，类型如下：\n\n```typescript\ntype Statement = BlockStatement | BreakStatement | ContinueStatement |\n    DebuggerStatement | DoWhileStatement | EmptyStatement |\n    ExpressionStatement | ForStatement | ForInStatement |\n    ForOfStatement | FunctionDeclaration | IfStatement |\n    LabeledStatement | ReturnStatement | SwitchStatement |\n    ThrowStatement | TryStatement | VariableDeclaration |\n    WhileStatement | WithStatement;\n```\n\n### 1. BlockStatement\n\n表示一个作用域块。\n\n```typescript\ninterface BlockStatement {\n    type: 'BlockStatement';\n    body: Statement[];\n}\n```\n\n```typescript\n{}\n```\n\n```typescript\n{\n  \"type\": \"BlockStatement\",\n  \"start\": 0,\n  \"end\": 2,\n  \"body\": []\n}\n```\n\n<a name=\"ylwvh\"></a>\n\n### 2. IfStatement\n\nIfStatement 用于表示 if 语句\n\n```typescript\ninterface IfStatement {\n    type: 'IfStatement';\n    test: Expression;\n    consequent: Statement;\n    alternate?: Statement;\n}\n```\n\n```typescript\nif (a > b) {}\n```\n\n```json\n{\n  \"type\": \"IfStatement\",\n  \"start\": 0,\n  \"end\": 13,\n  \"test\": {\n    \"type\": \"BinaryExpression\",\n    \"start\": 4,\n    \"end\": 9,\n    \"left\": {\n      \"type\": \"Identifier\",\n      \"start\": 4,\n      \"end\": 5,\n      \"name\": \"a\"\n    },\n    \"operator\": \">\",\n    \"right\": {\n      \"type\": \"Identifier\",\n      \"start\": 8,\n      \"end\": 9,\n      \"name\": \"b\"\n    }\n  },\n  \"consequent\": {\n    \"type\": \"BlockStatement\",\n    \"start\": 11,\n    \"end\": 13,\n    \"body\": []\n  },\n  \"alternate\": null\n}\n```\n\n<a name=\"lkIih\"></a>\n\n### 3. ReturnStatement\n\nReturenStatement 用于表示 return 语句\n\n```typescript\ninterface ReturnStatement {\n    type: 'ReturnStatement';\n    argument: Expression | null;\n}\n```\n\n```typescript\nfunction sleep() {\n\treturn 10;\n}\n```\n\n```typescript\n{\n  \"type\": \"ReturnStatement\",\n  \"start\": 20,\n  \"end\": 30,\n  \"argument\": {\n    \"type\": \"Literal\",\n    \"start\": 27,\n    \"end\": 29,\n    \"value\": 10,\n    \"raw\": \"10\"\n  }\n}\n```\n\n### 4. SwitchStatement\n\nSwitchStatement 用于表示 switch 语句。\n\n```typescript\ninterface SwitchStatement {\n    type: 'SwitchStatement';\n    discriminant: Expression;\n    cases: SwitchCase[];\n}\n```\n\n```typescript\nswitch(b) {\n  case 10:\n    console.log(10);\n    break;\n  case 20:\n    console.log(20);\n    break;\n  default:\n    console.log(\"default\")\n}\n```\n\n![20230608110506](http://s3.airtlab.com/blog/20230608110506.png)\n\n### 5. WhileStatement\n\nwhile 语句。\n\n```typescript\ninterface WhileStatement {\n    type: 'WhileStatement';\n    test: Expression;\n    body: Statement;\n}\n```\n\n<a name=\"zxenD\"></a>\n\n### 6. BreakStatement\n\nbreak 语句。\n\n```typescript\n{\n   \"type\": \"BreakStatement\",\n   \"label\": null | string\n}\n```\n\n```typescript\nfor(;;){\n\tbreak;\n}\n```\n\n<a name=\"pjLpI\"></a>\n\n### 7. ContinueStatement\n\ncontinue 语句。\n\n```typescript\n{\n   \"type\": \"ContinueStatement\",\n   \"label\": null | string\n}\n```\n\n```typescript\nfor(;;){\n\tcontinue;\n}\n```\n\n<a name=\"regOL\"></a>\n\n### 8. DebuggerStatement\n\ndebugger 语句。\n\n```typescript\n{\n   \"type\": \"DebuggerStatement\"\n}\n```\n\n```typescript\ndebugger;\n```\n\n<a name=\"i63zx\"></a>\n\n### 9. DoWhileStatement\n\n```json\ninterface DoWhileStatement {\n    type: 'DoWhileStatement';\n    body: Statement;\n    test: Expression;\n}\n```\n\n```typescript\ndo {} while(1)\n```\n\n```json\n{\n  \"type\": \"DoWhileStatement\",\n  \"start\": 0,\n  \"end\": 14,\n  \"body\": {\n    \"type\": \"BlockStatement\",\n    \"start\": 3,\n    \"end\": 5,\n    \"body\": []\n  },\n  \"test\": {\n    \"type\": \"Literal\",\n    \"start\": 12,\n    \"end\": 13,\n    \"value\": 1,\n    \"raw\": \"1\"\n  }\n}\n```\n\n<a name=\"RK0TE\"></a>\n\n### 10. EmptyStatement\n\n空语句。\n\n```typescript\ninterface EmptyStatement {\n  type: \"EmptyStatement\"\n}\n```\n\n```typescript\n;\n```\n\n<a name=\"yuv0l\"></a>\n\n### 11. ExpressionStatement\n\n表达式语句。\n\n```typescript\ninterface ExpressionStatement {\n  type: \"ExpressionStatement\";\n  expression: Expression\n}\n```\n\n```typescript\n(function() {})\n```\n\n```json\n{\n  \"type\": \"ExpressionStatement\",\n  \"start\": 0,\n  \"end\": 15,\n  \"expression\": {\n    \"type\": \"FunctionExpression\",\n    \"start\": 1,\n    \"end\": 14,\n    \"id\": null,\n    \"expression\": false,\n    \"generator\": false,\n    \"async\": false,\n    \"params\": [],\n    \"body\": {\n      \"type\": \"BlockStatement\",\n      \"start\": 12,\n      \"end\": 14,\n      \"body\": []\n    }\n  }\n}\n```\n\n<a name=\"NzoXy\"></a>\n\n### 12. ForStatement\n\n```typescript\ninterface ForStatement {\n    type: 'ForStatement';\n    init: Expression | VariableDeclaration | null; // 初始化\n    test: Expression | null; // 中间条件\n    update: Expression | null; // 迭代步骤\n    body: Statement; // 主体\n}\n```\n\n<a name=\"CtOnX\"></a>\n\n### 13. ForInStatement\n\nfor...in.. 语句\n\n```typescript\ninterface ForInStatement {\n    type: 'ForInStatement';\n    left: Expression;\n    right: Expression;\n    body: Statement;\n}\n```\n\n```typescript\nfor(let i in a) {}\n```\n\n```typescript\n{\n  \"type\": \"ForInStatement\",\n  \"start\": 0,\n  \"end\": 18,\n  \"left\": {\n    \"type\": \"VariableDeclaration\",\n    \"start\": 4,\n    \"end\": 9,\n    \"declarations\": [\n      {\n        \"type\": \"VariableDeclarator\",\n        \"start\": 8,\n        \"end\": 9,\n        \"id\": {\n          \"type\": \"Identifier\",\n          \"start\": 8,\n          \"end\": 9,\n          \"name\": \"i\"\n        },\n        \"init\": null\n      }\n    ],\n    \"kind\": \"let\"\n  },\n  \"right\": {\n    \"type\": \"Identifier\",\n    \"start\": 13,\n    \"end\": 14,\n    \"name\": \"a\"\n  },\n  \"body\": {\n    \"type\": \"BlockStatement\",\n    \"start\": 16,\n    \"end\": 18,\n    \"body\": []\n  }\n}\n```\n\n<a name=\"RXXqj\"></a>\n\n### 14. ForOfStatement\n\nfor...of 语句\n\n```typescript\ninterface ForOfStatement {\n    type: 'ForOfStatement';\n    left: Expression;\n    right: Expression;\n    body: Statement;\n}\n```\n\n<a name=\"z65t9\"></a>\n\n### 15. ThrowStatement\n\nthrow 语句\n\n```typescript\ninterface ThrowStatement {\n  type: \"ThrowStatement\",\n  argument: S\n}\n```\n\n```typescript\n// throw expression;\n```\n\n```json\n{\n  \"type\": \"ThrowStatement\",\n  \"start\": 0,\n  \"end\": 12,\n  \"argument\": {\n    \"type\": \"Literal\",\n    \"start\": 6,\n    \"end\": 11,\n    \"value\": \"err\",\n    \"raw\": \"\\\"err\\\"\"\n  }\n}\n```\n\n<a name=\"vttj4\"></a>\n\n### 16. TryStatement\n\ntry...catch... 语句\n\n```typescript\ninterface TryStatement {\n    type: 'TryStatement';\n    block: BlockStatement;\n    handler: CatchClause | null;\n    finalizer: BlockStatement | null;\n}\n```\n\n```typescript\ntry {}catch (e) {}\n```\n\n```json\n{\n  \"type\": \"TryStatement\",\n  \"start\": 0,\n  \"end\": 18,\n  \"block\": {\n    \"type\": \"BlockStatement\",\n    \"start\": 4,\n    \"end\": 6,\n    \"body\": []\n  },\n  \"handler\": {\n    \"type\": \"CatchClause\",\n    \"start\": 6,\n    \"end\": 18,\n    \"param\": {\n      \"type\": \"Identifier\",\n      \"start\": 13,\n      \"end\": 14,\n      \"name\": \"e\"\n    },\n    \"body\": {\n      \"type\": \"BlockStatement\",\n      \"start\": 16,\n      \"end\": 18,\n      \"body\": []\n    }\n  },\n  \"finalizer\": null\n}\n```\n\n<a name=\"on7Fu\"></a>\n\n### 17. WithStatement\n\nwith语句（指定块语句的作用域）\n\n```typescript\ninterface WithStatement {\n    type: 'WithStatement';\n    object: Expression;\n    body: Statement;\n}\n```\n","isLeaf":true}]},{"key":"/Babel/_meta.md","path":"/Babel/_meta.md","route":"/Babel/_meta.md","leaf":true,"title":"_meta","depth":1,"content":"","isLeaf":true}]},{"key":"/Javascript","path":"/Javascript","route":"/Javascript","leaf":false,"title":"Javascript","depth":0,"content":"","isLeaf":false,"children":[{"key":"/Javascript/_meta.md","path":"/Javascript/_meta.md","route":"/Javascript/_meta.md","leaf":true,"title":"_meta","depth":1,"content":"","isLeaf":true}]},{"key":"/NodeJS","path":"/NodeJS","route":"/NodeJS","leaf":false,"title":"NodeJS","depth":0,"content":"","isLeaf":false,"children":[{"key":"/NodeJS/01-basic","path":"/NodeJS/01-basic","route":"/NodeJS/01-basic","leaf":false,"title":"01-basic","depth":1,"content":"","isLeaf":false,"children":[{"key":"/NodeJS/01-basic/001-npm-usage.md","path":"/NodeJS/01-basic/001-npm-usage.md","route":"/NodeJS/01-basic/001-npm-usage.md","leaf":true,"title":"001-npm-usage","depth":2,"content":"---\ntitle: 001 npm 用法笔记\ntoc: true\ntags: NodeJS\ncategories: 前端开发\n---\n\n## 1、设置镜像地址\n\n用户级别 `npm` 配置文件一般在 `~/.npmrc`，可以手动打开并修改：\n\n```text\n;;;;\n; npm userconfig file: /Users/xxx/.npmrc\n; this is a simple ini-formatted file\n; lines that start with semi-colons are comments\n; run `npm help 7 config` for documentation of the various options\n;\n; Configs like `@scope:registry` map a scope to a given registry url.\n;\n; Configs like `//<hostname>/:_authToken` are auth that is restricted\n; to the registry host specified.\n\nhome=https://www.npmjs.org\nregistry=https://npm.shopee.io/ # 设置仓库地址\n```\n\n或者通过 `npm config` 命令打开文件:\n\n```bash\nnpm config edit\n```\n\n或者直接使用 `npm config` 命令进行修改：\n\n```text\nUsage:\nnpm config set <key>=<value> [<key>=<value> ...]\nnpm config get [<key> [<key> ...]]\nnpm config delete <key> [<key> ...]\nnpm config list [--json]\nnpm config edit\n```\n\n当然你也可以在项目的根目录新建 `.npmrc` 文件进行局部覆盖：\n\n```text\nregistry=https://registry.npmjs.org/\n```\n\n## 2、安装本地 npm 包\n\n```bash\nnpm install [path]\n```\n\n比如安装下面的 sleep 包，可以通过 `npm install ~/Desktop/sleep` 进行安装，其目录地址为 `~/Desktop/sleep`。\n\n![20230404152959](http://s3.airtlab.com/blog/20230404152959.png)\n\n```js\nconst sleep = () => {\n  console.log(sleep);\n};\nmodule.exports = { sleep };\n```\n\n安装完成后，`dependencies` 中显示 `sleep` 是一个本地文件：\n\n```json\n{\n  \"dependencies\": {\n    \"sleep\": \"file:../sleep\"\n  }\n}\n```\n\n`package-lock.json` 也会标注本地依赖：\n\n```json\n{\n  \"packages\": {\n    \"../sleep\": {\n      \"version\": \"1.0.0\",\n      \"license\": \"ISC\"\n    },\n    \"node_modules/sleep\": {\n      \"resolved\": \"../sleep\",\n      \"link\": true\n    }\n  }\n}\n```\n\n## 3、查看 npm 全局包\n\n执行 `npm -h` 提示：\n\n```shell\nroot@host ~ %\nroot@host ~ %\nroot@host ~ %\nroot@host ~ %\nroot@host ~ %\nroot@host ~ % npm -h\nnpm <command>\n\nUsage:\n\nnpm install        install all the dependencies in your project\nnpm install <foo>  add the <foo> dependency to your project\nnpm test           run this project's tests\nnpm run <foo>      run the script named <foo>\nnpm <command> -h   quick help on <command>\nnpm -l             display usage info for all commands\nnpm help <term>    search for help on <term>\nnpm help npm       more involved overview\n\nAll commands:\n\n    access, adduser, audit, bin, bugs, cache, ci, completion,\n    config, dedupe, deprecate, diff, dist-tag, docs, doctor,\n    edit, exec, explain, explore, find-dupes, fund, get, help,\n    hook, init, install, install-ci-test, install-test, link,\n    ll, login, logout, ls, org, outdated, owner, pack, ping,\n    pkg, prefix, profile, prune, publish, query, rebuild, repo,\n    restart, root, run-script, search, set, set-script,\n    shrinkwrap, star, stars, start, stop, team, test, token,\n    uninstall, unpublish, unstar, update, version, view, whoami\n\nSpecify configs in the ini-formatted file:\n    /Users/xiong.gao/.npmrc\nor on the command line via: npm <command> --key=value\n\nMore configuration info: npm help config\nConfiguration fields: npm help 7 config\n\nnpm@8.19.3 /usr/local/lib/node_modules/npm\n```\n\n其中最底部 `/usr/local/lib/node_modules` 就是全局包的安装路径\n\n## 4、npm link 用法\n\n`npm link` 在开发 npm 包进行本地调试的时候会很有用，假设现在有两个项目，main 为主项目，sleep 为 npm 包项目。\n\n- 在 sleep 目录下执行 `npm link`，此操作会在全局包中创建一个软连接指向真实目录\n- 在 main 目录下执行 `npm link sleep`，创建软连接到 node_modules\n\n![20230404154920](http://s3.airtlab.com/blog/20230404154920.png)\n\n## 5、npx 用法\n\nnpx 想要解决的主要问题，就是调用项目内部安装的模块。比如，项目内部安装了 xxx，如果想在命令行下调用，必须像下面这样：\n\n```shell\n# 项目的根目录下执行\n$ node-modules/.bin/xxx --version\n```\n\n使用 npx 只要像下面这样调用就行了\n\n```shell\nnpx xxx --version\n```\n\n## 6、npm ci 和 npm install 区别\n\n- 必须已经存在 package-lock.json 或 npm-shrinkwrap.json，否则无法使用 npm ci\n- 如果 package-lock.json 中的依赖项与 package.json 中的依赖项不匹配，则 npm ci 将退出并显示错误，而不是更新 package-lock.json\n- npm ci 一次只能安装整个项目，无法添加单个依赖项\n- npm ci 开始安装之前自动删除 node_modules 文件夹\n- npm ci 不会更改 package.json 和 package-lock.json\n\n## 7、npm prune 的作用\n\n在开发过程中，可能使用了某些模块，而后来的某个环节可能又不再使用。但是 npm install 一次，都会在 node_modules 中存留文件，node_modules 目录就会变的臃肿起来，npm prune 此命令的功能是根据 package.json 里的依赖项，删除不需要的模块文件。如果 --production 指定了标志或将 NODE_ENV 环境变量设置为 production，则此命令将删除您的包中指定的软件包 devDependencies\n\n```shell\nnpm prune --production\n```\n\n## 8、peerDependencies 作用\n\n当一个包被依赖时，如果它在其peer dependency中声明了另一个依赖包，那么这个依赖包的版本和安装方式将被忽略，而是使用当前项目中或父级包中已经安装的相同版本的依赖包。\n\n默认在安装依赖时 peerDependency 版本不一致会报错，可以设置忽略。\n\n## 9、npm devDependencies\n\n我的项目依赖了 npm 包 b， 当执行 npm install b 时，b 里面的 devDependencies 会被自动安装吗？\n\n在默认情况下，当您运行 `npm install b` 时，npm 将仅安装依赖项列表中列出的生产环境依赖项，而不会自动安装 `b` 包中 `devDependencies` 中列出的开发环境依赖项。\n如果你需要同时安装开发环境依赖项，你需要在安装时加上 `--dev` 或 `-D` 参数来安装所有生产和开发环境依赖项。\n\n例如，您可以运行以下命令来同时安装生产和开发环境依赖项：\n\n```\nnpm install b --save-dev\n```\n\n或者也可以简写为：\n\n```\nnpm install b -D\n```\n\n这将安装 `b` 依赖项和 `b` 的所有 `devDependencies` 依赖项。\n","isLeaf":true},{"key":"/NodeJS/01-basic/002-nodejs-version.md","path":"/NodeJS/01-basic/002-nodejs-version.md","route":"/NodeJS/01-basic/002-nodejs-version.md","leaf":true,"title":"002-nodejs-version","depth":2,"content":"---\ntitle: 002 NodeJS 版本管理\ntoc: true\ntags: NodeJS\ncategories: 前端开发\n---\n\n推荐在 windows 上使用 nvm，在 mac 上则使用 n。\n二者主要区别如下：\n- n 会将 nodejs 安装为全局版本，因此有可能在切换 node 版本后，发生全局模块执行出错的问题；\n- nvm 则会将全局模块存在于各自版本的沙箱中，切换版本后需要重新安装，不同版本间也不存在任何冲突；\n\n对于 `node` 可执行文件的位置:\n- n 存放到 `/usr/local/bin`，所以不需要配置环境变量就能访问\n- nvm 则需要手动指定路径。\n\n## 1. nvm\nnvm 全名 Node.js Version Management，在 macOS、Linux（包括适用于 Linux 的 Windows 子系统）和各种其他类 Unix 系统上均受支持。\n由于 Windows 支持程度不佳，社区孵化了 nvm-windows 供 Windows 使用，它们隶属于不同的项目，相互分开的支持和维护。\n\n- Linux、Mac OS：https://github.com/nvm-sh/nvm\n- Windows：https://github.com/coreybutler/nvm-windows\n\n### 1.1 安装\n#### Mac\n```shell\n# 方式1 浏览器打开下面链接下载\nhttps://github.com/nvm-sh/nvm/blob/v0.39.1/install.sh\n# 下载完成后，通过命令安装\nsh install.sh\n\n# 方式2 推荐\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash\n\n# 方式3\nwget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash\n```\n\n#### windows\n参考 https://www.freecodecamp.org/chinese/news/node-version-manager-nvm-install-guide/\n\n注意，如果在安装 nvm 之前已经装了 nodejs，建议先卸载掉。\n\n**nvm-setup 安装**\n请记住安装位置，后续配置环境变量时方便检查\n![vnm安装路径](http://s3.airtlab.com/blog/20230224224924.png)\n\n![链接路径](http://s3.airtlab.com/blog/20230224224943.png)\n\n**查看安装路径**\nC:\\Users\\Administrator\\AppData\\Roaming\\nvm\n![20230224225211](http://s3.airtlab.com/blog/20230224225211.png)\n\n**修改 setting 配置镜像**\n![20230224225244](http://s3.airtlab.com/blog/20230224225244.png)\n\n### 1.2 使用\n```shell\nnvm ls                # 查看版本安装所有版本\nnvm ls-remote         # 查看远程所有的 Node.js 版本\nnvm install 17.0.0    # 安装指定的 Node.js 版本\nnvm use 17.0.0        # 使用指定的 Node.js 版本\nnvm alias default 17.0.0  # 设置默认 Node.js 版本\nnvm alias dev 17.0.0  # 设置指定版本的别名，如将 17.0.0 版本别名设置为 dev\n```\n\n## 2. n\nn 是一款交互式的 Node.js 版本管理工具，没有子脚本，没有配置文件，也没有复杂的 API，使用起来非常简单。\nn 只适用于 macOS 和 Linux ，不适用于 Windows。\n### 2.1 安装\n\n```shell\nnpm install n -g\n```\n\n### 2.2 使用\n```shell\nn          # 显示所有已下载版本\nn 10.16.0  # 下载指定版本\nn lts      # 查看远程所有 LTS Node.js 版本\nn run 10.16.0 # 运行指定的 Node.js 版本\n```","isLeaf":true},{"key":"/NodeJS/01-basic/003-nodejs-debug.md","path":"/NodeJS/01-basic/003-nodejs-debug.md","route":"/NodeJS/01-basic/003-nodejs-debug.md","leaf":true,"title":"003-nodejs-debug","depth":2,"content":"---\ntitle: 003 nodejs 代码调试\ntoc: true\ntags: NodeJS\ncategories: 前端开发\n---\n\n目标：掌握程序的调试技巧\n\n## 1、开启调试模式\n\n在调试之前我们先初始化一个工程：\n```shell\n$ npm init -y\n$ npm install --save koa koa-route\n```\n\n```js\n// app.js\nconst Koa = require('koa');\nconst router = require('koa-route');\n\nconst app = new Koa();\n\nconst main = ctx => {\n  debugger\n  ctx.response.body = 'Hello World';\n};\n\nconst welcome = (ctx, name) => {\n  ctx.response.body = 'Hello ' + name;\n};\n\napp.use(router.get('/', main));\napp.use(router.get('/:name', welcome));\n\napp.listen(3000);\nconsole.log('listening on port 3000');\n```\n\n### 1) 9229\n\n端口 9229 是默认的 NodeJS 调试端口。它允许您将诸如Chrome 的 Inspector或 WebStorm 的远程调试之类的调试工具附加到使用特殊标志运行的 Node 进程\n\n### 2) --inspect\n\n在运行 nodejs 程序时，可以通过 `--inspect` 开始调试模式：\n```shell\nnode --inspect app.js\n```\n\n然后就可以通过 `浏览器` 和 `vscode` 以及 `webstorm` 等UI界面调试了。 \n\n启动后提示：\n```shell\n# 这里提示调试通道的地址为 ws://127.0.0.1:9229/91a04b5e-67bd-4b1a-93c5-9260a75403d2\nDebugger listening on ws://127.0.0.1:9229/91a04b5e-67bd-4b1a-93c5-9260a75403d2\nFor help, see: https://nodejs.org/en/docs/inspector\nlistening on port 3000\n```\n\n### 3) inspect-brk\n\n`--inspect-brk` 指定在第一行就设置断点。也就是说，一开始运行，就是暂停的状态。这对在 chrome 中调试非服务脚本会非常有用。否则在你设置断点之前程序就结束了。\n\n## 2、使用浏览器调试\n\n一共有两种打开调试工具的方法，第一种是在 Chrome 浏览器的地址栏，键入 `chrome://inspect` 或者 `about:inspect`，回车后就可以看到下面的界面：\n\n![20230225085601](http://s3.airtlab.com/blog/20230225085601.png)\n\n点击 inspect 链接，就能进入调试工具了。\n\n第二种方法，是在 http://127.0.0.1:3000 的窗口打开\"开发者工具\"，顶部左上角有一个 Node 的绿色标志，点击就可以进入。\n\n![20230225085741](http://s3.airtlab.com/blog/20230225085741.png)\n\n点击后进入：\n![20230225085820](http://s3.airtlab.com/blog/20230225085820.png)\n\n当我们访问 `http://localhost:3000`，就会进入暂停在断点处：\n![20230225090028](http://s3.airtlab.com/blog/20230225090028.png)\n\n### 1) url 调试地址\n\n假若 ws 地址为：ws://127.0.0.1:9229/8e951b59-b730-41dc-a4c0-15da52b71fd3，有两个很重要的页面地址：\n\n- **js_app.html**: `devtools://devtools/bundled/js_app.html?experiments=true&v8only=true&ws=127.0.0.1:9229/8e951b59-b730-41dc-a4c0-15da52b71fd3`\n\n- **inspector.html**: `devtools://devtools/bundled/inspector.html?experiments=true&v8only=true&ws=127.0.0.1:9229/8e951b59-b730-41dc-a4c0-15da52b71fd3` 访问该 url 即可进入调试页面\n\n## 3、使用 vscode 调试\n\n创建 `launch.json ` 文件, 格式如下：\n\n```json\n{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    // 配置1\n    {},\n    // 配置2\n    {}\n  ]\n}\n```\n\n### 1) 调试 Node.js 程序\n```json\n{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"type\": \"pwa-node\",\n      \"request\": \"launch\",\n      \"name\": \"Launch Javascript Program\",\n      \"skipFiles\": [\"<node_internals>/**\"],\n      \"program\": \"${workspaceFolder}/node_modules/@vue/cli-service/lib/Service.js\"\n    }\n  ]\n}\n```\n\n- type: 必填项，调试类型，当前为 node，如果是 PHP 调试，则在安装 PHP 调试插件后写 php；\n- request: 必填项，有两种类型，分别是 launch 和 attach，前者的意思就是 VSCode 会打开这个程序然后进入调试，后者的意思是你已经打开了程序，然后接通 Node.js 的内部调试协议进行调试，如果你看过“Node.js 的调试原理”一文，应该可以大致理解；\n- program: 程序的启动入口；\n\n还可以使用另外的配置方式，打开 launch.json 找到 name 为 调试 Node.js 程序 - args 的文件：\n```json\n{\n  \"name\": \"调试 Node.js 程序 - args\",\n  \"type\": \"node\",\n  \"request\": \"launch\",\n  \"runtimeExecutable\": \"node\",\n  \"args\": [\n    \"${workspaceFolder}/src/index.js\"\n  ]\n}\n```\n\n这里并没有采用 program 来描述程序入口，而是通过 runtimeExecutable 和 args 组合的方式来启动程序:\n\n- runtimeExecutable: 使用什么命令启动\n- args: 启动时的参数\n\n相当于：\n```shell\nnode ${workspaceFolder}/src/index.js\n```\n\n### 2) 通过npm脚本启动\n\n```json\n{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"type\": \"pwa-node\",\n      \"request\": \"launch\",\n      \"name\": \"Npm Command\",\n      \"skipFiles\": [\"<node_internals>/**\"],\n      \"runtimeExecutable\": \"npm\",\n      \"runtimeArgs\": [\"run-script\", \"build\"]\n    }\n  ]\n}\n```\n\nruntimeArgs 是为 runtimeExecutable 环境提供的配置，而 args 是为程序提供的配置。这个 JSON 的意思是：\n```shell\nnpm run build\n```\n\n### 3) 调试一个 TS Node 程序\n\n```json\n{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"type\": \"node\",\n      \"request\": \"launch\",\n      \"name\": \"Launch Typescript Program\",\n      \"runtimeArgs\": [\"-r\", \"ts-node/register\"],\n      \"args\": [\"${workspaceFolder}/main.ts\"]\n    }\n  ]\n}\n```\n\n等同于:\n```shell\nnode --inspect-brk=DEBUG_PORT -r ts-node/register $workspaceFolder/main.ts\n```\n\n### 4) 调试已启动的程序\n\n```json\n{\n  \"type\": \"pwa-node\",\n  \"request\": \"attach\",\n  \"name\": \"Attach\",\n  \"port\": 9229\n}\n```\n上面写死了 9229，你可以换种写法：\n\n```json\n{\n  \"type\": \"pwa-node\",\n  \"request\": \"attach\",\n  \"name\": \"Attach\",\n  \"processId\": \"${command:PickProcess}\"\n}\n```\n\n`${command:PickProcess}` 作为 processId 的值，VSCode 会遍历所有的 Node PID 列出来让你选择，如下图所示：\n![20230225094847](http://s3.airtlab.com/blog/20230225094847.png)\n\n\n### 5) 调试网页的 JS 代码\n大家应该十分熟悉在 Chrome 中调试 JS 代码，不过 VSCode 允许你在安装了 Debugger for Chrome 插件后，直接在 VSCode 调试 JS 代码，让你的代码和调试融为一体，提升开发体验：\n\n![20230225095030](http://s3.airtlab.com/blog/20230225095030.png)\n\n可以通过如下简单的配置进行调试：\n```json\n{\n  \"name\": \"调试网页的 JS 文件\",\n  \"request\": \"launch\",\n  \"type\": \"chrome\",\n  \"file\": \"${workspaceFolder}/index.html\"\n}\n```\n\n注意，这里的 type 是 chrome，默认会启动一个 Chrome 浏览器（新用户）加载 file 字段对应的文件地址（通过 file:// 协议加载），文件中用到的 JS 都可以断点调试。当然你也可以起一个 Web Server 来调试 http:// 协议的文件，这里就需要设置 webRoot 和 url 参数了，可自行 Google。\n\n\n## 3、参考文档\n- [nodejs debugger](https://code.visualstudio.com/docs/nodejs/nodejs-debugging)\n- [VSCode 调试中 launch.json 配置不完全指南](https://www.barretlee.com/blog/2019/03/18/debugging-in-vscode-tutorial/)\n- [Node 调试工具入门教程](https://www.ruanyifeng.com/blog/2018/03/node-debugger.html)\n- [让你 nodejs 水平暴增的 debugger 技巧](https://zhuanlan.zhihu.com/p/387270007?utm_source=wechat_session&utm_medium=social&utm_oi=635912988696121344)\n- [如何在vscode里面调试js和node.js](https://www.cnblogs.com/both-eyes/p/10152142.html)\n","isLeaf":true},{"key":"/NodeJS/01-basic/004-nodejs-debug-why.md","path":"/NodeJS/01-basic/004-nodejs-debug-why.md","route":"/NodeJS/01-basic/004-nodejs-debug-why.md","leaf":true,"title":"004-nodejs-debug-why","depth":2,"content":"---\ntitle: 004 nodejs 调试原理\ntoc: true\ntags: NodeJS\ncategories: 前端开发\n---\n\n> 原文 神光《JavaScript Debugger 原理揭秘》 https://zhuanlan.zhihu.com/p/372135871\n\n> 这篇文章首先对我是有帮助的，了解一些概念，但是作者在介绍 “解释型语言的 debugger” 原理时明显是有纰漏的，没有讲到解释器是如何支持中断的。比如我可以简单理解为死循环？这明显是错误的。其中可以参考雪碧大佬的回答：\n\n> doodlewind: 这个有点跑偏了吧……感觉这方面内容主要应该涉及 step over、step in 的时候会发生的事？（或者说引擎是如何支持调试协议的。）至于类似 INT3 中断的机制，这对解释器来说确实是必要的（比如引擎跑进死循环 JS 代码的时候，也可以响应 ctrl-c 的信号跳出 main loop），但我不太觉得这个概念就是调试器的「底层原理」……[捂脸]\n\n## 1、CPU 中断\n\ncpu 只会不断地执行下一条指令，但程序运行过程中难免要处理一些外部的消息，比如 io、网络、异常等等，所以设计了中断的机制，cpu 每执行完一条指令，就会去看下中断标记，是否需要中断了。就像 event loop 每次 loop 完都要检查下是否需要渲染一样。\n\n## 2、INT 指令\n\ncpu 支持 INT 指令来触发中断，中断有编号，不同的编号有不同的处理程序，记录编号和中断处理程序的表叫做中断向量表。其中 INT 3 (3 号中断)可以触发 debugger，这是一种约定。\n\n那么可执行文件是怎么利用这个 3 号中断来 debugger 的呢?其实就是运行时替换执行的内容，debugger 程序会在需要设置断点的位置把指令内容换成 INT 3，也就是 0xCC，这就断住了。就可以获取这时候的环境数据来做调试。\n\n![20230226204200](http://s3.airtlab.com/blog/20230226204200.png)\n\n通过机器码替换成 0xcc (INT 3)是把程序断住了，可是怎么恢复执行呢?其实也比较简单，把当时替换的机器码记录下来，需要释放断点的时候再换回去就行了。\n\n这就是可执行文件的 debugger 的原理了，最终还是靠 cpu 支持的中断机制来实现的。\n\n## 3、中断寄存器\n\n上面说的 debugger 实现方式是修改内存中的机器码的方式，但有的时候修改不了代码，比如 ROM，这种情况就要通过 cpu 提供的 4 个中断寄存器(DR0 - DR3)来做了。这种叫做硬中断。\n\n总之，INT 3 的软中断，还有中断寄存器的硬中断，是可执行文件实现 debugger 的两种方式。\n\n## 4、解释型语言的 debugger\n\n编译型语言因为直接在操作系统之上执行，所以要利用 cpu 和操作系统的中断机制和系统调用来实现 debugger。但是解释型语言是自己实现代码的解释执行的，所以不需要那一套，但是实现思路还是一样的，就是插入一段代码来断住，支持环境数据的查看和代码的执行，当释放断点的时候就继续往下执行。\n\n比如 javascript 中支持 debugger 语句，当解释器执行到这一条语句的时候就会断住。\n\n解释型语言的 debugger 相对简单一些，不需要了解 cpu 的 INT 3 中断。\n\n> 这个有点跑偏了吧……感觉这方面内容主要应该涉及 step over、step in 的时候会发生的事？（或者说引擎是如何支持调试协议的。）至于类似 INT3 中断的机制，这对解释器来说确实是必要的（比如引擎跑进死循环 JS 代码的时候，也可以响应 ctrl-c 的信号跳出 main loop），但我不太觉得这个概念就是调试器的「底层原理」……[捂脸]\n\n## 5、debugger 客户端\n\n上面我们了解了直接执行和解释执行的代码的 debugger 分别是怎么实现的。我们知道了代码是怎么断住的，那么断住之后呢?怎么把环境数据暴露出去，怎么执行外部代码?\n\n这就需要 debugger 客户端了。比如 v8 引擎会把设置断点、获取环境信息、执行脚本的能力通过 socket 暴露出去，socket 传递的信息格式就是 v8 debug protocol 。\n\n设置断点：\n\n```json\n{\n  \"seq\": 117,\n  \"type\": \"request\",\n  \"command\": \"setbreakpoint\",\n  \"arguments\": {\n    \"type\": \"function\",\n    \"target\": \"f\"\n  }\n}\n```\n\n去掉断点：\n\n```json\n{\n  \"seq\": 117,\n  \"type\": \"request\",\n  \"command\": \"clearbreakpoint\",\n  \"arguments\": {\n    \"type\": \"function\",\n    \"breakpoint\": 1\n  }\n}\n```\n\n继续：\n\n```json\n{\n  \"seq\": 117,\n  \"type\": \"request\",\n  \"command\": \"continue\"\n}\n```\n\n执行代码：\n\n```json\n{\n  \"seq\": 117,\n  \"type\": \"request\",\n  \"command\": \"evaluate\",\n  \"arguments\": { \"expression\": \"1+2\" }\n}\n```\n感兴趣的同学可以去 v8 debug protocol 的文档中去查看全部的协议。\n\n基于这些协议就可以控制 v8 的 debugger 了，所有的能够实现 debugger 的都是对接了这个协议，比如 chrome devtools、vscode debugger 还有其他各种 ide 的 debugger。\n\n## 6、nodejs 代码的调试\n\nnodejs 可以通过添加 --inspect 的 option 来做调试(也可以是 --inspect-brk，这个会在首行就断住)。\n\n它会起一个 debugger 的 websocket 服务端，我们可以用 vscode 来调试 nodejs 代码，也可以用 chrome devtools 来调试(见 nodejs debugger 文档)。\n\n```bash\nnode --inspect test.js\nDebugger listening on ws://127.0.0.1:9229/db309268-623a-4abe-b19a-c4407ed8998d\nFor help see https://nodejs.org/en/docs/inspector\n```\n\n原理就是实现了 v8 debug protocol。\n我们如果自己做调试工具、做 ide，那就要对接这个协议。\n\n## 7、debugger adaptor protocol\n上面介绍的 v8 debug protocol 可以实现 js 代码的调试，那么 python、c# 等肯定也有自己的调试协议，如果要实现 ide，都要对接一遍太过麻烦。所以后来出现了一个中间层协议，DAP(debugger adaptor protocol)。\n\ndebugger adaptor protocol， 顾名思义，就是适配的，一端适配各种 debugger 协议，一端提供给客户端统一的协议。这是适配器模式的一个很好的应用。\n\n![20230226205040](http://s3.airtlab.com/blog/20230226205040.png)\n\n## 8、总结\n\n本文我们学习了 debugger 的实现原理和暴露出的调试协议。\n\n首先我们了解了代码两种运行方式：直接执行和解释执行，然后分析了下为什么需要 debugger。\n\n之后探索了直接执行的代码通过 INT 3 的中断的方式来实现 debugger 和解释型语言自己实现的 debugger。\n\n然后 debugger 的能力会通过 socket 暴露给客户端，提供调试协议，比如 v8 debug protocol，各种客户端包括 chrome devtools、ide 等都实现了这个协议。\n\n但是每种语言都要实现一次的话太过麻烦，所以后来出现了一个适配层协议，屏蔽了不同协议的区别，提供统一的协议接口给客户端用。\n\n希望这篇文章能够让你理解 debugger 的原理，如果要实现调试工具也知道怎么该怎么去对接协议。能够知道 chrome devtools、vscode 为啥都可以调试 nodejs 代码。\n\n## 9、文章纠错\n其中涉及一些错误参考原文评论 -> https://zhuanlan.zhihu.com/p/372135871·","isLeaf":true},{"key":"/NodeJS/01-basic/005-Character-Encoding.md","path":"/NodeJS/01-basic/005-Character-Encoding.md","route":"/NodeJS/01-basic/005-Character-Encoding.md","leaf":true,"title":"005-Character-Encoding","depth":2,"content":"---\ntitle: 005 理解字符编码\ntoc: true\ntags: NodeJS\ncategories: 前端开发\n---\n\n> - ASCII编码转换 https://www.qqxiuzi.cn/bianma/ascii.htm\n> - Unicode(UTF-8, UTF-16)令人混淆的概念 https://www.cnblogs.com/kingcat/archive/2012/10/16/2726334.html\n\n### 1、ASCII\nASCII编码范围 0x00-0x7F，即十进制的0-127，定义了128个单字节字符，其中包含95个可打印字符（数字、字母、符号），以及33个控制字符（下表中文描述的字符）。国标码GB18030、国际码Unicode均兼容ASCII编码。\n\n### 2、Unicode\n统一码（Unicode），也叫万国码、Unicode的最初目标，是用1个16位的编码来为超过65000字符提供映射。但这还不够，它不能覆盖全部历史上的文字，也不能解决传输的问题 (implantation head-ache's)，尤其在那些基于网络的应用中。已有的软件必须做大量的工作来程序16位的数据。 \n\n因此，Unicode用一些基本的保留字符制定了三套编码方式。它们分别是`UTF-8`, `UTF-16` 和 `UTF-32`。\n\n在UTF－8中，字符 是以8位序列来编码的，用一个或几个字节来表示一个字符。这种方式的最大好处，是UTF－8保留了ASCII字符的编码做为它的一部分，例如，在 UTF－8和ASCII中，“A”的编码都是0x41。\n\nUTF－16和UTF－32分别是Unicode的16位和32位编码方式。考虑到最初的目的，通常说的Unicode就是指UTF-16。在讨论Unicode时，搞清楚哪种编码方式非常重要。Unicdoe相关的技术介绍参见http://www.unicode.org/unicode/standard/principles.html.\n\n### 3、UTF8\n参考 https://www.zhihu.com/question/23374078\n![20230226215929](http://s3.airtlab.com/blog/20230226215929.png)\n\n> UTF-8的编码方式中，当计算机读到1110XXXX，就知道目前的这个字符占了3个字节，应该继续往后读取。\n\n### 4、UTF-8/UTF-16/UTF-32\n（1）UTF-8是变长编码，每个Unicode代码点按照不同范围，可以有1-3字节的不同长度。\n\n（2）UTF-16长度相对固定，只要不处理大于\\U200000范围的字符，每个Unicode代码点使用16位即2字节表示，超出部分使用两个UTF-16即4字节表示。按照高低位字节顺序，又分为UTF-16BE/UTF-16LE。\n\n（3）UTF-32长度始终固定，每个Unicode代码点使用32位即4字节表示。按照高低位字节顺序，又分为UTF-32BE/UTF-32LE。\n\n**举个例子**\n假如中文字\"汉\"对应的 unicode 是6C49(这是用十六进制表示，用十进制表示是 27721 为啥不用十进制表示呢？很明显用十六进制表示要短点。其实都是等价的没啥不一样，就跟你说60分钟和1小时一样)。你可能会问当用程序打开一个文件时我们怎么知道那是用的UTF-8还是UTF-16啊.自然会有点啥标志,在文件的开头几个字节就是标志:\n```\nEF BB BF 表示UTF-8\nFE FF 表示UTF-16.\n```\n\n### 5、base64\nBase64是网络上最常见的用于传输8Bit字节码的编码方式之一，Base64就是一种`基于64个可打印字符来表示二进制数据的方法`。可查看RFC2045～RFC2049，上面有MIME的详细规范。base64 编码是可逆的。\n","isLeaf":true},{"key":"/NodeJS/01-basic/006-hexadecimal.md","path":"/NodeJS/01-basic/006-hexadecimal.md","route":"/NodeJS/01-basic/006-hexadecimal.md","leaf":true,"title":"006-hexadecimal","depth":2,"content":"---\ntitle: 006 进制表示\ntoc: true\ntags: NodeJS\ncategories: 前端开发\n---\n\n> 在线进制转换 https://www.sojson.com/hexconvert.html\n\n## 1. 二进制\n\n二进制数（binaries）是逢2进位的进位制，0、1 是基本算符。\n\n**特性**: 如果一个二进制数（整型）数的第零位的值是1，那么这个数就是奇数；而如果该位是0，那么这个数就是偶数。\n\n## 2. N 进制\n\n- 十进制：有10个基数：0、1、2、3、4、5、6、7、8、9，逢十进一\n- 二进制：有2 个基数：0、1，逢二进一\n- 八进制：有8个基数：0、1、2、3、4、5、6、7，逢八进一\n- 十六进制：有16个基数：0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、F，逢十六进一\n\n## 3. 进制转换\n\n![20230227091616](http://s3.airtlab.com/blog/20230227091616.png)\nhttps://zhuanlan.zhihu.com/p/459817484 \n\n## 4. 负数的表示\n- 求出原码\n- 求出反码\n- 求出补码\n\n演示 -5 的二进制计算过程：\n- 5的原码： 101 => 0000 0101\n- 求出反码：    => 1111 1010\n- 求出补码：    => 1111 1011\n\n如果要表示16位的-5，在左边添上8个1即\n1111 1111 1111 1011\n\n**逆运算**\n比如知道一个补码: 1111 1011\n- 根据补码得到反码: 1111 1010\n- 根据反码得到原码：0000  0101 => 5\n\n### 4.1 最高位上的1和0是表示正负，还是不表示正负？\n\n二进制是表示计数的一种方法，用二进制计数时，用最高位上的1和0来代表这个数的正与负，这样的数就称为“有符号数”，同时也存在着“无符号数”。\n\n那若给出一个用二进制表示出来的数，如何分辨最高位上的1和0是表示正负，还是不表示正负？\n\n比如 11010110:\n- 无符号数表示：214\n- 有符号数表示：-42\n  - 根据补码得到反码：11010110 - 1 = 11010101\n  - 根据反码得到原码：00101010 => 42\n\n这个是人为定义的，假如 int 占用1个字节，那么:\n```c\n// 定义有符号 -128 ——— 0 ———- 127\nint a\n\n// 定义无符号 0 —————– 255\nunsigned int b\n```\n\n## 5. 浮点数的表示\n\n![20230227232435](http://s3.airtlab.com/blog/20230227232435.png)\n\n很多人都遇到过这个问题 “0.1 + 0.2 == 0.3?” 答案是不一定：\n> 这主要是因为有的小数无法可以用「完整」的二进制来表示，所以计算机里只能采用近似数的方式来保存，那两个近似数相加，得到的必然也是一个近似数。https://xiaolincoding.com/os/1_hardware/float.html\n\n- double 的有效数字是 15~16 位\n- float 的有效数字是 7~8 位\n\n这些有效位是包含整数部分和小数部分；","isLeaf":true},{"key":"/NodeJS/01-basic/007-buffer.md","path":"/NodeJS/01-basic/007-buffer.md","route":"/NodeJS/01-basic/007-buffer.md","leaf":true,"title":"007-buffer","depth":2,"content":"---\ntitle: 007 buffer操作二进制数\ntoc: true\ntags: NodeJS\ncategories: 前端开发\n---\n\n> 部分内容参考 《针对 Node 的 Buffer 模块中难理解的 API 做一次彻底的讲解》https://www.bilibili.com/read/cv4881167?spm_id_from=333.999.0.0\n\nBuffer 对象用于表示固定长度的字节序列，许多 Node.js API 都支持 Buffer。\n\n## 1. 预备知识\n\n### 1.1 什么是缓冲区 Buffer\n\n在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理 I/O 操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。\n\n### 1.2 Buffer 与字符编码\n\nBuffer 实例一般用于表示编码字符的序列，比如 UTF-8 、 UCS2 、 Base64 、或十六进制编码的数据。 通过使用显式的字符编码，就可以在 Buffer 实例与普通的 JavaScript 字符串之间进行相互转换。\n\n```javascript\nconst buf = Buffer.from(\"r\", \"ascii\");\nconsole.log(buf); // <Buffer 72>\n// 这里的 72 在 ascii 编码中对应的十六进制值为72 => 其二进制值为 0111 0010\n```\n\n```javascript\nconst buf = Buffer.from(\"runoob\", \"ascii\");\n\n// 输出 72756e6f6f62\nconsole.log(buf.toString(\"hex\"));\n\n// 输出 cnVub29i\nconsole.log(buf.toString(\"base64\"));\n```\n\nNode.js 目前支持的字符编码包括：\n\n- ascii - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。\n- utf8 - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。\n- utf16le - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。\n- ucs2 - utf16le  的别名。\n- base64 - Base64 编码。\n- latin1 - 一种把  Buffer  编码成一字节编码的字符串的方式。\n- binary - latin1  的别名。\n- hex - 将每个字节编码为两个十六进制字符。\n\n### 1.3 Buffer 与 Stream 的关系\n\n在应用中，因为在后端与前端、后端的 IO 中，每当需要在 Node.js 中处理 I/O 操作中移动的数据时，就有可能使用 Buffer 库，很多时候会出现数据过大，不能一次性读取的问题。会导致程序的等待时间过长，因此，流操作（stream）便营运而生。\n\n在 readable 和 writable 的 Stream 之间筑起沟通，如果仅仅使用事件方法来进行的话，代码会显得很冗杂，因此需要出现 pipe（管道）方法来进行。\n\n```javascript\nreadable.pipe(writable);\n```\n\nStream 就像司机，它的作用就是将装着数据的 Buffer 开向终点，在 NodeJS 中，许多接口都集成 Stream。假如你不懂 Stream 也没有关系，先这样了解就可以了。\n\n## 2.  创建 Buffer 类\n\nBuffer 提供两类 API 来创建 buffer\n\n### 2.1 从字符串创建\n\n`Buffer.from(string[, encoding])`\n\n```javascript\nconst buf = Buffer.from(\"知\", \"utf-8\");\nconsole.log(buf); // <Buffer e7 9f a5>\n```\n\n### 2.2 指定字节序列创建\n\n指定字节序列创建 Buffer(使用 0 – 255 范围内的字节 array 分配)，该范围之外的数组条目将被截断以符合它。\n\n`Buffer.from(array)`\n\n```javascript\n// 创建包含字符串 'buffer' 的 UTF-8 字节的新缓冲区。\nconst buf = Buffer.from([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]);\nconsole.log(buf);\n```\n\n### 2.3 buffer 拷贝创建\n\n`Buffer.from(buffer)`\n\n```javascript\nconst buf1 = Buffer.from(\"buffer\");\nconst buf2 = Buffer.from(buf1);\n\nbuf1[0] = 0x61; // a\n\nconsole.log(buf1.toString());\n// 打印: auffer\nconsole.log(buf2.toString());\n// 打印: buffer\n```\n\n```javascript\nconst buf1 = Buffer.from(\"知\");\nconst buf2 = Buffer.from(buf1);\n\n// 根据 utf-8 编码规则, 后面两个字节显然无效喽\n// 因为它属于 0~U+007F\nbuf1[0] = 0x61;\n\nconsole.log(buf1.toString());\n// 打印: a��\nconsole.log(buf2.toString());\n// 打印: 知\n```\n\n### 2.4 Buffer.alloc\n\n```javascript\nconst buf = Buffer.alloc(26);\nfor (var i = 0; i < 26; i++) {\n  buf[i] = i + 97;\n}\n\nconsole.log(buf.toString(\"ascii\")); // 输出: abcdefghijklmnopqrstuvwxyz\nconsole.log(buf.toString(\"ascii\", 0, 5)); // 输出: abcde\nconsole.log(buf.toString(\"utf8\", 0, 5)); // 输出: abcde\nconsole.log(buf.toString(undefined, 0, 5)); // 使用 'utf8' 编码, 并输出: abcde\n```\n\n#### Buffer.alloc(size[, fill[, encoding]])\n\n- size 代表 Buffer 的长度\n- fill 初始化填充的内容\n- encoding 代表编码\n\n![20230228202308](http://s3.airtlab.com/blog/20230228202308.png)\n\n可以看出 fil l 和 encoding 之间的关系，fill 先按照 encoding 编码成二进制，然后一个字节一个字节的向此方法生成的 Buffer 中填充，根据长度 size，依次循环。\n\n### 2.5 Buffer.from 对比\n\n(1) Buffer.from(array)  返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖）。\n(2) Buffer.from(arrayBuffer[, byteOffset[, length]])  返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。\n(3) Buffer.from(buffer)  复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例。\n(4) Buffer.from(string[, encoding])： 返回一个被 string 的值初始化的新的 Buffer 实例。\n\n```javascript\n// 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。\nconst buf4 = Buffer.from([1, 2, 3]);\n\n// 创建一个包含 UTF-8 字节 [0x74, 0xc3, 0xa9, 0x73, 0x74] 的 Buffer。\nconst buf5 = Buffer.from(\"tést\");\n\n// 创建一个包含 Latin-1 字节 [0x74, 0xe9, 0x73, 0x74] 的 Buffer。\nconst buf6 = Buffer.from(\"tést\", \"latin1\");\n```\n\n#### Buffer.from(arrayBuffer[, byteOffset[, length]])\n\n![20230228202419](http://s3.airtlab.com/blog/20230228202419.png)\n\n将一个二进制数组`[5000, 4000]` 放入 Buffer 中生成了 `<88 a0>`，因为 Buffer 实例是 Uint8Array 的实例，此时相当于把 arr 放入 Uint8Array 中，元素一一对应，而 Uint8Array 每个元素都是 8 位，最大值是 256，所以发生了溢出，根据溢出的算法最终变为了<88 a0>。\n\n如果不想发生溢出，可以使用二进制数组的 buffer 属性（此时会共享内存）：\n\n![20230228202649](http://s3.airtlab.com/blog/20230228202649.png)\n\n可选的 byteOffset 和 length 参数指定 arrayBuffer 中与 Buffer 共享的内存范围，如果不使用 buffer 属性，这两个参数并不会生效。\n\n![20230228202659](http://s3.airtlab.com/blog/20230228202659.png)\n\n可选的 byteOffset 和 length 参数指定 arrayBuffer 中与 Buffer 共享的内存范围，如果不使用 buffer 属性，这两个参数并不会生效：\n![20230228202715](http://s3.airtlab.com/blog/20230228202715.png)\n\n## 3、读字节流\n\n### 3.1 readUInt8/readInt8\n\n读取一个字节的有/无符号的整数\n\n![20230228202626](http://s3.airtlab.com/blog/20230228202626.png)\n\n- readUInt8 直接读取一个字节的二进制\n- readInt8 读取 8 位有符号的二进制，所以有可能会发生溢出，溢出的算法之前已经提到了\n\n### 3.2 读取 16 位\n\n- readInt16BE\n- readInt16LE\n- readUInt16BE\n- readUInt16LE\n\n读取`两个字节`的有/无符号的整数\n\n- BE 代表大端字节序，高位在前，网络就是这种字节序\n- LE 代表小端字节序，低位在前\n\n![20230228202551](http://s3.airtlab.com/blog/20230228202551.png)\n\n```javascript\nconst buf = Buffer.from([0xff, 0x01, 0x08, 0x05]);\nconsole.log(buf);\n\nconsole.log(buf.readUInt16BE(0)); // 65281 = 15 * 16 * 16 * 16 + 15 * 16 * 16 + 1\n\n// 按照大端顺序读取（有符号）\n// => 1111 1111 0000 0001\n// => 1111 1110\n// => 1111 1111\nconsole.log(buf.readInt16BE(0)); // -255\n```\n\n```javascript\n{\n  const buf = Buffer.from([0x9f, 0xaf, 0x08, 0x05]);\n  console.log(buf);\n\n  // 9 * 16 * 16 * 16 + 15 * 16 * 16 + 10 * 16 + 15 = 40879\n  // 而16位有符号范围 -32768～32767\n  // 1001 1111 1010 1111 原码\n  // 0110 0000 0101 0000 反码\n  // 0110 0000 0110 0001 补码\n  // 6051 => 24657\n  console.log(buf.readInt16BE(0)); // -24657  这个数是怎么来的呢\n}\n```\n\n## 4.  写入缓冲区\n\n```javascript\nbuf.write(string[, offset[, length]][, encoding])\n// @param string - 写入缓冲区的字符串。\n// @param offset - 缓冲区开始写入的索引值，默认为 0 。\n// @param length - 写入的字节数，默认为 buffer.length\n// @param encoding - 使用的编码。默认为 'utf8' 。\n// @result 返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。\n```\n\n```javascript\nconst buf = Buffer.alloc(256);\nconst len = buf.write(\"www.runoob.com\");\nconsole.log(\"写入字节数 : \" + len);\nconsole.log(buf.toString(\"ascii\"));\n```\n\n## 5.  从缓冲区读取数据\n\n```javascript\nbuf.toString([encoding[, start[, end]]])\n// @param encoding - 使用的编码。默认为 'utf8' 。\n// @param start - 指定开始读取的索引位置，默认为 0。\n// @param end - 结束位置，默认为缓冲区的末尾。\n// @result 解码缓冲区数据并使用指定的编码返回字符串\n```\n\n```javascript\nbuf = Buffer.alloc(26);\nfor (var i = 0; i < 26; i++) {\n  buf[i] = i + 97;\n}\n\nconsole.log(buf.toString(\"ascii\")); // 输出: abcdefghijklmnopqrstuvwxyz\nconsole.log(buf.toString(\"ascii\", 0, 5)); // 输出: abcde\nconsole.log(buf.toString(\"utf8\", 0, 5)); // 输出: abcde\nconsole.log(buf.toString(undefined, 0, 5)); // 使用 'utf8' 编码, 并输出: abcde\n```\n\n## 6.  缓冲区合并\n\n```javascript\nvar buffer1 = Buffer.from(\"菜鸟教程\");\nvar buffer2 = Buffer.from(\"www.runoob.com\");\n\nvar buffer3 = Buffer.concat([buffer1, buffer2]);\nconsole.log(\"buffer3 内容: \" + buffer3.toString());\n```\n\n## 7. **TypedArray**\n\n> 一个 **_TypedArray_** 对象描述了底层[二进制数据缓冲区](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)的类数组视图，是所有 TypedArray 子类的通用父类。将 %TypedArray% 作为一个“抽象类”，\n\n```javascript\n// Create a TypedArray with a size in bytes\nconst typedArray1 = new Int8Array(8);\ntypedArray1[0] = 32;\n\nconst typedArray2 = new Int8Array(typedArray1);\ntypedArray2[1] = 42;\n\nconsole.log(typedArray1);\n// Expected output: Int8Array [32, 0, 0, 0, 0, 0, 0, 0]\n\nconsole.log(typedArray2);\n// Expected output: Int8Array [32, 42, 0, 0, 0, 0, 0, 0]\n```\n\n### TypeArray 列表\n\n| 类型                                                                                                                    | 值范围                                       | 字节大小 | 描述                                                      | Web IDL 类型        | 等价的 C 类型                 |\n| ----------------------------------------------------------------------------------------------------------------------- | -------------------------------------------- | -------- | --------------------------------------------------------- | ------------------- | ----------------------------- |\n| [Int8Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Int8Array)                 | -128 到 127                                  | 1        | 8 位有符号整型（补码）                                    | byte                | int8_t                        |\n| [Uint8Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array)               | 0 到 255                                     | 1        | 8 位无符号整型                                            | octet               | uint8_t                       |\n| [Uint8ClampedArray](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray) | 0 到 255                                     | 1        | 8 位无符号整型（一定在 0 到 255 之间）                    | octet               | uint8_t                       |\n| [Int16Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Int16Array)               | -32768 到 32767                              | 2        | 16 位有符号整型（补码）                                   | short               | int16_t                       |\n| [Uint16Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array)             | 0 到 65535                                   | 2        | 16 位无符号整型                                           | unsigned short      | uint16_t                      |\n| [Int32Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Int32Array)               | -2147483648 到 2147483647                    | 4        | 32 位有符号整型（补码）                                   | long                | int32_t                       |\n| [Uint32Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array)             | 0 到 4294967295                              | 4        | 32 位无符号整型                                           | unsigned long       | uint32_t                      |\n| [Float32Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Float32Array)           | -3.4E38 到 3.4E38 并且 1.2E-38 是最小的正数  | 4        | 32 位 IEEE 浮点数（7 位有效数字，例如 1.234567）          | unrestricted float  | float                         |\n| [Float64Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Float64Array)           | -1.8E308 到 1.8E308 并且 5E-324 是最小的正数 | 8        | 64 位 IEEE 浮点数（16 位有效数字，例如 1.23456789012345） | unrestricted double | double                        |\n| [BigInt64Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt64Array)         | -263 到 263 - 1                              | 8        | 64 位有符号整型（补码）                                   | bigint              | int64_t (signed long long)    |\n| [BigUint64Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigUint64Array)       | 0 到 264 - 1                                 | 8        | 64 位无符号整型                                           | bigint              | uint64_t (unsigned long long) |\n\n### 溢出规则\n\n```javascript\n{\n  // -128 到 127\n  const typedArray1 = new Int8Array(8);\n  typedArray1[0] = 128;\n\n  console.log(typedArray1); // ? 为什么是 -128\n  // Int8Array(8) [\n  //     -128, 0, 0, 0,\n  //        0, 0, 0, 0\n  //   ]\n}\n\n{\n  // -128 到 127\n  const typedArray1 = new Int8Array(8);\n  typedArray1[0] = 300;\n\n  console.log(typedArray1); // ? 为什么是44\n  // Int8Array(8) [\n  //     44, 0, 0, 0,\n  //        0, 0, 0, 0\n  //   ]\n}\n```\n","isLeaf":true},{"key":"/NodeJS/01-basic/008-buffer-array.md","path":"/NodeJS/01-basic/008-buffer-array.md","route":"/NodeJS/01-basic/008-buffer-array.md","leaf":true,"title":"008-buffer-array","depth":2,"content":"---\ntitle: 008 Buffer 数组\ntoc: true\ntags: NodeJS\ncategories: 前端开发\n---\n\n目前笔者很少有使用到相关API，仅做了解。\n\n## 1. 二进制数组的由来\n为了满足 JavaScript 与显卡之间大量的、实时的数据交换，它们之间的数据通信必须是二进制的，而不能是传统的文本格式。文本格式传递一个32位整数，两端的 JavaScript 脚本与显卡都要进行格式转化，将非常耗时。这时要是存在一种机制，可以像 C 语言那样，直接操作字节，将4个字节的32位整数，以二进制形式原封不动地送入显卡，脚本的性能就会大幅提升。\n\n比如 WebGL 相关接口的调用。\n\n二进制数组主要有三个对象：\n- ArrayBuffer\n- TypedArray\n- DataView\n\n参考文章：\n- [JS操作内存？二进制数组了解一下](https://www.bilibili.com/read/cv4386302/)\n- [ArrayBuffer 介绍](https://wizardforcel.gitbooks.io/es6-tutorial-3e/content/docs/arraybuffer.html)","isLeaf":true},{"key":"/NodeJS/01-basic/009-nodejs-tracing.md","path":"/NodeJS/01-basic/009-nodejs-tracing.md","route":"/NodeJS/01-basic/009-nodejs-tracing.md","leaf":true,"title":"009-nodejs-tracing","depth":2,"content":"---\ntitle: 009 nodejs 链路追踪\ntoc: true\ntags: NodeJS\ncategories: 前端开发\n---\n\n## 1、研究背景\n链路追踪是后台服务开发的一个很重要工具，它可以将所有的调用串联起来，形成一个有先后顺序的链路图。本文研究如何在 nodejs 中实现链路追踪。\n\n## 2、链路信息获取\n对于多线程语言如 Java 、 Python 来说，做全链路信息获取有线程上下文如 ThreadLocal 这种利器相助。而对于 Node.js 来说，由于单线程和基于IO回调的方式来完成异步操作，所以在全链路信息获取上存在天然获取难度大的问题。那么如何解决这个问题呢？\n\n## 3、业界方案\n由于 Node.js 单线程，非阻塞 IO 的设计思想。在全链路信息获取上，到目前为止，主要有以下 2 种方案：\n\n- 显式传递：手动传递、中间件挂载；\n- Async Hooks：node api；\n\n方案1显式传递过于繁琐和具有侵入性。<br />效果最好的方案就是第2种方案，这种方案有如下优点：\n\n- nodejs 原生支持的模块，具有可靠性性保证\n- 隐式的链路跟踪，入侵小，目前隐式跟踪的最优解；\n- 提供了 API 来追踪 node 中异步资源的生命周期；\n- 借助 async_hook 实现上下文的关联关系；\n\n## 4、Async Hooks\n### 4.1  Async Hooks 概念\nAsync Hooks 是 Node.js v8.x 版本新增加的一个核心模块，它提供了 API 用来追踪 Node.js 中异步资源的生命周期，可帮助我们正确追踪异步调用的处理逻辑及关系。\n\n### 4.2 Async Hooks 核心\n![image__1](http://s3.airtlab.com/blog/image__1.png)\n```typescript\nimport async_hooks from 'node:async_hooks';\n\n// Return the ID of the current execution context.\n// 返回当前异步资源的执行上下文 id\nconst eid = async_hooks.executionAsyncId();\n\n// Return the ID of the handle responsible for triggering the callback of the\n// current execution scope to call.\n// 返回当前异步资源执 execution scope 的 trigger ID\nconst tid = async_hooks.triggerAsyncId();\n\n// Create a new AsyncHook instance. All of these callbacks are optional.\n// 创建实例\nconst asyncHook =\n    async_hooks.createHook({ init, before, after, destroy, promiseResolve });\n\n// Allow callbacks of this AsyncHook instance to call. This is not an implicit\n// action after running the constructor, and must be explicitly run to begin\n// executing callbacks.\n// 启用\nasyncHook.enable();\n\n// Disable listening for new asynchronous events.\n// 禁用\nasyncHook.disable();\n\n//\n// The following are the callbacks that can be passed to createHook().\n//\n\n// init() is called during object construction. The resource may not have\n// completed construction when this callback runs. Therefore, all fields of the\n// resource referenced by \"asyncId\" may not have been populated.\n// 初始化(不一定完成)\nfunction init(asyncId, type, triggerAsyncId, resource) { }\n\n// before() is called just before the resource's callback is called. It can be\n// called 0-N times for handles (such as TCPWrap), and will be called exactly 1\n// time for requests (such as FSReqCallback).\nfunction before(asyncId) { }\n\n// after() is called just after the resource's callback has finished.\nfunction after(asyncId) { }\n\n// destroy() is called when the resource is destroyed.\nfunction destroy(asyncId) { }\n\n// promiseResolve() is called only for promise resources, when the\n// resolve() function passed to the Promise constructor is invoked\n// (either directly or through other means of resolving a promise).\nfunction promiseResolve(asyncId) { }\n```\n通过 async_hooks 钩子，我们可以探测异步资源执行的全生命周期，从 创建 -> 执行前 -> 执行后 -> 销毁。\n```javascript\nconst asyncHooks = require('async_hooks');\nconst fs = require('fs');\n\nconst hooks = asyncHooks.createHook({\n  init(asyncId, type, triggerAsyncId, resource) {\n    fs.writeFileSync(2, `init asyncId: ${asyncId}, type: ${type}, triggerAsyncId: ${triggerAsyncId}\\n`)\n  },\n  destroy (asyncId) {\n    fs.writeFileSync(2, `destroy: ${asyncId}\\n`)\n  },\n  before (asyncId) {\n    fs.writeFileSync(2, `before: ${asyncId}\\n`)\n  },\n  after (asyncId) {\n    fs.writeFileSync(2, `after: ${asyncId}\\n`)\n  }\n});\nhooks.enable();\n\nsetTimeout(() => {\n  setTimeout(() => {\n  })\n})\n```\n打印顺序如下：\n```javascript\ninit asyncId: 2, type: Timeout, triggerAsyncId: 1\nbefore: 2\ninit asyncId: 3, type: Timeout, triggerAsyncId: 2\nafter: 2\ndestroy: 2\nbefore: 3\nafter: 3\ndestroy: 3\n```\n\n### 4.3 AsyncResource 异步资源\nAsyncResource 用于创建异步资源 context，可以让很多个异步资源共享上下文。\n```typescript\nconst asyncHook = require(\"async_hooks\");\nconst fs = require(\"fs\");\nconst list = []\n\nasyncHook\n  .createHook({\n    init(asyncId, type, triggerAsyncId) {\n      const content = `asyncId: ${asyncId}, type: ${type}, triggerAsyncId: ${triggerAsyncId}`\n      fs.writeSync(1, content);\n      fs.writeSync(1, \"\\n\");\n    },\n  })\n  .enable();\n\nconst asyncResource = new asyncHook.AsyncResource(\"ZeroContext\");\nfs.writeSync(1, asyncResource.asyncId().toString());\nfs.writeSync(1, \"\\n\");\n\n// 在此异步资源的执行上下文中调用的函数\nasyncResource.runInAsyncScope(() => {\n  setTimeout(() => {})\n});\n\n// asyncId: 2, type: ZeroContext, triggerAsyncId: 1\n// 2\n// asyncId: 3, type: Timeout, triggerAsyncId: 2\n```\n```javascript\nconst http = require('http');\nconst { AsyncLocalStorage } = require('async_hooks');\n\nconst asyncLocalStorage = new AsyncLocalStorage();\n\nfunction logWithId(msg) {\n  const id = asyncLocalStorage.getStore();\n  console.log(`${id !== undefined ? id : '-'}:`, msg);\n}\n\nlet idSeq = 0;\n\nhttp.createServer((req, res) => {\n  // 每一个请求都有一个唯一的id\n  // 每一个请求的处理逻辑都放到 asyncLocalStorage.run 中，并且传入 id\n\n  asyncLocalStorage.run(idSeq++, () => {\n    logWithId('start');\n    setImmediate(() => {\n      logWithId('processing...');\n      setTimeout(() => {\n        logWithId('finish');\n        res.end(\"hello\");\n      }, 2000)\n    });\n  });\n}).listen(8080);\n```\n\n## 5、http-context 的实现\nhttp context 是指请求上下文，对于 server 来说，每一个请求都有独立的请求上下文。\n### 5.1 通过 hooks 实现\n简化后的代码，ns 对象有3个关键的属性: \n\n- active 当前的 context\n- _contexts context 和 asyncId 的映射\n- _set context 栈\n```javascript\nfunction Context() {\n  this._map = {};\n}\n\nContext.prototype.set = function (key, val) {\n  this._map[key] = val;\n};\n\nContext.prototype.get = function (key, val) {\n  return this._map[key];\n};\n\nconst ns = new Namespace();\nlet currentUid = -1;\n\nfunction createNamespace(name) {\n  let namespace = new Namespace(name);\n  namespace.id = currentUid;\n}\n\nconst hooks = asyncHooks.createHook({\n  // 当 int 被触发时说明，正在创建一个异步资源，\n  // 我们需要将该异步资源和当前的 context 关联起来\n  init(asyncId, type, triggerAsyncId, resource) {\n    currentUid = async_hooks.executionAsyncId();\n    if (namespace.active) {\n      namespace._contexts.set(asyncId, namespace.active);\n    } else if (currentUid === 0) {\n      const triggerId = async_hooks.triggerAsyncId();\n      const triggerIdContext = namespace._contexts.get(triggerId);\n      if (triggerIdContext) {\n        namespace._contexts.set(asyncId, triggerIdContext);\n      }\n    }\n  },\n  // 当 before 被调用时，说明马上要执行该异步资源的回调\n  // 我们需要更新该 active 为 _map[asyncId]\n  // 而且 push 到 context stack 中\n  before(asyncId) {\n    const context = this._map[asyncId];\n    ns.enter(context);\n  },\n  // 当 after 被调用时，说明马上要执行该异步资源的回调已经执行完毕\n  // 我们需要更新该 active 为 stack 中的倒数第二个\n  after(asyncId) {\n    const context = this._map[asyncId];\n    ns.exit(context);\n  },\n  // 异步资源销毁，释放资源\n  destroy(asyncId) {\n    ns._contexts[asyncId] = null;\n  },\n});\n\nhooks.enabled();\n\nfunction Namespace() {\n  this.active = null;\n  this._set = [];\n  this._contexts = new Map();\n}\n\nNamespace.prototype.run = function (fn) {\n  const context = new createContext();\n  this.enter(context);\n  fn(context);\n};\n\nNamespace.prototype.runPromise = function (fn) {\n  const context = new createContext();\n  const promise = this.enter(context);\n\n  return promise\n    .then((result) => {\n      this.exit(context);\n      return result;\n    })\n    .catch((err) => {\n      this.exit(context);\n      throw err;\n    });\n};\n\nNamespace.prototype.enter = function (context) {\n  this.active = context;\n  this.stack.push(this.active);\n};\n\nNamespace.prototype.exit = function (context) {\n  if (this.active === context) {\n    this.active = this._set.pop();\n    return;\n  }\n};\n\n// 提供 express middleware\nfunction contextMiddleware(req, res, next) {\n  ns.run(() => next());\n}\n```\n### 5.2 cls-hookd\n[npm cls]([https://www.npmjs.com/package/cls](https://www.npmjs.com/package/cls)) 的工作方式类似于 tls。[cls-hooked]([https://www.npmjs.com/package/cls-hooked](https://www.npmjs.com/package/cls-hooked)) 这个包从 cls fork 而来，cls-hooked 采用新的 api [async_hooks](https://link.juejin.cn/?target=https%3A%2F%2Fnodejs.org%2Fapi%2Fasync_hooks.html) 对核心逻辑进行了重写。\n### 5.3 express-http-context\n基于 cls-hookd 封装为 express 中间件的形式\n## 6、参考资料\n\n- VIVO 技术团队《 Node.js 应用全链路追踪技术》—— [全链路信息获取](https://mp.weixin.qq.com/s/SpC50ZqbKnKjlGBTSPMd9w?scene=25#wechat_redirect)","isLeaf":true},{"key":"/NodeJS/01-basic/010-how-to-crash-node.md","path":"/NodeJS/01-basic/010-how-to-crash-node.md","route":"/NodeJS/01-basic/010-how-to-crash-node.md","leaf":true,"title":"010-how-to-crash-node","depth":2,"content":"---\ntitle: 010 如何让 nodejs 程序 crash\ntoc: true\ntags: NodeJS\ncategories: 前端开发\n---\n\n- 异常未被捕获\n- 内存溢出\n- 发送中断信号（CTRL + C）或停止进程来停止Node.js程序\n- 在代码中引入不存在的模块或文件","isLeaf":true},{"key":"/NodeJS/01-basic/011-amazing-stream.md","path":"/NodeJS/01-basic/011-amazing-stream.md","route":"/NodeJS/01-basic/011-amazing-stream.md","leaf":true,"title":"011-amazing-stream","depth":2,"content":"---\ntitle: 011 stream 的使用\ntoc: true\ntags: NodeJS\ncategories: 前端开发\n---\n\n## 1、stream 介绍\n\nStream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对 http 服务器发起请求的 request 对象就是一个 Stream，还有 stdout（标准输出）。\n\n**Node.js Stream 有四种流类型**:\n- Readable - 可读操作。\n- Writable - 可写操作。\n- Duplex - 可读可写操作.\n- Transform - 操作被写入数据，然后读出结果。\n\n所有的 Stream 对象都是 EventEmitter 的实例。\n\n**常用的事件有**：\n- data - 当有数据可读时触发。\n- end - 没有更多的数据可读时触发。\n- error - 在接收和写入过程中发生错误时触发。\n- finish - 所有数据已被写入到底层系统时触发。\n\n## 2、stream 优势\n\n相对于使用其他的数据处理方法，流基本上提供了两个主要优点：\n- 内存效率: 无需加载大量的数据到内存中即可进行处理。\n- 时间效率: 当获得数据之后即可立即开始处理数据，这样所需的时间更少，而不必等到整个数据有效负载可用才开始\n\n## 3、内存占用测试\n\n```js\nconst fs = require(\"fs\");\nconst v8 = require(\"v8\");\n\nconst getData = (start) => {\n  const list = [];\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      const a = {};\n      a;\n      for (let i = 0; i < 50; i++) {\n        const index = start + i;\n        list.push({\n          name: \"姓名\" + index,\n          age: `${index}`,\n          content: `这是一个掩演示，哈哈哈 ${index}`,\n          name2: \"姓名\" + index,\n          age2: `${index}`,\n          content2: `这是一个掩演示，哈哈哈 ${index}`,\n          id: `大冰哥 ${index}`,\n          address: `深圳市 ${index}`,\n        });\n      }\n      resolve(list);\n    });\n  });\n};\n\nasync function testNormal() {\n  const list = [];\n  let i = 0;\n\n  // setInterval(() => {\n  //   console.log(v8.getHeapStatistics().used_heap_size);\n  // }, 2000);\n\n  while (i < 100 * 10000) {\n    const data = await getData(i);\n    list.push(...data);\n    i += 50;\n  }\n\n  console.log(\"case normal\", v8.getHeapStatistics().used_heap_size);\n\n  setTimeout(() => {\n    fs.writeFileSync(\"out.json\", JSON.stringify(list));\n  });\n}\n\nfunction write(stream, chunk) {\n  return new Promise((resolve) => {\n    stream.write(chunk, (err) => {\n      if (!err) {\n        resolve();\n      }\n    });\n  });\n}\n\nasync function testStream() {\n  const stream = fs.createWriteStream(\"stream.json\");\n\n  stream.on('drain', () => {\n    console.log(`drain`)\n  })\n\n  let i = 0;\n\n  setInterval(() => {\n    console.log(v8.getHeapStatistics().used_heap_size);\n  }, 2000);\n\n  while (i < 100 * 10000) {\n    const data = await getData(i);\n    await write(stream, JSON.stringify(data));\n    i += 50;\n  }\n\n  console.log(`case stream`);\n  console.log(v8.getHeapStatistics().used_heap_size);\n\n  setTimeout(() => {\n    stream.close();\n  });\n}\n\nasync function start() {\n  console.log(process.pid);\n  await testStream()\n  // setTimeout(() => {\n  //   testNormal();\n  // }, 1000)\n}\n\nstart()\n```\n\n通过对比发现，使用 stream 方式进行写文件时，内存占用比较稳定，而令另一种方式，内存会持续上升，直到文件写入完成。\n\n## 5、常见问题\n\n### 5.1 什么是 stream\n\nstream 是基于事件EventEmitter的数据管理模式．由各种不同的抽象接口组成，主要包括可写，可读，可读写，可转换等几种类型．\n\n### 5.2 stream 好处\n\n非阻塞式数据处理提升效率，片断处理节省内存，管道处理方便可扩展等.\n\n### 5.3 stream 典型应用\n\n文件，网络，数据转换，音频视频等.\n\n### 5.4 怎么捕获 stream 错误\n\n监听 error 事件，方法同 EventEmitter.\n\n### 5.5 有哪些常用 stream\n- Readable 为可被读流，在作为输入数据源时使用；\n- Writable 为可被写流,在作为输出源时使用；\n- Duplex 为可读写流,它作为输出源接受被写入，同时又作为输入源被后面的流读出．\n- Transform 机制和 Duplex 一样，都是双向流，区别是 Transform 只需要实现一个函数 `_transfrom(chunk, encoding, callback)` 而 Duplex 需要分别实现`_read(size)` 函数和 `_write(chunk, encoding, callback)` 函数。\n\n### 5.6 实现一个 writable stream\n\n三步走:\n- 1) 构造函数 call Writable \n- 2) 继承 Writable\n- 3) 实现 `_write(chunk, encoding, callback)` 函数\n\n```js\nvar Writable = require('stream').Writable;\nvar util = require('util');\n\nfunction MyWritable(options) {\n\tWritable.call(this, options);\n}\n\nutil.inherits(MyWritable, Writable); // 继承自Writable\n\nMyWritable.prototype._write = function(chunk, encoding, callback) {\n\tconsole.log(\"被写入的数据是:\", chunk.toString()); // 此处可对写入的数据进行处理\n\tcallback();\n};\n\nprocess.stdin.pipe(new MyWritable()); // stdin作为输入源，MyWritable作为输出源   \n```\n\n## 6、参考文档\n\n- [深入理解 Node Stream 内部机制](https://www.barretlee.com/blog/2017/06/06/dive-to-nodejs-at-stream-module/)\n- [想学Node.js，stream先有必要搞清楚](https://juejin.cn/post/6844903891083984910)\n- [可写流 - nodejs stream总结](https://www.cnblogs.com/walkermag/p/13579990.html)","isLeaf":true},{"key":"/NodeJS/01-basic/012-event-loop.md","path":"/NodeJS/01-basic/012-event-loop.md","route":"/NodeJS/01-basic/012-event-loop.md","leaf":true,"title":"012-event-loop","depth":2,"content":"---\ntitle: 012 事件循环\ntoc: true\ntags: NodeJS\ncategories: 前端开发\n---\n\n- 大循环宏任务\n- 小循环微任务","isLeaf":true},{"key":"/NodeJS/01-basic/013-settimeout.md","path":"/NodeJS/01-basic/013-settimeout.md","route":"/NodeJS/01-basic/013-settimeout.md","leaf":true,"title":"013-settimeout","depth":2,"content":"---\ntitle: 013 setTimeout 实现原理\ntoc: true\ntags: NodeJS\ncategories: 前端开发\n---\n\n不同的 Runtime 实现机制不一样，`setTimeout` 并不是 ECMA 的 API，而是 Web API，所以 V8 这类 JavaScript 引擎是不会帮你实现的，需要在 Runtime 中自行实现。 \n\n- [`死月` 和 `王译锋` 回答](https://www.zhihu.com/question/463446982/answer/1927497540)\n- [深入Linux C/C++ Timer定时器的实现核心原理](https://cloud.tencent.com/developer/article/1763594)","isLeaf":true},{"key":"/NodeJS/01-basic/014-max-old-space-size.md","path":"/NodeJS/01-basic/014-max-old-space-size.md","route":"/NodeJS/01-basic/014-max-old-space-size.md","leaf":true,"title":"014-max-old-space-size","depth":2,"content":"---\ntitle: 014 设置 max-old-space-size\ntoc: true\ntags: NodeJS\ncategories: 前端开发\n---\n\n设置 V8 旧生代内存部分的最大内存大小。 随着内存消耗接近极限，V8 会花更多的时间在垃圾回收上，以释放未使用的内存。\n\ntest.js\n```js\nconst v8 = require('v8');\nconsole.log(v8.getHeapStatistics())\n```\n\n当前的测试宿主机为 MacPro 2019 16G 内存。\n\n当执行 `node test.js`\n```json\n{\n  total_heap_size: 4984832,\n  total_heap_size_executable: 524288,\n  total_physical_size: 3947728,\n  total_available_size: 4342033176,\n  used_heap_size: 4170336,\n  heap_size_limit: 4345298944,\n  malloced_memory: 254120,\n  peak_malloced_memory: 90624,\n  does_zap_garbage: 0,\n  number_of_native_contexts: 1,\n  number_of_detached_contexts: 0,\n  total_global_handles_size: 8192,\n  used_global_handles_size: 3200,\n  external_memory: 321551\n}\n```\n\n当执行 `NODE_OPTIONS=--max-old-space-size=6144 node ./test.js`\n```json\n{\n  total_heap_size: 4984832,\n  total_heap_size_executable: 524288,\n  total_physical_size: 3913440,\n  total_available_size: 6489516800,\n  used_heap_size: 4170368,\n  heap_size_limit: 6492782592,\n  malloced_memory: 254120,\n  peak_malloced_memory: 221520,\n  does_zap_garbage: 0,\n  number_of_native_contexts: 1,\n  number_of_detached_contexts: 0,\n  total_global_handles_size: 8192,\n  used_global_handles_size: 3200,\n  external_memory: 321551\n}\n```\n\n其中 total_available_size 已经被修改。","isLeaf":true},{"key":"/NodeJS/01-basic/015-heapsnapshot.md","path":"/NodeJS/01-basic/015-heapsnapshot.md","route":"/NodeJS/01-basic/015-heapsnapshot.md","leaf":true,"title":"015-heapsnapshot","depth":2,"content":"---\ntitle: 015 v8 内存快照文件分析\ntoc: true\ntags: NodeJS\ncategories: 前端开发\n---\n\n- https://segmentfault.com/a/1190000039650874?sort=newest\n- https://zhengrenzhe.com/posts/v8-snapshot/","isLeaf":true},{"key":"/NodeJS/01-basic/016-node-monitor.md","path":"/NodeJS/01-basic/016-node-monitor.md","route":"/NodeJS/01-basic/016-node-monitor.md","leaf":true,"title":"016-node-monitor","depth":2,"content":"---\ntitle: 016 nodejs 应用监控\ntoc: true\ntags: NodeJS\ncategories: 前端开发\n---\n\n- [alinode](https://www.aliyun.com/product/nodejs)","isLeaf":true},{"key":"/NodeJS/01-basic/017-watch-file-change.md","path":"/NodeJS/01-basic/017-watch-file-change.md","route":"/NodeJS/01-basic/017-watch-file-change.md","leaf":true,"title":"017-watch-file-change","depth":2,"content":"---\ntitle: 017 监听文件变化\ntoc: true\ntags: NodeJS\ncategories: 前端开发\n---\n\n- [node.js监听文件变化](https://juejin.cn/post/6844903824738500622)\n- chokidar 的使用\n- nodemon 原理等\n- watchdog 的使用\n","isLeaf":true},{"key":"/NodeJS/01-basic/018-restart-node-app.md","path":"/NodeJS/01-basic/018-restart-node-app.md","route":"/NodeJS/01-basic/018-restart-node-app.md","leaf":true,"title":"018-restart-node-app","depth":2,"content":"---\ntitle: 018 如何重启服务\ntoc: true\ntags: NodeJS\ncategories: 前端开发\n---\n\n当 node 进程挂了，如何自动重启？supervisor nodemon 等重启原理。。\n\n在 Node.js 应用运行时，可以通过一些第三方的 Node.js 模块或者工具来实现应用挂了之后自动重。\n\n## 1. PM2\nPM2（process manager 2）是一个开源的 Node.js 进程管理器，它可以启动、停止、重启和监视 Node.js 应用。PM2 可以自动监控应用程序的运行状态，并且在应用程序退出或奔溃时自动重启。使用 PM2 启动应用程序后，可以使用一些基本的命令来管理应用程序，例如：\n\n```\npm2 start /path/to/app.js       // 启动应用程序\npm2 stop app                    // 停止应用程序\npm2 restart app                 // 重启应用程序\npm2 list                        // 列出当前运行的所有应用程序\n```\n\n## 2. Forever\nForever 是一个简单的命令行工具，它可以启动和管理 Node.js 应用程序，类似于 PM2。使用 Forever 启动应用程序后，Forever 会监视应用程序的运行状态，当应用程序奔溃时会自动重启应用程序。Forever 的命令行使用方式如下：\n\n```\nforever start /path/to/app.js   // 启动应用程序\nforever stop app                // 停止应用程序\nforever restart app             // 重启应用程序\nforever list                    // 列出当前运行的所有应用程序\n```\n\n总之，使用这些工具，可以方便地实现应用挂了之后自动重启的功能，减少应用程序奔溃对业务造成的影响。\n\n如果您不想使用第三方库，也可以编写一些代码来实现自动重启的功能。下面介绍两种方法。\n\n## 3. 增加监控程序\n1. 使用 child_process 模块启动子进程，并监听其 exit 事件。如果子进程退出，就重新启动新的子进程。示例代码如下：\n\n```\nconst { spawn } = require('child_process');\n\nfunction startApp() {\n  const app = spawn('node', ['/path/to/app.js']);\n\n  app.stdout.on('data', (data) => {\n    console.log(`stdout: ${data}`);\n  });\n\n  app.stderr.on('data', (data) => {\n    console.error(`stderr: ${data}`);\n  });\n\n  app.on('exit', (code) => {\n    console.log(`child process exited with code ${code}`);\n    setTimeout(startApp, 5000); // 重新启动子进程\n  });\n}\n\nstartApp();\n```\n\n2. 使用 try-catch 装饰器来捕获应用程序中的异常，并进行重启操作。示例代码如下：\n\n```\nfunction restartOnCrash(target) {\n  const originalMethod = target.prototype.run;\n\n  target.prototype.run = function() {\n    try {\n      originalMethod.apply(this, arguments);\n    } catch (err) {\n      console.error(`application crashed: ${err}`);\n      setTimeout(() => {\n        console.log(`restarting application...`);\n        this.run();\n      }, 5000);\n    }\n  };\n}\n\nclass MyApp {\n  run() {\n    // your application code goes here\n  }\n}\n\nrestartOnCrash(MyApp);\nconst app = new MyApp();\napp.run();\n```\n\n这里使用了装饰器 `restartOnCrash` 对 `MyApp` 类中的 `run` 方法进行装饰，当 `run` 方法中抛出异常时，会在 5 秒钟后重新调用 `run` 方法。\n","isLeaf":true},{"key":"/NodeJS/01-basic/019-cross-spawn.md","path":"/NodeJS/01-basic/019-cross-spawn.md","route":"/NodeJS/01-basic/019-cross-spawn.md","leaf":true,"title":"019-cross-spawn","depth":2,"content":"---\ntitle: 019 cross-spawn 跨平台进程\ntoc: true\ntags: NodeJS\ncategories: 前端开发\n---\n\nnpm cross-spawn 是一个 Node.js 模块，主要用于在跨平台环境中，安全地运行 shell 命令和子进程。\n在 Windows 和 Linux 等操作系统上，shell 命令和子进程的实现方式可能存在差异，例如 Windows 下的子进程可能需要使用 cmd.exe 来执行，而 Linux 下的子进程则需要使用 sh。\n\n这就会导致在跨平台开发中，使用 child_process 模块执行 shell 命令和子进程时，可能会出现一些兼容性问题。\n\n而 npm cross-spawn 利用了 Node.js 的 child_process 模块，提供了一个跨平台的解决方案，可以在不同的平台上安全地执行 shell 命令和子进程，并且能够自动识别当前所处的操作系统环境，从而选择正确的实现方式。这样可以有效避免因不同平台实现方式差异而导致的问题，提高跨平台开发的效率和可靠性。\n\n\n```js\nconst args = process.argv.slice(2);\n\nconst scriptIndex = args.findIndex(\n  (x) => x === \"build\" || x === \"eject\" || x === \"start\" || x === \"test\"\n);\nconst script = scriptIndex === -1 ? args[0] : args[scriptIndex];\nconst nodeArgs = scriptIndex > 0 ? args.slice(0, scriptIndex) : [];\n\nconst result = spawn.sync(\n    process.execPath, // node path\n    nodeArgs\n      .concat(require.resolve(\"../lib/\" + script))\n      .concat(args.slice(scriptIndex + 1)),\n    { stdio: \"inherit\" }\n  );\nconsole.log(result)\n```\n\n```js\n// work\nprocess.exit(10)\n```\n\n\n```json\n{\n  status: 10,\n  signal: null,\n  output: [ null, null, null ],\n  pid: 43229,\n  stdout: null,\n  stderr: null,\n  error: null\n}\n```\n","isLeaf":true},{"key":"/NodeJS/01-basic/020-linux-signal.md","path":"/NodeJS/01-basic/020-linux-signal.md","route":"/NodeJS/01-basic/020-linux-signal.md","leaf":true,"title":"020-linux-signal","depth":2,"content":"---\ntitle: 020 linux 进程信号\ntoc: true\ntags: NodeJS\ncategories: 前端开发\n---\n\n- 参考 http://gityuan.com/2015/12/20/signal/\n- https://blog.csdn.net/xiaobai_hellow/article/details/124673131\n\n\n## 1、linux 信号\n```bash\n[root@localhost test6]# kill -l\n```\n\n```text\n\n 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL\n\n 5) SIGTRAP      6) SIGABRT      7) SIGBUS       8) SIGFPE\n\n 9) SIGKILL     10) SIGUSR1     11) SIGSEGV     12) SIGUSR2\n\n13) SIGPIPE     14) SIGALRM     15) SIGTERM     16) SIGSTKFLT\n\n17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP\n\n21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU\n\n25) SIGXFSZ     26) SIGVTALRM   27) SIGPROF     28) SIGWINCH\n\n29) SIGIO       30) SIGPWR      31) SIGSYS      34) SIGRTMIN\n\n35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3  38) SIGRTMIN+4\n\n39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8\n\n43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12\n\n47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14\n\n51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10\n\n55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7  58) SIGRTMAX-6\n\n59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2\n\n63) SIGRTMAX-1  64) SIGRTMAX\n```\n\n只有第9种信号 (SIGKILL) 才可以无条件终止进程，其他信号进程都有权利忽略。下面是常用的信号：\n\n```text\nHUP　　1    终端断线\n\nINT　　2    中断（同 Ctrl+C）\n\nQUIT　 3    退出（同 Ctrl+\\）\n\nTERM   15   终止\n\nKILL   9    强制终止\n\nCONT   18   继续（与STOP相反， fg/bg命令）\n\nSTOP   19   暂停（同 Ctrl+Z）\n```\n\n## 2、演示给 node 进程发送信号\n\n```js\nconst http = require(\"http\");\nconsole.log(process.pid)\n\nconst server = http.createServer((req, res) => {\n  res.end('hello')\n});\n\nserver.listen(3002, () => {\n  console.log(\"服务启动成功\");\n});\n\nprocess.on('exit', function (code) {\n  // TODO 这里可以主动释放其他资源 如zookeeper连接等\n  console.log(`exit-------------------------`);\n\n  if (code === 1000) {\n    console.error('process:uncaughtException');\n  } else if (code === 1001) {\n    console.error('process:SIGINT');\n  } else if (code === 1002) {\n    console.error('process:SIGTERM');\n  } else {\n    console.error('process:unknown');\n  }\n});\n\nprocess.on('uncaughtException', function (e) {\n  console.log(`uncaughtException`, e);\n  // 异常可以选择不退出\n  process.exit(1000);\n});\n\nprocess.on('SIGINT', function () {\n  console.log(`SIGINT`);\n  process.exit(1001);\n});\n\nprocess.on('SIGTERM', function () {\n  console.log(`SIGTERM`);\n  process.exit(1002);\n});\n\nprocess.on('SIGHUP', () => {\n  console.log(`SIGHUP`);\n  console.log('接收到退出指令');\n});\n```\n\n假设进程 id 为 44525，执行：\n\n```shell\nkill -s SIGINTS 44525\n```\n\n会打印\n\n```text\nSIGINT\nexit-------------------------\nprocess:SIGINT\n```\n\n## 3、Node.js 捕获 Ctrl+C\nNode 支持信号事件，要捕获 Ctrl+C ，只要注册SIGINT信号事件就可以捕获 Ctrl+C。需要注意的是SIGINT信号事件被注册后，在终端按下 Ctrl+C 就没法终止程序了，所以在事件回调函数内必须调用process.exit() 函数终止程序。\n\n```js\nprocess.on('SIGINT', function () {\n    console.log('Exit now!');\n    process.exit();\n});\n```\n\n如果在退出之前需要做一些后续的处理，那么可以将 process.exit() 放在其它回调函数内调用。\n\n```js\nprocess.on('SIGINT', function () {\n    console.log('Exit now!');\n    port.write('ddd', function (){\n        process.exit();\n    });\n});\n```\n\n## 4、关于 kill 命令\nhttps://www.cnblogs.com/heracles-lau/articles/3392029.html\n","isLeaf":true},{"key":"/NodeJS/01-basic/021-nodejs-module.md","path":"/NodeJS/01-basic/021-nodejs-module.md","route":"/NodeJS/01-basic/021-nodejs-module.md","leaf":true,"title":"021-nodejs-module","depth":2,"content":"---\ntitle: 021 nodejs 模块机制\ntoc: true\ntags: NodeJS\ncategories: 前端开发\n---\n\n- nodejs 模块机制 https://juejin.cn/post/6844903951742025736\n","isLeaf":true},{"key":"/NodeJS/01-basic/022-crypto.md","path":"/NodeJS/01-basic/022-crypto.md","route":"/NodeJS/01-basic/022-crypto.md","leaf":true,"title":"022-crypto","depth":2,"content":"---\ntitle: 022 加密相关\ntoc: true\ntags: NodeJS\ncategories: 前端开发\n---\n\n## aes 演示\n\nNode.js内置了加密模块，该模块提供了各种加密和解密算法，如AES（高级加密标准）和DES（数据加密标准）等。\n下面是一些常用的加密和解密方法：\n\n- crypto.createHash(algorithm): 创建一个散列对象，该对象可用于生成一个加密的哈希值，其中的“algorithm”参数是散列算法的名称，如“sha256”，“sha512”等。\n\n- crypto.createCipheriv(algorithm, key, iv): 创建一个加密算法的对象，其中的“algorithm”参数是加密算法的名称，如“AES-128-CBC”或“DES-EDE3-CBC”，“key”参数是加密密钥，iv参数是初始化向量。\n\n- cipher.update(data, input_encoding, output_encoding): 使用输入编码（如果给出）和输出编码（如果给出）更新加密。\n\n- cipher.final(output_encoding): 返回加密的结果，并且关闭加密器。\n\n\n例如，AES加密可以使用以下代码：\n\n```javascript\nconst crypto = require('crypto');\n\nconst algorithm = 'aes-256-cbc';\nconst key = 'mysecretkey';\nconst iv = crypto.randomBytes(16);\nconst message = 'secret message';\n\nconst cipher = crypto.createCipheriv(algorithm, key, iv);\nlet encrypted = cipher.update(message, 'utf8', 'hex');\nencrypted += cipher.final('hex');\n\nconsole.log('Encrypted message:', encrypted);\n```\n\n在上面的示例代码中，我们使用AES-256-CBC加密算法，将密钥设置为“mysecretkey”，使用随机生成的16字节IV，并且我们将明文消息设置为“secret message”。通过 `crypto.createCipheriv()` 方法创建加密算法对象，然后使用 `cipher.update()` 来加密消息，并使用 `cipher.final()`来对消息进行最终加密。\n\n## md5 演示\n\n在Node.js中，也可以使用`crypto`模块来计算MD5散列值。下面是使用Node.js的代码示例，演示如何使用`crypto`模块计算字符串的MD5散列值：\n```javascript\nconst crypto = require('crypto');\n\nconst message = '需要加密的字符串';\nconst hash = crypto.createHash('md5').update(message).digest('hex');\n\nconsole.log('MD5加密后的字符串为：', hash);\n```\n\n在这个示例中，我们首先将要加密的字符串存储在变量`message`中。然后，我们使用`createHash()`方法创建一个MD5 hash对象，并使用`update()`方法将输入字符串添加到对象中。最后，我们使用`digest()`方法获得计算出的16进制字符串，它表示了输入字符串的MD5散列值。最后，使用`console.log()`语句输出计算后的散列值。\n\n需要注意的是，MD5虽然是一种常见的散列函数，但其安全性已经被攻击，因此建议使用更安全的散列函数，例如SHA-2系列的函数。\n","isLeaf":true},{"key":"/NodeJS/01-basic/023-mvc-starter.md","path":"/NodeJS/01-basic/023-mvc-starter.md","route":"/NodeJS/01-basic/023-mvc-starter.md","leaf":true,"title":"023-mvc-starter","depth":2,"content":"---\ntitle: 023 实现 mvc 框架\ntoc: true\ntags: NodeJS\ncategories: 前端开发\n---\n","isLeaf":true},{"key":"/NodeJS/01-basic/024-V8-GC.md","path":"/NodeJS/01-basic/024-V8-GC.md","route":"/NodeJS/01-basic/024-V8-GC.md","leaf":true,"title":"024-V8-GC","depth":2,"content":"---\ntitle: 024 V8 垃圾回收\ntoc: true\ntags: NodeJS\ncategories: 前端开发\n---\n","isLeaf":true},{"key":"/NodeJS/01-basic/025-libuv.md","path":"/NodeJS/01-basic/025-libuv.md","route":"/NodeJS/01-basic/025-libuv.md","leaf":true,"title":"025-libuv","depth":2,"content":"---\ntitle: 024 libuv\ntoc: true\ntags: NodeJS\ncategories: 前端开发\n---\n\n- https://musicfe.com/libuv/\n- https://zhuanlan.zhihu.com/p/50497450\n\n## libuv 的核心\n\nlibuv为什么可以这么高效呢？实际他使用了操作系统提供的高并发异步模型：\n- linux: epoll\n- freebsd: kqueue\n- windows: iocp\n\n每个我们常见的操作系统都为我们封装了类似的高并发异步模型，那libuv其实就是对各个操作系统进行封装，最后暴露出统一的api供开发者调用，开发者不需要关系底层是什么操作系统，什么API了。 我们来看一下同步模型和异步模型的区别\n\n\n![image](https://user-images.githubusercontent.com/34447750/230695916-e4c2dcef-62ce-432d-9fa0-d3ed667eabbd.png)\n","isLeaf":true}]},{"key":"/NodeJS/02-mvc","path":"/NodeJS/02-mvc","route":"/NodeJS/02-mvc","leaf":false,"title":"02-mvc","depth":1,"content":"","isLeaf":false,"children":[]},{"key":"/NodeJS/03-express","path":"/NodeJS/03-express","route":"/NodeJS/03-express","leaf":false,"title":"03-express","depth":1,"content":"","isLeaf":false,"children":[{"key":"/NodeJS/03-express/01-design.md","path":"/NodeJS/03-express/01-design.md","route":"/NodeJS/03-express/01-design.md","leaf":true,"title":"01-design","depth":2,"content":"---\ntitle: 01 整体介绍\ntoc: true\ntags: \n  - NodeJS\n  - ExpressJS\ncategories: 前端开发\n---\n\n## 1、初识 express\n[express.js](https://link.juejin.cn/?target=https%3A%2F%2Fwww.expressjs.com.cn%2F) 是一款基于 Node.js 平台，极简的 Web 开发框架。本文将基于 4.18.2 版本，详细讲解 Express 核心原理的实现，包括主体架构 以及 核心的中间件架构模型讲解。\n\nExpress 在使用上非常较简单：\n\n- （1）初始化一个应用\n- （2）注册中间件调用\n- （3）最后监听端口启动服务\n\n```typescript\nconst express = require('express')\n\n// 初始化一个应用\nconst app = express()\nconst port = 3000\n\n// 注册中间件调用\napp.get('/', (req, res) => {\n  res.send('Hello World!')\n})\n\n// 监听端口启动服务\napp.listen(port, () => {\n  console.log(`Example app listening on port ${port}`)\n})\n```\n \n这个例子很简单，在更进一步之前，我们需要理解 express.js 的中间件模型，它可以帮助我们理解源码。\n\n## 2、中间件模型\nexpress.js 本质上是一个中间件模型，比如对于如下代码：\n```cpp\nconst express = require('express')\nconst app = express()\nconst port = 3000\n\n// 注册中间件: 响应请求，打印1，并且调用 next() 进入下一个中间件\napp.get('/', (req, res, next) => {\n  console.log(1)\n  res.send('Hello World!')\n  next()\n})\n\n// 注册中间件: 打印2，并且调用 next() 进入下一个中间件\napp.get('/', (req, res, next) => {\n  console.log(2)\n  next()\n})\n\n// 注册中间: 打印3\napp.get('/', (req, res, next) => {\n  console.log(3)\n  next()\n})\n\n// 注册中间件: 打印4\napp.get('/hello', (req, res) => {\n  console.log(4)\n})\n\napp.listen(port, () => {\n  console.log(`Example app listening on port ${port}`)\n})\n```\n在这里我们注册了4个中间件，当访问 [http://localhost:3000/](http://localhost:3000/) 会命中前3个中间件，从而打印 1 2 3，其命中规则主要依靠 HTTP 请求方法 和 请求路径来判断。\n\n![图1](http://s3.airtlab.com/blog/20230228221626.png)\n\n在 express.js 内部，当监听到一个请求时，会遍历所有中间件，如果某个中间件命中，则会进入该中间件，否则跳过，直到所有中间件遍历结束。 \n\n## 3、核心概念介绍\n以下的内容，只需要大体清楚留个印象即可，在后面的章节中，我们会详细的介绍。\n\n### 3.1 application 对象\n该对象由 express() 创建，app 本质是一个函数(也是中间件)，用于接受请求并下发，同时挂载了很多方法。\n```typescript\nvar app = function(req, res, nest) {}\n\n/**\n * Initialize the server.\n *\n *   - setup default configuration\n *   - setup default middleware\n *   - setup route reflection methods\n *\n * @private\n */\n// 入口\napp.init = function init() {}\n\n/**\n * Initialize application configuration.\n * @private\n */\n// 初始化配置\napp.defaultConfiguration = function defaultConfiguration() {}\n\n// 创建 router\napp.lazyrouter = function lazyrouter() {}\n```\n### 3.2 middleware 中间件\nmiddleware 本质上是一个 Function，存在3种定义：\n```cpp\n// 正常中间件：你对数据进行处理，然后调用 next 调用下一个中间件\nfn1(req, res, next) {}\n\n// 异常中间件: 你出错口才调用它，而且必须是四个参数，不能多也不能少\nfn2(err, req, res, next) {}\n\n// 终止中间件：没有 next 说明数据到里结束\nfn3(req, res) {}\n```\n中间件可以绑定路由，也可以不用绑定路由：\n```cpp\n// 全局, 不绑定路由\napp.use(function(req, res, next){});\n\n// 路由中间件, 绑定路由 get 方法\napp.get(\"/ping\", function(req, res, next){})\n\n// 路由中间件, 绑定路由 所有方法\napp.all(\"/ping\", function(req, res, next){})\n```\n中间件的更多演示 [Middleware callback function examples]([https://expressjs.com/en/4x/api.html#app.use](https://expressjs.com/en/4x/api.html#app.use))\n\n### 3.3 Router 对象\n每一个 application 中都只有一个 router 路由对像，这个对像管理这个 application 下面有所有的 subApplication, middleware 和 route。\n\n### 3.4 Route 对象\n```cpp\nfunction Route(path) {\n  this.path = path;\n  this.stack = [];\n\n  debug('new %o', path)\n\n  // route handlers for various http methods\n  this.methods = {};\n}\n```\n用于管理路由对象，比如：\n```cpp\napp.get(\"/ping\", function fn1(req, res, next){})\n```\n这时，就会创建一个 Route 实例:\n```cpp\n{\n\t\"path\": \"/ping\", // 请求路径\n    \"stack\": [fn1],  // 回掉函数\n    \"methods\": {     // 该 route 绑定了的请求方法\n        \"get\": true\n    }\n}\n```\n\n### 3.5 Layer 对象\nLayer 是一个连接器，用于串联 router route 以及 middleware，也是 express.js 中间件的核心\n\n### 3.6 sub application 子应用\napplication 指一个 express 实例，这个实例可以有自己环境变量等，而 subApplication 是指的 application 下面又会嵌套 一个 express 实例对像。\n```cpp\n// An Express app is valid middleware.\nvar subApp = express()\nsubApp.get('/', function (req, res, next) {\n  next()\n})\napp.use(subApp)\n```","isLeaf":true},{"key":"/NodeJS/03-express/02-create-app.md","path":"/NodeJS/03-express/02-create-app.md","route":"/NodeJS/03-express/02-create-app.md","leaf":true,"title":"02-create-app","depth":2,"content":"---\ntitle: 02 创建 application\ntoc: true\ntags: ExpressJS\ncategories: 前端开发\n---\n\nexpress.js 第一步是创建 application 实例\n\n```js\nconst express = require('express')\n\n// 创建 application 实例\nconst app = express()\nconst port = 3000\n\napp.get('/', (req, res) => {\n  res.send('Hello World!')\n})\n\napp.listen(port, () => {\n  console.log(`Example app listening on port ${port}`)\n})\n```\n\n我们来看看 调用 express 函数后，背后的逻辑是什么。\n\n## 1. createApplication()\n\n源码：lib/express.js<br />express 函数就是 createApplication:\n\n```js\n/**\n* Create an express application.\n*\n* @return {Function}\n* @api public\n*/\n\nfunction createApplication() {\n  // app 仅仅是一个函数\n  // app 为什么这么定义，后续会讲到\n  var app = function (req, res, next) {\n    app.handle(req, res, next);\n  };\n\n  // 给 app 扩展 发布订阅\n  mixin(app, EventEmitter.prototype, false);\n\n  // 给 app 扩展 application 里面所定义对象\n  // 比如 app.init 就在 proto 中定义的\n  mixin(app, proto, false);\n\n  // 将 request 挂载到 app.request\n  // 并且 app 挂载到   request.app\n  // expose the prototype that will get set on requests\n  app.request = Object.create(req, {\n    app: { configurable: true, enumerable: true, writable: true, value: app },\n\t});\n\n  // 将 response 挂载到  app.response\n  // 并且 app 挂载到 response.app\n  // expose the prototype that will get set on responses\n  app.response = Object.create(res, {\n    app: { configurable: true, enumerable: true, writable: true, value: app },\n  });\n\n  // 初始化\n  app.init();\n\n  return app;\n}\n```\n\n## 2. app.init()\n\n源码：lib/application.js\n\n```js\n/**\n* Initialize the server.\n*\n*   - setup default configuration\n*   - setup default middleware\n*   - setup route reflection methods\n*\n* @private\n*/\n\napp.init = function init() {\n  this.cache = {};\n  this.engines = {};\n  this.settings = {};\n\n  // 初始化 setting\n  // setting 用于存储一些配置项\n  this.defaultConfiguration();\n};\n```\n\n## 3. app.defaultConfiguration()\n\n源码：lib/application.js\n\n```js\n/**\n* Initialize application configuration.\n* @private\n*/\n\napp.defaultConfiguration = function defaultConfiguration() {\n  var env = process.env.NODE_ENV || 'development';\n\n  // default settings\n  // this.set(key, value) 设置 settings\n  this.enable('x-powered-by');\n  this.set('etag', 'weak');\n  this.set('env', env);\n  this.set('query parser', 'extended');\n  this.set('subdomain offset', 2);\n  this.set('trust proxy', false);\n\n  // trust proxy inherit back-compat\n  Object.defineProperty(this.settings, trustProxyDefaultSymbol, {\n    configurable: true,\n    value: true\n    });\n\n  debug('booting in %s mode', env);\n\n  // MARK TODO mount 事件什么时候 emit\n  this.on('mount', function onmount(parent) {\n    // inherit trust proxy\n    if (this.settings[trustProxyDefaultSymbol] === true\n    && typeof parent.settings['trust proxy fn'] === 'function') {\n    delete this.settings['trust proxy'];\n    delete this.settings['trust proxy fn'];\n  }\n\n  // inherit protos\n  setPrototypeOf(this.request, parent.request)\n    setPrototypeOf(this.response, parent.response)\n    setPrototypeOf(this.engines, parent.engines)\n    setPrototypeOf(this.settings, parent.settings)\n  });\n\n  // setup locals\n  this.locals = Object.create(null);\n\n  // top-most app is mounted at /\n  this.mountpath = '/';\n\n  // default locals\n  this.locals.settings = this.settings;\n\n  // default configuration\n  this.set('view', View);\n  this.set('views', resolve('views'));\n  this.set('jsonp callback name', 'callback');\n\n  if (env === 'production') {\n    this.enable('view cache');\n  }\n\n  Object.defineProperty(this, 'router', {\n    get: function() {\n      throw new Error('\\'app.router\\' is deprecated!\\nPlease see the 3.x to 4.x migration guide for details on how to update your app.');\n    }\n  });\n};\n```\n\n## 4. 监听 mount 事件\n\n当 express 实例是一个子应用时，该子应用注册成功后，就会收到 mount 事件\n\n```js\n  app.on('mount', function onmount(parent) {\n    // inherit trust proxy\n    if (this.settings[trustProxyDefaultSymbol] === true\n      && typeof parent.settings['trust proxy fn'] === 'function') {\n      delete this.settings['trust proxy'];\n      delete this.settings['trust proxy fn'];\n    }\n\n    // inherit protos\n    setPrototypeOf(this.request, parent.request)\n    setPrototypeOf(this.response, parent.response)\n    setPrototypeOf(this.engines, parent.engines)\n    setPrototypeOf(this.settings, parent.settings)\n  });\n```\n\n```js\n// An Express app is valid middleware.\nvar subApp = express()\nsubApp.get('/', function (req, res, next) {\n  next()\n})\napp.use(subApp)\n```\n\napp.use 源码\n\n```js\napp.use = function use(fn) {\n  var offset = 0;\n  var path = '/';\n\n  // default path to '/'\n  // disambiguate app.use([fn])\n  if (typeof fn !== 'function') {\n    var arg = fn;\n\n    while (Array.isArray(arg) && arg.length !== 0) {\n      arg = arg[0];\n    }\n\n    // first arg is the path\n    if (typeof arg !== 'function') {\n      offset = 1;\n      path = fn;\n    }\n  }\n\n  var fns = flatten(slice.call(arguments, offset));\n\n  if (fns.length === 0) {\n    throw new TypeError('app.use() requires a middleware function')\n  }\n\n  // setup router\n  this.lazyrouter();\n  var router = this._router;\n\n  fns.forEach(function (fn) {\n    // non-express app\n    if (!fn || !fn.handle || !fn.set) {\n      return router.use(path, fn);\n    }\n\n    debug('.use app under %s', path);\n    fn.mountpath = path;\n    fn.parent = this;\n\n    // restore .app property on req and res\n    router.use(path, function mounted_app(req, res, next) {\n      var orig = req.app;\n      fn.handle(req, res, function (err) {\n        setPrototypeOf(req, orig.request)\n        setPrototypeOf(res, orig.response)\n        next(err);\n      });\n    });\n\n    // mounted an app\n    fn.emit('mount', this);\n  }, this);\n\n  return this;\n};\n```\n","isLeaf":true},{"key":"/NodeJS/03-express/03-app-receive-request.md","path":"/NodeJS/03-express/03-app-receive-request.md","route":"/NodeJS/03-express/03-app-receive-request.md","leaf":true,"title":"03-app-receive-request","depth":2,"content":"---\ntitle: 03 app 接收请求\ntoc: true\ntags: ExpressJS\ncategories: 前端开发\n---\n\n```js\nconst express = require('express')\n\n// 初始化一个应用\nconst app = express()\nconst port = 3000\n\n// 注册中间件调用\napp.get('/', (req, res) => {\n  res.send('Hello World!')\n})\n\n// 监听端口启动服务\napp.listen(port, () => {\n  console.log(`Example app listening on port ${port}`)\n})\n```\n然后 app.listen 内部封装 http.createServer，所以先看看 app.listen\n\n## 1. app.listen()\n```js\n// lib/application.js\napp.listen = function listen() {\n  // this 就是\n  // var app = function (req, res, next) {\n  //   next 为 undefined  \n  //   app.handle(req, res, next);\n  // };\n\n  var server = http.createServer(this);\n\n  return server.listen.apply(server, arguments);\n};\n```\n所以当监听到请求时会进入 app.handle\n\n## 2. app.handle()\n```cpp\n// lib/application.js\n\n// Dispatch a req, res pair into the application. Starts pipeline processing.\n// If no callback is provided, then default error handlers will respond\n// in the event of an error bubbling through the stack.\napp.handle = function handle(req, res, callback) {\n  var router = this._router;\n\n  // final handler\n  var done = callback || finalhandler(req, res, {\n    env: this.get('env'),\n    onerror: logerror.bind(this)\n  });\n\n  // no routes\n  if (!router) {\n    debug('no routes defined on app');\n    done();\n    // 如果没有注册任何的中间件，则 done()\n    return;\n  }\n\n  router.handle(req, res, done);\n};\n```\n app.handle  用于下发请求到 router 进行处理，首先定义了 done Function，这个函数会在所有中间件都执行完了后执行。调用 router.handle 后，会进人流水线处理流程，我们先看看 finalhandler 的定义\n```cpp\nfunction finalhandler (req, res, options) {\n  var opts = options || {}\n\n  // get environment\n  var env = opts.env || process.env.NODE_ENV || 'development'\n\n  // get error callback\n  var onerror = opts.onerror\n\n  // 如果执行流水线执行完成，或者中途出现了错误\n  // 则会调用这个函数，并且传入错误信息\n  return function (err) {\n    var headers\n    var msg\n    var status\n\n    // ignore 404 on in-flight response\n    // 如果没错误，但是已经响应请求了，则请求处理完成\n    if (!err && headersSent(res)) {\n      debug('cannot 404 after headers sent')\n      return\n    }\n\n    // unhandled error\n    if (err) {\n      // respect status code from error\n      status = getErrorStatusCode(err)\n\n      if (status === undefined) {\n        // fallback to status code on response\n        status = getResponseStatusCode(res)\n      } else {\n        // respect headers from error\n        headers = getErrorHeaders(err)\n      }\n\n      // get error message\n      msg = getErrorMessage(err, status, env)\n    } else {\n      // not found\n      status = 404\n      msg = 'Cannot ' + req.method + ' ' + encodeUrl(getResourceName(req))\n    }\n\n    debug('default %s', status)\n\n    // schedule onerror callback\n    if (err && onerror) {\n      defer(onerror, err, req, res)\n    }\n\n    // cannot actually respond\n    if (headersSent(res)) {\n      debug('cannot %d after headers sent', status)\n      req.socket.destroy()\n      return\n    }\n\n    // send response\n    send(req, res, status, headers, msg)\n  }\n}\n```\n接下来，我们看看 router.handle 的逻辑\n\n## 3. router.handle()\nrouter.handle 是中间件执行调度的核心，我们后续会用单独的章节详细介绍，这里只做大概的阐述。<br />实际上，所有注册的中间件都会被 router 对象所管理，在 router.handle 内部封装了关键的 next 方法 以及 关键指针 idx，next 方法 + idx 指针来串联所有的中间件：\n\n- 从 idx = 0 开始，进入 next 方法，取一个 matched 的中间件\n- 当第一个中间件执行完成后，并且 next 被调用\n- 则取下一个 matched，这样直到所有 middleware 都被处理\n- 最后执行 done() \n\n下面是极简的代码（仅仅提供帮助理解，后续会详细介绍）\n```js\nproto.handle = function handle(req, res, out) {\n  var self = this;\n\n  var idx = 0;\n\n  // middleware and routes\n  var stack = self.stack;\n\n  var done = restore(out, req, 'baseUrl', 'next', 'params');\n\n  // setup basic req values\n  req.baseUrl = parentUrl;\n  req.originalUrl = req.originalUrl || req.url;\n\n  next();\n\n  function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // max sync stack\n    if (++sync > 100) {\n      return setImmediate(next, err)\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    // while 循环负责获取一个 matched 的中间件\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer);\n      if (match !== true) {\n        continue;\n      }\n    }\n\n    // 执行该中间件\n\thandle_request(req, res, next)\n  }\n};\n```\n然后整个请求就处理完成了\n","isLeaf":true},{"key":"/NodeJS/03-express/04-middleware-register.md","path":"/NodeJS/03-express/04-middleware-register.md","route":"/NodeJS/03-express/04-middleware-register.md","leaf":true,"title":"04-middleware-register","depth":2,"content":"---\ntitle: 04 中间件注册流程\ntoc: true\ntags: ExpressJS\ncategories: 前端开发\n---\n\n创建 app 以及 app 接收请求 我们已经阐述过了，并且在《app 接收请求》这一小节中，我们介绍了 router.handle 中间件宏观的执行流程。现在我们需要详细的理解 中间件的注册流程 以及 中间件的执行流程。\n\n这一小节先介绍注册流程（如果你希望快速了解 middleware 的模型，请看文章末尾的 layer 模型图）\n\n## 1. 从 `app[method]()` 开始\n`app[method](path, fn)` 注册中间件:\n```js\n// 注册中间件: 响应请求，打印1，并且调用 next() 进入下一个中间件\napp.get('/', (req, res, next) => {\n  console.log(1)\n  res.send('Hello World!')\n  next()\n})\n```\n\n我们需要知道 `app.get` 是如何定义的：\n```js\n// lib/application.js\n// 遍历所有 http method\nmethods.forEach(function(method){\n  app[method] = function(path){\n    if (method === 'get' && arguments.length === 1) {\n      // app.get(setting)\n      return this.set(path);\n    }\n\n    // 创建 router, 内部有判断，只会全局创建一个 router\n    this.lazyrouter();\n      \n    // 创建 Route 实例\n    var route = this._router.route(path);\n\n    // 这个调用了 route.method 方法\n    // 本质上给该 route 创建了一个 layer\n    // route 绑定了 handle\n    route[method].apply(route, slice.call(arguments, 1));\n\n    return this;\n  };\n});\n```\n处理逻辑包括：\n\n- 创建 Router 实例 (内部有判断，只会全局创建一个 router)\n- 创建 Route 实例，每次调用 app[method] 都会创建一个 Route\n  - 创建 route\n  - 创建 router layer\n- 执行 route[method] 方法，参数为 handle\n  - 创建 route layer\n\n下面分别详细介绍。\n\n## 2. new Router\n### app.lazyrouter [创建 router]\n```js\napp.lazyrouter = function lazyrouter() {\n  if (!this._router) {\n    this._router = new Router({\n      caseSensitive: this.enabled('case sensitive routing'),\n      strict: this.enabled('strict routing')\n    });\n\n    // query parser: 解析 url 参数\n    this._router.use(query(this.get('query parser fn')));\n\n    // 完成 req 和 res 互相引用，以及按照国际惯例增加 \"X-Powered-By\" 😁\n    this._router.use(middleware.init(this));\n  }\n};\n```\nlazyrouter 内部决定是否执行 new Router，只会创建一个实例，这里可以理解为两步：\n\n- 创建 Router 实例\n- 注册两个内置的 middleware\n\n### Router 的定义\nlib/router/index.js\n```js\nvar proto = module.exports = function(options) {\n  var opts = options || {};\n\n  // 有趣的是 router 本身也是一个充当 middlewaren handle 的函数\n  // 这个会很有用, 比如路由分组  \n  function router(req, res, next) {\n    router.handle(req, res, next);\n  }\n\n  // mixin Router class functions\n  setPrototypeOf(router, proto)\n\n  router.params = {};\n  router._params = [];\n  router.caseSensitive = opts.caseSensitive;\n  router.mergeParams = opts.mergeParams;\n  router.strict = opts.strict;\n\n  // 用于保存所有的 middleware\n  router.stack = [];\n\n  return router;\n};\n```\n\n## 3. new Route\n### router.route() [创建 Route & router layer]\n注册中间件时:\n\n- (1) 创建一个 route\n- (2) 创建一个 layer\n- (3) layer.route = route\n- (4) 将 layer 添加到 router.stack 中\n\n```js\n/**\n * Create a new Route for the given path.\n *\n * Each route contains a separate middleware stack and VERB handlers.\n *\n * See the Route api documentation for details on adding handlers\n * and middleware to routes.\n *\n * @param {String} path\n * @return {Route}\n * @public\n */\nproto.route = function route(path) {\n  var route = new Route(path);\n\n  // layer 的 handle 为 route.dispatch 这个很重要\n  var layer = new Layer(path, {\n    sensitive: this.caseSensitive,\n    strict: this.strict,\n    end: true\n  }, route.dispatch.bind(route));\n\n  layer.route = route;\n\n  this.stack.push(layer);\n  return route;\n};\n```\n\n### route[method] [创建 route layer]\nlib/router/route.js\n```js\nmethods.forEach(function(method){\n  Route.prototype[method] = function(){\n      // handles 就是 app.method(path, fn1, fn2) 中的 [fn1, fn2]\n    var handles = flatten(slice.call(arguments));\n\n    for (var i = 0; i < handles.length; i++) {\n      var handle = handles[i];\n\n      if (typeof handle !== 'function') {\n        var type = toString.call(handle);\n        var msg = 'Route.' + method + '() requires a callback function but got a ' + type\n        throw new Error(msg);\n      }\n\n      debug('%s %o', method, this.path)\n\n      // 创建 Layer\n      // 将 layer 添加到 layer.stack 中\n      var layer = Layer('/', {}, handle);\n      layer.method = method;\n\n      this.methods[method] = true;\n      this.stack.push(layer);\n    }\n\n    return this;\n  };\n});\n\n```\n\n## 4. new Layer\nLayer 是对 middleware 的封装，先看 Layer 的定义。\n\n### Layer 的定义\n```js\n\nvar pathRegexp = require('path-to-regexp');\nvar debug = require('debug')('express:router:layer');\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nmodule.exports = Layer;\n\nfunction Layer(path, options, fn) {\n  if (!(this instanceof Layer)) {\n    return new Layer(path, options, fn);\n  }\n\n  debug('new %o', path)\n  var opts = options || {};\n\n  // 关键属性\n  this.handle = fn;\n\n  this.name = fn.name || '<anonymous>';\n  this.params = undefined;\n  this.path = undefined;\n  this.regexp = pathRegexp(path, this.keys = [], opts);\n\n  // set fast path flags\n  this.regexp.fast_star = path === '*'\n  this.regexp.fast_slash = path === '/' && opts.end === false\n}\n\n/**\n * Handle the error for the layer.\n *\n * @param {Error} error\n * @param {Request} req\n * @param {Response} res\n * @param {function} next\n * @api private\n */\nLayer.prototype.handle_error = function handle_error(error, req, res, next) {\n  var fn = this.handle;\n\n  if (fn.length !== 4) {\n    // not a standard error handler\n    return next(error);\n  }\n\n  try {\n    fn(error, req, res, next);\n  } catch (err) {\n    next(err);\n  }\n};\n\n/**\n * Handle the request for the layer.\n *\n * @param {Request} req\n * @param {Response} res\n * @param {function} next\n * @api private\n */\nLayer.prototype.handle_request = function handle(req, res, next) {\n  var fn = this.handle;\n\n    // 如果 handle 参数只有2个时\n    // 内部会帮助 next() 避免 pipe 中断\n  if (fn.length > 3) {\n    // not a standard request handler\n    return next();\n  }\n\n  try {\n    fn(req, res, next);\n  } catch (err) {\n    next(err);\n  }\n};\n\n/**\n * Check if this route matches `path`, if so\n * populate `.params`.\n *\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\nLayer.prototype.match = function match(path) {\n  var match\n\n  if (path != null) {\n    // fast path non-ending match for / (any path matches)\n    if (this.regexp.fast_slash) {\n      this.params = {}\n      this.path = ''\n      return true\n    }\n\n    // fast path for * (everything matched in a param)\n    if (this.regexp.fast_star) {\n      this.params = {'0': decode_param(path)}\n      this.path = path\n      return true\n    }\n\n    // match the path\n    match = this.regexp.exec(path)\n  }\n\n  if (!match) {\n    this.params = undefined;\n    this.path = undefined;\n    return false;\n  }\n\n  // store values\n  this.params = {};\n  this.path = match[0]\n\n  var keys = this.keys;\n  var params = this.params;\n\n  for (var i = 1; i < match.length; i++) {\n    var key = keys[i - 1];\n    var prop = key.name;\n    var val = decode_param(match[i])\n\n    if (val !== undefined || !(hasOwnProperty.call(params, prop))) {\n      params[prop] = val;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Decode param value.\n *\n * @param {string} val\n * @return {string}\n * @private\n */\n\nfunction decode_param(val) {\n  if (typeof val !== 'string' || val.length === 0) {\n    return val;\n  }\n\n  try {\n    return decodeURIComponent(val);\n  } catch (err) {\n    if (err instanceof URIError) {\n      err.message = 'Failed to decode param \\'' + val + '\\'';\n      err.status = err.statusCode = 400;\n    }\n\n    throw err;\n  }\n}\n\n```\n\n从 2 和 3 中可以看到, route 和 router 实例都有 stack 属性，都用于保存 Layer 实例，它们之间有什么区别呢？主要 handle function 的差异。\n\n### route layer 和 route layer\n前面我们已经讲过，router layer 是在调用 router.route 方法时创建的：\n```js\nrouter.route = function route(path) {\n  var route = new Route(path);\n\n  var layer = new Layer(path, {\n    sensitive: this.caseSensitive,\n    strict: this.strict,\n    end: true\n  }, route.dispatch.bind(route));\n\n  layer.route = route;\n\n  this.stack.push(layer);\n  return route;\n};\n```\n注意 router layer 的 handle 实际上是  route.dispatch，而 route layer 是在调用 route[method]() 创建的:\n```js\nmethods.forEach(function(method){\n  Route.prototype[method] = function(){\n    var handles = flatten(slice.call(arguments));\n\n    for (var i = 0; i < handles.length; i++) {\n      var handle = handles[i];\n\n      if (typeof handle !== 'function') {\n        var type = toString.call(handle);\n        var msg = 'Route.' + method + '() requires a callback function but got a ' + type\n        throw new Error(msg);\n      }\n\n      debug('%s %o', method, this.path)\n\n      var layer = Layer('/', {}, handle);\n      layer.method = method;\n      // route layer 必须绑定 method, 因为一个 route 既可以绑定 post 也可以绑定 get...\n      // post 对应 post layer, get 对应 get layer\n\n      this.methods[method] = true;\n      this.stack.push(layer);\n    }\n\n    return this;\n  };\n});\n```\n对比差异：\n```js\n// router layer\nnew Layer(path, {\n    sensitive: this.caseSensitive,\n    strict: this.strict,\n    end: true\n  }, route.dispatch.bind(route));\nlayer.route = route;\n\n// route layer\nvar layer = Layer('/', {}, handle);\nlayer.method = method;\n```\n\n### user handle 和 dispatch handle\n概念区分，体现差异\n\n### layer 测试\n```js\nconst express = require('express')\nconst app = express()\nconst port = 3000\n\n// 注册中间件\n// 功能包含：响应请求，打印1，并且调用 next() 进入下一个中间件\napp.get('/', (req, res, next) => {\n  console.log(1)\n  res.send('Hello World!')\n  next()\n})\n\n// 注册中间件\n// 功能包含：打印2，并且调用 next() 进入下一个中间件\napp.get('/', (req, res, next) => {\n  console.log(2)\n  next()\n})\n\napp.listen(port, () => {\n  console.log(`Example app listening on port ${port}`)\n})\ndebugger\n```\n针对上面代码，当执行到 debugger 时, app._router.stack 长度为 4:\n\n![20230228234147](http://s3.airtlab.com/blog/20230228234147.png)\n\n前两个是内置中间件，后面2个是自定义注册的。我们看看第三个 layer:\n\n![20230228234130](http://s3.airtlab.com/blog/20230228234130.png)\n\n该 layer 的 handle 是 route.dispatch 方法，而且该 layer 有一个 route 属性。route 也有 一个 layer, 其 handle 就是我们注册的 callback function。route.stack 是一个数组，这表示一个route可以拥有多layer，比如：\n```js\n// route.all 或者 route.get 支持链式写法\n// 给一个 route 注册了两个layer\nrouter.route('/users/:user_id')\n  .all(function (req, res, next) {\n    // runs for all HTTP verbs first\n    // think of it as route specific middleware!\n    next()\n  })\n  .get(function (req, res, next) {\n    res.json(req.user)\n  })\n```\n\n### layer 模型图\n到此为止我们画出 Layer 的模型图:\n\n![20230228234105](http://s3.airtlab.com/blog/20230228234105.png)\n\n### route 多 layer\n```js\napp.route('/user') \n.get((req, res, next) => { \n    res.send('GET request called'); \n}) \n.post((req, res, next) => { \n\tres.send('POST request called'); \n}) \n.all((req, res, next) => { \n\tres.send('Other requests called'); \n}) \n  \n```","isLeaf":true},{"key":"/NodeJS/03-express/05-middleware-runtime.md","path":"/NodeJS/03-express/05-middleware-runtime.md","route":"/NodeJS/03-express/05-middleware-runtime.md","leaf":true,"title":"05-middleware-runtime","depth":2,"content":"---\ntitle: 05 中间件执行流程\ntoc: true\ntags: ExpressJS\ncategories: 前端开发\n---\n\n使用以下代码进行调试:\n```cpp\nconst express = require('express')\nconst app = express()\nconst port = 3000\n\n// 注册中间件\n// 功能包含：响应请求，打印1，并且调用 next() 进入下一个中间件\napp.get('/', (req, res, next) => {\n  console.log(1)\n  res.send('Hello World!')\n  next()\n})\n\n// 注册中间件\n// 功能包含：打印2，并且调用 next() 进入下一个中间件\napp.get('/', (req, res, next) => {\n  console.log(2)\n  next()\n})\n\napp.listen(port, () => {\n  debugger\n  console.log(`Example app listening on port ${port}`)\n})\n```\n\n### 1. layer 执行流程\n先了解 express.js 中 layer 的执行流程，再看代码会变得非常简单。<br />\n![image](http://s3.airtlab.com/blog/image.png)\n\n- 理解 router layer 递归\n- 理解 route layer 递归\n\n### 2. router.handle 接管请求\n```cpp\n/**\n * Dispatch a req, res into the router.\n * @private\n */\nrouter.handle = function handle(req, res, out) {\n  var self = this;\n\n  debug('dispatching %s %s', req.method, req.url);\n\n  var idx = 0;\n  var protohost = getProtohost(req.url) || ''\n  var removed = '';\n  var slashAdded = false;\n  var sync = 0\n  var paramcalled = {};\n\n  // store options for OPTIONS request\n  // only used if OPTIONS request\n  var options = [];\n\n  // middleware and routes\n  var stack = self.stack;\n\n  // manage inter-router variables\n  var parentParams = req.params;\n  var parentUrl = req.baseUrl || '';\n  var done = restore(out, req, 'baseUrl', 'next', 'params');\n\n  // setup next layer\n  req.next = next;\n\n  // for options requests, respond with a default if nothing else responds\n  if (req.method === 'OPTIONS') {\n    done = wrap(done, function(old, err) {\n      if (err || options.length === 0) return old(err);\n      sendOptionsResponse(res, options, old);\n    });\n  }\n\n  // setup basic req values\n  req.baseUrl = parentUrl;\n  req.originalUrl = req.originalUrl || req.url;\n\n  next();\n\n  function next(err) {}\n}\n```\n#### next() 递归函数\n我们只看 next 的核心逻辑，就是递归的匹配 layer 并执行 handle，其他的可以先忽略。\n```cpp\n  function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.slice(1)\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.slice(protohost.length)\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // max sync stack\n    if (++sync > 100) {\n      return setImmediate(next, err)\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n\n    // layerPath 和 path 的区别\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        next(layerError || err)\n      } else if (route) {\n          // 如果是一个 route layer, 则执行 layer.handle, 也就是 route.dispatch\n        layer.handle_request(req, res, next)\n      } else {\n          // 如果不是 route layer, 则要 trim_prefix\n          // 后续在讲 trim_prefix 是干什么\n        trim_prefix(layer, layerError, layerPath, path)\n      }\n\n      sync = 0\n    });\n  }\n\n```\n```cpp\nLayer.prototype.handle_request = function handle(req, res, next) {\n  var fn = this.handle;\n\n  if (fn.length > 3) {\n    // not a standard request handler\n    return next();\n  }\n\n  try {\n    fn(req, res, next);\n  } catch (err) {\n    next(err);\n  }\n};\n\n// app.get('/', (req, res, next) => {\n//   console.log(2)\n//   next() => router next()\n// })\n```\n#### trim_prefix 函数\n```cpp\n  function trim_prefix(layer, layerError, layerPath, path) {\n    if (layerPath.length !== 0) {\n      // Validate path is a prefix match\n      if (layerPath !== path.slice(0, layerPath.length)) {\n        next(layerError)\n        return\n      }\n\n      // Validate path breaks on a path separator\n      var c = path[layerPath.length]\n      if (c && c !== '/' && c !== '.') return next(layerError)\n\n      // Trim off the part of the url that matches the route\n      // middleware (.use stuff) needs to have the path stripped\n      debug('trim prefix (%s) from url %s', layerPath, req.url);\n      removed = layerPath;\n      req.url = protohost + req.url.slice(protohost.length + removed.length)\n\n      // Ensure leading slash\n      if (!protohost && req.url[0] !== '/') {\n        req.url = '/' + req.url;\n        slashAdded = true;\n      }\n\n      // Setup base URL (no trailing slash)\n      req.baseUrl = parentUrl + (removed[removed.length - 1] === '/'\n        ? removed.substring(0, removed.length - 1)\n        : removed);\n    }\n\n    debug('%s %s : %s', layer.name, layerPath, req.originalUrl);\n\n    if (layerError) {\n      layer.handle_error(layerError, req, res, next);\n    } else {\n      layer.handle_request(req, res, next);\n    }\n  }\n```\n#### layerPath 和 path 的区别\n#### req.baseUrl & req.url 维护\n`req.baseUrl` 表示当前 router instance 所挂载的路径\n```cpp\nconst app = express()\nconst port = 3000\n\n// 演示1\napp.get('/test', function (req, res) {\n  console.log(req.baseUrl) // ''\n  console.log(req.path) // /test\n\n  res.send('Konichiwa!')\n})\n\n\n// 演示2\nvar greet = express.Router()\n\ngreet.get('/jp', function (req, res) {\n  console.log(req.baseUrl) // /greet\n  console.log(req.path) // jp\n  res.send('Konichiwa!')\n})\n\napp.use('/greet', greet) // load the router on '/greet'\n\n// 演示3\ngreet.get('/:id', function (req, res) {\n  console.log(req.baseUrl) // /greet\n  console.log(req.path) // 12\n  res.send('Konichiwa!')\n})\n\napp.use('/greet', greet) // load the router on '/greet'\n// visit /greet/12\n```\n### 3. route.dispatch\n```cpp\n// 当 route 里面的 layer 执行完成之后，会执行 done\n// 这个 done 实际就是 router layer next\nRoute.prototype.dispatch = function dispatch(req, res, done) {}\n```\n```cpp\nRoute.prototype.dispatch = function dispatch(req, res, done) {\n  var idx = 0;\n  var stack = this.stack;\n  var sync = 0\n\n  if (stack.length === 0) {\n    return done();\n  }\n\n  var method = req.method.toLowerCase();\n  if (method === 'head' && !this.methods['head']) {\n    method = 'get';\n  }\n\n  req.route = this;\n\n  next();\n\n  function next(err) {\n    // signal to exit route\n    if (err && err === 'route') {\n      return done();\n    }\n\n    // signal to exit router\n    if (err && err === 'router') {\n      return done(err)\n    }\n\n    // max sync stack\n    if (++sync > 100) {\n      return setImmediate(next, err)\n    }\n\n    var layer = stack[idx++]\n\n    // end of layers\n    if (!layer) {\n      return done(err)\n    }\n\n    // layer 也绑定了 method  \n    if (layer.method && layer.method !== method) {\n      next(err)\n    } else if (err) {\n      layer.handle_error(err, req, res, next);\n    } else {\n      layer.handle_request(req, res, next);\n    }\n\n    sync = 0\n  }\n};\n```","isLeaf":true},{"key":"/NodeJS/03-express/06-router-group.md","path":"/NodeJS/03-express/06-router-group.md","route":"/NodeJS/03-express/06-router-group.md","leaf":true,"title":"06-router-group","depth":2,"content":"---\ntitle: 06 路由分组原理\ntoc: true\ntags: ExpressJS\ncategories: 前端开发\n---\n\n`app[http method]` 用于挂载一个路由到默认的 router，而 `app.use` 可以挂载子 router, 因为 router instance 本身也是一个中间件。<br />调试代码：\n\n```js\nconst express = require('express')\nconst app = express()\nconst port = 3000\n\nvar greet = express.Router()\ngreet.get('/jp', function (req, res) {\n  res.send('Konichiwa!')\n})\n\napp.use('/greet', greet) // load the router on '/greet'\n\ndebugger\napp.listen(port, () => {\n  console.log(`Example app listening on port ${port}`)\n})\n\n```\n\n![image](http://s3.airtlab.com/blog/image.png)\n\n### 1. app.use()\n\n```cpp\napp.use = function use(fn) {\n  var offset = 0;\n  var path = '/';\n\n  // default path to '/'\n  // disambiguate app.use([fn])\n  if (typeof fn !== 'function') {\n    var arg = fn;\n\n    while (Array.isArray(arg) && arg.length !== 0) {\n      arg = arg[0];\n    }\n\n    // first arg is the path\n    if (typeof arg !== 'function') {\n      offset = 1;\n      path = fn;\n    }\n  }\n\n  var fns = flatten(slice.call(arguments, offset));\n\n  if (fns.length === 0) {\n    throw new TypeError('app.use() requires a middleware function')\n  }\n\n  // setup router\n  this.lazyrouter();\n  var router = this._router;\n\n  fns.forEach(function (fn) {\n    // non-express app\n    if (!fn || !fn.handle || !fn.set) {\n        // entered\n      return router.use(path, fn);\n    }\n\n    debug('.use app under %s', path);\n    fn.mountpath = path;\n    fn.parent = this;\n\n    // restore .app property on req and res\n    router.use(path, function mounted_app(req, res, next) {\n      var orig = req.app;\n      fn.handle(req, res, function (err) {\n        setPrototypeOf(req, orig.request)\n        setPrototypeOf(res, orig.response)\n        next(err);\n      });\n    });\n\n    // mounted an app\n    fn.emit('mount', this);\n  }, this);\n\n  return this;\n};\n\n```\n![image_1](http://s3.airtlab.com/blog/image_1.png)\n\n### 2. router.use()\n\n在 router 中注册中间件有两种方式，第一种是 router[method](), 另一种是 router.use(), 后者注册的方式和 HTTP Method 无关，只有 path 有关：\n\n```cpp\n// all requests to this router will first hit this middleware\nrouter.use(function (req, res, next) {\n  console.log('%s %s %s', req.method, req.url, req.path)\n  next()\n})\n\n// this will only be invoked if the path starts with /bar from the mount point\nrouter.use('/bar', function (req, res, next) {\n  // ... maybe some additional /bar logging ...\n  next()\n})\n```\n\n源码：\n\n```cpp\nrouter.use = function use(fn) {\n  var offset = 0;\n  var path = '/';\n\n  // default path to '/'\n  // disambiguate router.use([fn])\n  if (typeof fn !== 'function') {\n    var arg = fn;\n\n    while (Array.isArray(arg) && arg.length !== 0) {\n      arg = arg[0];\n    }\n\n    // first arg is the path\n    if (typeof arg !== 'function') {\n      offset = 1;\n      path = fn;\n    }\n  }\n\n  var callbacks = flatten(slice.call(arguments, offset));\n\n  if (callbacks.length === 0) {\n    throw new TypeError('Router.use() requires a middleware function')\n  }\n\n  for (var i = 0; i < callbacks.length; i++) {\n    var fn = callbacks[i];\n\n    if (typeof fn !== 'function') {\n      throw new TypeError('Router.use() requires a middleware function but got a ' + gettype(fn))\n    }\n\n    // add the middleware\n    debug('use %o %s', path, fn.name || '<anonymous>')\n\n    var layer = new Layer(path, {\n      sensitive: this.caseSensitive,\n      strict: false,\n      end: false\n    }, fn);\n\n    // 通过\n    layer.route = undefined;\n\n    this.stack.push(layer);\n  }\n\n  return this;\n};\n```\n\n### 3. trim_prefix() 剥掉分组前缀\n当执行到 greet 中间件时:\n![image_](http://s3.airtlab.com/blog/image_.png)\n\n```cpp\nfunction trim_prefix(layer, layerError, layerPath, path) {\n    if (layerPath.length !== 0) {\n      // Validate path is a prefix match\n      // 校验前缀是否相等\n      if (layerPath !== path.slice(0, layerPath.length)) {\n        next(layerError)\n        return\n      }\n\n      // Validate path breaks on a path separator\n      // 校验分割符\n      var c = path[layerPath.length]\n      if (c && c !== '/' && c !== '.') return next(layerError)\n\n      // Trim off the part of the url that matches the route\n      // middleware (.use stuff) needs to have the path stripped\n      debug('trim prefix (%s) from url %s', layerPath, req.url);\n      removed = layerPath;\n\n      // /greeting/test => /test\n      req.url = protohost + req.url.slice(protohost.length + removed.length)\n\n      // Ensure leading slash\n      // 保证 / 开头\n      if (!protohost && req.url[0] !== '/') {\n        req.url = '/' + req.url;\n        slashAdded = true;\n      }\n\n      // Setup base URL (no trailing slash)\n      req.baseUrl = parentUrl + (removed[removed.length - 1] === '/'\n        ? removed.substring(0, removed.length - 1)\n        : removed);\n    }\n\n    debug('%s %s : %s', layer.name, layerPath, req.originalUrl);\n\n    if (layerError) {\n      layer.handle_error(layerError, req, res, next);\n    } else {\n      layer.handle_request(req, res, next);\n    }\n  }\n```\n","isLeaf":true}]},{"key":"/NodeJS/04-koa","path":"/NodeJS/04-koa","route":"/NodeJS/04-koa","leaf":false,"title":"04-koa","depth":1,"content":"","isLeaf":false,"children":[{"key":"/NodeJS/04-koa/01-design.md","path":"/NodeJS/04-koa/01-design.md","route":"/NodeJS/04-koa/01-design.md","leaf":true,"title":"01-design","depth":2,"content":"---\ntitle: 01 架构设计\n---\n\nTODO","isLeaf":true}]},{"key":"/NodeJS/05-prisma","path":"/NodeJS/05-prisma","route":"/NodeJS/05-prisma","leaf":false,"title":"05-prisma","depth":1,"content":"","isLeaf":false,"children":[{"key":"/NodeJS/05-prisma/01-prisma-usage.md","path":"/NodeJS/05-prisma/01-prisma-usage.md","route":"/NodeJS/05-prisma/01-prisma-usage.md","leaf":true,"title":"01-prisma-usage","depth":2,"content":"## 1、prisma 用法\n\n- quick-start https://www.prisma.io/docs/getting-started/quickstart\n- https://dev.to/inezabonte/setting-up-a-mysql-database-using-prisma-2869\n- 《面向 Node.js 和 TypeScript 的下一代 ORM 工具 Prisma》 https://www.justsoso.tech/default/prisma-without-foreignKey.html\n\n**初始化**\n\n```\nnpx prisma init --datasource-provider mysql\n```\n\n**创建 diff 并且同步到远程 db**\n\n```\nnpx prisma migrate dev\n```\n\n**将远程 db 的结构同步到本地，这可能会导致本地一些 relation 丢失**\n\n```\nnpx prisma db pull\n```\n\n**ddl diff**\n\n```\nnpx prisma migrate diff \\\n    --from-url \"mysql://root:123456@localhost:3306/test\"  \\\n    --to-url \"mysql://root:123456@localhost:3306/test_2\" \\\n    --script\n```\n\n## 2、prisma schema\n\n```prisma\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\ndatasource db {\n  provider = \"mysql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel user {\n  id   Int     @id @default(autoincrement()) @db.UnsignedInt\n  name String? @default(\"\") @db.VarChar(255)\n}\n\nmodel post {\n  id        Int     @id @default(autoincrement())\n  title     String\n  content   String?\n  published Boolean @default(false)\n  uid       Int\n}\n```\n\n## 3、增删改查\n\n### 1) create\n\n```ts\nimport { PrismaClient } from \"@prisma/client\";\n\nconst prisma = new PrismaClient();\n\nasync function main() {\n  const user = await prisma.user.create({\n    data: {\n      name: \"Alice\",\n    },\n  });\n  console.log(user);\n}\n\nmain()\n  .then(async () => {\n    await prisma.$disconnect();\n  })\n  .catch(async (e) => {\n    console.error(e);\n    await prisma.$disconnect();\n    process.exit(1);\n  });\n```\n\n### 2) findMany\n```ts\nimport { PrismaClient } from '@prisma/client';\n\nconst prisma = new PrismaClient();\n\n// query\nasync function main() {\n  const users = await prisma.user.findMany({})\n  console.log(users)\n}\n\nmain()\n  .then(async () => {\n    await prisma.$disconnect();\n  })\n  .catch(async (e) => {\n    console.error(e);\n    await prisma.$disconnect();\n    process.exit(1);\n  });\n\n```\n\n### 3) create  with relation\n\n```ts\nimport { PrismaClient } from '@prisma/client';\n\nconst prisma = new PrismaClient();\n\nasync function main() {\n  const user = await prisma.user.create({\n    data: {\n      name: 'Bob',\n      post: {\n        create: {\n          title: 'Hello World',\n        },\n      },\n    },\n  });\n  console.log(user);\n}\n\nmain()\n  .then(async () => {\n    await prisma.$disconnect();\n  })\n  .catch(async (e) => {\n    console.error(e);\n    await prisma.$disconnect();\n    process.exit(1);\n  });\n\n```\n\n### 4) query with relation\n```ts\nimport { PrismaClient } from '@prisma/client';\n\nconst prisma = new PrismaClient();\n\n// query\nasync function main() {\n  const users = await prisma.user.findMany({\n    take: 10,\n    skip: 1,\n    include: {\n      post: true\n    },\n  })\n  console.dir(users, { depth: null })\n}\n\nmain()\n  .then(async () => {\n    await prisma.$disconnect();\n  })\n  .catch(async (e) => {\n    console.error(e);\n    await prisma.$disconnect();\n    process.exit(1);\n  });\n```\n\n### 5) logger\n\n```ts\nimport { Prisma, PrismaClient } from '@prisma/client';\n\nconst prisma = new PrismaClient({\n  log: ['query', 'error', 'info', 'warn']\n});\n\n\n// query\nasync function main() {\n  const res = await prisma.$queryRaw(Prisma.sql`select * from user`);\n  console.log(res)\n\n  const users = await prisma.user.findMany({\n    take: 10,\n    skip: 1,\n    include: {\n      post: true\n    },\n  })\n  console.dir(users, { depth: null })\n}\n\nmain()\n  .then(async () => {\n    await prisma.$disconnect();\n  })\n  .catch(async (e) => {\n    console.error(e);\n    await prisma.$disconnect();\n    process.exit(1);\n  });\n\n```\n\n### 6) $queryRaw\n\n```ts\nimport { Prisma, PrismaClient } from '@prisma/client';\n\nconst prisma = new PrismaClient({\n  log: ['query', 'error', 'info', 'warn']\n});\n\n// query\nasync function main() {\n  const res = await prisma.$queryRaw(Prisma.sql`select * from user`);\n  console.log(res)\n}\n\nmain()\n  .then(async () => {\n    await prisma.$disconnect();\n  })\n  .catch(async (e) => {\n    console.error(e);\n    await prisma.$disconnect();\n    process.exit(1);\n  });\n```","isLeaf":true}]},{"key":"/NodeJS/index.md","path":"/NodeJS/index.md","route":"/NodeJS/index.md","leaf":true,"title":"index","depth":1,"content":"![](https://www.persistent.com/wp-content/uploads/2016/02/blog-banner-Is-your-Node.js-application-production-ready-scaled.jpg)\n\nnodejs 学习笔记，内容非完全原创，相关内容会备注原作者。\n\n特别感谢：\n- [Barret李靖](https://github.com/barretlee)\n- [doodlewind](https://www.zhihu.com/people/doodlewind)\n- [做前端的蜗牛](https://space.bilibili.com/486675132)\n- [邱昊宇](https://www.zhihu.com/people/timothyqiu)\n- [小林coding](https://xiaolincoding.com/)\n- [神说要有光](https://www.zhihu.com/people/di-xu-guang-50)\n\n参考资料：\n- NodeJS 技术栈 https://www.nodejs.red/#/README","isLeaf":true}]}]