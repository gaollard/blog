---
title: 02-锁的分类
---

<https://baijiahao.baidu.com/s?id=1719317428791454942&wfr=spider&for=pc> 

### 1、锁的分类

- 从性能上分
  - 乐观锁(用版本对比来实现)
  - 悲观锁;
- 从对数据库操作的类型分 (都属于悲观锁)
  - 读锁（共享锁，S锁(Shared)）：针对同一份数据，多个读操作可以同时进行而不会互相影响
  - 写锁（排它锁，X锁(eXclusive)）：当前写操作没有完成前，它会阻断其他写锁和读锁
- 从对数据操作的粒度分
  - 表锁
  - 行锁 

### 2、表锁与行锁



#### 1. 表锁的介绍

每次操作锁住整张表：

- 开销小（不需要定位到某个元素，只需要定位到表）
- 加锁快；
- 不会出现死锁；
- 锁定粒度大，发生锁冲突的概率最高，并发度最低；

一般用在整表数据迁移的场景。



#### 2. 表锁操作方式 (lock table...)

- 手动增加表锁: `lock table 表名称 read(write),表名称2 read(write);`
- 查看表上加过的锁: `show open tables;`
- 删除表锁: `unlock tables;`



#### 3. 行锁的介绍

每次操作锁住一行数据。

- 开销大，加锁慢；
- 会出现死锁；
- 锁定粒度最小，发生锁冲突的概率最低，并发度高。

InnoDB 与MYISAM 的最大不同点：InnoDB 支持行级锁、支持事务

- MyISAM 在执行查询语句 SELECT 前，会自动给涉及的所有表加读锁,在执行 update、insert、delete 操作会自动给涉及的表加写锁。
- InnoDB 在执行查询语句 SELECT 时(非串行隔离级别)，不会加锁。但是 update、insert、delete 操作会加行锁。



#### 4. 行锁操作方式 （...`for update`）

sql 后增加 `for update` 来实现行锁。`for update` 在不走索引的时候会锁表！但是当要修改或者查询的数据不存在的时候，不会锁表，也不会锁定行！



### 3、读锁与写锁

读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞。



### 4、并发场景下挑战

多线程或者分布式程序中，并发的对 mysql 表记录进行修改时，由于网络原因，在逻辑上无法保证最后的修改者，无法保证数据的正确性。举例：



#### 1. 乐观锁方案

在表里增加个字段，版本号字段，每次更新前先从数据库里获取这个版本号的值，然后更新时要同步更新版本号+1，并且增加更新条件版本号=查询出来的值。

因为更新时每次只可能有一个线程更新到数据，等到另外一个线程再去更新数据的时候版本号已经+1了，所以会更新失败，重新获取版本号再走更新流程，这样就解决了多线程并发更新被覆盖的问题。

而且乐观锁机制避免了长事务中的数据库加锁开销（多个线程操作过程中，都没有对数据库数据加锁），大大提升了大并发量下的系统整体性能表现。
