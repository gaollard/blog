---
title: mysql 34道练习题（1-10）
---

参考文档：<https://www.cnblogs.com/d9e84208/p/10977986.html>

```sql
DROP TABLE IF EXISTS EMP;
DROP TABLE IF EXISTS DEPT;
DROP TABLE IF EXISTS SALGRADE;

CREATE TABLE DEPT
	(DEPTNO int(2) not null ,
	DNAME VARCHAR(14) ,
	LOC VARCHAR(13) ,
	primary key (DEPTNO)
	);
CREATE TABLE EMP
	(EMPNO int(4) not null ,
	ENAME VARCHAR(10) ,
	JOB VARCHAR(9) ,
	MGR INT(4) ,
	HIREDATE DATE DEFAULT NULL ,
	SAL DOUBLE(7,2) ,
	COMM DOUBLE(7,2) ,
	primary key (EMPNO) ,
	DEPTNO INT(2)
	);
CREATE TABLE SALGRADE
	(GRADE INT ,
	LOSAL INT ,
	HISAL INT 
	);
	
INSERT INTO DEPT ( DEPTNO, DNAME, LOC ) VALUES (
10, 'ACCOUNTING', 'NEW YOURK');
INSERT INTO DEPT ( DEPTNO, DNAME, LOC ) VALUES (
20, 'RESEARCH', 'DALLAS');
INSERT INTO DEPT ( DEPTNO, DNAME, LOC ) VALUES (
30, 'SALES', 'CHICAGO');
INSERT INTO DEPT( DEPTNO, DNAME, LOC ) VALUES (
40, 'OPERATIONS', 'BOSTON');
commit;

INSERT INTO EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES (
7396, 'SMITH', 'CLERK', 7902, '1980-12-17', 800, NULL, 20);
INSERT INTO EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES (
7499, 'ALLEN', 'SALESMAN', 7698, '1981-02-20', 1600, 300,30);
INSERT INTO EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES (
7521, 'WARD', 'SALESMAN', 7698, '1981-02-22', 1250, 500, 30);
INSERT INTO EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES (
7566, 'JONES', 'MANAGER', 7839, '1981-04-02', 2975, NULL, 20);
INSERT INTO EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES (
7654, 'MARTIN', 'SALESMAN', 7698, '1981-09-28', 1250, 1400, 30);
INSERT INTO EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES (
7698, 'BLAKE', 'MANAGER', 7839, '1981-05-01', 2850, NULL, 30);
INSERT INTO EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES (
7782, 'CLARK', 'MANAGER', 7839, '1981-06-09', 2450, NULL, 20);
INSERT INTO EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES (
7788, 'SCOTT', 'ANALYST', 7566, '1987-04-19', 3000, NULL, 20);
INSERT INTO EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES (
7839, 'KING', 'PRESIDENT', NULL, '1981-11-17', 5000, NULL, 10);
INSERT INTO EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES (
7844, 'TURNER', 'SALESMAN', 7698, '1981-09-08', 1500, 0, 30);
INSERT INTO EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES (
7876, 'ADAMS', 'CLERK', 7788, '1987-05-23', 1100, NULL, 20);
INSERT INTO EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES (
7900, 'JAMES', 'CLERK', 7698, '1981-12-03', 950, NULL, 30);
INSERT INTO EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES (
7902, 'FORD', 'ANALYST', 7566, '1981-12-03', 3000, NULL, 20);
INSERT INTO EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES (
7934, 'MILLER', 'CLERK', 7782, '1982-01-23', 1300, NULL, 10);
commit;

INSERT INTO SALGRADE (GRADE, LOSAL, HISAL) VALUES (
1, 700, 1200);
INSERT INTO SALGRADE (GRADE, LOSAL, HISAL) VALUES (
2, 1201, 1400);
INSERT INTO SALGRADE (GRADE, LOSAL, HISAL) VALUES (
3, 1401, 2000);
INSERT INTO SALGRADE (GRADE, LOSAL, HISAL) VALUES (
4, 2001, 3000);
INSERT INTO SALGRADE (GRADE, LOSAL, HISAL) VALUES (
5, 3001, 9999);
commit;
```

### 1. **取得每个部门最高薪水的人员名称**

注意可能存在某个部门有多个员工的工资相同，而且是最高的。

(1) 先找出每个部门的最高薪资表 T

```sql
# 查询各部门最高薪水（临时表T1）
# 按照部门编号分组找出每一组最大值
select e.deptno, max(SAL) as maxSal from EMP e group by deptno

+--------+---------+
| deptno | maxSal  |
+--------+---------+
|     10 | 5000.00 |
|     20 | 3000.00 |
|     30 | 2850.00 |
+--------+---------+
```

（2）将员工表和T1表连接查询

```sql
	
select
        e.deptno,
        e.ename,
        t.maxsal,
        e.sal
from
		EMP e
join
		(select e.deptno,max(e.sal) as maxsal from EMP e group by e.deptno) t
on
		e.deptno=t.deptno
where
    t.maxsal=e.sal

+--------+-------+---------+---------+
| deptno | ename | maxsal  | sal     |
+--------+-------+---------+---------+
|     30 | BLAKE | 2850.00 | 2850.00 |
|     20 | SCOTT | 3000.00 | 3000.00 |
|     10 | KING  | 5000.00 | 5000.00 |
|     20 | FORD  | 3000.00 | 3000.00 |
+--------+-------+---------+---------+
4 rows in set (0.00 sec)
```

### 2.那些人的薪水在部门平均薪水之上

（1）先求出部门的平均薪水

```sql
select e.ename, deptno, avg(e.sal) as avgsale from EMP e group by e.`DEPTNO`

+-------+--------+-------------+
| ename | deptno | avgsale     |
+-------+--------+-------------+
| KING  |     10 | 3150.000000 |
| SMITH |     20 | 2220.833333 |
| ALLEN |     30 | 1566.666667 |
+-------+--------+-------------+
3 rows in set (0.00 sec)
```

（2）连接员工表筛选

```sql
select
		e.ename,
		e.deptno,
		e.sal
from
		EMP e
join
		(select e.ename, deptno, avg(e.sal) as avgsale from EMP e group by e.`DEPTNO`) t
on
		e.deptno = t.deptno
and
		e.sal > t.avgsale;
```

![20230718180900](http://s3.airtlab.com/blog/20230718180900.png)


### 3. **取得部门所有人的平均薪水等级**

```sql

select
		e.deptno,
		avg(t.grade) as avggrade
from
		EMP e
join
		SALGRADE t
on
		e.sal between t.losal and t.hisal
group by
	e.deptno
```

![20230718180918](http://s3.airtlab.com/blog/20230718180918.png)


### 4. **不准用聚合函数(max)，取得最高薪水(给出两种方法)**

1. 使用max(否定)

```sql
select max(t.sal) from EMP t
```

2. 排序取一个

```sql
select t.sal from EMP t order by sal DESC limit 1
```

3. 两表连接把不是最大值的先找出来，然后用排除法找出最大值

```sql
SELECT
		e.sal,
		e.ename
FROM
		EMP e
WHERE
	e.sal not in (SELECT distinct t.sal FROM EMP e JOIN EMP t WHERE e.sal > t.sal)
```

![20230718181000](http://s3.airtlab.com/blog/20230718181000.png)


### 5. **取得平均薪水最高的部门的部门编号**

先取出每个部门平均值，然后再取出最大值

```sql
select 
		e.deptno,
		max(e.avg_sal) as max_avg_sal
from 
		(select avg(e.sal) as avg_sal, e.deptno from EMP e group by e.deptno) e
```

![20230718181017](http://s3.airtlab.com/blog/20230718181017.png)

### 6. **取得平均薪水最高的部门的部门名称**

```sql
select
		e.deptno,
		d.dname,
		avg(e.sal)
from
		EMP e
JOIN
		DEPT d
on
	d.deptno = e.deptno
group by
		e.deptno
limit 	1
```

![20230718181057](http://s3.airtlab.com/blog/20230718181057.png)

**如果是求平均薪水最低的部门名称呢？**
（1）思路整理

```sql
# 薪水表和部门表进行内连接，并且分组，找出：部门编号，部门名称，平均薪水
# 对上表进行生序排序，并取出第一个值
```

（2）我的代码

```sql
select
		e.deptno,
		d.dname,
		avg(e.sal) as avg_sal
from
		EMP e
JOIN
		DEPT d
on
	d.deptno = e.deptno
group by
		e.deptno
order by
		avg_sal ASC
limit 1
```

![20230718181124](http://s3.airtlab.com/blog/20230718181124.png)

### 7. 求平均薪水等级最低的部门的部门名称&#xA;

（1）我的方法1

```sql
# 求出部门的员工的薪水等级
# 求出部门的员工平均薪水等级
# 求出平均薪水等级最低的部门
```

方法：分组+子查询

```sql
select
		t.DEPTNO,
		avg(t.sal_grade)
from
		(
			SELECT
					e.*,
					s.GRADE as sal_grade
			from
					EMP e
			JOIN
					SALGRADE s
			on
					e.sal between s.LOSAL and s.HISAL
		) as t
group by
		t.DEPTNO
order by 
		avg(t.sal_grade)
limit 1
```

![20230718181146](http://s3.airtlab.com/blog/20230718181146.png)

当某个部门没有员工时，返回的数据没有包含改部门，是符合逻辑的。

***


### 8. **取得比普通员工(员工代码没有在mgr上出现)最高薪水还要高的经理人姓名**

```sql
-- 找出 mgr
select distinct mgr  from emp;


-- mgr 员工
select
	*
from
	emp
where
	empno
in
	(select distinct mgr from emp where mgr is not null)


-- 普通员工
select
	*
from
	emp
where
	empno
not in
	(select distinct mgr from emp where mgr is not null)



-- 找出普通员工的ID： 
select
	empno, sal
from
	emp
where
	empno
not in 
	(select distinct mgr  from emp where mgr is not null); 

/* empno	sal
7396	800.00
7499	1600.00
7521	1250.00
7654	1250.00
7844	1500.00
7876	1100.00
7900	950.00
7934	1300.00 */


-- 3：取得普通员工的最高薪水
select
	max(t.sal) as max_sal 
from
	(select empno,sal from emp where empno not in (select distinct mgr  from emp where mgr is not null)) t;
  

-- 4: 最终语句
select
	ename,
	sal
from
-- 	emp e
	(select * from emp where empno in (select distinct mgr from emp where mgr is not null)) e
where
	e.sal > (
		select max(t.sal) as max_sal 
		from  (select empno, sal from emp where empno not in (select distinct mgr from emp where mgr is not null)) t
	)
```

### 9. 取得薪水最高的前五名员工

```sql
select ename, sal from emp e order by	e.sal limit	0,5
```

### 10. 取得薪水最高的第六到第十名员工

```sql
select ename, sal from emp e order by	e.sal limit	6,10
```

### 11. 取得最后入职的五名员工
